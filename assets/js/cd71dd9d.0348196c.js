"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8898],{81591:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var s=n(74848),i=n(28453);const r={layout:"docs",page_title:"Limits and Maximums",description:"Learn about the maximum number of objects within OpenBao."},a="OpenBao limits and maximums",o={id:"internals/limits",title:"OpenBao limits and maximums",description:"Learn about the maximum number of objects within OpenBao.",source:"@site/content/docs/internals/limits.mdx",sourceDirName:"internals",slug:"/internals/limits",permalink:"/openbao/docs/internals/limits",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/internals/limits.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Limits and Maximums",description:"Learn about the maximum number of objects within OpenBao."},sidebar:"tutorialSidebar",previous:{title:"Integrated storage",permalink:"/openbao/docs/internals/integrated-storage"},next:{title:"Key rotation",permalink:"/openbao/docs/internals/rotation"}},l={},d=[{value:"Storage-Related limits",id:"storage-related-limits",level:2},{value:"Storage entry size",id:"storage-entry-size",level:3},{value:"Mount point limits",id:"mount-point-limits",level:3},{value:"Namespace limits",id:"namespace-limits",level:3},{value:"Entity and group limits",id:"entity-and-group-limits",level:3},{value:"Token limits",id:"token-limits",level:3},{value:"Policy limits",id:"policy-limits",level:3},{value:"Versioned key-value store (kv-v2 secret engine)",id:"versioned-key-value-store-kv-v2-secret-engine",level:3},{value:"Transit secret engine",id:"transit-secret-engine",level:3},{value:"Other limits",id:"other-limits",level:2},{value:"Request size",id:"request-size",level:3},{value:"Request duration",id:"request-duration",level:3},{value:"Lease limits",id:"lease-limits",level:3},{value:"Transform limits",id:"transform-limits",level:3},{value:"External plugin limits",id:"external-plugin-limits",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"openbao-limits-and-maximums",children:"OpenBao limits and maximums"}),"\n",(0,s.jsx)(t.p,{children:"OpenBao imposes fixed upper limits on the size of certain fields and\nobjects, and configurable limits on others. OpenBao also has upper\nbounds that are a consequence of its underlying storage. This page\nattempts to collect these limits, to assist in planning OpenBao\ndeployments."}),"\n",(0,s.jsx)(t.p,{children:"In some cases, the system will show performance problems in advance of\nthe absolute limits being reached."}),"\n",(0,s.jsx)(t.h2,{id:"storage-related-limits",children:"Storage-Related limits"}),"\n",(0,s.jsx)(t.h3,{id:"storage-entry-size",children:"Storage entry size"}),"\n",(0,s.jsx)(t.p,{children:"The maximum size of an object written to a storage backend is determined\nby that backend."}),"\n",(0,s.jsxs)(t.p,{children:["For the integrated storage backend, the default limit is 1 MiB. This may be\nconfigured via ",(0,s.jsx)(t.code,{children:"max_entry_size"})," in the ",(0,s.jsx)(t.a,{href:"/docs/configuration/storage/raft#max_entry_size",children:"storage\nstanza"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Many of the other limits within OpenBao derive from the maximum size of\na storage entry, as described in the next sections. It is possible to\nrecover from an error where a storage entry has reached its maximum\nsize by reconfiguring OpenBao to a larger maximum storage\nentry. However, using large storage entries also negatively affects\nperformance, as even a small change may become a large\nread-modify-write cycle on the entire entry. Larger writes may also delay\nRaft heartbeats, leading to leadership instability."}),"\n",(0,s.jsx)(t.h3,{id:"mount-point-limits",children:"Mount point limits"}),"\n",(0,s.jsx)(t.p,{children:"All secret engine mount points, and all auth mount points, must each fit\nwithin a single storage entry. Each JSON object describing a mount\ntakes about 500 bytes, but is stored in compressed form at a typical cost of\nabout 75 bytes. Each of (1) auth mounts, (2) secret engine mount points,\n(3) local-only auth methods, and (4) local-only secret engine mounts are\nstored separately, so the limit applies to each independently."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Integrated storage default (1 MiB)"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of secret engine mount points"}),(0,s.jsx)(t.td,{children:"~14000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of enabled auth methods"}),(0,s.jsx)(t.td,{children:"~14000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum mount point length"}),(0,s.jsx)(t.td,{children:"no enforced limit"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Specifying distinct per-mount options, or using long mount point paths, can\nincrease the space required per mount."}),"\n",(0,s.jsxs)(t.p,{children:["The number of mount points can be monitored by reading the\n",(0,s.jsx)(t.a,{href:"/api-docs/system/auth",children:(0,s.jsx)(t.code,{children:"sys/auth"})})," and\n",(0,s.jsx)(t.a,{href:"/api-docs/system/mounts",children:(0,s.jsx)(t.code,{children:"sys/mounts"})})," endpoints from the root namespace and\nsimilar sub-paths for namespaces respectively, like: ",(0,s.jsx)(t.code,{children:"namespace1/sys/auth"}),",\n",(0,s.jsx)(t.code,{children:"namespace1/sys/mounts"}),", etc."]}),"\n",(0,s.jsxs)(t.p,{children:["Alternatively, use the\n",(0,s.jsx)(t.a,{href:"/docs/internals/telemetry/metrics/core-system#vault-core-mount_table-num_entries",children:(0,s.jsx)(t.code,{children:"vault.core.mount_table.num_entries"})}),"\nand\n",(0,s.jsx)(t.a,{href:"/docs/internals/telemetry/metrics/core-system#vault-core-mount_table-size",children:(0,s.jsx)(t.code,{children:"vault.core.mount_table.size"})}),"\ntelemetry metrics to monitor the number of mount points and size of each mount table."]}),"\n",(0,s.jsx)(t.h3,{id:"namespace-limits",children:"Namespace limits"}),"\n",(0,s.jsxs)(t.p,{children:["The entire list of namespaces must fit in a single storage\nentry. However, the effective limit is generally much smaller because each\nnamespace must have at least two secret engine mounts (for ",(0,s.jsx)(t.code,{children:"sys"})," and ",(0,s.jsx)(t.code,{children:"identity"}),"),\none local secret engine (",(0,s.jsx)(t.code,{children:"cubbyhole"}),") and one auth engine mount (",(0,s.jsx)(t.code,{children:"token"}),")."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Integrated storage default (1 MiB)"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of namespaces"}),(0,s.jsx)(t.td,{children:"~7000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of namespaces with one additional secret engine per namespace"}),(0,s.jsx)(t.td,{children:"~4600"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum nesting depth for namespaces"}),(0,s.jsx)(t.td,{children:"~220"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"The maximum nesting depth calculation assumes a cost of 40 bytes per namespace\npath element. 160 nested paths = 160 namespaces ranging from 40 bytes to\n6400 bytes."}),"\n",(0,s.jsxs)(t.p,{children:["The number of namespaces can be monitored by querying\n",(0,s.jsx)(t.a,{href:"/api-docs/system/namespaces",children:(0,s.jsx)(t.code,{children:"sys/namespaces"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["To estimate the number of namespaces that can be created, divide the mount\npoint limit by the larger of the number of auth mounts per namespace\n(including ",(0,s.jsx)(t.code,{children:"ns_token"}),") and the number of secret mounts per namespace\n(including ",(0,s.jsx)(t.code,{children:"identity"})," and ",(0,s.jsx)(t.code,{children:"sys"}),".)"]}),"\n",(0,s.jsx)(t.h3,{id:"entity-and-group-limits",children:"Entity and group limits"}),"\n",(0,s.jsx)(t.p,{children:"The metadata that may be attached to an identity entity or an entity group\nhas the following constraints:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Limit"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Number of key-value pairs in metadata"}),(0,s.jsx)(t.td,{children:"64"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Metadata key size"}),(0,s.jsx)(t.td,{children:"128 bytes"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Metadata value size"}),(0,s.jsx)(t.td,{children:"512 bytes"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"OpenBao shards the entities across 256 storage entries. This creates a hard\nlimit of  256MiB on integrated storage with its default settings. Entity aliases\nare stored inline in the Entity objects and so consume the same pool of storage.\nEntity definitions are compressed within each storage entry, and the\npre-compression size varies with the number of entity aliases and the amount of\nmetadata. Minimally-populated entities about 200 bytes after compression."}),"\n",(0,s.jsx)(t.p,{children:"Group definitions are stored separately, in their own pool of 256\nstorage entries. The size of each group object depends on the number\nof members and the amount of metadata. Group aliases and group\nmembership information is stored inline in each Group object. A group\nwith no metadata, holding 10 entities, will use about 500 bytes per\ngroup. A group holding 100 entities would instead consume about 4,000\nbytes."}),"\n",(0,s.jsx)(t.p,{children:"The following table shows a best-case estimate and a more conservative\nestimate for entities and groups. The number is slightly less than the\namount that fits in one shard, to reflect the fact that the first\nshard to fill up will start inducing failures. This maximum will\ndecrease if each entity has a large amount of metadata, or if each\ngroup has a large number of members."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Integrated storage default (1 MiB)"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of identity entities (best case, 200 bytes per entity)"}),(0,s.jsx)(t.td,{children:"~1,250,000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of identity entities (conservative case, 500 bytes per entity)"}),(0,s.jsx)(t.td,{children:"~480,000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of identity entities (maximum permitted metadata, 41160 bytes per entity)"}),(0,s.jsx)(t.td,{children:"2,400"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of groups (10 entities per group)"}),(0,s.jsx)(t.td,{children:"~480,000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of groups (100 entities per group)"}),(0,s.jsx)(t.td,{children:"~50,000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of members in a group"}),(0,s.jsx)(t.td,{children:"~23,000"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["The number of entities can be monitored using OpenBao's ",(0,s.jsx)(t.a,{href:"/docs/internals/telemetry#token-identity-and-lease-metrics",children:"telemetry"}),"; see ",(0,s.jsx)(t.code,{children:"vault.identity.num_entities"})," (total) or ",(0,s.jsx)(t.code,{children:"vault.identity.entities.count"})," (by namespace)."]}),"\n",(0,s.jsxs)(t.p,{children:["The cost of entity and group updates grows as the number of objects in\neach shard increases. This cost can be monitored via the\n",(0,s.jsx)(t.code,{children:"vault.identity.upsert_entity_txn"})," and\nthe ",(0,s.jsx)(t.code,{children:"vault.identity.upsert_group_txn"})," metrics."]}),"\n",(0,s.jsxs)(t.p,{children:["Very large internal groups should be avoided (more than 1000 members),\nbecause the membership list in a group must reside in a single storage entry.\nInstead, consider using ",(0,s.jsx)(t.a,{href:"/docs/concepts/identity#external-vs-internal-groups",children:"external groups"})," or split the group up into multiple sub-groups."]}),"\n",(0,s.jsx)(t.h3,{id:"token-limits",children:"Token limits"}),"\n",(0,s.jsx)(t.p,{children:"One storage entry is used per token; there is thus no\nupper bound on the number of active tokens. There are no restrictions on\nthe token metadata field, other than the entire token must fit into one\nstorage entry:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Limit"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Number of key-value pairs in metadata"}),(0,s.jsx)(t.td,{children:"no limit"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Metadata key size"}),(0,s.jsx)(t.td,{children:"no limit"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Metadata value size"}),(0,s.jsx)(t.td,{children:"no limit"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Total size of token metadata"}),(0,s.jsx)(t.td,{children:"512 KiB"})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"policy-limits",children:"Policy limits"}),"\n",(0,s.jsx)(t.p,{children:"The maximum size of a policy is limited by the storage\nentry size. Policy lists that appear in tokens or entities must fit\nwithin a single storage entry."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Integrated storage default (1 MiB)"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum policy size"}),(0,s.jsx)(t.td,{children:"1 MiB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of policies per namespace"}),(0,s.jsx)(t.td,{children:"no limit"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of policies per token"}),(0,s.jsx)(t.td,{children:"~28,000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of policies per entity or group"}),(0,s.jsx)(t.td,{children:"~28,000"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["Each time a token is used, OpenBao must assemble the collection of\npolicies attached to that token, to the entity, to any groups that the\nentity belongs to, and recursively to any groups that contain those groups.\nVery large numbers of policies are possible, but can cause OpenBao\u2019s\nresponse time to increase. You can monitor the\n",(0,s.jsx)(t.a,{href:"/docs/internals/telemetry#core-metrics",children:(0,s.jsx)(t.code,{children:"vault.core.fetch_acl_and_token"})}),"\nmetric to determine if the time required to assemble an access control list\nis becoming excessive."]}),"\n",(0,s.jsx)(t.h3,{id:"versioned-key-value-store-kv-v2-secret-engine",children:"Versioned key-value store (kv-v2 secret engine)"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Limit"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Number of secrets"}),(0,s.jsx)(t.td,{children:"no limit, up to available storage capacity"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum size of one version of a secret"}),(0,s.jsx)(t.td,{children:"slightly less than one storage entry (512 KiB or 1024 KiB)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Number of versions of a secret"}),(0,s.jsx)(t.td,{children:"default 10; configurable per-secret or per-mount"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of versions (not checked when configured)"}),(0,s.jsx)(t.td,{children:"at least 24,000"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Each version of a secret must fit in a single storage entry; the\nkey-value pairs are converted to JSON before storage."}),"\n",(0,s.jsx)(t.p,{children:"Version metadata consumes 21 bytes per version and must fit in a\nsingle storage entry, separate from the stored data."}),"\n",(0,s.jsxs)(t.p,{children:["Each secret also has version-agnostic metadata. This data can contain a ",(0,s.jsx)(t.code,{children:"custom_metadata"})," field of\nuser-provided key-value pairs. OpenBao imposes the following custom metadata limits:"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Limit"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Number of custom metadata key-value pairs"}),(0,s.jsx)(t.td,{children:"64"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Custom metadata key size"}),(0,s.jsx)(t.td,{children:"128 bytes"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Custom metadata value size"}),(0,s.jsx)(t.td,{children:"512 bytes"})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"transit-secret-engine",children:"Transit secret engine"}),"\n",(0,s.jsxs)(t.p,{children:["The maximum size of a Transit ciphertext or plaintext is limited by OpenBao's\nmaximum request size, as described ",(0,s.jsx)(t.a,{href:"#request-size",children:"below"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"All archived versions of a single key must fit in a single storage entry.\nThis limit depends on the key size."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Key length"}),(0,s.jsx)(t.th,{children:"Integrated storage default (1 MiB)"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"aes128-gcm96 keys"}),(0,s.jsx)(t.td,{children:"4017"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"aes256-gcm96 keys"}),(0,s.jsx)(t.td,{children:"3731"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"chacha-poly1305 keys"}),(0,s.jsx)(t.td,{children:"3731"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"ed25519 keys"}),(0,s.jsx)(t.td,{children:"2841"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"ecdsa-p256 keys"}),(0,s.jsx)(t.td,{children:"1635"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"ecdsa-p384 keys"}),(0,s.jsx)(t.td,{children:"1318"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"ecdsa-p523 keys"}),(0,s.jsx)(t.td,{children:"1078"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1024-bit RSA keys"}),(0,s.jsx)(t.td,{children:"333"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"2048-bit RSA keys"}),(0,s.jsx)(t.td,{children:"233"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"4096-bit RSA kyes"}),(0,s.jsx)(t.td,{children:"178"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"other-limits",children:"Other limits"}),"\n",(0,s.jsx)(t.h3,{id:"request-size",children:"Request size"}),"\n",(0,s.jsxs)(t.p,{children:["The maximum size of an HTTP request sent to OpenBao is limited by\nthe ",(0,s.jsx)(t.code,{children:"max_request_size"})," option in the ",(0,s.jsx)(t.a,{href:"/docs/configuration/listener/tcp",children:"listener stanza"}),". It defaults to 32 MiB. This value, minus the overhead of\nthe HTTP request itself, places an upper bound on any Transit operation,\nand on the maximum size of any key-value secrets."]}),"\n",(0,s.jsx)(t.h3,{id:"request-duration",children:"Request duration"}),"\n",(0,s.jsxs)(t.p,{children:["The maximum duration of an OpenBao operation is\n",(0,s.jsx)(t.a,{href:"/docs//configuration/listener/tcp",children:(0,s.jsx)(t.code,{children:"max_request_duration"})}),", which defaults to\n90 seconds. If a particular secret engine takes longer than this to perform an\noperation on a remote service, the OpenBao client will see a failure."]}),"\n",(0,s.jsxs)(t.p,{children:["The environment variable ",(0,s.jsx)(t.a,{href:"/docs/commands#vault_client_timeout",children:(0,s.jsx)(t.code,{children:"VAULT_CLIENT_TIMEOUT"})})," sets a client-side maximum duration as well,\nwhich is 60 seconds by default."]}),"\n",(0,s.jsx)(t.h3,{id:"lease-limits",children:"Lease limits"}),"\n",(0,s.jsxs)(t.p,{children:["A systemwide ",(0,s.jsx)(t.a,{href:"/docs/configuration#max_lease_ttl",children:"maximum TTL"}),", and a\n",(0,s.jsx)(t.a,{href:"/api-docs/system/mounts#max_lease_ttl-1",children:"maximum TTL per mount point"})," can be\nconfigured."]}),"\n",(0,s.jsx)(t.p,{children:"Although no technical maximum exists, high lease counts can cause\ndegradation in system performance. We recommend short default\ntime-to-live values on tokens and leases to avoid a large backlog of\nunexpired leases, or a large number of simultaneous expirations."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{children:"Limit"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum number of leases"}),(0,s.jsx)(t.td,{children:"advisory limit at 256,000"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Maximum duration of lease or token"}),(0,s.jsx)(t.td,{children:"768 hours by default"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["The current number of unexpired leases can be monitored via the\n",(0,s.jsx)(t.a,{href:"/docs/internals/telemetry#token-identity-and-lease-metrics",children:(0,s.jsx)(t.code,{children:"vault.expire.num_leases"})})," metric."]}),"\n",(0,s.jsx)(t.h3,{id:"transform-limits",children:"Transform limits"}),"\n",(0,s.jsxs)(t.p,{children:["The Transform secret engine obeys the ",(0,s.jsx)(t.a,{href:"/docs/secrets/transform#input-limits",children:"FF3-1 minimum and maximum sizes\non the length of an input"}),", which\nare a function of the alphabet size."]}),"\n",(0,s.jsx)(t.h3,{id:"external-plugin-limits",children:"External plugin limits"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"/docs/plugins",children:"plugin system"})," launches a separate process\ninitiated by OpenBao that communicates over RPC. For each secret engine and auth\nmethod that's enabled as an external plugin, OpenBao will spawn a process on the\nhost system. For the Database Secrets Engines, external database plugins will\nspawn a process for every configured connection."]}),"\n",(0,s.jsx)(t.p,{children:"Regardless of plugin type, each of these processes will incur resource overhead\non the system, including but not limited to resources such as CPU, memory,\nnetworking, and file descriptors. There's no specific limit on the number\nsecrets engines, auth methods, or database configured connections that can be\nenabled. This ultimately depends on the particular plugin resource utilization,\nthe extent to which that plugin is being called, and the available resources on\nthe system. For plugins of the same type, each additional process will incur a\nroughly linear increase in resource utilization. This assumes the usage of each\nplugin of the same type is similar."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);