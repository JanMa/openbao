"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2829],{73816:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var o=n(74848),i=n(28453);const s={layout:"docs",page_title:"Tokens",description:"Tokens are a core auth method in OpenBao. Concepts and important features."},a="Tokens",r={id:"concepts/tokens",title:"Tokens",description:"Tokens are a core auth method in OpenBao. Concepts and important features.",source:"@site/content/docs/concepts/tokens.mdx",sourceDirName:"concepts",slug:"/concepts/tokens",permalink:"/openbao/docs/concepts/tokens",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/concepts/tokens.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Tokens",description:"Tokens are a core auth method in OpenBao. Concepts and important features."},sidebar:"tutorialSidebar",previous:{title:"Storage",permalink:"/openbao/docs/concepts/storage"},next:{title:"Transform secrets engine",permalink:"/openbao/docs/concepts/transform"}},l={},h=[{value:"Token types",id:"token-types",level:2},{value:"The token store",id:"the-token-store",level:2},{value:"Root tokens",id:"root-tokens",level:2},{value:"Token hierarchies and orphan tokens",id:"token-hierarchies-and-orphan-tokens",level:2},{value:"Token accessors",id:"token-accessors",level:2},{value:"Token Time-To-Live, periodic tokens, and explicit max TTLs",id:"token-time-to-live-periodic-tokens-and-explicit-max-ttls",level:2},{value:"The general case",id:"the-general-case",level:3},{value:"Explicit max TTLs",id:"explicit-max-ttls",level:3},{value:"Periodic tokens",id:"periodic-tokens",level:3},{value:"CIDR-Bound tokens",id:"cidr-bound-tokens",level:2},{value:"Token types in detail",id:"token-types-in-detail",level:2},{value:"Service tokens",id:"service-tokens",level:3},{value:"Batch tokens",id:"batch-tokens",level:3},{value:"Token type comparison",id:"token-type-comparison",level:3},{value:"Service vs. batch token lease handling",id:"service-vs-batch-token-lease-handling",level:3},{value:"Service tokens",id:"service-tokens-1",level:4},{value:"Batch tokens",id:"batch-tokens-1",level:4}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"tokens",children:"Tokens"}),"\n",(0,o.jsx)(t.admonition,{title:"Internal token structure is volatile",type:"warning",children:(0,o.jsx)(t.p,{children:"Tokens are opaque values so their structure is undocumented and subject to change.\nScripts and automations that rely on the internal structure of a token in scripts will break."})}),"\n",(0,o.jsxs)(t.p,{children:["Tokens are the core method for ",(0,o.jsx)(t.em,{children:"authentication"})," within OpenBao. Tokens\ncan be used directly or ",(0,o.jsx)(t.a,{href:"/docs/concepts/auth",children:"auth methods"}),"\ncan be used to dynamically generate tokens based on external identities."]}),"\n",(0,o.jsxs)(t.p,{children:["If you've gone through the getting started guide, you probably noticed that\n",(0,o.jsx)(t.code,{children:"bao server -dev"})," (or ",(0,o.jsx)(t.code,{children:"bao operator init"}),' for a non-dev server) outputs an\ninitial "root token." This is the first method of authentication for OpenBao.\nIt is also the only auth method that cannot be disabled.']}),"\n",(0,o.jsxs)(t.p,{children:["As stated in the ",(0,o.jsx)(t.a,{href:"/docs/concepts/auth",children:"authentication concepts"}),",\nall external authentication mechanisms, such as GitHub, map down to dynamically\ncreated tokens. These tokens have all the same properties as a normal manually\ncreated token."]}),"\n",(0,o.jsxs)(t.p,{children:["Within OpenBao, tokens map to information. The most important information mapped\nto a token is a set of one or more attached\n",(0,o.jsx)(t.a,{href:"/docs/concepts/policies",children:"policies"}),". These policies control what the token\nholder is allowed to do within OpenBao. Other mapped information includes\nmetadata that can be viewed and is added to the audit log, such as creation\ntime, last renewal time, and more."]}),"\n",(0,o.jsxs)(t.p,{children:["Read on for a deeper dive into token concepts.  See the\n",(0,o.jsx)(t.a,{href:"/tutorials/tokens/tokens",children:"tokens tutorial"}),"\nfor details on how these concepts play out in practice."]}),"\n",(0,o.jsx)(t.h2,{id:"token-types",children:"Token types"}),"\n",(0,o.jsxs)(t.p,{children:["There are two types of tokens: ",(0,o.jsx)(t.code,{children:"service"})," tokens and ",(0,o.jsx)(t.code,{children:"batch"})," tokens. A section\nnear the bottom of this page contains detailed information about their\ndifferences, but it is useful to understand other token concepts first. The\nfeatures in the following sections all apply to service tokens, and their\napplicability to batch tokens is discussed later."]}),"\n",(0,o.jsx)(t.h2,{id:"the-token-store",children:"The token store"}),"\n",(0,o.jsxs)(t.p,{children:['Often in documentation or in help channels, the "token store" is referenced.\nThis is the same as the ',(0,o.jsxs)(t.a,{href:"/docs/auth/token",children:[(0,o.jsx)(t.code,{children:"token"})," authentication\nbackend"]}),". This is a special\nbackend in that it is responsible for creating and storing tokens, and cannot\nbe disabled. It is also the only auth method that has no login\ncapability -- all actions require existing authenticated tokens."]}),"\n",(0,o.jsx)(t.h2,{id:"root-tokens",children:"Root tokens"}),"\n",(0,o.jsxs)(t.p,{children:["Root tokens are tokens that have the ",(0,o.jsx)(t.code,{children:"root"})," policy attached to them. Root\ntokens can do anything in OpenBao. ",(0,o.jsx)(t.em,{children:"Anything"}),". In addition, they are the only\ntype of token within OpenBao that can be set to never expire without any renewal\nneeded. As a result, it is purposefully hard to create root tokens; in fact\nthere are only three ways to create root tokens:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["The initial root token generated at ",(0,o.jsx)(t.code,{children:"bao operator init"})," time -- this token has no\nexpiration"]}),"\n",(0,o.jsx)(t.li,{children:"By using another root token; a root token with an expiration cannot create a\nroot token that never expires"}),"\n",(0,o.jsxs)(t.li,{children:["By using ",(0,o.jsx)(t.code,{children:"bao operator generate-root"})," (",(0,o.jsx)(t.a,{href:"/tutorials/operations/generate-root",children:"example"}),")\nwith the permission of a quorum of unseal key holders"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Root tokens are useful in development but should be extremely carefully guarded\nin production. In fact, the OpenBao team recommends that root tokens are only\nused for just enough initial setup (usually, setting up auth methods\nand policies necessary to allow administrators to acquire more limited tokens)\nor in emergencies, and are revoked immediately after they are no longer needed.\nIf a new root token is needed, the ",(0,o.jsx)(t.code,{children:"operator generate-root"})," command and associated\n",(0,o.jsx)(t.a,{href:"/api-docs/system/generate-root",children:"API endpoint"})," can be used to generate one on-the-fly."]}),"\n",(0,o.jsx)(t.p,{children:"It is also good security practice for there to be multiple eyes on a terminal\nwhenever a root token is live. This way multiple people can verify as to the\ntasks performed with the root token, and that the token was revoked immediately\nafter these tasks were completed."}),"\n",(0,o.jsx)(t.h2,{id:"token-hierarchies-and-orphan-tokens",children:"Token hierarchies and orphan tokens"}),"\n",(0,o.jsx)(t.p,{children:"Normally, when a token holder creates new tokens, these tokens will be created\nas children of the original token; tokens they create will be children of them;\nand so on. When a parent token is revoked, all of its child tokens -- and all\nof their leases -- are revoked as well. This ensures that a user cannot escape\nrevocation by simply generating a never-ending tree of child tokens."}),"\n",(0,o.jsxs)(t.p,{children:["Often this behavior is not desired, so users with appropriate access can create\n",(0,o.jsx)(t.code,{children:"orphan"})," tokens. These tokens have no parent -- they are the root of their own\ntoken tree. These orphan tokens can be created:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Via ",(0,o.jsx)(t.code,{children:"write"})," access to the ",(0,o.jsx)(t.code,{children:"auth/token/create-orphan"})," endpoint"]}),"\n",(0,o.jsxs)(t.li,{children:["By having ",(0,o.jsx)(t.code,{children:"sudo"})," or ",(0,o.jsx)(t.code,{children:"root"})," access to the ",(0,o.jsx)(t.code,{children:"auth/token/create"}),"\nand setting the ",(0,o.jsx)(t.code,{children:"no_parent"})," parameter to ",(0,o.jsx)(t.code,{children:"true"})]}),"\n",(0,o.jsx)(t.li,{children:"Via token store roles"}),"\n",(0,o.jsxs)(t.li,{children:["By logging in with any other (non-",(0,o.jsx)(t.code,{children:"token"}),") auth method"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Users with appropriate permissions can also use the ",(0,o.jsx)(t.code,{children:"auth/token/revoke-orphan"}),"\nendpoint, which revokes the given token but rather than revoke the rest of the\ntree, it instead sets the tokens' immediate children to be orphans. Use with\ncaution!"]}),"\n",(0,o.jsx)(t.h2,{id:"token-accessors",children:"Token accessors"}),"\n",(0,o.jsx)(t.p,{children:"When tokens are created, a token accessor is also created and returned. This\naccessor is a value that acts as a reference to a token and can only be used to\nperform limited actions:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Look up a token's properties (not including the actual token ID)"}),"\n",(0,o.jsx)(t.li,{children:"Look up a token's capabilities on a path"}),"\n",(0,o.jsx)(t.li,{children:"Renew the token"}),"\n",(0,o.jsx)(t.li,{children:"Revoke the token"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The token ",(0,o.jsx)(t.em,{children:"making the call"}),", ",(0,o.jsx)(t.em,{children:"not"})," the token associated with the accessor, must\nhave appropriate permissions for these functions."]}),"\n",(0,o.jsxs)(t.p,{children:["There are many useful workflows around token accessors. As an example, a\nservice that creates tokens on behalf of another service (such as the\n",(0,o.jsx)(t.a,{href:"https://www.nomadproject.io/",children:"Nomad"})," scheduler) can store the accessor\ncorrelated with a particular job ID. When the job is complete, the accessor can\nbe used to instantly revoke the token given to the job and all of its leased\ncredentials, limiting the chance that a bad actor will discover and use them."]}),"\n",(0,o.jsx)(t.p,{children:"Audit devices can optionally be set to not obfuscate token accessors in audit\nlogs. This provides a way to quickly revoke tokens in case of an emergency.\nHowever, it also means that the audit logs can be used to perform a larger-scale\ndenial of service attack."}),"\n",(0,o.jsxs)(t.p,{children:['Finally, the only way to "list tokens" is via the ',(0,o.jsx)(t.code,{children:"auth/token/accessors"}),"\ncommand, which actually gives a list of token accessors. While this is still a\ndangerous endpoint (since listing all of the accessors means that they can then\nbe used to revoke all tokens), it also provides a way to audit and revoke the\ncurrently-active set of tokens."]}),"\n",(0,o.jsx)(t.h2,{id:"token-time-to-live-periodic-tokens-and-explicit-max-ttls",children:"Token Time-To-Live, periodic tokens, and explicit max TTLs"}),"\n",(0,o.jsx)(t.p,{children:"Every non-root token has a time-to-live (TTL) associated with it, which is a\ncurrent period of validity since either the token's creation time or last\nrenewal time, whichever is more recent. (Root tokens may have a TTL associated,\nbut the TTL may also be 0, indicating a token that never expires). After the\ncurrent TTL is up, the token will no longer function -- it, and its associated\nleases, are revoked."}),"\n",(0,o.jsxs)(t.p,{children:["If the token is renewable, OpenBao can be asked to extend the token validity\nperiod using ",(0,o.jsx)(t.code,{children:"bao token renew"})," or the appropriate renewal endpoint. At this\ntime, various factors come into play. What happens depends upon whether the\ntoken is a periodic token (available for creation by ",(0,o.jsx)(t.code,{children:"root"}),"/",(0,o.jsx)(t.code,{children:"sudo"})," users, token\nstore roles, or some auth methods), has an explicit maximum TTL\nattached, or neither."]}),"\n",(0,o.jsx)(t.h3,{id:"the-general-case",children:"The general case"}),"\n",(0,o.jsx)(t.p,{children:"In the general case, where there is neither a period nor explicit maximum TTL\nvalue set on the token, the token's lifetime since it was created will be\ncompared to the maximum TTL. This maximum TTL value is dynamically generated\nand can change from renewal to renewal, so the value cannot be displayed when a\ntoken's information is looked up. It is based on a combination of factors:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"The system max TTL, which is 32 days but can be changed in OpenBao's\nconfiguration file."}),"\n",(0,o.jsxs)(t.li,{children:["The max TTL set on a mount using ",(0,o.jsx)(t.a,{href:"/api-docs/system/mounts",children:"mount\ntuning"}),". This value\nis allowed to override the system max TTL -- it can be longer or shorter,\nand if set this value will be respected."]}),"\n",(0,o.jsx)(t.li,{children:"A value suggested by the auth method that issued the token. This\nmight be configured on a per-role, per-group, or per-user basis. This value\nis allowed to be less than the mount max TTL (or, if not set, the system max\nTTL), but it is not allowed to be longer."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Note that the values in (2) and (3) may change at any given time, which is why\na final determination about the current allowed max TTL is made at renewal time\nusing the current values. It is also why it is important to always ensure that\nthe TTL returned from a renewal operation is within an allowed range; if this\nvalue is not extending, likely the TTL of the token cannot be extended past its\ncurrent value and the client may want to reauthenticate and acquire a new\ntoken. However, outside of direct operator interaction, OpenBao will never revoke\na token before the returned TTL has expired."}),"\n",(0,o.jsx)(t.h3,{id:"explicit-max-ttls",children:"Explicit max TTLs"}),"\n",(0,o.jsx)(t.p,{children:"Tokens can have an explicit max TTL set on them. This value becomes a hard\nlimit on the token's lifetime -- no matter what the values in (1), (2), and (3)\nfrom the general case are, the token cannot live past this explicitly-set\nvalue. This has an effect even when using periodic tokens to escape the normal\nTTL mechanism."}),"\n",(0,o.jsx)(t.h3,{id:"periodic-tokens",children:"Periodic tokens"}),"\n",(0,o.jsx)(t.p,{children:"In some cases, having a token be revoked would be problematic -- for instance,\nif a long-running service needs to maintain its SQL connection pool over a long\nperiod of time. In this scenario, a periodic token can be used. Periodic tokens\ncan be created in a few ways:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["By having ",(0,o.jsx)(t.code,{children:"sudo"})," capability or a ",(0,o.jsx)(t.code,{children:"root"})," token with the ",(0,o.jsx)(t.code,{children:"auth/token/create"}),"\nendpoint"]}),"\n",(0,o.jsx)(t.li,{children:"By using token store roles"}),"\n",(0,o.jsx)(t.li,{children:"By using an auth method that supports issuing these, such as\nAppRole"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["At issue time, the TTL of a periodic token will be equal to the configured\nperiod. At every renewal time, the TTL will be reset back to this configured\nperiod, and as long as the token is successfully renewed within each of these\nperiods of time, it will never expire. Outside of ",(0,o.jsx)(t.code,{children:"root"})," tokens, it is\ncurrently the only way for a token in OpenBao to have an unlimited lifetime."]}),"\n",(0,o.jsx)(t.p,{children:"The idea behind periodic tokens is that it is easy for systems and services to\nperform an action relatively frequently -- for instance, every two hours, or\neven every five minutes. Therefore, as long as a system is actively renewing\nthis token -- in other words, as long as the system is alive -- the system is\nallowed to keep using the token and any associated leases. However, if the\nsystem stops renewing within this period (for instance, if it was shut down),\nthe token will expire relatively quickly. It is good practice to keep this\nperiod as short as possible, and generally speaking it is not useful for humans\nto be given periodic tokens."}),"\n",(0,o.jsx)(t.p,{children:"There are a few important things to know when using periodic tokens:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["When a periodic token is created via a token store role, the ",(0,o.jsx)(t.em,{children:"current"})," value\nof the role's period setting will be used at renewal time"]}),"\n",(0,o.jsx)(t.li,{children:"A token with both a period and an explicit max TTL will act like a periodic\ntoken but will be revoked when the explicit max TTL is reached"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"cidr-bound-tokens",children:"CIDR-Bound tokens"}),"\n",(0,o.jsx)(t.p,{children:"Some tokens are able to be bound to CIDR(s) that restrict the range of client\nIPs allowed to use them. These affect all tokens except for non-expiring root\ntokens (those with a TTL of zero). If a root token has an expiration, it also\nis affected by CIDR-binding."}),"\n",(0,o.jsx)(t.h2,{id:"token-types-in-detail",children:"Token types in detail"}),"\n",(0,o.jsx)(t.p,{children:"There are currently two types of tokens."}),"\n",(0,o.jsx)(t.h3,{id:"service-tokens",children:"Service tokens"}),"\n",(0,o.jsx)(t.p,{children:'Service tokens are what users will generally think of as "normal" OpenBao tokens.\nThey support all features, such as renewal, revocation, creating child tokens,\nand more. They are correspondingly heavyweight to create and track.'}),"\n",(0,o.jsx)(t.h3,{id:"batch-tokens",children:"Batch tokens"}),"\n",(0,o.jsx)(t.p,{children:"Batch tokens are encrypted blobs that carry enough information for them to\nbe used for OpenBao actions, but they require no storage on disk to track them.\nAs a result they are extremely lightweight and scalable, but lack most of the\nflexibility and features of service tokens."}),"\n",(0,o.jsx)(t.h3,{id:"token-type-comparison",children:"Token type comparison"}),"\n",(0,o.jsx)(t.p,{children:"This reference chart describes the difference in behavior between service and\nbatch tokens."}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{}),(0,o.jsx)(t.th,{style:{textAlign:"right"},children:"Service Tokens"}),(0,o.jsx)(t.th,{style:{textAlign:"right"},children:"Batch Tokens"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Can Be Root Tokens"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Can Create Child Tokens"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Can be Renewable"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Manually Revocable"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Can be Periodic"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Can have Explicit Max TTL"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No (always uses a fixed TTL)"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Has Accessors"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Has Cubbyhole"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"No"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Revoked with Parent (if not orphan)"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Yes"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Stops Working"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Dynamic Secrets Lease Assignment"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Self"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Parent (if not orphan)"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Cost"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Heavyweight; multiple storage writes per token creation"}),(0,o.jsx)(t.td,{style:{textAlign:"right"},children:"Lightweight; no storage cost for token creation"})]})]})]}),"\n",(0,o.jsx)(t.h3,{id:"service-vs-batch-token-lease-handling",children:"Service vs. batch token lease handling"}),"\n",(0,o.jsx)(t.h4,{id:"service-tokens-1",children:"Service tokens"}),"\n",(0,o.jsx)(t.p,{children:"Leases created by service tokens (including child tokens' leases) are tracked\nalong with the service token and revoked when the token expires."}),"\n",(0,o.jsx)(t.h4,{id:"batch-tokens-1",children:"Batch tokens"}),"\n",(0,o.jsx)(t.p,{children:"Leases created by batch tokens are constrained to the remaining TTL of the\nbatch tokens and, if the batch token is not an orphan, are tracked by the\nparent. They are revoked when the batch token's TTL expires, or when the batch\ntoken's parent is revoked (at which point the batch token is also denied access\nto OpenBao)."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(96540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);