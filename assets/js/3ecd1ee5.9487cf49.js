"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[70],{50116:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var o=t(74848),r=t(28453);const s={sidebar_label:"Overview",description:"Learn about the integrated raft storage in OpenBao."},i="Integrated storage",a={id:"concepts/integrated-storage/index",title:"Integrated storage",description:"Learn about the integrated raft storage in OpenBao.",source:"@site/content/docs/concepts/integrated-storage/index.mdx",sourceDirName:"concepts/integrated-storage",slug:"/concepts/integrated-storage/",permalink:"/openbao/docs/concepts/integrated-storage/",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/concepts/integrated-storage/index.mdx",tags:[],version:"current",frontMatter:{sidebar_label:"Overview",description:"Learn about the integrated raft storage in OpenBao."},sidebar:"docs",previous:{title:"Storage",permalink:"/openbao/docs/concepts/storage"},next:{title:"Autopilot",permalink:"/openbao/docs/concepts/integrated-storage/autopilot"}},d={},c=[{value:"Server-to-Server communication",id:"server-to-server-communication",level:2},{value:"Cluster membership",id:"cluster-membership",level:2},{value:"Joining nodes",id:"joining-nodes",level:3},{value:"<code>retry_join</code> configuration",id:"retry_join-configuration",level:4},{value:"Join from the CLI",id:"join-from-the-cli",level:4},{value:"Removing peers",id:"removing-peers",level:3},{value:"Listing peers",id:"listing-peers",level:3},{value:"Integrated storage and TLS",id:"integrated-storage-and-tls",level:2},{value:"OpenBao networking recap",id:"openbao-networking-recap",level:3},{value:"Assisted raft join techniques",id:"assisted-raft-join-techniques",level:3},{value:"Autojoin with TLS servername",id:"autojoin-with-tls-servername",level:4},{value:"Autojoin but constrain CIDR, list all possible IPs in certificate",id:"autojoin-but-constrain-cidr-list-all-possible-ips-in-certificate",level:4},{value:"Load balancer instead of autojoin",id:"load-balancer-instead-of-autojoin",level:4},{value:"Outage recovery",id:"outage-recovery",level:2},{value:"Quorum maintained",id:"quorum-maintained",level:3},{value:"Quorum lost",id:"quorum-lost",level:3},{value:"Manual recovery using peers.json",id:"manual-recovery-using-peersjson",level:3},{value:"Other recovery methods",id:"other-recovery-methods",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"integrated-storage",children:"Integrated storage"}),"\n",(0,o.jsx)(n.p,{children:"OpenBao supports a number of storage options for the durable storage of OpenBao's\ninformation. This Integrated Storage backend does not rely on any third party\nsystems, implements high availability semantics and provides backup/restore\nworkflows."}),"\n",(0,o.jsxs)(n.p,{children:["The option stores OpenBao's data on the server's filesystem and\nuses a consensus protocol to replicate data to each server in the cluster. More\ninformation on the internals of Integrated Storage can be found in the\n",(0,o.jsx)(n.a,{href:"/docs/internals/integrated-storage/",children:"Integrated Storage internals\ndocumentation"}),". Additionally, the\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft/",children:"Configuration"})," docs can help in configuring\nOpenBao to use Integrated Storage."]}),"\n",(0,o.jsx)(n.p,{children:"The sections below go into various details on how to operate OpenBao with\nIntegrated Storage."}),"\n",(0,o.jsx)(n.h2,{id:"server-to-server-communication",children:"Server-to-Server communication"}),"\n",(0,o.jsxs)(n.p,{children:["Once nodes are joined to one another they begin to communicate using mTLS over\nOpenBao's cluster port. The cluster port defaults to ",(0,o.jsx)(n.code,{children:"8201"}),". The TLS information\nis exchanged at join time and is rotated on a cadence."]}),"\n",(0,o.jsxs)(n.p,{children:["A requirement for Integrated Storage is that the\n",(0,o.jsx)(n.a,{href:"/docs/concepts/ha#per-node-cluster-address",children:(0,o.jsx)(n.code,{children:"cluster_addr"})})," configuration option\nis set. This allows OpenBao to assign an address to the node ID at join time."]}),"\n",(0,o.jsx)(n.h2,{id:"cluster-membership",children:"Cluster membership"}),"\n",(0,o.jsx)(n.p,{children:"This section will outline how to bootstrap and manage a cluster of OpenBao nodes\nrunning Integrated Storage."}),"\n",(0,o.jsxs)(n.p,{children:["Integrated Storage is bootstrapped during the ",(0,o.jsx)(n.a,{href:"/tutorials/getting-started/getting-started-deploy#initializing-the-vault",children:"initialization\nprocess"}),",\nand results in a cluster of size 1. Depending on the ",(0,o.jsx)(n.a,{href:"/docs/internals/integrated-storage/#deployment-table",children:"desired deployment\nsize"}),", nodes can be joined\nto the active OpenBao node."]}),"\n",(0,o.jsx)(n.h3,{id:"joining-nodes",children:"Joining nodes"}),"\n",(0,o.jsx)(n.p,{children:"Joining is the process of taking an uninitialized OpenBao node and making it a\nmember of an existing cluster. In order to authenticate the new node to the\ncluster it must use the same seal mechanism. If using a Auto Unseal the node\nmust be configured to use the same KMS provider and Key as the cluster it's\nattempting to join. If using a Shamir seal the unseal keys must be provided to\nthe new node before the join process can complete. Once a node has successfully\njoined, data from the active node can begin to replicate to it. Once a node has\nbeen joined it cannot be re-joined to a different cluster."}),"\n",(0,o.jsxs)(n.p,{children:["You can either join the node automatically via the config file or manually through the\nAPI (both methods described below). When joining a node, the API address of the leader node must be used. We\nrecommend setting the ",(0,o.jsx)(n.a,{href:"/docs/concepts/ha#direct-access",children:(0,o.jsx)(n.code,{children:"api_addr"})})," configuration\noption on all nodes to make joining simpler."]}),"\n",(0,o.jsxs)(n.h4,{id:"retry_join-configuration",children:[(0,o.jsx)(n.code,{children:"retry_join"})," configuration"]}),"\n",(0,o.jsx)(n.p,{children:"This method enables setting one, or more, target leader nodes in the config file.\nWhen an uninitialized OpenBao server starts up it will attempt to join each potential\nleader that is defined, retrying until successful. When one of the specified\nleaders become active this node will successfully join. When using Shamir seal,\nthe joined nodes will still need to be unsealed manually. When using Auto Unseal\nthe node will be able to join and unseal automatically."}),"\n",(0,o.jsxs)(n.p,{children:["An example ",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#retry_join-stanza",children:(0,o.jsx)(n.code,{children:"retry_join"})}),"\nconfig can be seen below:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-hcl",children:'storage "raft" {\n  path    = "/var/raft/"\n  node_id = "node3"\n\n  retry_join {\n    leader_api_addr = "https://node1.openbao.local:8200"\n  }\n  retry_join {\n    leader_api_addr = "https://node2.openbao.local:8200"\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note, in each ",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#retry_join-stanza",children:(0,o.jsx)(n.code,{children:"retry_join"})}),"\nstanza, you may provide a single\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#leader_api_addr",children:(0,o.jsx)(n.code,{children:"leader_api_addr"})})," or\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#auto_join",children:(0,o.jsx)(n.code,{children:"auto_join"})})," value. When a cloud\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#auto_join",children:(0,o.jsx)(n.code,{children:"auto_join"})})," configuration value is\nprovided, OpenBao will use ",(0,o.jsx)(n.a,{href:"https://github.com/hashicorp/go-discover",children:"go-discover"}),"\nto automatically attempt to discover and resolve potential Raft leader\naddresses."]}),"\n",(0,o.jsxs)(n.p,{children:["See the go-discover\n",(0,o.jsx)(n.a,{href:"https://github.com/hashicorp/go-discover/blob/master/README.md",children:"README"})," for\ndetails on the format of the ",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#auto_join",children:(0,o.jsx)(n.code,{children:"auto_join"})})," value."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-hcl",children:'storage "raft" {\n  path    = "/var/raft/"\n  node_id = "node3"\n\n  retry_join {\n    auto_join = "provider=aws region=eu-west-1 tag_key=openbao tag_value=... access_key_id=... secret_access_key=..."\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["By default, OpenBao will attempt to reach discovered peers using HTTPS and port 8200. Operators may override these through the\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#auto_join_scheme",children:(0,o.jsx)(n.code,{children:"auto_join_scheme"})})," and\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#auto_join_port",children:(0,o.jsx)(n.code,{children:"auto_join_port"})})," fields\nrespectively."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-hcl",children:'storage "raft" {\n  path    = "/var/raft/"\n  node_id = "node3"\n\n  retry_join {\n    auto_join = "provider=aws region=eu-west-1 tag_key=openbao tag_value=... access_key_id=... secret_access_key=..."\n    auto_join_scheme = "http"\n    auto_join_port = 8201\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"join-from-the-cli",children:"Join from the CLI"}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively you can use the ",(0,o.jsxs)(n.a,{href:"/docs/commands/operator/raft/#join",children:[(0,o.jsx)(n.code,{children:"join"})," CLI\ncommand"]})," or the API to join a node. The\nactive node's API address will need to be specified:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell-session",children:"$ bao operator raft join https://node1.openbao.local:8200\n"})}),"\n",(0,o.jsx)(n.h3,{id:"removing-peers",children:"Removing peers"}),"\n",(0,o.jsx)(n.p,{children:"Removing a peer node is a necessary step when you no longer want the node in the\ncluster. This could happen if the node is rotated for a new one, the hostname\npermanently changes and can no longer be accessed, you're attempting to shrink\nthe size of the cluster, or for many other reasons. Removing the peer will\nensure the cluster stays at the desired size, and that quorum is maintained."}),"\n",(0,o.jsxs)(n.p,{children:["To remove the peer you can issue a\n",(0,o.jsx)(n.a,{href:"/docs/commands/operator/raft#remove-peer",children:(0,o.jsx)(n.code,{children:"remove-peer"})})," command and provide the\nnode ID you wish to remove:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell-session",children:"$ bao operator raft remove-peer node1\nPeer removed successfully!\n"})}),"\n",(0,o.jsx)(n.h3,{id:"listing-peers",children:"Listing peers"}),"\n",(0,o.jsxs)(n.p,{children:["To see the current peer set for the cluster you can issue a\n",(0,o.jsx)(n.a,{href:"/docs/commands/operator/raft#list-peers",children:(0,o.jsx)(n.code,{children:"list-peers"})})," command. All the voting\nnodes that are listed here contribute to the quorum and a majority must be alive\nfor Integrated Storage to continue to operate."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell-session",children:"$ bao operator raft list-peers\nNode     Address                   State       Voter\n----     -------                   -----       -----\nnode1    node1.openbao.local:8201    follower    true\nnode2    node2.openbao.local:8201    follower    true\nnode3    node3.openbao.local:8201    leader      true\n"})}),"\n",(0,o.jsx)(n.h2,{id:"integrated-storage-and-tls",children:"Integrated storage and TLS"}),"\n",(0,o.jsxs)(n.p,{children:["We've glossed over some details in the above sections on bootstrapping clusters.\nThe instructions are sufficient for most cases, but some users have run into\nproblems when using auto-join and TLS in conjunction with things like auto-scaling.\nThe issue is that ",(0,o.jsx)(n.a,{href:"https://github.com/hashicorp/go-discover",children:"go-discover"})," on\nmost platforms returns IPs (not hostnames), and because the IPs aren't knowable\nin advance, the TLS certificates used to secure the OpenBao API port don't contain\nthese IPs in their IP SANs."]}),"\n",(0,o.jsx)(n.h3,{id:"openbao-networking-recap",children:"OpenBao networking recap"}),"\n",(0,o.jsx)(n.p,{children:"Before we explore solutions to this problem, let's recapitulate how OpenBao nodes\nspeak to one another."}),"\n",(0,o.jsxs)(n.p,{children:["OpenBao exposes two TCP ports: ",(0,o.jsx)(n.a,{href:"/docs/configuration#api_addr",children:"the API port"})," and\n",(0,o.jsx)(n.a,{href:"/docs/configuration#cluster_addr",children:"the cluster port"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The API port is where clients send their OpenBao HTTP requests."}),"\n",(0,o.jsx)(n.p,{children:"For a single-node OpenBao cluster you don't worry about a cluster port as it won't be used."}),"\n",(0,o.jsx)(n.p,{children:"When you have multiple nodes, you also need a cluster port. This is used by OpenBao\nnodes to issue RPCs to one another, e.g. to forward requests from a standby node\nto the active node, or when Raft is in use, to handle leader election and\nreplication of stored data."}),"\n",(0,o.jsx)(n.p,{children:"The cluster port is secured using a TLS certificate that the OpenBao active node\ngenerates internally. It's clear how this can work when not using integrated\nstorage: every node has at least read access to storage, so once the active\nnode has persisted the certificate, the standby nodes can fetch it, and all\nagree on how cluster traffic should be encrypted."}),"\n",(0,o.jsx)(n.p,{children:"It's less clear how this works with Integrated Storage, as there is a chicken\nand egg problem. Nodes don't have a shared view of storage until the raft\ncluster has been formed, but we're trying to form the raft cluster! To solve\nthis problem, an OpenBao node must speak to another OpenBao node using the API port\ninstead of the cluster port. This is currently the only situation in which\nOpenBao does this."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"node2"})," wants to join the cluster, so issues challenge API request to existing member ",(0,o.jsx)(n.code,{children:"node1"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"node1"})," replies to challenge request with (1) an encrypted random UUID and (2) seal config"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"node2"})," must decrypt UUID using seal; if using auto-unseal can do it directly, if using Shamir must wait for user to provide enough unseal keys to perform decryption"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"node2"})," sends decrypted UUID back to ",(0,o.jsx)(n.code,{children:"node1"})," using answer API"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"node1"})," sees ",(0,o.jsx)(n.code,{children:"node2"})," can be trusted (since it has seal access) and replies with a bootstrap package which includes the cluster TLS certificate and private key"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"node2"})," gets sent a raft snapshot over the cluster port"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"After this procedure the new node will never again send traffic to the API port.\nAll subsequent inter-node communication will use the cluster port."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Raft Join Process",src:t(93526).A+"",width:"1600",height:"1026"})}),"\n",(0,o.jsx)(n.h3,{id:"assisted-raft-join-techniques",children:"Assisted raft join techniques"}),"\n",(0,o.jsxs)(n.p,{children:["The simplest option is to do it by hand: issue ",(0,o.jsx)(n.a,{href:"/docs/commands/operator/raft#join",children:(0,o.jsx)(n.code,{children:"raft join"})})," commands specifying the explicit names\nor IPs of the nodes to join to. In this section we look at other TLS-compatible\noptions that lend themselves more to automation."]}),"\n",(0,o.jsx)(n.h4,{id:"autojoin-with-tls-servername",children:"Autojoin with TLS servername"}),"\n",(0,o.jsxs)(n.p,{children:["The simplest option might be to specify a\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#leader_tls_servername",children:(0,o.jsx)(n.code,{children:"leader_tls_servername"})}),"\nin the ",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#retry_join-stanza",children:(0,o.jsx)(n.code,{children:"retry_join"})}),"\nstanza which matches a ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Subject_Alternative_Name",children:"DNS\nSAN"})," in the certificate."]}),"\n",(0,o.jsxs)(n.p,{children:["Note that names in a certificate's DNS SAN don't actually have to be registered\nin a DNS server. Your nodes may have no names found in DNS, while still\nusing certificate(s) that contain this shared ",(0,o.jsx)(n.code,{children:"servername"})," in their DNS SANs."]}),"\n",(0,o.jsx)(n.h4,{id:"autojoin-but-constrain-cidr-list-all-possible-ips-in-certificate",children:"Autojoin but constrain CIDR, list all possible IPs in certificate"}),"\n",(0,o.jsxs)(n.p,{children:["If all the OpenBao node IPs are assigned from a small subnet, e.g. a ",(0,o.jsx)(n.code,{children:"/28"}),", it\nbecomes practical to put all the IPs that exist in that subnet into the IP SANs\nof the TLS certificate the nodes will share."]}),"\n",(0,o.jsx)(n.p,{children:"The drawback here is that the cluster may someday outgrow the CIDR and changing\nit may be a pain. For similar reasons this solution may be impractical when\nusing non-voting nodes and dynamically scaling clusters."}),"\n",(0,o.jsx)(n.h4,{id:"load-balancer-instead-of-autojoin",children:"Load balancer instead of autojoin"}),"\n",(0,o.jsxs)(n.p,{children:["Most OpenBao instances are going to have a load balancer (LB) between clients and\nthe OpenBao nodes. In that case, the LB knows how to route traffic to working\nOpenBao nodes, and there's no need for auto-join: we can just use\n",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft#retry_join-stanza",children:(0,o.jsx)(n.code,{children:"retry_join"})})," with the LB\naddress as the target."]}),"\n",(0,o.jsx)(n.p,{children:"One potential issue here: some users want a public facing LB for clients to\nconnect to OpenBao, but aren't comfortable with OpenBao internal traffic\negressing from the internal network it normally runs on."}),"\n",(0,o.jsx)(n.h2,{id:"outage-recovery",children:"Outage recovery"}),"\n",(0,o.jsx)(n.h3,{id:"quorum-maintained",children:"Quorum maintained"}),"\n",(0,o.jsx)(n.p,{children:"This section outlines the steps to take when a single server or multiple servers\nare in a failed state but quorum is still maintained. This means the remaining\nalive servers are still operational, can elect a leader, and are able to process\nwrite requests."}),"\n",(0,o.jsx)(n.p,{children:"If the failed server is recoverable, the best option is to bring it back online\nand have it reconnect to the cluster with the same host address. This will return\nthe cluster to a fully healthy state."}),"\n",(0,o.jsxs)(n.p,{children:["If this is impractical, you need to remove the failed server. Usually, you can\nissue a ",(0,o.jsx)(n.a,{href:"/docs/commands/operator/raft#remove-peer",children:(0,o.jsx)(n.code,{children:"remove-peer"})})," command to\nremove the failed server if it's still a member of the cluster."]}),"\n",(0,o.jsxs)(n.p,{children:["If the ",(0,o.jsx)(n.a,{href:"/docs/commands/operator/raft#remove-peer",children:(0,o.jsx)(n.code,{children:"remove-peer"})})," command isn't\npossible or you'd rather manually re-write the cluster membership a\n",(0,o.jsx)(n.a,{href:"#manual-recovery-using-peers-json",children:(0,o.jsx)(n.code,{children:"raft/peers.json"})})," file can be written to\nthe configured data directory."]}),"\n",(0,o.jsx)(n.h3,{id:"quorum-lost",children:"Quorum lost"}),"\n",(0,o.jsx)(n.p,{children:"In the event that multiple servers are lost, causing a loss of quorum and a\ncomplete outage, partial recovery is still possible."}),"\n",(0,o.jsx)(n.p,{children:"If the failed servers are recoverable, the best option is to bring them back\nonline and have them reconnect to the cluster using the same host addresses.\nThis will return the cluster to a fully healthy state."}),"\n",(0,o.jsx)(n.p,{children:"If the failed servers are not recoverable, partial recovery is possible using\ndata on the remaining servers in the cluster. There may be data loss in this\nsituation because multiple servers were lost, so information about what's\ncommitted could be incomplete. The recovery process implicitly commits all\noutstanding Raft log entries, so it's also possible to commit data that was\nuncommitted before the failure."}),"\n",(0,o.jsxs)(n.p,{children:["See the section below on manual recovery using\n",(0,o.jsx)(n.a,{href:"#manual-recovery-using-peers-json",children:(0,o.jsx)(n.code,{children:"peers.json"})})," for details of the recovery\nprocedure. You include only the remaining servers in the\n",(0,o.jsx)(n.a,{href:"#manual-recovery-using-peers-json",children:(0,o.jsx)(n.code,{children:"peers.json"})})," recovery file. The\ncluster should be able to elect a leader once the remaining servers are all\nrestarted with an identical\n",(0,o.jsx)(n.a,{href:"#manual-recovery-using-peers-json",children:(0,o.jsx)(n.code,{children:"peers.json"})})," configuration."]}),"\n",(0,o.jsx)(n.p,{children:"Any servers you introduce later can be fresh with totally clean data\ndirectories and joined using OpenBao's join command."}),"\n",(0,o.jsxs)(n.p,{children:["In extreme cases, it should be possible to recover with just a single remaining\nserver by starting that single server with itself as the only peer in the\n",(0,o.jsx)(n.a,{href:"#manual-recovery-using-peers-json",children:(0,o.jsx)(n.code,{children:"peers.json"})})," recovery file."]}),"\n",(0,o.jsx)(n.h3,{id:"manual-recovery-using-peersjson",children:"Manual recovery using peers.json"}),"\n",(0,o.jsxs)(n.p,{children:["Using ",(0,o.jsx)(n.code,{children:"raft/peers.json"})," for recovery can cause uncommitted Raft log entries to be\nimplicitly committed, so this should only be used after an outage where no other\noption is available to recover a lost server. Make sure you don't have any\nautomated processes that will put the peers file in place on a periodic basis."]}),"\n",(0,o.jsx)(n.p,{children:"To begin, stop all remaining servers."}),"\n",(0,o.jsxs)(n.p,{children:["The next step is to go to the ",(0,o.jsx)(n.a,{href:"/docs/configuration/storage/raft/#path",children:"configured data\npath"})," of each OpenBao server. Inside that\ndirectory, there will be a ",(0,o.jsx)(n.code,{children:"raft/"})," sub-directory. We need to create a\n",(0,o.jsx)(n.code,{children:"raft/peers.json"})," file. The file should be formatted as a JSON array containing\nthe node ID, ",(0,o.jsx)(n.code,{children:"address:port"}),", and suffrage information of each OpenBao server you\nwish to be in the cluster:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "id": "node1",\n    "address": "node1.openbao.local:8201",\n    "non_voter": false\n  },\n  {\n    "id": "node2",\n    "address": "node2.openbao.local:8201",\n    "non_voter": false\n  },\n  {\n    "id": "node3",\n    "address": "node3.openbao.local:8201",\n    "non_voter": false\n  }\n]\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"id"})," ",(0,o.jsx)(n.code,{children:"(string: <required>)"})," - Specifies the node ID of the server. This can be\nfound in the config file, or inside the ",(0,o.jsx)(n.code,{children:"node-id"})," file in the server's data\ndirectory if it was auto-generated."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"address"})," ",(0,o.jsx)(n.code,{children:"(string: <required>)"})," - Specifies the host and port of the server. The\nport is the server's cluster port."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Create entries for all servers. You must confirm that servers you do not\ninclude here have indeed failed and will not later rejoin the cluster. Ensure\nthat this file is the same across all remaining server nodes."}),"\n",(0,o.jsx)(n.p,{children:"At this point, you can restart all the remaining servers. The cluster should be\nin an operable state again. One of the nodes should claim leadership and become\nactive."}),"\n",(0,o.jsx)(n.h3,{id:"other-recovery-methods",children:"Other recovery methods"}),"\n",(0,o.jsxs)(n.p,{children:["For other, non-quorum related recovery ",(0,o.jsx)(n.a,{href:"/docs/concepts/recovery-mode/",children:"OpenBao's\nrecovery"})," mode can be used."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},93526:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/raft-join-detailed-1fafbe82aaa1390b1f1b17049977fb80.png"},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);