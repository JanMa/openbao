"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6746],{35176:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var i=t(74848),r=t(28453);const a={layout:"docs",page_title:"Integrated Storage - Storage Backends - Configuration",description:"\nThe Integrated Storage (Raft) backend is used to persist OpenBao's data. Unlike all the other\nstorage backends, this backend does not operate from a single source for the\ndata. Instead all the nodes in an OpenBao cluster will have a replicated copy of\nthe entire data. The data is replicated across the nodes using the Raft\nConsensus Algorithm."},s="Integrated storage (Raft) backend",o={id:"configuration/storage/raft",title:"Integrated storage (Raft) backend",description:"\nThe Integrated Storage (Raft) backend is used to persist OpenBao's data. Unlike all the other\nstorage backends, this backend does not operate from a single source for the\ndata. Instead all the nodes in an OpenBao cluster will have a replicated copy of\nthe entire data. The data is replicated across the nodes using the Raft\nConsensus Algorithm.",source:"@site/content/docs/configuration/storage/raft.mdx",sourceDirName:"configuration/storage",slug:"/configuration/storage/raft",permalink:"/openbao/docs/configuration/storage/raft",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/configuration/storage/raft.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Integrated Storage - Storage Backends - Configuration",description:"\nThe Integrated Storage (Raft) backend is used to persist OpenBao's data. Unlike all the other\nstorage backends, this backend does not operate from a single source for the\ndata. Instead all the nodes in an OpenBao cluster will have a replicated copy of\nthe entire data. The data is replicated across the nodes using the Raft\nConsensus Algorithm."},sidebar:"docs",previous:{title:"In-Memory storage backend",permalink:"/openbao/docs/configuration/storage/in-memory"},next:{title:"telemetry stanza",permalink:"/openbao/docs/configuration/telemetry"}},l={},d=[{value:"<code>raft</code> parameters",id:"raft-parameters",level:2},{value:"<code>retry_join</code> stanza",id:"retry_join-stanza",level:3},{value:"Tutorial",id:"tutorial",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"integrated-storage-raft-backend",children:"Integrated storage (Raft) backend"}),"\n",(0,i.jsxs)(n.p,{children:["The Integrated Storage backend is used to persist OpenBao's data. Unlike other storage\nbackends, Integrated Storage does not operate from a single source of data. Instead\nall the nodes in an OpenBao cluster will have a replicated copy of OpenBao's data.\nData gets replicated across all the nodes via the ",(0,i.jsx)(n.a,{href:"https://raft.github.io/",title:"The Raft Consensus Algorithm",children:"Raft Consensus\nAlgorithm"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"High Availability"})," \u2013 the Integrated Storage backend supports high availability."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"HashiCorp Supported"})," \u2013 the Integrated Storage backend is officially supported\nby HashiCorp."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hcl",children:'storage "raft" {\n  path = "/path/to/raft/data"\n  node_id = "raft_node_1"\n}\ncluster_addr = "http://127.0.0.1:8201"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Note:"})," When using the Integrated Storage backend, it is required to provide\n",(0,i.jsx)(n.a,{href:"/docs/concepts/ha#per-node-cluster-address",children:(0,i.jsx)(n.code,{children:"cluster_addr"})})," to indicate the address and port to be used for communication\nbetween the nodes in the Raft cluster."]}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Note:"})," When using the Integrated Storage backend, a separate\n",(0,i.jsx)(n.a,{href:"/docs/configuration#ha_storage",children:(0,i.jsx)(n.code,{children:"ha_storage"})}),"\nbackend cannot be declared."]}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Note:"})," When using the Integrated Storage backend, it is strongly recommended to\nset ",(0,i.jsx)(n.a,{href:"/docs/configuration#disable_mlock",children:(0,i.jsx)(n.code,{children:"disable_mlock"})})," to ",(0,i.jsx)(n.code,{children:"true"}),", and to disable memory swapping on the system."]}),"\n",(0,i.jsxs)(n.h2,{id:"raft-parameters",children:[(0,i.jsx)(n.code,{children:"raft"})," parameters"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"path"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," \u2013 The file system path where all the OpenBao data gets\nstored.\nThis value can be overridden by setting the ",(0,i.jsx)(n.code,{children:"VAULT_RAFT_PATH"})," environment variable."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"node_id"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - The identifier for the node in the Raft cluster.\nThis value can be overridden by setting the ",(0,i.jsx)(n.code,{children:"VAULT_RAFT_NODE_ID"})," environment variable."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"performance_multiplier"})," ",(0,i.jsx)(n.code,{children:"(integer: 0)"})," - An integer multiplier used by\nservers to scale key Raft timing parameters. Tuning this affects the time it\ntakes OpenBao to detect leader failures and to perform leader elections, at the\nexpense of requiring more network and CPU resources for better performance.\nOmitting this value or setting it to 0 uses default timing described below.\nLower values are used to tighten timing and increase sensitivity while higher\nvalues relax timings and reduce sensitivity."]}),"\n",(0,i.jsx)(n.p,{children:"By default, OpenBao will use a lower-performance timing that's suitable for\nminimal OpenBao servers, currently equivalent to setting this to a value of 5\n(this default may be changed in future versions of OpenBao, depending if the\ntarget minimum server profile changes). Setting this to a value of 1 will\nconfigure Raft to its highest-performance mode and is recommended for\nproduction OpenBao servers. The maximum allowed value is 10."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"trailing_logs"})," ",(0,i.jsx)(n.code,{children:"(integer: 10000)"})," - This controls how many log entries are\nleft in the log store on disk after a snapshot is made. This should only be\nadjusted when followers cannot catch up to the leader due to a very large\nsnapshot size and high write throughput causing log truncation before a\nsnapshot can be fully installed. If you need to use this to recover a cluster,\nconsider reducing write throughput or the amount of data stored on OpenBao. The\ndefault value is 10000 which is suitable for all normal workloads. The\n",(0,i.jsx)(n.code,{children:"trailing_logs"})," metric is not the same as ",(0,i.jsx)(n.code,{children:"max_trailing_logs"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"snapshot_threshold"})," ",(0,i.jsx)(n.code,{children:"(integer: 8192)"})," - This controls the minimum number of Raft\ncommit entries between snapshots that are saved to disk. This is a low-level\nparameter that should rarely need to be changed. Very busy clusters\nexperiencing excessive disk IO may increase this value to reduce disk IO and\nminimize the chances of all servers taking snapshots at the same time.\nIncreasing this trades off disk IO for disk space since the log will grow much\nlarger and the space in the ",(0,i.jsx)(n.code,{children:"raft.db"})," file can't be reclaimed till the next\nsnapshot. Servers may take longer to recover from crashes or failover if this\nis increased significantly as more logs will need to be replayed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"snapshot_interval"})," ",(0,i.jsx)(n.code,{children:"(integer: 120 seconds)"})," - The snapshot interval\ncontrols how often Raft checks whether a snapshot operation is\nrequired. Raft randomly staggers snapshots between the configured\ninterval and twice the configured interval to keep the entire cluster\nfrom performing a snapshot at once. The default snapshot interval is\n120 seconds."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"retry_join"})," ",(0,i.jsx)(n.code,{children:"(list: [])"})," - A set of connection details for another node in the\ncluster, which is used to help nodes locate a leader in order to join a cluster.\nThere can be one or more ",(0,i.jsx)(n.a,{href:"#retry_join-stanza",children:(0,i.jsx)(n.code,{children:"retry_join"})})," stanzas."]}),"\n",(0,i.jsxs)(n.p,{children:["If the connection details for all nodes in the cluster are known in advance, you\ncan include these stanzas to enable nodes to automatically join the Raft cluster.\nOnce one of the nodes is initialized as the leader, the remaining nodes will use\ntheir ",(0,i.jsx)(n.a,{href:"#retry_join-stanza",children:(0,i.jsx)(n.code,{children:"retry_join"})})," configuration to locate the leader and\njoin the cluster. Note that when using Shamir seal, the joined nodes will still\nneed to be unsealed manually.\nSee ",(0,i.jsx)(n.a,{href:"#retry_join-stanza",children:"the section below"})," for the parameters accepted by the\n",(0,i.jsx)(n.a,{href:"#retry_join-stanza",children:(0,i.jsx)(n.code,{children:"retry_join"})})," stanza."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"retry_join_as_non_voter"})," ",(0,i.jsx)(n.code,{children:"(boolean: false)"})," - If set, causes any ",(0,i.jsx)(n.code,{children:"retry_join"}),"\nconfig to join the Raft cluster as a non-voter. The node will not participate\nin the Raft quorum but will still receive the data replication stream, adding\nread scalability to a cluster. This option has the same effect as the\n",(0,i.jsx)(n.a,{href:"/docs/commands/operator/raft#non-voter",children:(0,i.jsx)(n.code,{children:"-non-voter"})})," flag for the\n",(0,i.jsx)(n.code,{children:"bao operator raft join"})," command, but only affects voting status when joining\nvia ",(0,i.jsx)(n.code,{children:"retry_join"})," config. This setting can be overridden to true by setting the\n",(0,i.jsx)(n.code,{children:"VAULT_RAFT_RETRY_JOIN_AS_NON_VOTER"})," environment variable to any non-empty value.\nOnly valid if there is at least one ",(0,i.jsx)(n.code,{children:"retry_join"})," stanza."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"max_entry_size"})," ",(0,i.jsx)(n.code,{children:"(integer: 1048576)"})," - This configures the maximum number of\nbytes for a Raft entry. It applies to both Put operations and transactions.\nAny put or transaction operation exceeding this configuration value will cause\nthe respective operation to fail. Raft has a suggested max size of data in a\nRaft log entry. This is based on current architecture, default timing, etc.\nIntegrated Storage also uses a chunk size that is the threshold used for\nbreaking a large value into chunks. By default, the chunk size is the same as\nRaft's max size log entry. The default value for this configuration is 1048576\n-- two times the chunking size."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"autopilot_reconcile_interval"})," ",(0,i.jsx)(n.code,{children:'(string: "10s")'})," - This is the interval after\nwhich autopilot will pick up any state changes. State change could mean multiple\nthings; for example a newly joined voter node, initially added as non-voter to\nthe Raft cluster by autopilot has successfully completed the stabilization\nperiod thereby qualifying for being promoted as a voter, a node that has become\nunhealthy and needs to be shown as such in the state API, a node has been marked\nas dead needing eviction from Raft configuration, etc."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"autopilot_update_interval"})," ",(0,i.jsx)(n.code,{children:'(string: "2s")'})," - This is the interval after which\nautopilot will poll OpenBao for any updates to the information it cares about. This\nincludes things like the autopilot configuration, current autopilot state, raft\nconfiguration, known servers, latest raft index, and stats for all the known servers.\nThe information that autopilot receives will be used to calculate its next state."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"retry_join-stanza",children:[(0,i.jsx)(n.code,{children:"retry_join"})," stanza"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_api_addr"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - Address of a possible leader node."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"auto_join"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - Cloud auto-join configuration, using\n",(0,i.jsx)(n.a,{href:"https://github.com/hashicorp/go-discover",children:"go-discover"})," syntax."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"auto_join_scheme"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - The optional URI protocol scheme for addresses\ndiscovered via auto-join. Available values are ",(0,i.jsx)(n.code,{children:"http"})," or ",(0,i.jsx)(n.code,{children:"https"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"auto_join_port"})," ",(0,i.jsx)(n.code,{children:'(uint: "")'})," - The optional port used for addressed discovered\nvia auto-join."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_tls_servername"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - The TLS server name to use when\nconnecting with HTTPS.\nShould match one of the names in the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Subject_Alternative_Name",children:"DNS\nSANs"})," of the remote\nserver certificate.\nSee also ",(0,i.jsx)(n.a,{href:"/docs/concepts/integrated-storage#autojoin-with-tls-servername",children:"Integrated Storage and TLS"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_ca_cert_file"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - File path to the CA cert of the\npossible leader node."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_client_cert_file"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - File path to the client certificate\nfor the follower node to establish client authentication with the possible\nleader node."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_client_key_file"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - File path to the client key for the\nfollower node to establish client authentication with the possible leader node."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_ca_cert"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - CA cert of the possible leader node."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_client_cert"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - Client certificate for the follower node\nto establish client authentication with the possible leader node."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leader_client_key"})," ",(0,i.jsx)(n.code,{children:'(string: "")'})," - Client key for the follower node to\nestablish client authentication with the possible leader node."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(n.a,{href:"#retry_join-stanza",children:(0,i.jsx)(n.code,{children:"retry_join"})})," block may provide TLS certificates via\nfile paths or as a single-line certificate string value with newlines delimited\nby ",(0,i.jsx)(n.code,{children:"\\n"}),", but not a combination of both. Each ",(0,i.jsx)(n.a,{href:"#retry_join-stanza",children:(0,i.jsx)(n.code,{children:"retry_join"})}),"\nstanza may contain either a ",(0,i.jsx)(n.a,{href:"#leader_api_addr",children:(0,i.jsx)(n.code,{children:"leader_api_addr"})})," value or a\ncloud ",(0,i.jsx)(n.a,{href:"#auto_join",children:(0,i.jsx)(n.code,{children:"auto_join"})})," configuration value, but not both. When an\n",(0,i.jsx)(n.a,{href:"#auto_join",children:(0,i.jsx)(n.code,{children:"auto_join"})})," value is provided, OpenBao will automatically attempt to\ndiscover and resolve potential Raft leader addresses using ",(0,i.jsx)(n.a,{href:"https://github.com/hashicorp/go-discover",children:"go-discover"}),".\nSee the go-discover\n",(0,i.jsx)(n.a,{href:"https://github.com/hashicorp/go-discover/blob/master/README.md",children:"README"}),"\nfor details on the format of the ",(0,i.jsx)(n.code,{children:"auto_join"})," value."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, OpenBao will attempt to reach discovered peers using HTTPS and port 8200. Operators may override these through the\n",(0,i.jsx)(n.a,{href:"#auto_join_scheme",children:(0,i.jsx)(n.code,{children:"auto_join_scheme"})})," and ",(0,i.jsx)(n.a,{href:"#auto_join_port",children:(0,i.jsx)(n.code,{children:"auto_join_port"})}),"\nfields respectively."]}),"\n",(0,i.jsx)(n.p,{children:"Example Configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-hcl",children:'storage "raft" {\n  path    = "/Users/foo/raft/"\n  node_id = "node1"\n\n  retry_join {\n    leader_api_addr = "http://127.0.0.2:8200"\n    leader_ca_cert_file = "/path/to/ca1"\n    leader_client_cert_file = "/path/to/client/cert1"\n    leader_client_key_file = "/path/to/client/key1"\n  }\n  retry_join {\n    leader_api_addr = "http://127.0.0.3:8200"\n    leader_ca_cert_file = "/path/to/ca2"\n    leader_client_cert_file = "/path/to/client/cert2"\n    leader_client_key_file = "/path/to/client/key2"\n  }\n  retry_join {\n    leader_api_addr = "http://127.0.0.4:8200"\n    leader_ca_cert_file = "/path/to/ca3"\n    leader_client_cert_file = "/path/to/client/cert3"\n    leader_client_key_file = "/path/to/client/key3"\n  }\n  retry_join {\n    auto_join = "provider=aws region=eu-west-1 tag_key=openbao tag_value=... access_key_id=... secret_access_key=..."\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,i.jsxs)(n.p,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"/tutorials/raft",children:"Integrated\nStorage"})," series of tutorials to learn more about implementing OpenBao using Integrated Storage."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);