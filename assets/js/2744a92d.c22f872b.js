"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6406],{95670:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var s=t(74848),a=t(28453);const r={layout:"docs",page_title:"Lease, Renew, and Revoke",description:"OpenBao provides a lease with every secret. When this lease is expired, OpenBao will revoke that secret."},o="Lease, renew, and revoke",i={id:"concepts/lease",title:"Lease, renew, and revoke",description:"OpenBao provides a lease with every secret. When this lease is expired, OpenBao will revoke that secret.",source:"@site/content/docs/concepts/lease.mdx",sourceDirName:"concepts",slug:"/concepts/lease",permalink:"/openbao/docs/concepts/lease",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/concepts/lease.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Lease, Renew, and Revoke",description:"OpenBao provides a lease with every secret. When this lease is expired, OpenBao will revoke that secret."},sidebar:"docs",previous:{title:"Seal/Unseal",permalink:"/openbao/docs/concepts/seal"},next:{title:"Authentication",permalink:"/openbao/docs/concepts/auth"}},c={},l=[{value:"Lease IDs",id:"lease-ids",level:2},{value:"Lease durations and renewal",id:"lease-durations-and-renewal",level:2},{value:"Prefix-based revocation",id:"prefix-based-revocation",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"lease-renew-and-revoke",children:"Lease, renew, and revoke"}),"\n",(0,s.jsxs)(n.p,{children:["With every dynamic secret and ",(0,s.jsx)(n.code,{children:"service"})," type authentication token, OpenBao\ncreates a ",(0,s.jsx)(n.em,{children:"lease"}),": metadata containing information such as a time duration,\nrenewability, and more. OpenBao promises that the data will be valid for the\ngiven duration, or Time To Live (TTL). Once the lease is expired, OpenBao can\nautomatically revoke the data, and the consumer of the secret can no longer be\ncertain that it is valid."]}),"\n",(0,s.jsx)(n.p,{children:"The benefit should be clear: consumers of secrets need to check in with\nOpenBao routinely to either renew the lease (if allowed) or request a\nreplacement secret. This makes the OpenBao audit logs more valuable and\nalso makes key rolling a lot easier."}),"\n",(0,s.jsx)(n.p,{children:"All dynamic secrets in OpenBao are required to have a lease. Even if the data is\nmeant to be valid for eternity, a lease is required to force the consumer\nto check in routinely."}),"\n",(0,s.jsxs)(n.p,{children:["In addition to renewals, a lease can be ",(0,s.jsx)(n.em,{children:"revoked"}),". When a lease is revoked, it\ninvalidates that secret immediately and prevents any further renewals. For\nexample, with the ",(0,s.jsx)(n.a,{href:"/docs/secrets/kubernetes",children:"Kubernetes secrets engine"}),", the\nservice accounts will be deleted from Kubernetes the moment a lease is revoked. This\nrenders the access keys invalid from that point forward."]}),"\n",(0,s.jsxs)(n.p,{children:["Revocation can happen manually via the API, via the ",(0,s.jsx)(n.code,{children:"bao lease revoke"})," cli command,\nthe user interface (UI) under the Access tab, or automatically by OpenBao. When a lease\nis expired, OpenBao will automatically revoke that lease. When a token is revoked,\nOpenBao will revoke all leases that were created using that token."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": The ",(0,s.jsx)(n.a,{href:"/docs/secrets/kv",children:"Key/Value Backend"})," which stores\narbitrary secrets does not issue leases although it will sometimes return a\nlease duration; see the documentation for more information."]}),"\n",(0,s.jsx)(n.h2,{id:"lease-ids",children:"Lease IDs"}),"\n",(0,s.jsxs)(n.p,{children:["When reading a dynamic secret, such as via ",(0,s.jsx)(n.code,{children:"bao read"}),", OpenBao always returns a\n",(0,s.jsx)(n.code,{children:"lease_id"}),". This is the ID used with commands such as ",(0,s.jsx)(n.code,{children:"bao lease renew"})," and ",(0,s.jsx)(n.code,{children:"bao lease revoke"})," to manage the lease of the secret."]}),"\n",(0,s.jsx)(n.h2,{id:"lease-durations-and-renewal",children:"Lease durations and renewal"}),"\n",(0,s.jsxs)(n.p,{children:["Along with the lease ID, a ",(0,s.jsx)(n.em,{children:"lease duration"})," can be read. The lease duration is\na Time To Live value: the time in seconds for which the lease is valid. A\nconsumer of this secret must renew the lease within that time."]}),"\n",(0,s.jsxs)(n.p,{children:["When renewing the lease, the user can request a specific amount of time they\nwant remaining on the lease, termed the ",(0,s.jsx)(n.code,{children:"increment"}),". This is not an increment\nat the end of the current TTL; it is an increment ",(0,s.jsx)(n.em,{children:"from the current time"}),". For\nexample, ",(0,s.jsx)(n.code,{children:"bao lease renew -increment=3600 my-lease-id"})," would request that the TTL of the lease\nbe adjusted to 1 hour (3600 seconds). Having the increment be rooted at the\ncurrent time instead of the end of the lease makes it easy for users to reduce\nthe length of leases if they don't actually need credentials for the full\npossible lease period, allowing those credentials to expire sooner and\nresources to be cleaned up earlier."]}),"\n",(0,s.jsx)(n.p,{children:"The requested increment is completely advisory. The backend in charge of the\nsecret can choose to completely ignore it. For most secrets, the backend does\nits best to respect the increment, but often limits it to ensure renewals every\nso often."}),"\n",(0,s.jsx)(n.p,{children:"As a result, the return value of renewals should be carefully inspected to\ndetermine what the new lease is."}),"\n",(0,s.jsxs)(n.p,{children:["-> To implement token renewal logic in your application code, refer to the ",(0,s.jsx)(n.a,{href:"/docs/concepts/auth#code-example",children:"code example in the Authentication doc"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"prefix-based-revocation",children:"Prefix-based revocation"}),"\n",(0,s.jsx)(n.p,{children:"In addition to revoking a single secret, operators with proper access control\ncan revoke multiple secrets based on their lease ID prefix."}),"\n",(0,s.jsxs)(n.p,{children:["Lease IDs are structured in a way that their prefix is always the path where\nthe secret was requested from. This lets you revoke trees of secrets. For\nexample, to revoke all Userpass logins, you can do ",(0,s.jsx)(n.code,{children:"bao lease revoke -prefix auth/userpass/"}),".\nFor more information about revoke command please check\n",(0,s.jsx)(n.a,{href:"/docs/commands/lease/revoke#lease-revoke",children:"cli's lease revoke"}),"\ncommand docs."]}),"\n",(0,s.jsx)(n.p,{children:"This is very useful if there is an intrusion within a specific system: all\nsecrets of a specific backend or a certain configured backend can be revoked\nquickly and easily."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);