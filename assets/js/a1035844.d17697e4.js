"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5189],{71580:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>h});var a=n(74848),r=n(28453),o=n(11470),s=n(19365);const i={layout:"docs",page_title:"AppRole - Auth Methods",description:"The AppRole auth method allows machines and services to authenticate with\nOpenBao."},l="AppRole auth method",c={id:"auth/approle",title:"AppRole auth method",description:"The AppRole auth method allows machines and services to authenticate with\nOpenBao.",source:"@site/content/docs/auth/approle.mdx",sourceDirName:"auth",slug:"/auth/approle",permalink:"/openbao/docs/auth/approle",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/auth/approle.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"AppRole - Auth Methods",description:"The AppRole auth method allows machines and services to authenticate with\nOpenBao."},sidebar:"tutorialSidebar",previous:{title:"Auth methods",permalink:"/openbao/docs/auth/"},next:{title:"TLS certificates auth method",permalink:"/openbao/docs/auth/cert"}},d={},h=[{value:"Authentication",id:"authentication",level:2},{value:"Via the CLI",id:"via-the-cli",level:3},{value:"Via the API",id:"via-the-api",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Via the CLI",id:"via-the-cli-1",level:3},{value:"Via the API",id:"via-the-api-1",level:3},{value:"Credentials/Constraints",id:"credentialsconstraints",level:2},{value:"RoleID",id:"roleid",level:3},{value:"SecretID",id:"secretid",level:3},{value:"Pull and push SecretID modes",id:"pull-and-push-secretid-modes",level:4},{value:"Further constraints",id:"further-constraints",level:3},{value:"Tutorial",id:"tutorial",level:2},{value:"User lockout",id:"user-lockout",level:2},{value:"API",id:"api",level:2},{value:"Code example",id:"code-example",level:2}];function u(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"approle-auth-method",children:"AppRole auth method"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"approle"})," auth method allows machines or ",(0,a.jsx)(t.em,{children:"apps"})," to authenticate with\nOpenBao-defined ",(0,a.jsx)(t.em,{children:"roles"}),". The open design of ",(0,a.jsx)(t.code,{children:"AppRole"})," enables a varied set of\nworkflows and configurations to handle large numbers of apps. This auth method\nis oriented to automated workflows (machines and services), and is less useful\nfor human operators."]}),"\n",(0,a.jsx)(t.p,{children:'An "AppRole" represents a set of OpenBao policies and login constraints that must\nbe met to receive a token with those policies. The scope can be as narrow or\nbroad as desired. An AppRole can be created for a particular machine, or even\na particular user on that machine, or a service spread across machines. The\ncredentials required for successful login depend upon the constraints set on\nthe AppRole associated with the credentials.'}),"\n",(0,a.jsx)(t.h2,{id:"authentication",children:"Authentication"}),"\n",(0,a.jsx)(t.h3,{id:"via-the-cli",children:"Via the CLI"}),"\n",(0,a.jsxs)(t.p,{children:["The default path is ",(0,a.jsx)(t.code,{children:"/approle"}),". If this auth method was enabled at a different\npath, specify ",(0,a.jsx)(t.code,{children:"auth/my-path/login"})," instead."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:"$ bao write auth/approle/login \\\n    role_id=db02de05-fa39-4855-059b-67221c5c2f63 \\\n    secret_id=6a174c20-f6de-a53c-74d2-6018fcceff64\n\nKey                Value\n---                -----\ntoken              65b74ffd-842c-fd43-1386-f7d7006e520a\ntoken_accessor     3c29bc22-5c72-11a6-f778-2bc8f48cea0e\ntoken_duration     20m0s\ntoken_renewable    true\ntoken_policies     [default]\n"})}),"\n",(0,a.jsx)(t.h3,{id:"via-the-api",children:"Via the API"}),"\n",(0,a.jsxs)(t.p,{children:["The default endpoint is ",(0,a.jsx)(t.code,{children:"auth/approle/login"}),". If this auth method was enabled\nat a different path, use that value instead of ",(0,a.jsx)(t.code,{children:"approle"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:'$ curl \\\n    --request POST \\\n    --data \'{"role_id":"988a9df-...","secret_id":"37b74931..."}\' \\\n    http://127.0.0.1:8200/v1/auth/approle/login\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The response will contain the token at ",(0,a.jsx)(t.code,{children:"auth.client_token"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'{\n  "auth": {\n    "renewable": true,\n    "lease_duration": 2764800,\n    "metadata": {},\n    "policies": ["default", "dev-policy", "test-policy"],\n    "accessor": "5d7fb475-07cb-4060-c2de-1ca3fcbf0c56",\n    "client_token": "98a4c7ab-b1fe-361b-ba0b-e307aacfd587"\n  }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["-> ",(0,a.jsx)(t.strong,{children:"Application Integration:"})," See the ",(0,a.jsx)(t.a,{href:"#code-example",children:"Code Example"})," section\nfor a code snippet demonstrating the authentication with OpenBao using the\nAppRole auth method."]}),"\n",(0,a.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,a.jsx)(t.p,{children:"Auth methods must be configured in advance before users or machines can\nauthenticate. These steps are usually completed by an operator or configuration\nmanagement tool."}),"\n",(0,a.jsx)(t.h3,{id:"via-the-cli-1",children:"Via the CLI"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Enable the AppRole auth method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:"$ bao auth enable approle\n"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Create a named role:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:"$ bao write auth/approle/role/my-role \\\n    secret_id_ttl=10m \\\n    token_num_uses=10 \\\n    token_ttl=20m \\\n    token_max_ttl=30m \\\n    secret_id_num_uses=40\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["~> ",(0,a.jsx)(t.strong,{children:"Note:"})," If the token issued by your approle needs the ability to create child tokens, you will need to set token_num_uses to 0."]}),"\n",(0,a.jsx)(t.p,{children:"For the complete list of configuration options, please see the API\ndocumentation."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Fetch the RoleID of the AppRole:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:"$ bao read auth/approle/role/my-role/role-id\nrole_id     db02de05-fa39-4855-059b-67221c5c2f63\n"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Get a SecretID issued against the AppRole:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:"$ bao write -f auth/approle/role/my-role/secret-id\nsecret_id               6a174c20-f6de-a53c-74d2-6018fcceff64\nsecret_id_accessor      c454f7e5-996e-7230-6074-6ef26b7bcf86\nsecret_id_ttl           10m\nsecret_id_num_uses      40\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"via-the-api-1",children:"Via the API"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Enable the AppRole auth method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:'$ curl \\\n    --header "X-Vault-Token: ..." \\\n    --request POST \\\n    --data \'{"type": "approle"}\' \\\n    http://127.0.0.1:8200/v1/sys/auth/approle\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Create an AppRole with desired set of policies:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:'$ curl \\\n    --header "X-Vault-Token: ..." \\\n    --request POST \\\n    --data \'{"policies": "dev-policy,test-policy"}\' \\\n    http://127.0.0.1:8200/v1/auth/approle/role/my-role\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Fetch the identifier of the role:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:'$ curl \\\n    --header "X-Vault-Token: ..." \\\n    http://127.0.0.1:8200/v1/auth/approle/role/my-role/role-id\n'})}),"\n",(0,a.jsx)(t.p,{children:"The response will look like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'{\n  "data": {\n    "role_id": "988a9dfd-ea69-4a53-6cb6-9d6b86474bba"\n  }\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Create a new secret identifier under the role:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:'$ curl \\\n    --header "X-Vault-Token: ..." \\\n    --request POST \\\n     http://127.0.0.1:8200/v1/auth/approle/role/my-role/secret-id\n'})}),"\n",(0,a.jsx)(t.p,{children:"The response will look like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'{\n  "data": {\n    "secret_id_accessor": "45946873-1d96-a9d4-678c-9229f74386a5",\n    "secret_id": "37b74931-c4cd-d49a-9246-ccc62d682a25",\n    "secret_id_ttl": 600,\n    "secret_id_num_uses": 40\n  }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"credentialsconstraints",children:"Credentials/Constraints"}),"\n",(0,a.jsx)(t.h3,{id:"roleid",children:"RoleID"}),"\n",(0,a.jsxs)(t.p,{children:["RoleID is an identifier that selects the AppRole against which the other\ncredentials are evaluated. When authenticating against this auth method's login\nendpoint, the RoleID is a required argument (via ",(0,a.jsx)(t.code,{children:"role_id"}),") at all times. By\ndefault, RoleIDs are unique UUIDs, which allow them to serve as secondary\nsecrets to the other credential information. However, they can be set to\nparticular values to match introspected information by the client (for\ninstance, the client's domain name)."]}),"\n",(0,a.jsx)(t.h3,{id:"secretid",children:"SecretID"}),"\n",(0,a.jsxs)(t.p,{children:["SecretID is a credential that is required by default for any login (via\n",(0,a.jsx)(t.code,{children:"secret_id"}),") and is intended to always be secret. (For advanced usage,\nrequiring a SecretID can be disabled via an AppRole's ",(0,a.jsx)(t.code,{children:"bind_secret_id"}),"\nparameter, allowing machines with only knowledge of the RoleID, or matching\nother set constraints, to fetch a token). SecretIDs can be created against an\nAppRole either via generation of a 128-bit purely random UUID by the role\nitself (",(0,a.jsx)(t.code,{children:"Pull"})," mode) or via specific, custom values (",(0,a.jsx)(t.code,{children:"Push"})," mode). Similarly to\ntokens, SecretIDs have properties like usage-limit, TTLs and expirations."]}),"\n",(0,a.jsx)(t.h4,{id:"pull-and-push-secretid-modes",children:"Pull and push SecretID modes"}),"\n",(0,a.jsxs)(t.p,{children:['If the SecretID used for login is fetched from an AppRole, this is operating in\nPull mode. If a "custom" SecretID is set against an AppRole by the client, it\nis referred to as a Push mode. Push mode mimics the behavior of the deprecated\nApp-ID auth method; however, in most cases Pull mode is the better approach. The\nreason is that Push mode requires some other system to have knowledge of the\nfull set of client credentials (RoleID and SecretID) in order to create the\nentry, even if these are then distributed via different paths. However, in Pull\nmode, even though the RoleID must be known in order to distribute it to the\nclient, the SecretID can be kept confidential from all parties except for the\nfinal authenticating client by using ',(0,a.jsx)(t.a,{href:"/docs/concepts/response-wrapping",children:"Response Wrapping"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Push mode is available for App-ID workflow compatibility, which in some\nspecific cases is preferable, but in most cases Pull mode is more secure and\nshould be preferred."}),"\n",(0,a.jsx)(t.h3,{id:"further-constraints",children:"Further constraints"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"role_id"})," is a required credential at the login endpoint. AppRole pointed to by\nthe ",(0,a.jsx)(t.code,{children:"role_id"})," will have constraints set on it. This dictates other ",(0,a.jsx)(t.code,{children:"required"}),"\ncredentials for login. The ",(0,a.jsx)(t.code,{children:"bind_secret_id"})," constraint requires ",(0,a.jsx)(t.code,{children:"secret_id"})," to\nbe presented at the login endpoint. Going forward, this auth method can support\nmore constraint parameters to support varied set of Apps. Some constraints will\nnot require a credential, but still enforce constraints for login. For\nexample, ",(0,a.jsx)(t.code,{children:"secret_id_bound_cidrs"})," will only allow logins coming from IP addresses\nbelonging to configured CIDR blocks on the AppRole."]}),"\n",(0,a.jsx)(t.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,a.jsxs)(t.p,{children:["Refer to the ",(0,a.jsx)(t.a,{href:"/tutorials/auth-methods/approle",children:"AppRole Pull\nAuthentication"}),"\ntutorial to learn how to use the AppRole method to generate tokens for machines or apps."]}),"\n",(0,a.jsx)(t.h2,{id:"user-lockout",children:"User lockout"}),"\n",(0,a.jsx)(t.p,{children:'If a user provides bad credentials several times in quick succession,\nOpenBao will stop trying to validate their credentials for a while, instead returning immediately\nwith a permission denied error. We call this behavior "user lockout". The time for which\na user will be locked out is called \u201clockout duration\u201d. The user will be able to login after the lockout\nduration has passed. The number of failed login attempts after which the user is locked out is called\n\u201clockout threshold\u201d. The lockout threshold counter is reset to zero after a few minutes without login attempts,\nor upon a successful login attempt. The duration after which the counter will be reset to zero\nafter no login attempts is called "lockout counter reset". This can defeat both automated and targeted requests\ni.e, user-based password guessing attacks as well as automated attacks.'}),"\n",(0,a.jsx)(t.p,{children:'The user lockout feature is enabled by default. The default values for "lockout threshold" is 5 attempts,\n"lockout duration" is 15 minutes, "lockout counter reset" is 15 minutes.'}),"\n",(0,a.jsx)(t.p,{children:"The user lockout feature can be disabled as follows:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["It can be disabled globally using environment variable ",(0,a.jsx)(t.code,{children:"VAULT_DISABLE_USER_LOCKOUT"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["It can be disabled for all supported auth methods (ldap, userpass and approle) or a specific supported auth method using the ",(0,a.jsx)(t.code,{children:"disable_lockout"}),"\nparameter within ",(0,a.jsx)(t.code,{children:"user_lockout"})," stanza in configuration file.\nPlease see ",(0,a.jsx)(t.a,{href:"/docs/configuration/user-lockout#user_lockout-stanza",children:"user lockout configuration"})," for more details."]}),"\n",(0,a.jsxs)(t.li,{children:['It can be disabled for a specific auth mount using "auth tune". Please see ',(0,a.jsx)(t.a,{href:"/docs/commands/auth/tune",children:"auth tune command"}),"\nor ",(0,a.jsx)(t.a,{href:"/api-docs/system/auth#tune-auth-method",children:"auth tune api"})," for more details."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["~> ",(0,a.jsx)(t.strong,{children:"NOTE"}),": This feature is only supported by the userpass, ldap, and approle auth methods."]}),"\n",(0,a.jsx)(t.h2,{id:"api",children:"API"}),"\n",(0,a.jsxs)(t.p,{children:["The AppRole auth method has a full HTTP API. Please see the\n",(0,a.jsx)(t.a,{href:"/api-docs/auth/approle",children:"AppRole API"})," for more\ndetails."]}),"\n",(0,a.jsx)(t.h2,{id:"code-example",children:"Code example"}),"\n",(0,a.jsx)(t.p,{children:"The following example demonstrates AppRole authentication with response\nwrapping."}),"\n",(0,a.jsx)(o.A,{children:(0,a.jsx)(s.A,{value:"Go",heading:"Go",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"os"\n\n\topenbao "github.com/openbao/openbao/api"\n\tauth "github.com/openbao/openbao/api/auth/approle"\n)\n\n// Fetches a key-value secret (kv-v2) after authenticating via AppRole.\nfunc getSecretWithAppRole() (string, error) {\n\tconfig := openbao.DefaultConfig() // modify for more granular configuration\n\n\tclient, err := openbao.NewClient(config)\n\tif err != nil {\n\t\treturn "", fmt.Errorf("unable to initialize OpenBao client: %w", err)\n\t}\n\n\t// A combination of a Role ID and Secret ID is required to log in to OpenBao\n\t// with an AppRole.\n\t// First, let\'s get the role ID given to us by our OpenBao administrator.\n\troleID := os.Getenv("APPROLE_ROLE_ID")\n\tif roleID == "" {\n\t\treturn "", fmt.Errorf("no role ID was provided in APPROLE_ROLE_ID env var")\n\t}\n\n\t// The Secret ID is a value that needs to be protected, so instead of the\n\t// app having knowledge of the secret ID directly, we have a trusted orchestrator (https://learn.hashicorp.com/tutorials/vault/secure-introduction?in=vault/app-integration#trusted-orchestrator)\n\t// give the app access to a short-lived response-wrapping token (https://www.vaultproject.io/docs/concepts/response-wrapping).\n\t// Read more at: https://learn.hashicorp.com/tutorials/vault/approle-best-practices?in=vault/auth-methods#secretid-delivery-best-practices\n\tsecretID := &auth.SecretID{FromFile: "path/to/wrapping-token"}\n\n\tappRoleAuth, err := auth.NewAppRoleAuth(\n\t\troleID,\n\t\tsecretID,\n\t\tauth.WithWrappingToken(), // Only required if the secret ID is response-wrapped.\n\t)\n\tif err != nil {\n\t\treturn "", fmt.Errorf("unable to initialize AppRole auth method: %w", err)\n\t}\n\n\tauthInfo, err := client.Auth().Login(context.Background(), appRoleAuth)\n\tif err != nil {\n\t\treturn "", fmt.Errorf("unable to login to AppRole auth method: %w", err)\n\t}\n\tif authInfo == nil {\n\t\treturn "", fmt.Errorf("no auth info was returned after login")\n\t}\n\n\t// get secret from the default mount path for KV v2 in dev mode, "secret"\n\tsecret, err := client.KVv2("secret").Get(context.Background(), "creds")\n\tif err != nil {\n\t\treturn "", fmt.Errorf("unable to read secret: %w", err)\n\t}\n\n\t// data map can contain more than one key-value pair,\n\t// in this case we\'re just grabbing one of them\n\tvalue, ok := secret.Data["password"].(string)\n\tif !ok {\n\t\treturn "", fmt.Errorf("value type assertion failed: %T %#v", secret.Data["password"], secret.Data["password"])\n\t}\n\n\treturn value, nil\n}\n'})})})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>s});n(96540);var a=n(34164);const r={tabItem:"tabItem_Ymn6"};var o=n(74848);function s(e){let{children:t,hidden:n,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>k});var a=n(96540),r=n(34164),o=n(23104),s=n(56347),i=n(205),l=n(57485),c=n(31682),d=n(89466);function h(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const r=(0,s.W6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=u(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[c,h]=f({queryString:n,groupId:r}),[m,b]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,d.Dv)(n);return[r,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),g=(()=>{const e=c??m;return p({value:e,tabValues:o})?e:null})();(0,i.A)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),b(e)}),[h,b,o]),tabValues:o}}var b=n(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=n(74848);function v(e){let{className:t,block:n,selectedValue:a,selectValue:s,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),d=e=>{const t=e.currentTarget,n=l.indexOf(t),r=i[n].value;r!==a&&(c(t),s(r))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:i.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:h,onClick:d,...o,className:(0,r.A)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function j(e){let{lazy:t,children:n,selectedValue:r}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function w(e){const t=m(e);return(0,x.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,x.jsx)(v,{...e,...t}),(0,x.jsx)(j,{...e,...t})]})}function k(e){const t=(0,b.A)();return(0,x.jsx)(w,{...e,children:h(e.children)},String(t))}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var a=n(96540);const r={},o=a.createContext(r);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);