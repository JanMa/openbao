"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1875],{90602:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=t(74848),a=t(28453);const i={layout:"docs",page_title:"Agent Sidecar Injector Overview",description:"The Vault Agent Sidecar Injector is a Kubernetes admission webhook that adds Vault Agent containers to pods for consuming Vault secrets."},o="Agent sidecar injector",r={id:"platform/k8s/injector/index",title:"Agent sidecar injector",description:"The Vault Agent Sidecar Injector is a Kubernetes admission webhook that adds Vault Agent containers to pods for consuming Vault secrets.",source:"@site/content/docs/platform/k8s/injector/index.mdx",sourceDirName:"platform/k8s/injector",slug:"/platform/k8s/injector/",permalink:"/openbao/docs/platform/k8s/injector/",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/platform/k8s/injector/index.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Agent Sidecar Injector Overview",description:"The Vault Agent Sidecar Injector is a Kubernetes admission webhook that adds Vault Agent containers to pods for consuming Vault secrets."},sidebar:"tutorialSidebar",previous:{title:"Configuring Vault helm with terraform",permalink:"/openbao/docs/platform/k8s/helm/terraform"},next:{title:"Annotations",permalink:"/openbao/docs/platform/k8s/injector/annotations"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Mutations",id:"mutations",level:3},{value:"Authenticating with Vault",id:"authenticating-with-vault",level:3},{value:"Requesting secrets",id:"requesting-secrets",level:3},{value:"Secrets via annotations",id:"secrets-via-annotations",level:4},{value:"Secret templates",id:"secret-templates",level:5},{value:"Renewals and updating secrets",id:"renewals-and-updating-secrets",level:3},{value:"Vault agent configuration map",id:"vault-agent-configuration-map",level:3},{value:"Tutorial",id:"tutorial",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"agent-sidecar-injector",children:"Agent sidecar injector"}),"\n",(0,s.jsxs)(n.p,{children:["The Vault Agent Injector alters pod specifications to include Vault Agent\ncontainers that render Vault secrets to a shared memory volume using\n",(0,s.jsx)(n.a,{href:"/docs/agent-and-proxy/agent/template",children:"Vault Agent Templates"}),".\nBy rendering secrets to a shared volume, containers within the pod can consume\nVault secrets without being Vault aware."]}),"\n",(0,s.jsxs)(n.p,{children:["The injector is a ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/",children:"Kubernetes Mutation Webhook Controller"}),".\nThe controller intercepts pod events and applies mutations to the pod if annotations exist within\nthe request. This functionality is provided by the ",(0,s.jsx)(n.a,{href:"https://github.com/hashicorp/vault-k8s",children:"vault-k8s"}),"\nproject and can be automatically installed and configured using the\n",(0,s.jsx)(n.a,{href:"https://github.com/hashicorp/vault-helm",children:"Vault Helm"})," chart."]}),"\n",(0,s.jsx)(n.h2,{children:"Supported kubernetes versions"}),"\n",(0,s.jsxs)(n.p,{children:["The following ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/releases/",children:"Kubernetes minor releases"})," are currently supported.\nThe latest version is tested against each Kubernetes version. It may work with\nother versions of Kubernetes, but those are not supported."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1.27"}),"\n",(0,s.jsx)(n.li,{children:"1.26"}),"\n",(0,s.jsx)(n.li,{children:"1.25"}),"\n",(0,s.jsx)(n.li,{children:"1.24"}),"\n",(0,s.jsx)(n.li,{children:"1.23"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The Vault Agent Injector works by intercepting pod ",(0,s.jsx)(n.code,{children:"CREATE"})," and ",(0,s.jsx)(n.code,{children:"UPDATE"}),"\nevents in Kubernetes. The controller parses the event and looks for the metadata\nannotation ",(0,s.jsx)(n.code,{children:"vault.hashicorp.com/agent-inject: true"}),". If found, the controller will\nalter the pod specification based on other annotations present."]}),"\n",(0,s.jsx)(n.h3,{id:"mutations",children:"Mutations"}),"\n",(0,s.jsxs)(n.p,{children:["At a minimum, every container in the pod will be configured to mount a shared\nmemory volume. This volume is mounted to ",(0,s.jsx)(n.code,{children:"/vault/secrets"})," and will be used by the Vault\nAgent containers for sharing secrets with the other containers in the pod."]}),"\n",(0,s.jsx)(n.p,{children:"Next, two types of Vault Agent containers can be injected: init and sidecar. The\ninit container will prepopulate the shared memory volume with the requested\nsecrets prior to the other containers starting. The sidecar container will\ncontinue to authenticate and render secrets to the same location as the pod runs.\nUsing annotations, the initialization and sidecar containers may be disabled."}),"\n",(0,s.jsx)(n.p,{children:"Last, two additional types of volumes can be optionally mounted to the Vault Agent\ncontainers. The first is secret volume containing TLS requirements such as client\nand CA (certificate authority) certificates and keys. This volume is useful when\ncommunicating and verifying the Vault server's authenticity using TLS. The second\nis a configuration map containing Vault Agent configuration files. This volume is\nuseful to customize Vault Agent beyond what the provided annotations offer."}),"\n",(0,s.jsx)(n.h3,{id:"authenticating-with-vault",children:"Authenticating with Vault"}),"\n",(0,s.jsx)(n.p,{children:"The primary method of authentication with Vault when using the Vault Agent Injector\nis the service account attached to the pod. Other authentication methods can be configured\nusing annotations."}),"\n",(0,s.jsx)(n.p,{children:"For Kubernetes authentication, the service account must be bound to a Vault role and a\npolicy granting access to the secrets desired."}),"\n",(0,s.jsxs)(n.p,{children:["A service account must be present to use the Vault Agent Injector with the Kubernetes\nauthentication method. It is ",(0,s.jsx)(n.em,{children:"not"})," recommended to bind Vault roles to the default service\naccount provided to pods if no service account is defined."]}),"\n",(0,s.jsx)(n.h3,{id:"requesting-secrets",children:"Requesting secrets"}),"\n",(0,s.jsx)(n.p,{children:"There are two methods of configuring the Vault Agent containers to render secrets:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["the ",(0,s.jsx)(n.code,{children:"vault.hashicorp.com/agent-inject-secret"})," annotation, or"]}),"\n",(0,s.jsx)(n.li,{children:"a configuration map containing Vault Agent configuration files."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Only one of these methods may be used at any time."}),"\n",(0,s.jsx)(n.h4,{id:"secrets-via-annotations",children:"Secrets via annotations"}),"\n",(0,s.jsx)(n.p,{children:"To configure secret injection using annotations, the user must supply:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["one or more ",(0,s.jsx)(n.em,{children:"secret"})," annotations, and"]}),"\n",(0,s.jsx)(n.li,{children:"the Vault role used to access those secrets."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The annotation must have the format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"vault.hashicorp.com/agent-inject-secret-<unique-name>: /path/to/secret\n"})}),"\n",(0,s.jsx)(n.p,{children:"The unique name will be the filename of the rendered secret and must be unique if\nmultiple secrets are defined by the user. For example, consider the following\nsecret annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"vault.hashicorp.com/agent-inject-secret-foo: database/roles/app\nvault.hashicorp.com/agent-inject-secret-bar: consul/creds/app\nvault.hashicorp.com/role: 'app'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The first annotation will be rendered to ",(0,s.jsx)(n.code,{children:"/vault/secrets/foo"})," and the second\nannotation will be rendered to ",(0,s.jsx)(n.code,{children:"/vault/secrets/bar"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It's possible to set the file format of the rendered secret using the annotation. For example the\nfollowing secret will be rendered to ",(0,s.jsx)(n.code,{children:"/vault/secrets/foo.txt"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"vault.hashicorp.com/agent-inject-secret-foo.txt: database/roles/app\nvault.hashicorp.com/role: 'app'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The secret unique name must consist of alphanumeric characters, ",(0,s.jsx)(n.code,{children:"."}),", ",(0,s.jsx)(n.code,{children:"_"})," or ",(0,s.jsx)(n.code,{children:"-"}),"."]}),"\n",(0,s.jsx)(n.h5,{id:"secret-templates",children:"Secret templates"}),"\n",(0,s.jsxs)(n.p,{children:["~> Vault Agent uses the Consul Template project to render secrets. For more information\non writing templates, see the ",(0,s.jsx)(n.a,{href:"https://github.com/hashicorp/consul-template",children:"Consul Template documentation"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["How the secret is rendered to the file is also configurable. To configure the template\nused, the user must supply a ",(0,s.jsx)(n.em,{children:"template"})," annotation using the same unique name of\nthe secret. The annotation must have the following format:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"vault.hashicorp.com/agent-inject-template-<unique-name>: |\n  <\n    TEMPLATE\n    HERE\n  >\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example, consider the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"vault.hashicorp.com/agent-inject-secret-foo: 'database/creds/db-app'\nvault.hashicorp.com/agent-inject-template-foo: |\n  {{- with secret \"database/creds/db-app\" -}}\n  postgres://{{ .Data.username }}:{{ .Data.password }}@postgres:5432/mydb?sslmode=disable\n  {{- end }}\nvault.hashicorp.com/role: 'app'\n"})}),"\n",(0,s.jsx)(n.p,{children:"The rendered secret would look like this within the container:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ cat /vault/secrets/foo\npostgres://v-kubernet-pg-app-q0Z7WPfVN:A1a-BUEuQR52oAqPrP1J@postgres:5432/mydb?sslmode=disable\n"})}),"\n",(0,s.jsxs)(n.p,{children:["~> The default left and right template delimiters are ",(0,s.jsx)(n.code,{children:"{{"})," and ",(0,s.jsx)(n.code,{children:"}}"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If no template is provided the following generic template is used:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{{ with secret "/path/to/secret" }}\n    {{ range $k, $v := .Data }}\n        {{ $k }}: {{ $v }}\n    {{ end }}\n{{ end }}\n'})}),"\n",(0,s.jsx)(n.p,{children:"For example, the following annotation will use the default template to render\nPostgreSQL secrets found at the configured path:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"vault.hashicorp.com/agent-inject-secret-foo: 'database/roles/pg-app'\nvault.hashicorp.com/role: 'app'\n"})}),"\n",(0,s.jsx)(n.p,{children:"The rendered secret would look like this within the container:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ cat /vault/secrets/foo\npassword: A1a-BUEuQR52oAqPrP1J\nusername: v-kubernet-pg-app-q0Z7WPfVNqqTJuoDqCTY-1576529094\n"})}),"\n",(0,s.jsxs)(n.p,{children:["~> Some secrets such as KV are stored in maps. Their data can be accessed using ",(0,s.jsx)(n.code,{children:".Data.data.<NAME>"})]}),"\n",(0,s.jsx)(n.h3,{id:"renewals-and-updating-secrets",children:"Renewals and updating secrets"}),"\n",(0,s.jsxs)(n.p,{children:["For more information on when Vault Agent fetches and renews secrets, see the\n",(0,s.jsx)(n.a,{href:"/docs/agent-and-proxy/agent/template#renewals-and-updating-secrets",children:"Agent documentation"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"vault-agent-configuration-map",children:"Vault agent configuration map"}),"\n",(0,s.jsxs)(n.p,{children:["For advanced use cases, it may be required to define Vault Agent configuration\nfiles to mount instead of using secret and template annotations. The Vault Agent\nInjector supports mounting ConfigMaps by specifying the name using the ",(0,s.jsx)(n.code,{children:"vault.hashicorp.com/agent-configmap"}),"\nannotation. The configuration files will be mounted to ",(0,s.jsx)(n.code,{children:"/vault/configs"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The configuration map must contain either one or both of the following files:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"config-init.hcl"})," used by the init container. This must have ",(0,s.jsx)(n.code,{children:"exit_after_auth"})," set to ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"config.hcl"})," used by the sidecar container. This must have ",(0,s.jsx)(n.code,{children:"exit_after_auth"})," set to ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An example of mounting a Vault Agent configmap ",(0,s.jsx)(n.a,{href:"/docs/platform/k8s/injector/examples#configmap-example",children:"can be found here"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,s.jsxs)(n.p,{children:["Refer to the ",(0,s.jsx)(n.a,{href:"/tutorials/kubernetes/kubernetes-sidecar",children:"Injecting Secrets into Kubernetes Pods via Vault Helm\nSidecar"})," guide\nfor a step-by-step tutorial."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(96540);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);