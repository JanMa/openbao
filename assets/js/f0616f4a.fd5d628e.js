"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7223],{21242:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=t(74848),s=t(28453);const r={sidebar_label:"Overview",description:"The transit secrets engine for OpenBao encrypts/decrypts data in-transit. It doesn't store any secrets."},a="Transit secrets engine",o={id:"secrets/transit/index",title:"Transit secrets engine",description:"The transit secrets engine for OpenBao encrypts/decrypts data in-transit. It doesn't store any secrets.",source:"@site/content/docs/secrets/transit/index.mdx",sourceDirName:"secrets/transit",slug:"/secrets/transit/",permalink:"/docs/secrets/transit/",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/secrets/transit/index.mdx",tags:[],version:"current",frontMatter:{sidebar_label:"Overview",description:"The transit secrets engine for OpenBao encrypts/decrypts data in-transit. It doesn't store any secrets."},sidebar:"docs",previous:{title:"TOTP",permalink:"/docs/secrets/totp"},next:{title:"Import Key Wrapping Guide",permalink:"/docs/secrets/transit/key-wrapping-guide"}},c={},d=[{value:"Working set management",id:"working-set-management",level:2},{value:"NIST rotation guidance",id:"nist-rotation-guidance",level:2},{value:"Key types",id:"key-types",level:2},{value:"Convergent encryption",id:"convergent-encryption",level:2},{value:"Setup",id:"setup",level:2},{value:"Usage",id:"usage",level:2},{value:"Bring your own key (BYOK)",id:"bring-your-own-key-byok",level:2},{value:"HSM",id:"hsm",level:3},{value:"Manual process",id:"manual-process",level:3},{value:"Tutorial",id:"tutorial",level:2},{value:"API",id:"api",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"transit-secrets-engine",children:"Transit secrets engine"}),"\n",(0,i.jsx)(n.p,{children:'The transit secrets engine handles cryptographic functions on data in-transit.\nOpenBao doesn\'t store the data sent to the secrets engine. It can also be viewed\nas "cryptography as a service" or "encryption as a service". The transit secrets\nengine can also sign and verify data; generate hashes and HMACs of data; and act\nas a source of random bytes.'}),"\n",(0,i.jsxs)(n.p,{children:["The primary use case for ",(0,i.jsx)(n.code,{children:"transit"})," is to encrypt data from applications while\nstill storing that encrypted data in some primary data store. This relieves the\nburden of proper encryption/decryption from application developers and pushes\nthe burden onto the operators of OpenBao."]}),"\n",(0,i.jsx)(n.p,{children:"Key derivation is supported, which allows the same key to be used for multiple\npurposes by deriving a new key based on a user-supplied context value. In this\nmode, convergent encryption can optionally be supported, which allows the same\ninput values to produce the same ciphertext."}),"\n",(0,i.jsx)(n.p,{children:"Datakey generation allows processes to request a high-entropy key of a given\nbit length be returned to them, encrypted with the named key. Normally this will\nalso return the key in plaintext to allow for immediate use, but this can be\ndisabled to accommodate auditing requirements."}),"\n",(0,i.jsx)(n.h2,{id:"working-set-management",children:"Working set management"}),"\n",(0,i.jsxs)(n.p,{children:["The Transit engine supports versioning of keys. Key versions that are earlier\nthan a key's specified ",(0,i.jsx)(n.code,{children:"min_decryption_version"})," gets archived, and the rest of\nthe key versions belong to the working set. This is a performance consideration\nto keep key loading fast, as well as a security consideration: by disallowing\ndecryption of old versions of keys, found ciphertext corresponding to obsolete\n(but sensitive) data can not be decrypted by most users, but in an emergency\nthe ",(0,i.jsx)(n.code,{children:"min_decryption_version"})," can be moved back to allow for legitimate\ndecryption."]}),"\n",(0,i.jsx)(n.p,{children:"Currently this archive is stored in a single storage entry. With some storage\nbackends, notably those using Raft or Paxos for HA capabilities, frequent\nrotation may lead to a storage entry size for the archive that is larger than\nthe storage backend can handle. For frequent rotation needs, using named keys\nthat correspond to time bounds (e.g. five-minute periods floored to the closest\nmultiple of five) may provide a good alternative, allowing for several keys to\nbe live at once and a deterministic way to decide which key to use at any given\ntime."}),"\n",(0,i.jsx)(n.h2,{id:"nist-rotation-guidance",children:"NIST rotation guidance"}),"\n",(0,i.jsxs)(n.p,{children:["Periodic rotation of the encryption keys is recommended, even in the absence of\ncompromise. For AES-GCM keys, rotation should occur before approximately 2",(0,i.jsx)("sup",{children:"32"}),"\nencryptions have been performed by a key version, following the guidelines of NIST\npublication 800-38D. It is recommended that operators estimate the\nencryption rate of a key and use that to determine a frequency of rotation\nthat prevents the guidance limits from being reached. For example, if one determines\nthat the estimated rate is 40 million operations per day, then rotating a key every\nthree months is sufficient."]}),"\n",(0,i.jsx)(n.h2,{id:"key-types",children:"Key types"}),"\n",(0,i.jsx)(n.p,{children:"As of now, the transit secrets engine supports the following key types (all key\ntypes also generate separate HMAC keys):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"aes128-gcm96"}),": AES-GCM with a 128-bit AES key and a 96-bit nonce; supports\nencryption, decryption, key derivation, and convergent encryption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"aes256-gcm96"}),": AES-GCM with a 256-bit AES key and a 96-bit nonce; supports\nencryption, decryption, key derivation, and convergent encryption (default)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chacha20-poly1305"}),": ChaCha20-Poly1305 with a 256-bit key; supports\nencryption, decryption, key derivation, and convergent encryption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ed25519"}),": Ed25519; supports signing, signature verification, and key\nderivation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ecdsa-p256"}),": ECDSA using curve P-256; supports signing and signature\nverification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ecdsa-p384"}),": ECDSA using curve P-384; supports signing and signature\nverification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ecdsa-p521"}),": ECDSA using curve P-521; supports signing and signature\nverification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rsa-2048"}),": 2048-bit RSA key; supports encryption, decryption, signing, and\nsignature verification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rsa-3072"}),": 3072-bit RSA key; supports encryption, decryption, signing, and\nsignature verification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rsa-4096"}),": 4096-bit RSA key; supports encryption, decryption, signing, and\nsignature verification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hmac"}),": HMAC; supporting HMAC generation and verification."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Note"}),": All key types support HMAC operations through the use of a second randomly\ngenerated key created key creation time or rotation. The HMAC key type only\nsupports HMAC, and behaves identically to other algorithms with\nrespect to the HMAC operations but supports key import. By default,\nthe HMAC key type uses a 256-bit key."]}),"\n",(0,i.jsx)(n.p,{children:"RSA operations use one of the following methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"OAEP (encrypt, decrypt), with SHA-256 hash function and MGF,"}),"\n",(0,i.jsx)(n.li,{children:"PSS (sign, verify), with configurable hash function also used for MGF, and"}),"\n",(0,i.jsx)(n.li,{children:"PKCS#1v1.5: (sign, verify), with configurable hash function."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"convergent-encryption",children:"Convergent encryption"}),"\n",(0,i.jsx)(n.p,{children:"Convergent encryption is a mode where the same set of plaintext+context always\nresult in the same ciphertext. It does this by deriving a key using a key\nderivation function but also by deterministically deriving a nonce. Because\nthese properties differ for any combination of plaintext and ciphertext over a\nkeyspace the size of 2^256, the risk of nonce reuse is near zero."}),"\n",(0,i.jsx)(n.p,{children:"This has many practical uses. One common usage mode is to allow values to be stored\nencrypted in a database, but with limited lookup/query support, so that rows\nwith the same value for a specific field can be returned from a query."}),"\n",(0,i.jsx)(n.p,{children:"To accommodate for any needed upgrades to the algorithm, different versions of\nconvergent encryption have historically been supported:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Version 1 required the client to provide their own nonce, which is highly\nflexible but if done incorrectly can be dangerous. Keys using this version\ncannot be upgraded."}),"\n",(0,i.jsx)(n.li,{children:"Version 2 used an algorithmic approach to deriving the parameters. However,\nthe algorithm used was susceptible to offline plaintext-confirmation attacks,\nwhich could allow attackers to brute force decryption if the plaintext size\nwas small. Keys using version 2 can be upgraded by simply performing a rotate\noperation to a new key version; existing values can then be rewrapped against\nthe new key version and will use the version 3 algorithm."}),"\n",(0,i.jsx)(n.li,{children:"Version 3 uses a different algorithm designed to be resistant to offline\nplaintext-confirmation attacks. It is similar to AES-SIV in that it uses a\nPRF to generate the nonce from the plaintext."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,i.jsx)(n.p,{children:"Most secrets engines must be configured in advance before they can perform their\nfunctions. These steps are usually completed by an operator or configuration\nmanagement tool."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Enable the Transit secrets engine:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao secrets enable transit\nSuccess! Enabled the transit secrets engine at: transit/\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By default, the secrets engine will mount at the name of the engine. To\nenable the secrets engine at a different path, use the ",(0,i.jsx)(n.code,{children:"-path"})," argument."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create a named encryption key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao write -f transit/keys/my-key\nSuccess! Data written to: transit/keys/my-key\n"})}),"\n",(0,i.jsx)(n.p,{children:"Usually each application has its own encryption key."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"After the secrets engine is configured and a user/machine has an OpenBao token with\nthe proper permission, it can use this secrets engine."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Encrypt some plaintext data using the ",(0,i.jsx)(n.code,{children:"/encrypt"})," endpoint with a named key:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NOTE:"})," All plaintext data ",(0,i.jsx)(n.strong,{children:"must be base64-encoded"}),'. The reason for this\nrequirement is that OpenBao does not require that the plaintext is "text". It\ncould be a binary file such as a PDF or image. The easiest safe transport\nmechanism for this data as part of a JSON payload is to base64-encode it.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'$ bao write transit/encrypt/my-key plaintext=$(echo "my secret data" | base64)\n\nKey           Value\n---           -----\nciphertext    vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The returned ciphertext starts with ",(0,i.jsx)(n.code,{children:"vault:v1:"}),". The first prefix (",(0,i.jsx)(n.code,{children:"vault"}),")\nidentifies that it has been wrapped by OpenBao. The ",(0,i.jsx)(n.code,{children:"v1"})," indicates the key\nversion 1 was used to encrypt the plaintext; therefore, when you rotate\nkeys, OpenBao knows which version to use for decryption. The rest is a base64\nconcatenation of the initialization vector (IV) and ciphertext."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that OpenBao does not ",(0,i.jsx)(n.em,{children:"store"})," any of this data. The caller is responsible\nfor storing the encrypted ciphertext. When the caller wants the plaintext,\nit must provide the ciphertext back to OpenBao to decrypt the value."]}),"\n",(0,i.jsxs)(n.p,{children:["!> OpenBao HTTP API imposes a maximum request size of 32MB to prevent a denial\nof service attack. This can be tuned per ",(0,i.jsxs)(n.a,{href:"/docs/configuration/listener/tcp",children:[(0,i.jsx)(n.code,{children:"listener"}),"\nblock"]})," in the OpenBao server\nconfiguration."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Decrypt a piece of data using the ",(0,i.jsx)(n.code,{children:"/decrypt"})," endpoint with a named key:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao write transit/decrypt/my-key ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==\n\nKey          Value\n---          -----\nplaintext    bXkgc2VjcmV0IGRhdGEK\n"})}),"\n",(0,i.jsx)(n.p,{children:"The resulting data is base64-encoded (see the note above for details on\nwhy). Decode it to get the raw plaintext:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'$ base64 --decode <<< "bXkgc2VjcmV0IGRhdGEK"\nmy secret data\n'})}),"\n",(0,i.jsx)(n.p,{children:"It is also possible to script this decryption using some clever shell\nscripting in one command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao write -field=plaintext transit/decrypt/my-key ciphertext=... | base64 --decode\nmy secret data\n"})}),"\n",(0,i.jsx)(n.p,{children:"Using ACLs, it is possible to restrict using the transit secrets engine such\nthat trusted operators can manage the named keys, and applications can only\nencrypt or decrypt using the named keys they need access to."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Rotate the underlying encryption key. This will generate a new encryption key\nand add it to the keyring for the named key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao write -f transit/keys/my-key/rotate\nSuccess! Data written to: transit/keys/my-key/rotate\n"})}),"\n",(0,i.jsx)(n.p,{children:"Future encryptions will use this new key. Old data can still be decrypted\ndue to the use of a key ring."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Upgrade already-encrypted data to a new key. OpenBao will decrypt the value\nusing the appropriate key in the keyring and then encrypted the resulting\nplaintext with the newest key in the keyring."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao write transit/rewrap/my-key ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==\n\nKey           Value\n---           -----\nciphertext    vault:v2:0VHTTBb2EyyNYHsa3XiXsvXOQSLKulH+NqS4eRZdtc2TwQCxqJ7PUipvqQ==\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This process ",(0,i.jsx)(n.strong,{children:"does not"}),' reveal the plaintext data. As such, an OpenBao policy\ncould grant almost an untrusted process the ability to "rewrap" encrypted\ndata, since the process would not be able to get access to the plaintext\ndata.']}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"bring-your-own-key-byok",children:"Bring your own key (BYOK)"}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Note:"})," Key import functionality supports cases in which there is a need to bring\nin an existing key from an HSM or other outside system. It is more secure to\nhave Transit generate and manage a key within OpenBao."]}),"\n",(0,i.jsx)(n.p,{children:"First, the wrapping key needs to be read from transit:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"$ bao read transit/wrapping_key\n"})}),"\n",(0,i.jsx)(n.p,{children:"The wrapping key will be a 4096-bit RSA public key."}),"\n",(0,i.jsxs)(n.p,{children:["Then the wrapping key is used to create the ciphertext input for the ",(0,i.jsx)(n.code,{children:"import"})," endpoint,\nas described below. In the below, the target key refers to the key being imported."]}),"\n",(0,i.jsx)(n.h3,{id:"hsm",children:"HSM"}),"\n",(0,i.jsx)(n.p,{children:"If the key is being imported from an HSM that supports PKCS#11, there are\ntwo possible scenarios:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the HSM supports the CKM_RSA_AES_KEY_WRAP mechanism, that can be used to wrap the\ntarget key using the wrapping key."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Otherwise, two mechanisms can be combined to wrap the target key. First, a 256-bit AES key should\nbe generated and then used to wrap the target key using the CKM_AES_KEY_WRAP_KWP mechanism.\nThen the AES key should be wrapped under the wrapping key using the CKM_RSA_PKCS_OAEP mechanism\nusing MGF1 and either SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The ciphertext is constructed by appending the wrapped target key to the wrapped AES key."}),"\n",(0,i.jsx)(n.p,{children:"The ciphertext bytes should be base64-encoded."}),"\n",(0,i.jsx)(n.h3,{id:"manual-process",children:"Manual process"}),"\n",(0,i.jsxs)(n.p,{children:["If the target key is not stored in an HSM or KMS, the following steps can be used to construct\nthe ciphertext for the input of the ",(0,i.jsx)(n.code,{children:"import"})," endpoint:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Generate an ephemeral 256-bit AES key."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Wrap the target key using the ephemeral AES key with AES-KWP."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["~> Note: When wrapping a symmetric key (such as an AES or ChaCha20 key), wrap\nthe raw bytes of the key. For instance, with an AES 128-bit key, this'll be\na byte array 16 characters in length that will directly be wrapped without\nbase64 or other encodings.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"When wrapping an asymmetric key\n(such as a RSA or ECDSA key), wrap the ",(0,i.jsx)(n.strong,{children:"PKCS8"})," encoded format of this\nkey, in raw DER/binary form. Do not apply PEM encoding to this blob prior\nto encryption and do not base64 encode it."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Wrap the AES key under the OpenBao wrapping key using RSAES-OAEP with MGF1 and\neither SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Delete the ephemeral AES key."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Append the wrapped target key to the wrapped AES key."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Base64 encode the result."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more details about wrapping the key for import into transit, see the\n",(0,i.jsx)(n.a,{href:"/docs/secrets/transit/key-wrapping-guide",children:"key wrapping guide"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,i.jsxs)(n.p,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"/tutorials/encryption-as-a-service/eaas-transit",children:"Encryption as a Service: Transit Secrets\nEngine"}),"\ntutorial to learn how to use the transit secrets engine to handle cryptographic functions on data in-transit."]}),"\n",(0,i.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,i.jsxs)(n.p,{children:["The Transit secrets engine has a full HTTP API. Please see the\n",(0,i.jsx)(n.a,{href:"/api-docs/secret/transit",children:"Transit secrets engine API"})," for more\ndetails."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);