"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2430],{51332:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var i=n(74848),a=n(28453);const s={description:"OpenBao provides an identity management solution to maintain clients who are recognized by OpenBao."},o="Identity",r={id:"concepts/identity",title:"Identity",description:"OpenBao provides an identity management solution to maintain clients who are recognized by OpenBao.",source:"@site/content/docs/concepts/identity.mdx",sourceDirName:"concepts",slug:"/concepts/identity",permalink:"/openbao/docs/concepts/identity",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/concepts/identity.mdx",tags:[],version:"current",frontMatter:{description:"OpenBao provides an identity management solution to maintain clients who are recognized by OpenBao."},sidebar:"docs",previous:{title:"Tokens",permalink:"/openbao/docs/concepts/tokens"},next:{title:"OIDC provider",permalink:"/openbao/docs/concepts/oidc-provider"}},d={},l=[{value:"Entities and aliases",id:"entities-and-aliases",level:2},{value:"Entity management",id:"entity-management",level:2},{value:"Entity policies",id:"entity-policies",level:2},{value:"Mount bound aliases",id:"mount-bound-aliases",level:2},{value:"Implicit entities",id:"implicit-entities",level:2},{value:"Identity auditing",id:"identity-auditing",level:2},{value:"Identity groups",id:"identity-groups",level:2},{value:"Group hierarchical permissions",id:"group-hierarchical-permissions",level:2},{value:"External vs internal groups",id:"external-vs-internal-groups",level:2},{value:"Tutorial",id:"tutorial",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"identity",children:"Identity"}),"\n",(0,i.jsxs)(t.p,{children:["This document contains conceptual information about ",(0,i.jsx)(t.strong,{children:"Identity"})," along with an\noverview of the various terminologies and their concepts. The idea of Identity\nis to maintain the clients who are recognized by OpenBao. As such, OpenBao provides\nan identity management solution through the ",(0,i.jsx)(t.strong,{children:"Identity secrets engine"}),". For\nmore information about the Identity secrets engine and how it is used, refer to\nthe ",(0,i.jsx)(t.a,{href:"/docs/secrets/identity",children:"Identity Secrets Engine"})," documentation."]}),"\n",(0,i.jsx)(t.h2,{id:"entities-and-aliases",children:"Entities and aliases"}),"\n",(0,i.jsxs)(t.p,{children:["Each user may have multiple accounts with various identity providers, and OpenBao\nsupports many of those providers to authenticate with OpenBao. OpenBao Identity can\ntie authentications from various auth methods to a single representation. This representation of a consolidated identity is called an ",(0,i.jsx)(t.strong,{children:"Entity"})," and their\ncorresponding accounts with authentication providers can be mapped as\n",(0,i.jsx)(t.strong,{children:"Aliases"}),". In essence, each entity is made up of zero or more aliases. An entity cannot have more than one alias for\na particular authentication backend."]}),"\n",(0,i.jsx)(t.p,{children:"For example, a user with accounts in both GitHub and LDAP can be mapped to a\nsingle entity in OpenBao with two aliases, one of type GitHub and one of type\nLDAP."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Entity  overview",src:n(66705).A+"",width:"1600",height:"920"})}),"\n",(0,i.jsx)(t.p,{children:"However, if both aliases are created on the same auth mount, such as\na Github mount, both aliases cannot be mapped to the same entity. The aliases can\nhave the same auth type, as long as the auth mounts are different, and\nstill be associated to the same entity. The diagrams below illustrate both valid\nand invalid scenarios."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Valid Alias Mapping",src:n(47244).A+"",width:"1600",height:"920"}),"\n",(0,i.jsx)(t.img,{alt:"Invalid Alias Mapping",src:n(58869).A+"",width:"1600",height:"920"})]}),"\n",(0,i.jsx)(t.p,{children:"When a client authenticates via any credential backend (except the Token\nbackend), OpenBao creates a new entity. It attaches a new alias to it if a\ncorresponding entity does not already exist. The entity identifier will be tied\nto the authenticated token. When such tokens are used, their entity identifiers\nare audit logged, marking a trail of actions performed by specific users."}),"\n",(0,i.jsx)(t.h2,{id:"entity-management",children:"Entity management"}),"\n",(0,i.jsxs)(t.p,{children:["Entities in OpenBao ",(0,i.jsx)(t.strong,{children:"do not"})," automatically pull identity information from\nanywhere. It needs to be explicitly managed by operators. This way, it is\nflexible in terms of administratively controlling the number of entities to be\nsynced against OpenBao. In some sense, OpenBao will serve as a ",(0,i.jsx)(t.em,{children:"cache"})," of\nidentities and not as a ",(0,i.jsx)(t.em,{children:"source"})," of identities."]}),"\n",(0,i.jsx)(t.h2,{id:"entity-policies",children:"Entity policies"}),"\n",(0,i.jsxs)(t.p,{children:["OpenBao policies can be assigned to entities which will grant ",(0,i.jsx)(t.em,{children:"additional"}),"\npermissions to the token on top of the existing policies on the token. If the\ntoken presented on the API request contains an identifier for the entity and if\nthat entity has a set of policies on it, then the token will be capable of\nperforming actions allowed by the policies on the entity as well."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Entity policies",src:n(6810).A+"",width:"1230",height:"571"})}),"\n",(0,i.jsxs)(t.p,{children:["This is a paradigm shift in terms of ",(0,i.jsx)(t.em,{children:"when"})," the policies of the token get\nevaluated. Before identity, the policy names on the token were immutable (not\nthe contents of those policies though). But with entity policies, along with\nthe immutable set of policy names on the token, the evaluation of policies\napplicable to the token through its identity will happen at request time. This\nalso adds enormous flexibility to control the behavior of already issued\ntokens."]}),"\n",(0,i.jsxs)(t.p,{children:["It is important to note that the policies on the entity are only a means to grant\n",(0,i.jsx)(t.em,{children:"additional"})," capabilities and not a replacement for the policies on the token.\nTo know the full set of capabilities of the token with an associated entity\nidentifier, the policies on the token should be taken into account."]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"NOTE:"})," Be careful in granting permissions to non-readonly identity endpoints.\nIf a user can modify an entity, they can grant it additional privileges through\npolicies. If a user can modify an alias they can login with, they can bind it to\nan entity with higher privileges. If a user can modify group membership, they\ncan add their entity to a group with higher privileges."]})}),"\n",(0,i.jsx)(t.h2,{id:"mount-bound-aliases",children:"Mount bound aliases"}),"\n",(0,i.jsx)(t.p,{children:"OpenBao supports multiple authentication backends and also allows enabling the\nsame type of authentication backend on different mount paths. The alias name of\nthe user will be unique within the backend's mount. But identity store needs to\nuniquely distinguish between conflicting alias names across different mounts of\nthese identity providers. Hence, the alias name in combination with the\nauthentication backend mount's accessor, serve as the unique identifier of an\nalias."}),"\n",(0,i.jsxs)(t.p,{children:["The table below shows what information each of the supported auth methods uses\nto form the alias name. This is the identifying information that is used to match or create\nan entity. If no entities are explicitly created or merged, then one ",(0,i.jsx)(t.a,{href:"#implicit-entities",children:"entity will be implicitly created"}),"\nfor each object on the right-hand side of the table, when it is used to authenticate on\na particular auth mount point."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Auth method"}),(0,i.jsx)(t.th,{children:"Name reported by auth method"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"AppRole"}),(0,i.jsx)(t.td,{children:"Role ID"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"JWT/OIDC"}),(0,i.jsxs)(t.td,{children:["Configurable via ",(0,i.jsx)(t.code,{children:"user_claim"})," to one of the presented claims (no default value)"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Kerberos"}),(0,i.jsx)(t.td,{children:"Username"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Kubernetes"}),(0,i.jsxs)(t.td,{children:["Configurable via ",(0,i.jsx)(t.code,{children:"alias_name_source"})," to one of: Service account UID (default), Service account name"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LDAP"}),(0,i.jsx)(t.td,{children:"Username"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"RADIUS"}),(0,i.jsx)(t.td,{children:"Username"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"TLS Certificate"}),(0,i.jsx)(t.td,{children:"Subject CommonName"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Token"}),(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"entity_alias"}),", if provided"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Username (userpass)"}),(0,i.jsx)(t.td,{children:"Username"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"implicit-entities",children:"Implicit entities"}),"\n",(0,i.jsx)(t.p,{children:"Operators can create entities for all the users of an auth mount beforehand and\nassign policies to them, so that when users login, the desired capabilities to\nthe tokens via entities are already assigned. But if that's not done, upon a\nsuccessful user login from any of the authentication backends, OpenBao will\ncreate a new entity and assign an alias against the login that was successful."}),"\n",(0,i.jsxs)(t.p,{children:["Note that the tokens created using the token authentication backend will not\nnormally have any associated identity information. An existing or new implicit\nentity can be assigned by using the ",(0,i.jsx)(t.code,{children:"entity_alias"})," parameter, when creating a\ntoken using a token role with a configured list of ",(0,i.jsx)(t.code,{children:"allowed_entity_aliases"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"identity-auditing",children:"Identity auditing"}),"\n",(0,i.jsx)(t.p,{children:"If the token used to make API calls has an associated entity identifier, it\nwill be audit logged as well. This leaves a trail of actions performed by\nspecific users."}),"\n",(0,i.jsx)(t.h2,{id:"identity-groups",children:"Identity groups"}),"\n",(0,i.jsxs)(t.p,{children:["OpenBao identity has support for ",(0,i.jsx)(t.strong,{children:"groups"}),". A group can contain multiple entities\nas its members. A group can also have subgroups. Policies set on the group are\ngranted to all members of the group. During request time, when the token's\nentity ID is being evaluated for the policies that it has access to, policies\nthat are inherited due to group memberships are granted along with the policies\non the entity itself."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Identity overview",src:n(96643).A+"",width:"1573",height:"708"})}),"\n",(0,i.jsx)(t.h2,{id:"group-hierarchical-permissions",children:"Group hierarchical permissions"}),"\n",(0,i.jsx)(t.p,{children:"Entities can be direct members of groups, in which case they inherit the\npolicies of the groups they belong to. Entities can also be indirect members of\ngroups. For example, if a GroupA has GroupB as subgroup, then members of GroupB\nare indirect members of GroupA. Hence, the members of GroupB will have access\nto policies on both GroupA and GroupB."}),"\n",(0,i.jsx)(t.h2,{id:"external-vs-internal-groups",children:"External vs internal groups"}),"\n",(0,i.jsxs)(t.p,{children:["By default, the groups created in identity store are called the internal\ngroups. The membership management of these groups should be carried out\nmanually. A group can also be created as an external group. In this case, the\nentity membership in the group is managed semi-automatically. An external group\nserves as a mapping to a group that is outside of the identity store. External\ngroups can have one (and only one) alias. This alias should map to a notion of\na group that is outside of the identity store. For example, groups in LDAP and\nteams in GitHub. A username in LDAP belonging to a group in LDAP can get its\nentity ID added as a member of a group in OpenBao automatically during ",(0,i.jsx)(t.em,{children:"logins"}),"\nand ",(0,i.jsx)(t.em,{children:"token renewals"}),". This works only if the group in OpenBao is an external\ngroup and has an alias that maps to the group in LDAP. If the user is removed\nfrom the group in LDAP, that change gets reflected in OpenBao only upon the\nsubsequent login or renewal operation."]}),"\n",(0,i.jsxs)(t.p,{children:["For information about Identity Secrets Engine, refer to ",(0,i.jsx)(t.a,{href:"/docs/secrets/identity",children:"Identity Secrets Engine"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,i.jsxs)(t.p,{children:["Refer to the ",(0,i.jsx)(t.a,{href:"/tutorials/auth-methods/identity",children:"Identity: Entities and\nGroups"})," tutorial to learn how OpenBao supports mutliple authentication methods and enables the same authentication method to be used with different mount paths."]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},66705:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/vault-identity-doc-1-27039609ed35325a24a08be5b12e7816.png"},6810:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/vault-identity-doc-2-beb778032859e636cf831d365545539a.png"},96643:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/vault-identity-doc-3-f51024948a6640572323f436acd00d61.png"},47244:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/vault-identity-doc-4-2f61d04366514994bd949273aed6ffe2.png"},58869:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/vault-identity-doc-5-639dc31002d3a8e2fbe3349151c3a78a.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(96540);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);