"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7053],{43722:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=t(74848),s=t(28453);const o={layout:"docs",page_title:"Response Wrapping",description:"Wrapping responses in cubbyholes for secure distribution."},r="Response wrapping",a={id:"concepts/response-wrapping",title:"Response wrapping",description:"Wrapping responses in cubbyholes for secure distribution.",source:"@site/content/docs/concepts/response-wrapping.mdx",sourceDirName:"concepts",slug:"/concepts/response-wrapping",permalink:"/openbao/docs/concepts/response-wrapping",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/concepts/response-wrapping.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Response Wrapping",description:"Wrapping responses in cubbyholes for secure distribution."},sidebar:"docs",previous:{title:"OIDC provider",permalink:"/openbao/docs/concepts/oidc-provider"},next:{title:"Policies",permalink:"/openbao/docs/concepts/policies"}},p={},c=[{value:"Overview",id:"overview",level:2},{value:"Response-Wrapping tokens",id:"response-wrapping-tokens",level:2},{value:"Response-Wrapping token operations",id:"response-wrapping-token-operations",level:2},{value:"Response-Wrapping token creation",id:"response-wrapping-token-creation",level:2},{value:"Response-Wrapping token validation",id:"response-wrapping-token-validation",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"response-wrapping",children:"Response wrapping"}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"In many OpenBao deployments, clients can access OpenBao directly and consume\nreturned secrets. In other situations, it may make sense to or be desired to\nseparate privileges such that one trusted entity is responsible for interacting\nwith most of the OpenBao API and passing secrets to the end consumer."}),"\n",(0,i.jsx)(n.p,{children:"However, the more relays a secret travels through, the more possibilities for\naccidental disclosure, especially if the secret is being transmitted in\nplaintext. For instance, you may wish to get a TLS private key to a machine\nthat has been cold-booted, but since you do not want to store a decryption key\nin persistent storage, you cannot encrypt this key in transit."}),"\n",(0,i.jsxs)(n.p,{children:["To help address this problem, OpenBao includes a feature called ",(0,i.jsx)(n.em,{children:"response\nwrapping"}),". When requested, OpenBao can take the response it would have sent to an\nHTTP client and instead insert it into the\n",(0,i.jsx)(n.a,{href:"/docs/secrets/cubbyhole",children:(0,i.jsx)(n.code,{children:"cubbyhole"})})," of a single-use token,\nreturning that single-use token instead."]}),"\n",(0,i.jsx)(n.p,{children:"Logically speaking, the response is\nwrapped by the token, and retrieving it requires an unwrap operation against\nthis token. Functionally speaking, the token provides authorization to use\nan encryption key from OpenBao's keyring to decrypt the data."}),"\n",(0,i.jsxs)(n.p,{children:["This provides a powerful mechanism for information sharing in many\nenvironments. In the types of scenarios, described above, often the best\npractical option is to provide ",(0,i.jsx)(n.em,{children:"cover"})," for the secret information, be able to\n",(0,i.jsx)(n.em,{children:"detect malfeasance"})," (interception, tampering), and limit ",(0,i.jsx)(n.em,{children:"lifetime"})," of the\nsecret's exposure. Response wrapping performs all three of these duties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["It provides ",(0,i.jsx)(n.em,{children:"cover"})," by ensuring that the value being transmitted across the\nwire is not the actual secret but a reference to such a secret, namely the\nresponse-wrapping token. Information stored in logs or captured along the\nway do not directly see the sensitive information."]}),"\n",(0,i.jsxs)(n.li,{children:["It provides ",(0,i.jsx)(n.em,{children:"malfeasance detection"})," by ensuring that only a single party can\never unwrap the token and see what's inside. A client receiving a token that\ncannot be unwrapped can trigger an immediate security incident. In addition,\na client can inspect a given token before unwrapping to ensure that its\norigin is from the expected location in OpenBao."]}),"\n",(0,i.jsxs)(n.li,{children:["It ",(0,i.jsx)(n.em,{children:"limits the lifetime"})," of secret exposure because the response-wrapping\ntoken has a lifetime that is separate from the wrapped secret (and often can\nbe much shorter), so if a client fails to come up and unwrap the token, the\ntoken can expire very quickly."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"response-wrapping-tokens",children:"Response-Wrapping tokens"}),"\n",(0,i.jsx)(n.p,{children:"When a response is wrapped, the normal API response from OpenBao does not contain\nthe original secret, but rather contains a set of information related to the\nresponse-wrapping token:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"TTL: The TTL of the response-wrapping token itself"}),"\n",(0,i.jsx)(n.li,{children:"Token: The actual token value"}),"\n",(0,i.jsx)(n.li,{children:"Creation Time: The time that the response-wrapping token was created"}),"\n",(0,i.jsx)(n.li,{children:"Creation Path: The API path that was called in the original request"}),"\n",(0,i.jsx)(n.li,{children:"Wrapped Accessor: If the wrapped response is an authentication response\ncontaining an OpenBao token, this is the value of the wrapped token's accessor.\nThis is useful for orchestration systems (such as Nomad) to be able to control\nthe lifetime of secrets based on their knowledge of the lifetime of jobs,\nwithout having to actually unwrap the response-wrapping token or gain\nknowledge of the token ID inside."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"OpenBao currently does not provide signed response-wrapping tokens, as it\nprovides little extra protection. If you are being pointed to the correct OpenBao\nserver, token validation is performed by interacting with the server itself; a\nsigned token does not remove the need to validate the token with the server,\nsince the token is not carrying data but merely an access mechanism and the\nserver will not release data without validating it. If you are being attacked\nand pointed to the wrong OpenBao server, the same attacker could trivially give\nyou the wrong signing public key that corresponds to the wrong OpenBao server.\nYou could cache a previously valid key, but could also cache a previously valid\naddress (and in most cases the OpenBao address will not change or will be set via\na service discovery mechanism). As such, we rely on the fact that the token\nitself is not carrying authoritative data and do not sign it."}),"\n",(0,i.jsx)(n.h2,{id:"response-wrapping-token-operations",children:"Response-Wrapping token operations"}),"\n",(0,i.jsxs)(n.p,{children:["Via the ",(0,i.jsx)(n.code,{children:"sys/wrapping"})," path, several operations can be run against wrapping\ntokens:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Lookup (",(0,i.jsx)(n.code,{children:"sys/wrapping/lookup"}),"): This allows fetching the response-wrapping\ntoken's creation time, creation path, and TTL. This path is unauthenticated\nand available to response-wrapping tokens themselves. In other words, a\nresponse-wrapping token holder wishing to perform validation is always\nallowed to look up the properties of the token."]}),"\n",(0,i.jsxs)(n.li,{children:["Unwrap (",(0,i.jsx)(n.code,{children:"sys/wrapping/unwrap"}),"): Unwrap the token, returning the response\ninside. The response that is returned will be the original wire-format\nresponse; it can be used directly with API clients."]}),"\n",(0,i.jsxs)(n.li,{children:["Rewrap (",(0,i.jsx)(n.code,{children:"sys/wrapping/rewrap"}),"): Allows migrating the wrapped data to a new\nresponse-wrapping token. This can be useful for long-lived secrets. For\nexample, an organization may wish (or be required in a compliance scenario)\nto have the ",(0,i.jsx)(n.code,{children:"pki"})," backend's root CA key be returned in a long-lived\nresponse-wrapping token to ensure that nobody has seen the key (easily\nverified by performing lookups on the response-wrapping token) but available\nfor signing CRLs in case they ever accidentally change or lose the ",(0,i.jsx)(n.code,{children:"pki"}),"\nmount. Often, compliance schemes require periodic rotation of secrets, so\nthis helps achieve that compliance goal without actually exposing what's\ninside."]}),"\n",(0,i.jsxs)(n.li,{children:["Wrap (",(0,i.jsx)(n.code,{children:"sys/wrapping/wrap"}),"): A helper endpoint that echoes back the data sent\nto it in a response-wrapping token. Note that blocking access to this\nendpoint does not remove the ability for arbitrary data to be wrapped, as it\ncan be done elsewhere in OpenBao."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"response-wrapping-token-creation",children:"Response-Wrapping token creation"}),"\n",(0,i.jsxs)(n.p,{children:["Response wrapping is per-request and is triggered by providing to OpenBao the\ndesired TTL for a response-wrapping token for that request. This is set by the\nclient using the ",(0,i.jsx)(n.code,{children:"X-Vault-Wrap-TTL"})," header and can be either an integer number\nof seconds or a string duration of seconds (",(0,i.jsx)(n.code,{children:"15s"}),"), minutes (",(0,i.jsx)(n.code,{children:"20m"}),"), or hours\n(",(0,i.jsx)(n.code,{children:"25h"}),"). When using the OpenBao CLI, you can set this via the ",(0,i.jsx)(n.code,{children:"-wrap-ttl"}),"\nparameter. When using the Go API, wrapping is triggered by ",(0,i.jsx)(n.a,{href:"https://godoc.org/github.com/openbao/openbao/api#Client.SetWrappingLookupFunc",children:"setting a helper\nfunction"}),"\nthat tells the API the conditions under which to request wrapping, by mapping\nan operation and path to a desired TTL."]}),"\n",(0,i.jsx)(n.p,{children:"If a client requests wrapping:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The original HTTP response is serialized"}),"\n",(0,i.jsx)(n.li,{children:"A new single-use token is generated with the TTL supplied by the client"}),"\n",(0,i.jsx)(n.li,{children:"Internally, the original serialized response is stored in the single-use\ntoken's cubbyhole"}),"\n",(0,i.jsx)(n.li,{children:"A new response is generated, with the token ID, TTL, and path stored in the\nnew response's wrap information object"}),"\n",(0,i.jsx)(n.li,{children:"The new response is returned to the caller"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that policies can control minimum/maximum wrapping TTLs; see the ",(0,i.jsx)(n.a,{href:"/docs/concepts/policies",children:"policies\nconcepts page"})," for\nmore information."]}),"\n",(0,i.jsx)(n.h2,{id:"response-wrapping-token-validation",children:"Response-Wrapping token validation"}),"\n",(0,i.jsx)(n.p,{children:"Proper validation of response-wrapping tokens is essential to ensure that any\nmalfeasance is detected. It's also pretty straightforward."}),"\n",(0,i.jsx)(n.p,{children:"Validation is best performed by the following steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If a client has been expecting delivery of a response-wrapping token and\nnone arrives, this may be due to an attacker intercepting the token and then\npreventing it from traveling further. This should cause an alert to trigger\nan immediate investigation."}),"\n",(0,i.jsx)(n.li,{children:"Perform a lookup on the response-wrapping token. This immediately tells you\nif the token has already been unwrapped or is expired (or otherwise\nrevoked). If the lookup indicates that a token is invalid, it does not\nnecessarily mean that the data was intercepted (for instance, perhaps the\nclient took a long time to start up and the TTL expired) but should trigger\nan alert for immediate investigation, likely with the assistance of OpenBao's\naudit logs to see if the token really was unwrapped."}),"\n",(0,i.jsxs)(n.li,{children:["With the token information in hand, validate that the creation path matches\nexpectations. If you expect to find a TLS key/certificate inside, chances\nare the path should be something like ",(0,i.jsx)(n.code,{children:"pki/issue/..."}),". If the path is not\nwhat you expect, it is possible that the data contained inside was read and\nthen put into a new response-wrapping token. (This is especially likely if\nthe path starts with ",(0,i.jsx)(n.code,{children:"cubbyhole"})," or ",(0,i.jsx)(n.code,{children:"sys/wrapping/wrap"}),".) Particular care\nshould be taken with ",(0,i.jsx)(n.code,{children:"kv"})," secrets engine: exact matches on the path are best\nthere. For example, if you expect a secret to come from ",(0,i.jsx)(n.code,{children:"secret/foo"})," and\nthe interceptor provides a token with ",(0,i.jsx)(n.code,{children:"secret/bar"})," as the path, simply\nchecking for a prefix of ",(0,i.jsx)(n.code,{children:"secret/"})," is not enough."]}),"\n",(0,i.jsx)(n.li,{children:"After prefix validation, unwrap the token. If the unwrap fails, the response\nis similar to if the initial lookup fails: trigger an alert for immediate\ninvestigation."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Following those steps provides very strong assurance that the data contained\nwithin the response-wrapping token has never been seen by anyone other than the\nintended client and that any interception or tampering has resulted in a\nsecurity alert."})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);