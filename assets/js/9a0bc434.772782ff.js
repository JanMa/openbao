"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[151],{37908:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var i=s(74848),r=s(28453);const t={description:"This section documents configuration options for the Vault Helm chart"},l="Configuration",o={id:"platform/k8s/helm/configuration",title:"Configuration",description:"This section documents configuration options for the Vault Helm chart",source:"@site/content/docs/platform/k8s/helm/configuration.mdx",sourceDirName:"platform/k8s/helm",slug:"/platform/k8s/helm/configuration",permalink:"/docs/platform/k8s/helm/configuration",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/platform/k8s/helm/configuration.mdx",tags:[],version:"current",frontMatter:{description:"This section documents configuration options for the Vault Helm chart"},sidebar:"docs",previous:{title:"Run Vault on OpenShift",permalink:"/docs/platform/k8s/helm/openshift"},next:{title:"Terraform",permalink:"/docs/platform/k8s/helm/terraform"}},c={},d=[];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Important Note:"})," This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart."]}),"\n",(0,i.jsxs)(n.p,{children:["The chart is highly customizable using\n",(0,i.jsx)(n.a,{href:"https://helm.sh/docs/intro/using_helm/#customizing-the-chart-before-installing",children:"Helm configuration values"}),".\nEach value has a default tuned for an optimal getting started experience\nwith Vault. Before going into production, please review the parameters below\nand consider if they're appropriate for your deployment."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"global"})," - These global values affect multiple components of the chart."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - The master enabled/disabled configuration. If this is true, most components will be installed by default. If this is false, no components will be installed by default and manually opting-in is required, such as by setting ",(0,i.jsx)(n.code,{children:"server.enabled"})," to true."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"imagePullSecrets"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - References secrets to be used when pulling images from private registries. See ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/",children:"Pull an Image from a Private Registry"})," for more details. May be specified as an array of name map entries or just as an array of names:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"imagePullSecrets:\n  - name: image-pull-secret\n# or\nimagePullSecrets:\n  - image-pull-secret\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tlsDisable"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", changes URLs from ",(0,i.jsx)(n.code,{children:"https"})," to ",(0,i.jsx)(n.code,{children:"http"})," (such as the ",(0,i.jsx)(n.code,{children:"VAULT_ADDR=http://127.0.0.1:8200"})," environment variable set on the Vault pods)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"externalVaultAddr"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - External vault server address for the injector and CSI provider to use. Setting this will disable deployment of a vault server. A service account with token review permissions is automatically created if ",(0,i.jsx)(n.code,{children:"server.serviceAccount.create=true"})," is set for the external Vault server to use."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"openshift"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - If ",(0,i.jsx)(n.code,{children:"true"}),", enables configuration specific to OpenShift such as NetworkPolicy, SecurityContext, and Route."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"psp"})," - Values that configure Pod Security Policy."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enable"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", enables Pod Security Policies for Vault and Vault Agent Injector."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the Pod Security Policies. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default\n  apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default\n  seccomp.security.alpha.kubernetes.io/defaultProfileName:  runtime/default\n  apparmor.security.beta.kubernetes.io/defaultProfileName:  runtime/default\n# or\nannotations: |\n  seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default\n  apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default\n  seccomp.security.alpha.kubernetes.io/defaultProfileName:  runtime/default\n  apparmor.security.beta.kubernetes.io/defaultProfileName:  runtime/default\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serverTelemetry"})," - Values that configure metrics and telemetry"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"prometheusOperator"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", enables integration with the\nPrometheus Operator. Be sure to configure the top-level ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration#servertelemetry-1",children:(0,i.jsx)(n.code,{children:"serverTelemetry"})})," section for more details\nand required configuration values."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"injector"})," - Values that configure running a Vault Agent Injector Admission Webhook Controller within Kubernetes."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:'boolean or string: "-"'}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", the Vault Agent Injector Admission Webhook controller will be created. When set to ",(0,i.jsx)(n.code,{children:'"-"'}),", defaults to the value of ",(0,i.jsx)(n.code,{children:"global.enabled"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"externalVaultAddr"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Deprecated: Please use ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration#externalvaultaddr",children:"global.externalVaultAddr"})," instead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"replicas"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - The number of pods to deploy to create a highly available cluster of Vault Agent Injectors. Requires Vault K8s 0.7.0 to have more than 1 replica."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"leaderElector"})," - Values that configure the Vault Agent Injector leader election for HA deployments."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", enables leader election for Vault Agent Injector. This is required when using auto-tls and more than 1 replica."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"image"})," - Values that configure the Vault Agent Injector Docker image."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"repository"})," (",(0,i.jsx)(n.code,{children:'string: "hashicorp/vault-k8s"'}),") - The name of the Docker image for Vault Agent Injector."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tag"})," (",(0,i.jsx)(n.code,{children:'string: "1.2.1"'}),") - The tag of the Docker image for the Vault Agent Injector. ",(0,i.jsx)(n.strong,{children:"This should be pinned to a specific version when running in production."})," Otherwise, other changes to the chart may inadvertently upgrade your admission controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pullPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "IfNotPresent"'}),") - The pull policy for container images. The default pull policy is ",(0,i.jsx)(n.code,{children:"IfNotPresent"})," which causes the Kubelet to skip pulling an image if it already exists."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"agentImage"})," - Values that configure the Vault Agent sidecar image."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"repository"})," (",(0,i.jsx)(n.code,{children:'string: "hashicorp/vault"'}),") - The name of the Docker image for the Vault Agent sidecar. This should be set to the official Vault Docker image."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tag"})," (",(0,i.jsx)(n.code,{children:'string: "1.14.0"'}),") - The tag of the Vault Docker image to use for the Vault Agent Sidecar. ",(0,i.jsx)(n.strong,{children:"Vault 1.3.1+ is required by the admission controller"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"agentDefaults"})," - Values that configure the injected Vault Agent containers default values."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"cpuLimit"})," (",(0,i.jsx)(n.code,{children:'string: "500m"'}),") - The default CPU limit for injected Vault Agent containers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"cpuRequest"})," (",(0,i.jsx)(n.code,{children:'string: "250m"'}),") - The default CPU request for injected Vault Agent containers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"memLimit"})," (",(0,i.jsx)(n.code,{children:'string: "128Mi"'}),") - The default memory limit for injected Vault Agent containers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"memRequest"})," (",(0,i.jsx)(n.code,{children:'string: "64Mi"'}),") - The default memory request for injected Vault Agent containers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ephemeralLimit"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - The default ephemeral storage limit for injected Vault Agent containers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ephemeralRequest"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - The default ephemeral storage request for injected Vault Agent containers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"template"})," (",(0,i.jsx)(n.code,{children:'string: "map"'}),") - The default template type for rendered secrets if no custom templates are defined.\nPossible values include ",(0,i.jsx)(n.code,{children:"map"})," and ",(0,i.jsx)(n.code,{children:"json"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"templateConfig"})," - Default values within Agent's ",(0,i.jsxs)(n.a,{href:"/docs/agent-and-proxy/agent/template",children:[(0,i.jsx)(n.code,{children:"template_config"})," stanza"]}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"exitOnRetryFailure"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - Controls whether Vault Agent exits after it has exhausted its number of template retry attempts due to failures."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"staticSecretRenderInterval"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Configures how often Vault Agent Template should render non-leased secrets such as KV v2. See the ",(0,i.jsx)(n.a,{href:"/docs/agent-and-proxy/agent/template#non-renewable-secrets",children:"Vault Agent Templates documentation"})," for more details."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"metrics"})," - Values that configure the Vault Agent Injector metric exporter."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", the Vault Agent Injector exports Prometheus metrics at the ",(0,i.jsx)(n.code,{children:"/metrics"})," path."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"authPath"})," (",(0,i.jsx)(n.code,{children:'string: "auth/kubernetes"'}),") - Mount path of the Vault Kubernetes Auth Method."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"logLevel"})," (",(0,i.jsx)(n.code,{children:'string: "info"'}),") - Configures the log verbosity of the injector. Supported log levels: trace, debug, error, warn, info."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"logFormat"})," (",(0,i.jsx)(n.code,{children:'string: "standard"'}),') - Configures the log format of the injector. Supported log formats: "standard", "json".']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"revokeOnShutdown"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - Configures all Vault Agent sidecars to revoke their token when shutting down."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"securityContext"})," - Security context for the pod template and the injector container"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pod"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Defines the securityContext for the injector Pod, as YAML or a YAML-formatted multi-line templated string. Default if not specified:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"runAsNonRoot: true\nrunAsGroup: {{ .Values.injector.gid | default 1000 }}\nrunAsUser: {{ .Values.injector.uid | default 100 }}\nfsGroup: {{ .Values.injector.gid | default 1000 }}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"container"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Defines the securityContext for the injector container, as YAML or a YAML-formatted multi-line templated string. Default if not specified:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"allowPrivilegeEscalation: false\ncapabilities:\n  drop:\n    - ALL\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resources"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - The resource requests and limits (CPU, memory, etc.) for each container of the injector. This should be a YAML dictionary of a Kubernetes ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#resourcerequirements-v1-core",children:"ResourceRequirements"})," object. If this isn't specified, then the pods won't request any specific amount of resources, which limits the ability for Kubernetes to make efficient use of compute resources.",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.strong,{children:"Setting this is highly recommended."})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"resources:\n  requests:\n    memory: '256Mi'\n    cpu: '250m'\n  limits:\n    memory: '256Mi'\n    cpu: '250m'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"webhook"})," - Values that control the Mutating Webhook Configuration."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failurePolicy"})," (",(0,i.jsx)(n.code,{children:'string: "Ignore"'}),") - Configures failurePolicy of the webhook. To block pod creation while the webhook is unavailable, set the policy to ",(0,i.jsx)(n.code,{children:'"Fail"'}),". See ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy",children:"Failure Policy"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"matchPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "Exact"'}),") - Specifies the approach to accepting changes based on the rules of the MutatingWebhookConfiguration. See ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchpolicy",children:"Match Policy"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 30"}),") - Specifies the number of seconds before the webhook request will be ignored or fails. If it is ignored or fails depends on the ",(0,i.jsx)(n.code,{children:"failurePolicy"}),". See ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts",children:"timeouts"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"namespaceSelector"})," (",(0,i.jsx)(n.code,{children:"object: {}"}),") - The selector used by the admission webhook controller to limit what namespaces where injection can happen. If unset, all non-system namespaces are eligible for injection. See ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector",children:"Matching requests: namespace selector"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"namespaceSelector:\n  matchLabels:\n    sidecar-injector: enabled\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"objectSelector"})," (",(0,i.jsx)(n.code,{children:"object: {}"}),") - The selector used by the admission webhook controller to limit what objects can be affected by mutation. See ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector",children:"Matching requests: object selector"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"objectSelector:\n  matchLabels:\n    sidecar-injector: enabled\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"string or object: {}"}),") - Defines additional annotations to attach to the webhook. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"namespaceSelector"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Deprecated: please use ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration#namespaceselector",children:(0,i.jsx)(n.code,{children:"webhook.namespaceSelector"})})," instead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"objectSelector"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Deprecated: please use ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration#objectselector",children:(0,i.jsx)(n.code,{children:"webhook.objectSelector"})})," instead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraLabels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional labels for Vault Agent Injector pods."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraLabels:\n  'sample/label1': 'foo'\n  'sample/label2': 'bar'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"certs"})," - The certs section configures how the webhook TLS certs are configured. These are the TLS certs for the Kube apiserver communicating to the webhook. By default, the injector will generate and manage its own certs, but this requires the ability for the injector to update its own ",(0,i.jsx)(n.code,{children:"MutatingWebhookConfiguration"}),". In a production environment, custom certs should probably be used. Configure the values below to enable this."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"secretName"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - secretName is the name of the Kubernetes secret that has the TLS certificate and private key to serve the injector webhook. If this is null, then the injector will default to its automatic management mode."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"caBundle"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - The PEM-encoded CA public certificate bundle for the TLS certificate served by the injector. This must be specified as a string and can't come from a secret because it must be statically configured on the Kubernetes ",(0,i.jsx)(n.code,{children:"MutatingAdmissionWebhook"})," resource. This only needs to be specified if ",(0,i.jsx)(n.code,{children:"secretName"})," is not null."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"certName"})," (",(0,i.jsx)(n.code,{children:'string: "tls.crt"'}),") - The name of the certificate file within the ",(0,i.jsx)(n.code,{children:"secretName"})," secret."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"keyName"})," (",(0,i.jsx)(n.code,{children:'string: "tls.key"'}),") - The name of the key file within the ",(0,i.jsx)(n.code,{children:"secretName"})," secret."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraEnvironmentVars"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Extra environment variables to set in the injector deployment."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Example setting injector TLS options in a deployment:\nextraEnvironmentVars:\n  AGENT_INJECT_TLS_MIN_VERSION: tls13\n  AGENT_INJECT_TLS_CIPHER_SUITES: ...\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"affinity"})," - This value defines the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity",children:"affinity"})," for Vault Agent Injector pods. This can either be multi-line string or YAML matching the PodSpec's affinity field. It defaults to allowing only a single pod on each node, which minimizes risk of the cluster becoming unusable if a node is lost. If you need to run more pods per node (for example, testing on Minikube), set this value to ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Recommended default server affinity:\naffinity: |\n  podAntiAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchLabels:\n          app.kubernetes.io/name: {{ template "vault.name" . }}-agent-injector\n          app.kubernetes.io/instance: "{{ .Release.Name }}"\n          component: webhook\n      topologyKey: kubernetes.io/hostname\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topologySpreadConstraints"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/",children:"Topology settings"}),"\nfor injector pods. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tolerations"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - Toleration Settings for injector pods. This should be either a multi-line string or YAML matching the Toleration array."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"nodeSelector"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - nodeSelector labels for injector pod assignment, formatted as a muli-line string or YAML map."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"priorityClassName"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Priority class for injector pods"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations for injector pods. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n# or\nannotations: |\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failurePolicy"})," (",(0,i.jsx)(n.code,{children:'string: "Ignore"'}),") - Deprecated: please use ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration#failurepolicy",children:(0,i.jsx)(n.code,{children:"webhook.failurePolicy"})})," instead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"webhookAnnotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Deprecated: please use ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration#annotations-1",children:(0,i.jsx)(n.code,{children:"webhook.annotations"})})," instead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"service"})," - The service section configures the Kubernetes service for the Vault Agent Injector."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the Vault Agent Injector service. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n# or\nannotations: |\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceAccount"})," - Injector serviceAccount specific config"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Extra annotations to attach to the injector serviceAccount. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"hostNetwork"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to true, configures the Vault Agent Injector to run on the host network. This is useful\nwhen alternative cluster networking is used."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"port"})," (",(0,i.jsx)(n.code,{children:"int: 8080"}),") - Configures the port the Vault Agent Injector listens on."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"podDisruptionBudget"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - A disruption budget limits the number of pods of a replicated application that are down simultaneously from voluntary disruptions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"podDisruptionBudget:\n  maxUnavailable: 1\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"strategy"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Strategy for updating the deployment. This can be a multi-line string or a YAML map."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"strategy:\n  rollingUpdate:\n    maxSurge: 25%\n    maxUnavailable: 25%\n  type: RollingUpdate\n# or\nstrategy: |\n  rollingUpdate:\n    maxSurge: 25%\n    maxUnavailable: 25%\n  type: RollingUpdate\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"livenessProbe"})," - Values that configure the liveness probe for the injector."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 60"}),") - Sets the initial delay of the liveness probe when the container starts."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"readinessProbe"})," - Values that configure the readiness probe for the injector."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 60"}),") - Sets the initial delay of the readiness probe when the container starts."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"startupProbe"})," - Values that configure the startup probe for the injector."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 60"}),") - Sets the initial delay of the startup probe when the container starts."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"server"})," - Values that configure running a Vault server within Kubernetes."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:'boolean or string: "-"'}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", the Vault server will be created. When set to ",(0,i.jsx)(n.code,{children:'"-"'}),", defaults to the value of ",(0,i.jsx)(n.code,{children:"global.enabled"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"image"})," - Values that configure the Vault Docker image."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"repository"})," (",(0,i.jsx)(n.code,{children:'string: "hashicorp/vault"'}),") - The name of the Docker image for the containers running Vault."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tag"})," (",(0,i.jsx)(n.code,{children:'string: "1.14.0"'}),") - The tag of the Docker image for the containers running Vault. ",(0,i.jsx)(n.strong,{children:"This should be pinned to a specific version when running in production."})," Otherwise, other changes to the chart may inadvertently upgrade your admission controller."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pullPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "IfNotPresent"'}),") - The pull policy for container images. The default pull policy is ",(0,i.jsx)(n.code,{children:"IfNotPresent"})," which causes the Kubelet to skip pulling an image if it already exists."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"updateStrategyType"})," (",(0,i.jsx)(n.code,{children:'string: "OnDelete"'}),") - Configure the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies",children:"Update Strategy Type"})," for the StatefulSet."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"logLevel"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Configures the Vault server logging verbosity. If set this will override values defined in the Vault configuration file.\nSupported log levels include: ",(0,i.jsx)(n.code,{children:"trace"}),", ",(0,i.jsx)(n.code,{children:"debug"}),", ",(0,i.jsx)(n.code,{children:"info"}),", ",(0,i.jsx)(n.code,{children:"warn"}),", ",(0,i.jsx)(n.code,{children:"error"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"logFormat"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Configures the Vault server logging format. If set this will override values defined in the Vault configuration file.\nSupported log formats include: ",(0,i.jsx)(n.code,{children:"standard"}),", ",(0,i.jsx)(n.code,{children:"json"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resources"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - The resource requests and limits (CPU, memory, etc.) for each container of the server. This should be a YAML dictionary of a Kubernetes ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",children:"resource"})," object. If this isn't specified, then the pods won't request any specific amount of resources, which limits the ability for Kubernetes to make efficient use of compute resources. ",(0,i.jsx)(n.strong,{children:"Setting this is highly recommended."})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"resources:\n  requests:\n    memory: '10Gi'\n  limits:\n    memory: '10Gi'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ingress"})," - Values that configure Ingress services for Vault."]}),"\n",(0,i.jsxs)(n.p,{children:["~> If deploying on OpenShift, these ingress settings are ignored. Use the ",(0,i.jsx)(n.a,{href:"#route",children:(0,i.jsx)(n.code,{children:"route"})})," configuration to expose Vault on OpenShift. ",(0,i.jsx)("br",{})," ",(0,i.jsx)("br",{}),"\nIf ",(0,i.jsx)(n.a,{href:"#ha",children:(0,i.jsx)(n.code,{children:"ha"})})," is enabled the Ingress will point to the active vault server via the ",(0,i.jsx)(n.code,{children:"active"})," Service. This requires vault 1.4+ and ",(0,i.jsx)(n.a,{href:"/docs/configuration/service-registration/kubernetes",children:"service_registration"})," to be set in the vault config."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", an ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/",children:"Ingress"})," service will be created."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"labels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Labels for the ingress service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the Ingress service. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  kubernetes.io/ingress.class: nginx\n  kubernetes.io/tls-acme: "true"\n# or\nannotations: |\n  kubernetes.io/ingress.class: nginx\n  kubernetes.io/tls-acme: "true"\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ingressClassName"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Specify the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-class",children:"IngressClass"})," that should be used to implement the Ingress"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"activeService"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When HA mode is enabled and K8s service registration is being used, configure the ingress to point to the Vault active service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraPaths"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - Configures extra paths to prepend to the host configuration.\nThis is useful when working with annotation based services."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraPaths:\n  - path: /*\n    backend:\n      service:\n        name: ssl-redirect\n        port:\n          number: use-annotation\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tls"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - Configures the TLS portion of the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/#tls",children:"Ingress spec"}),", where ",(0,i.jsx)(n.code,{children:"hosts"})," is a list of the hosts defined in the Common Name of the TLS certificate, and ",(0,i.jsx)(n.code,{children:"secretName"})," is the name of the Secret containing the required TLS files such as certificates and keys."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"tls:\n  - hosts:\n      - sslexample.foo.com\n      - sslexample.bar.com\n    secretName: testsecret-tls\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"hosts"})," - Values that configure the Ingress host rules."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"host"})," (",(0,i.jsx)(n.code,{children:'string: "chart-example.local"'}),"): Name of the host to use for Ingress."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"paths"})," (",(0,i.jsx)(n.code,{children:"array: []"}),"): Deprecated: ",(0,i.jsx)(n.code,{children:"server.ingress.extraPaths"})," should be used instead. A list of paths that will be directed to the Vault service. At least one path is required."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"paths:\n  - /\n  - /vault\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"route"})," - Values that configure Route services for Vault in OpenShift"]}),"\n",(0,i.jsxs)(n.p,{children:["~> If ",(0,i.jsx)(n.a,{href:"#ha",children:(0,i.jsx)(n.code,{children:"ha"})})," is enabled the Route will point to the active vault server via the ",(0,i.jsx)(n.code,{children:"active"})," Service (requires vault 1.4+ and ",(0,i.jsx)(n.a,{href:"/docs/configuration/service-registration/kubernetes",children:"service_registration"})," to be set in the vault config)."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", a Route for Vault will be created."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"activeService"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When HA mode is enabled and K8s service registration is being used, configure the route to point to the Vault active service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"labels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Labels for the Route"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Annotations to add to the Route. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"host"})," (",(0,i.jsx)(n.code,{children:'string: "chart-example.local"'}),") - Sets the hostname for the Route."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tls"})," (",(0,i.jsx)(n.code,{children:"dictionary: {termination: passthrough}"}),") - TLS config that will be passed directly to the route's TLS config, which can be used to configure other termination methods that terminate TLS at the router."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"authDelegator"})," - Values that configure the Cluster Role Binding attached to the Vault service account."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", a Cluster Role Binding will be bound to the Vault service account. This Cluster Role Binding has the necessary privileges for Vault to use the ",(0,i.jsx)(n.a,{href:"/docs/auth/kubernetes",children:"Kubernetes Auth Method"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"readinessProbe"})," - Values that configure the readiness probe for the Vault pods."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", a readiness probe will be applied to the Vault pods."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"path"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - When set to a value, enables HTTP/HTTPS probes instead of using the default ",(0,i.jsx)(n.code,{children:"exec"})," probe. The http/https scheme is controlled by the ",(0,i.jsx)(n.code,{children:"tlsDisable"})," value."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures the number of seconds after the container has started before probe initiates."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"port"})," (",(0,i.jsx)(n.code,{children:"int: 8200"}),") - When set to a value, overrides the default port used for the server readiness probe."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"readinessProbe:\n  enabled: true\n  path: /v1/sys/health?standbyok=true\n  failureThreshold: 2\n  initialDelaySeconds: 5\n  periodSeconds: 5\n  successThreshold: 1\n  timeoutSeconds: 3\n  port: 8200\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"livenessProbe"})," - Values that configure the liveness probe for the Vault pods."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", a liveness probe will be applied to the Vault pods."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"path"})," (",(0,i.jsx)(n.code,{children:'string: "/v1/sys/health?standbyok=true"'}),") - When set to a value, enables HTTP/HTTPS probes instead of using the default ",(0,i.jsx)(n.code,{children:"exec"})," probe. The http/https scheme is controlled by the ",(0,i.jsx)(n.code,{children:"tlsDisable"})," value."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 60"}),") - Sets the initial delay of the liveness probe when the container starts."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"port"})," (",(0,i.jsx)(n.code,{children:"int: 8200"}),") - When set to a value, overrides the default port used for the server liveness probe."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"livenessProbe:\n  enabled: true\n  path: /v1/sys/health?standbyok=true\n  initialDelaySeconds: 60\n  failureThreshold: 2\n  periodSeconds: 5\n  successThreshold: 1\n  timeoutSeconds: 3\n  port: 8200\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"terminationGracePeriodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 10"}),") - Optional duration in seconds the pod needs to terminate gracefully. See: ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/",children:"https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"preStopSleepSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - Used to set the sleep time during the preStop step."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"postStart"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - Used to define commands to run after the pod is ready. This can be used to automate processes such as initialization or bootstrapping auth methods."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"postStart:\n  - /bin/sh\n  - -c\n  - /vault/userconfig/myscript/run.sh\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraInitContainers"})," (",(0,i.jsx)(n.code,{children:"array: null"}),") - extraInitContainers is a list of init containers. Specified as a YAML list. This is useful if you need to run a script to provision TLS certificates or write out configuration files in a dynamic way."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraContainers"})," (",(0,i.jsx)(n.code,{children:"array: null"}),") - The extra containers to be applied to the Vault server pods."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraContainers:\n  - name: mycontainer\n    image: 'app:0.0.0'\n    env: ...\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"extraEnvironmentVars"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - The extra environment variables to be applied to the Vault server."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Extra Environment Variables are defined as key/value strings.\nextraEnvironmentVars:\n  GOOGLE_REGION: global\n  GOOGLE_PROJECT: myproject\n  GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/myproject/myproject-creds.json\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"shareProcessNamespace"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - Enables process namespace sharing between Vault and the extraContainers. This is useful if Vault must be signaled, e.g. to send a SIGHUP for log rotation."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraArgs"})," (",(0,i.jsx)(n.code,{children:"string: null"}),") - The extra arguments to be applied to the Vault server startup command."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraArgs: '-config=/path/to/extra/config.hcl -log-format=json'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraPorts"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - additional ports to add to the server statefulset"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraPorts:\n  - containerPort: 8300\n    name: http-monitoring\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraSecretEnvironmentVars"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - The extra environment variables populated from a secret to be applied to the Vault server."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"envName"})," (",(0,i.jsx)(n.code,{children:"string: required"}),") -\nName of the environment variable to be populated in the Vault container."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"secretName"})," (",(0,i.jsx)(n.code,{children:"string: required"}),") -\nName of Kubernetes secret used to populate the environment variable defined by ",(0,i.jsx)(n.code,{children:"envName"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"secretKey"})," (",(0,i.jsx)(n.code,{children:"string: required"}),") -\nName of the key where the requested secret value is located in the Kubernetes secret."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Extra Environment Variables populated from a secret.\nextraSecretEnvironmentVars:\n  - envName: AWS_SECRET_ACCESS_KEY\n    secretName: vault\n    secretKey: AWS_SECRET_ACCESS_KEY\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraVolumes"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - Deprecated: please use ",(0,i.jsx)(n.code,{children:"volumes"})," instead. A list of extra volumes to mount to Vault servers. This is useful for bringing in extra data that can be referenced by other configurations at a well known path, such as TLS certificates. The value of this should be a list of objects. Each object supports the following keys:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"type"})," (",(0,i.jsx)(n.code,{children:"string: required"}),') -\nType of the volume, must be one of "configMap" or "secret". Case sensitive.']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"name"})," (",(0,i.jsx)(n.code,{children:"string: required"}),") -\nName of the configMap or secret to be mounted. This also controls the path\nthat it is mounted to. The volume will be mounted to ",(0,i.jsx)(n.code,{children:"/vault/userconfig/<name>"})," by default\nunless ",(0,i.jsx)(n.code,{children:"path"})," is configured."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"path"})," (",(0,i.jsx)(n.code,{children:"string: /vault/userconfigs"}),") -\nName of the path where a configMap or secret is mounted. If not specified\nthe volume will be mounted to ",(0,i.jsx)(n.code,{children:"/vault/userconfig/<name of volume>"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"defaultMode"})," (",(0,i.jsx)(n.code,{children:'string: "420"'}),") -\nDefault mode of the mounted files."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraVolumes:\n  - type: 'secret'\n    name: 'vault-certs'\n    path: '/etc/pki'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"volumes"})," (",(0,i.jsx)(n.code,{children:"array: null"}),") - A list of volumes made available to all containers. This takes\nstandard Kubernetes volume definitions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"volumes:\n  - name: plugins\n    emptyDir: {}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"volumeMounts"})," (",(0,i.jsx)(n.code,{children:"array: null"}),") - A list of volumes mounts made available to all containers. This takes\nstandard Kubernetes volume definitions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"volumeMounts:\n  - mountPath: /usr/local/libexec/vault\n    name: plugins\n    readOnly: true\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"affinity"})," - This value defines the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity",children:"affinity"})," for server pods. This should be either a multi-line string or YAML matching the PodSpec's affinity field. It defaults to allowing only a single pod on each node, which minimizes risk of the cluster becoming unusable if a node is lost. If you need to run more pods per node (for example, testing on Minikube), set this value to ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Recommended default server affinity:\naffinity: |\n  podAntiAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n      matchLabels:\n        app.kubernetes.io/name: {{ template "vault.name" . }}\n        app.kubernetes.io/instance: "{{ .Release.Name }}"\n        component: server\n      topologyKey: kubernetes.io/hostname\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topologySpreadConstraints"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/",children:"Topology settings"}),"\nfor server pods. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tolerations"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - This value defines the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/",children:"tolerations"})," that are acceptable when being scheduled. This should be either a multi-line string or YAML matching the Toleration array in a PodSpec."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"tolerations: |\n  - key: 'node.kubernetes.io/unreachable'\n    operator: 'Exists'\n    effect: 'NoExecute'\n    tolerationSeconds: 6000\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nodeSelector"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional node selection criteria for more control over where the Vault servers are deployed. This should be formatted as a multi-line string or YAML map."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"nodeSelector: |\n  disktype: ssd\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"networkPolicy"})," - Values that configure the Vault Network Policy."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", enables a Network Policy for the Vault cluster."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"egress"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - This value configures the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/",children:"egress"})," network policy rules."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"egress:\n  - to:\n      - ipBlock:\n          cidr: 10.0.0.0/24\n    ports:\n      - protocol: TCP\n        port: 8200\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"priorityClassName"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Priority class for server pods"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraLabels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional labels for server pods."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraLabels:\n  'sample/label1': 'foo'\n  'sample/label2': 'bar'\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations for server pods. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n# or\nannotations: |\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"service"})," - Values that configure the Kubernetes service created for Vault. These options are also used for the ",(0,i.jsx)(n.code,{children:"active"})," and ",(0,i.jsx)(n.code,{children:"standby"})," services when ",(0,i.jsx)(n.a,{href:"#ha",children:(0,i.jsx)(n.code,{children:"ha"})})," is enabled."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", a Kubernetes service will be created for Vault."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"active"})," - Values that apply only to the vault-active service."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", the vault-active Kubernetes service will be created for Vault, selecting pods which label themselves as the cluster leader with ",(0,i.jsx)(n.code,{children:'vault-active: "true"'}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"standby"})," - Values that apply only to the vault-standby service."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", the vault-standby Kubernetes service will be created for Vault, selecting pods which label themselves as a cluster follower with ",(0,i.jsx)(n.code,{children:'vault-active: "false"'}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"clusterIP"})," (",(0,i.jsx)(n.code,{children:"string"}),") - ClusterIP controls whether an IP address (cluster IP) is attached to the Vault service within Kubernetes. By default the Vault service will be given a Cluster IP address, set to ",(0,i.jsx)(n.code,{children:"None"}),' to disable. When disabled Kubernetes will create a "headless" service. Headless services can be used to communicate with pods directly through DNS instead of a round robin load balancer.']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"type"})," (",(0,i.jsx)(n.code,{children:'string: "ClusterIP"'}),") - Sets the type of service to create, such as ",(0,i.jsx)(n.code,{children:"NodePort"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"externalTrafficPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "Cluster"'}),") - The ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy",children:"externalTrafficPolicy"})," can be set to either Cluster or Local and is only valid for LoadBalancer and NodePort service types."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"port"})," (",(0,i.jsx)(n.code,{children:"int: 8200"}),") - Port on which Vault server is listening inside the pod."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"targetPort"})," (",(0,i.jsx)(n.code,{children:"int: 8200"}),") - Port on which the service is listening."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"nodePort"})," (",(0,i.jsx)(n.code,{children:"int:"}),") - When type is set to ",(0,i.jsx)(n.code,{children:"NodePort"}),", the bound node port can be configured using this value. A random port will be assigned if this is left blank."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"activeNodePort"})," (",(0,i.jsx)(n.code,{children:"int:"}),') - (When HA mode is enabled) If type is set to "NodePort", a specific nodePort value can be configured for the ',(0,i.jsx)(n.code,{children:"active"})," service, and will be random if left blank."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"standbyNodePort"})," (",(0,i.jsx)(n.code,{children:"int:"}),') - (When HA mode is enabled) If type is set to "NodePort", a specific nodePort value can be configured for the ',(0,i.jsx)(n.code,{children:"standby"})," service, will be random if left blank."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"publishNotReadyAddresses"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - If true, do not wait for pods to be ready before including them in the services' targets. Does not apply to the headless service, which is used for cluster-internal communication."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"instanceSelector"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - When set to false, the service selector used for the vault, vault-active, and vault-standby services will not filter on ",(0,i.jsx)(n.code,{children:"app.kubernetes.io/instance"}),". This means they may select pods from outside this deployment of the Helm chart. Does not affect the headless vault-internal service with ",(0,i.jsx)(n.code,{children:"ClusterIP: None"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations for the service. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n# or\nannotations: |\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceAccount"})," - Values that configure the Kubernetes service account created for Vault."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"create"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),"): If set to true, creates a service account used by Vault."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"name"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),'): Name of the service account to use. If not set and create is true, a name is generated using the name of the installation (default is "vault").']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations for the service account. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n# or\nannotations: |\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"extraLabels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional labels for the Vault Server service account."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"extraLabels:\n  'sample/label1': 'foo'\n  'sample/label2': 'bar'\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceDiscovery"})," - Values that configure permissions required for Vault Server to automatically discover and join a Vault cluster using pod metadata."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - Enable or disable a service account role binding with the permissions required for Vault's Kubernetes ",(0,i.jsx)(n.a,{href:"/docs/configuration/service-registration/kubernetes",children:(0,i.jsx)(n.code,{children:"service_registration"})})," config option."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dataStorage"})," - This configures the volume used for storing Vault data when not using external storage such as Consul."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") -\nEnables a persistent volume to be created for storing Vault data when not using an external storage service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"size"})," (",(0,i.jsx)(n.code,{children:"string: 10Gi"}),") -\nSize of the volume to be created for Vault's data storage when not using an external storage service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"storageClass"})," (",(0,i.jsx)(n.code,{children:"string: null"}),") -\nName of the storage class to use when creating the data storage volume."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"mountPath"})," (",(0,i.jsx)(n.code,{children:"string: /vault/data"}),") -\nConfigures the path in the Vault pod where the data storage will be mounted."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"accessMode"})," (",(0,i.jsx)(n.code,{children:"string: ReadWriteOnce"}),") -\nType of access mode of the storage device. See the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes",children:"official Kubernetes"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the data PVCs. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  kubernetes.io/my-pvc: foobar\n# or\nannotations: |\n  kubernetes.io/my-pvc: foobar\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"auditStorage"})," - This configures the volume used for storing Vault's audit logs. See the ",(0,i.jsx)(n.a,{href:"/docs/audit",children:"Vault documentation"})," for more information."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") -\nEnables a persistent volume to be created for storing Vault's audit logs."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"size"})," (",(0,i.jsx)(n.code,{children:"string: 10Gi"}),") -\nSize of the volume to be created for Vault's audit logs."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"storageClass"})," (",(0,i.jsx)(n.code,{children:"string: null"}),") -\nName of the storage class to use when creating the audit storage volume."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"mountPath"})," (",(0,i.jsx)(n.code,{children:"string: /vault/audit"}),") -\nConfigures the path in the Vault pod where the audit storage will be mounted."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"accessMode"})," (",(0,i.jsx)(n.code,{children:"string: ReadWriteOnce"}),") -\nType of access mode of the storage device."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the audit PVCs. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  kubernetes.io/my-pvc: foobar\n# or\nannotations: |\n  kubernetes.io/my-pvc: foobar\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dev"})," - This configures ",(0,i.jsx)(n.code,{children:"dev"})," mode for the Vault server."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") -\nEnables ",(0,i.jsx)(n.code,{children:"dev"})," mode for the Vault server. This mode is useful for experimenting with Vault without needing to unseal."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"devRootToken"})," (",(0,i.jsx)(n.code,{children:'string: "root"'}),") - Configures the root token for the Vault development server."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["~> ",(0,i.jsx)(n.strong,{children:"Security Warning:"}),' Never, ever, ever run a "dev" mode server in production. It is insecure and will lose data on every restart (since it stores data in-memory). It is only made for development or experimentation.']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"standalone"})," - This configures ",(0,i.jsx)(n.code,{children:"standalone"})," mode for the Vault server."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") -\nEnables ",(0,i.jsx)(n.code,{children:"standalone"})," mode for the Vault server. This mode uses the ",(0,i.jsx)(n.code,{children:"file"})," storage backend and requires a volume for persistence (",(0,i.jsx)(n.code,{children:"dataStorage"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"config"})," (",(0,i.jsx)(n.code,{children:'string or object: "{}"'}),") -\nA raw string of extra HCL or JSON ",(0,i.jsx)(n.a,{href:"/docs/configuration",children:"configuration"})," for Vault servers.\nThis will be saved as-is into a ConfigMap that is read by the Vault servers.\nThis can be used to add additional configuration that isn't directly exposed by the chart.\nIf an object is provided, it will be written as JSON."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# ExtraConfig values are formatted as a multi-line string:\nconfig: |\n  api_addr = "http://POD_IP:8200"\n\n  listener "tcp" {\n    tls_disable = 1\n    address     = "0.0.0.0:8200"\n  }\n\n  storage "file" {\n    path = "/vault/data"\n  }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This can also be set using Helm's ",(0,i.jsx)(n.code,{children:"--set"})," flag (vault-helm v0.1.0 and later), using the following syntax:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'--set server.standalone.config=\'{ listener "tcp" { address = "0.0.0.0:8200" }\'\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ha"})," - This configures ",(0,i.jsx)(n.code,{children:"ha"})," mode for the Vault server."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") -\nEnables ",(0,i.jsx)(n.code,{children:"ha"})," mode for the Vault server. This mode uses a highly available backend storage (such as Consul) to store Vault's data. By default this is configured to use ",(0,i.jsx)(n.a,{href:"https://github.com/hashicorp/consul-helm",children:"Consul Helm"}),". For a complete list of storage backends, see the ",(0,i.jsx)(n.a,{href:"/docs/configuration",children:"Vault documentation"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"apiAddr"}),": (",(0,i.jsx)(n.code,{children:'string: "{}"'}),") -\nSet the API address configuration for a Vault cluster. If set to an empty string, the pod IP address is used."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"clusterAddr"})," (",(0,i.jsx)(n.code,{children:"string: null"}),") - Set the ",(0,i.jsx)(n.a,{href:"/docs/configuration#cluster_addr",children:(0,i.jsx)(n.code,{children:"cluster_addr"})})," configuration for Vault HA.\nIf null, defaults to ",(0,i.jsx)(n.code,{children:'https://$(HOSTNAME).{{ template "vault.fullname" . }}-internal:8201'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"raft"})," - This configures ",(0,i.jsx)(n.code,{children:"raft"})," integrated storage mode for the Vault server."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") -\nEnables ",(0,i.jsx)(n.code,{children:"raft"})," integrated storage mode for the Vault server. This mode uses persistent volumes for storage."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"setNodeId"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - Set the Node Raft ID to the name of the pod."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"config"})," (",(0,i.jsx)(n.code,{children:'string or object: "{}"'}),") -\nA raw string of extra HCL or JSON ",(0,i.jsx)(n.a,{href:"/docs/configuration",children:"configuration"})," for Vault servers.\nThis will be saved as-is into a ConfigMap that is read by the Vault servers.\nThis can be used to add additional configuration that isn't directly exposed by the chart.\nIf an object is provided, it will be written as JSON."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"replicas"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") -\nThe number of pods to deploy to create a highly available cluster of Vault servers."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"updatePartition"})," (",(0,i.jsx)(n.code,{children:"int: 0"}),") -\nIf an updatePartition is specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s ",(0,i.jsx)(n.code,{children:".spec.template"})," is updated. If set to ",(0,i.jsx)(n.code,{children:"0"}),", this disables partition updates. For more information see the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#rolling-updates",children:"official Kubernetes documentation"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"config"})," (",(0,i.jsx)(n.code,{children:'string or object: "{}"'}),") -\nA raw string of extra HCL or JSON ",(0,i.jsx)(n.a,{href:"/docs/configuration",children:"configuration"})," for Vault servers.\nThis will be saved as-is into a ConfigMap that is read by the Vault servers.\nThis can be used to add additional configuration that isn't directly exposed by the chart.\nIf an object is provided, it will be written as JSON."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# ExtraConfig values are formatted as a multi-line string:\nconfig: |\n  ui = true\n  api_addr = "http://POD_IP:8200"\n  listener "tcp" {\n      tls_disable = 1\n      address     = "0.0.0.0:8200"\n  }\n\n  storage "consul" {\n      path = "vault/"\n      address = "HOST_IP:8500"\n  }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This can also be set using Helm's ",(0,i.jsx)(n.code,{children:"--set"})," flag (vault-helm v0.1.0 and later), using the following syntax:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'--set server.ha.config=\'{ listener "tcp" { address = "0.0.0.0:8200" }\'\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"disruptionBudget"})," - Values that configures the disruption budget policy. See the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/run-application/configure-pdb/",children:"official Kubernetes documentation"})," for more information."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") -\nEnables disruption budget policy to limit the number of pods that are down simultaneously from voluntary disruptions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"maxUnavailable"})," (",(0,i.jsx)(n.code,{children:"int: null"}),") -\nThe maximum number of unavailable pods. By default, this will be automatically\ncomputed based on the ",(0,i.jsx)(n.code,{children:"server.replicas"})," value to be ",(0,i.jsx)(n.code,{children:"(n/2)-1"}),". If you need to set\nthis to ",(0,i.jsx)(n.code,{children:"0"}),", you will need to add a ",(0,i.jsx)(n.code,{children:"--set 'server.disruptionBudget.maxUnavailable=0'"}),"\nflag to the helm chart installation command because of a limitation in the Helm\ntemplating language."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"statefulSet"})," - This configures settings for the Vault Statefulset."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the Vault statefulset. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  kubernetes.io/my-statefulset: foobar\n# or\nannotations: |\n  kubernetes.io/my-statefulset: foobar\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"securityContext"})," - Set the Pod and container security contexts"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pod"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Defines the securityContext for the server Pods, as YAML or a YAML-formatted multi-line templated string."]}),"\n",(0,i.jsxs)(n.p,{children:["Default if not specified and ",(0,i.jsx)(n.code,{children:"global.openshift=false"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"runAsNonRoot: true\nrunAsGroup: {{ .Values.server.gid | default 1000 }}\nrunAsUser: {{ .Values.server.uid | default 100 }}\nfsGroup: {{ .Values.server.gid | default 1000 }}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Defaults to empty if not specified and ",(0,i.jsx)(n.code,{children:"global.openshift=true"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"container"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Defines the securityContext for the server containers, as YAML or a YAML-formatted multi-line templated string."]}),"\n",(0,i.jsxs)(n.p,{children:["Default if not specified and ",(0,i.jsx)(n.code,{children:"global.openshift=false"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"allowPrivilegeEscalation: false\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Defaults to empty if not specified and ",(0,i.jsx)(n.code,{children:"global.openshift=true"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ui"})," - Values that configure the Vault UI."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - If true, the UI will be enabled. The UI will only be enabled on Vault servers. If ",(0,i.jsx)(n.code,{children:"server.enabled"})," is false, then this setting has no effect. To expose the UI in some way, you must configure ",(0,i.jsx)(n.code,{children:"ui.service"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceType"})," (",(0,i.jsx)(n.code,{children:"string: ClusterIP"}),") - The service type to register. This defaults to ",(0,i.jsx)(n.code,{children:"ClusterIP"}),".\nThe available service types are documented on\n",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types",children:"the Kubernetes website"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"publishNotReadyAddresses"})," (",(0,i.jsx)(n.code,{children:"boolean: true"}),") - If set to true, will route traffic to Vault pods that aren't ready (if they're sealed or uninitialized."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"activeVaultPodOnly"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - If set to true, the UI service will only route to the active pod in a Vault HA cluster."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceNodePort"})," (",(0,i.jsx)(n.code,{children:"int: null"}),") - Sets the Node Port value when using ",(0,i.jsx)(n.code,{children:"serviceType: NodePort"})," on the Vault UI service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"externalPort"})," (",(0,i.jsx)(n.code,{children:"int: 8200"}),") - Sets the external port value of the service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"targetPort"})," (",(0,i.jsx)(n.code,{children:"int: 8200"}),") - Sets the target port value of the service."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"externalTrafficPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "Cluster"'}),") - The ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy",children:"externalTrafficPolicy"})," can be set to either Cluster or Local and is only valid for LoadBalancer and NodePort service types."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"loadBalancerSourceRanges"})," (",(0,i.jsx)(n.code,{children:"array"}),") - This value defines additional source CIDRs when using ",(0,i.jsx)(n.code,{children:"serviceType: LoadBalancer"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"loadBalancerSourceRanges:\n  - 10.0.0.0/16\n  - 120.78.23.3/32\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"loadBalancerIP"})," (",(0,i.jsx)(n.code,{children:"string"}),") - This value defines the IP address of the load balancer when using ",(0,i.jsx)(n.code,{children:"serviceType: LoadBalancer"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations for the UI service. This can either be YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'annotations:\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n# or\nannotations: |\n  "sample/annotation1": "foo"\n  "sample/annotation2": "bar"\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"csi"})," - Values that configure running the Vault CSI Provider."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", the Vault CSI Provider daemonset will be created."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"image"})," - Values that configure the Vault CSI Provider Docker image."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"repository"})," (",(0,i.jsx)(n.code,{children:'string: "hashicorp/vault-csi-provider"'}),") - The name of the Docker image for the Vault CSI Provider."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tag"})," (",(0,i.jsx)(n.code,{children:'string: "1.4.0"'}),") - The tag of the Docker image for the Vault CSI Provider.. ",(0,i.jsx)(n.strong,{children:"This should be pinned to a specific version when running in production."})," Otherwise, other changes to the chart may inadvertently upgrade your CSI provider."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pullPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "IfNotPresent"'}),") - The pull policy for container images. The default pull policy is ",(0,i.jsx)(n.code,{children:"IfNotPresent"})," which causes the Kubelet to skip pulling an image if it already exists locally."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"volumes"})," (",(0,i.jsx)(n.code,{children:"array: null"}),") - A list of volumes made available to all containers. This takes\nstandard Kubernetes volume definitions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"volumes:\n  - name: plugins\n    emptyDir: {}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"volumeMounts"})," (",(0,i.jsx)(n.code,{children:"array: null"}),") - A list of volumes mounts made available to all containers. This takes\nstandard Kubernetes volume mount definitions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"volumeMounts:\n  - mountPath: /usr/local/libexec/vault\n    name: plugins\n    readOnly: true\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resources"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - The resource requests and limits (CPU, memory, etc.) for each of the CSI containers. This should be a YAML dictionary of a Kubernetes ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",children:"resource"})," object. If this isn't specified, then the pods won't request any specific amount of resources, which limits the ability for Kubernetes to make efficient use of compute resources.",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.strong,{children:"Setting this is highly recommended."})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"resources:\n  requests:\n    memory: '10Gi'\n  limits:\n    memory: '10Gi'\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"hmacSecretName"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Override the default secret name for the CSI Provider's HMAC key used for generating secret versions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"daemonSet"})," - Values that configure the Vault CSI Provider daemonSet."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"updateStrategy"})," - Values that configure the Vault CSI Provider update strategy."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"type"})," (",(0,i.jsx)(n.code,{children:'string: "RollingUpdate"'}),") - The ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies",children:"type of update strategy"})," to be used when the daemonset is updated using Helm upgrades."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"maxUnavailable"})," (",(0,i.jsx)(n.code,{children:"int: null"}),") - The maximum number of unavailable pods during an upgrade."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the Vault CSI Provider daemonset. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  foo: bar\n# or\nannotations: |\n  foo: bar\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraLabels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional labels for the CSI provider daemonset."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"providersDir"})," (",(0,i.jsx)(n.code,{children:'string: "/etc/kubernetes/secrets-store-csi-providers"'}),") - Provider host path (must match the CSI provider's path)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"kubeletRootDir"})," (",(0,i.jsx)(n.code,{children:'string: "/var/lib/kubelet"'}),") - Kubelet host path"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"securityContext"})," - Security context for the pod template and container in the csi provider daemonSet"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pod"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Pod-level securityContext. May be specified as YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"container"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Container-level securityContext. May be specified as YAML or a YAML-formatted multi-line templated string."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pod"})," - Values that configure the Vault CSI Provider pod."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional annotations to\nadd to the Vault CSI Provider pods. This can either be YAML or a YAML-formatted\nmulti-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  foo: bar\n# or\nannotations: |\n  foo: bar\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraLabels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional labels for CSI provider pods."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"nodeSelector"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector",children:"nodeSelector"})," labels for csi pod assignment, formatted as a multi-line string or YAML map."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"nodeSelector:\n  beta.kubernetes.io/arch: amd64\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"affinity"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This should be either a multi-line string or YAML matching the PodSpec's affinity field."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tolerations"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - Toleration Settings for CSI pods. This should be a multi-line string or YAML matching the Toleration array in a PodSpec."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"priorityClassName"})," (",(0,i.jsx)(n.code,{children:'string: ""'}),") - Priority class for CSI Provider pods"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceAccount"})," - Values that configure the Vault CSI Provider's serviceaccount."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"annotations"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional\nannotations for the serviceAccount definition. This can either be YAML or\na YAML-formatted multi-line templated string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"annotations:\n  foo: bar\n# or\nannotations: |\n  foo: bar\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraLabels"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - This value defines additional labels for the CSI provider service account."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"readinessProbe"})," - Values that configure the readiness probe for the Vault CSI Provider pods."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures the number of seconds after the container has started before probe initiates."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"livenessProbe"})," - Values that configure the liveness probe for the Vault CSI Provider pods."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"initialDelaySeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - Sets the initial delay of the liveness probe when the container starts."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"failureThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 2"}),") - When set to a value, configures how many probe failures will be tolerated by Kubernetes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"periodSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 5"}),") - When set to a value, configures how often (in seconds) to perform the probe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"successThreshold"})," (",(0,i.jsx)(n.code,{children:"int: 1"}),") - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"timeoutSeconds"})," (",(0,i.jsx)(n.code,{children:"int: 3"}),") - When set to a value, configures the number of seconds after which the probe times out."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"debug"})," (",(0,i.jsx)(n.code,{children:"bool: false"}),") - When set to true, enables debug logging on the Vault CSI Provider daemonset."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraArgs"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - The extra arguments to be applied to the CSI pod startup command. See ",(0,i.jsx)(n.a,{href:"/docs/platform/k8s/csi/configurations#command-line-arguments",children:"here"})," for available flags."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"agent"})," - Configures the Vault Agent sidecar for the CSI Provider"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"bool: true"}),") - whether to enable the agent sidecar for the CSI provider"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"extraArgs"})," (",(0,i.jsx)(n.code,{children:"array: []"}),") - The extra arguments to be applied to the agent startup command."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"image"})," - Values that configure the Vault Agent sidecar image for the CSI Provider."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"pullPolicy"})," (",(0,i.jsx)(n.code,{children:'string: "IfNotPresent"'}),") - The pull policy for agent image. The default pull policy is ",(0,i.jsx)(n.code,{children:"IfNotPresent"})," which causes the Kubelet to skip pulling an image if it already exists."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"repository"})," (",(0,i.jsx)(n.code,{children:'string: "hashicorp/vault"'}),") - The name of the Docker image for the Vault Agent sidecar. This should be set to the official Vault Docker image."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tag"})," (",(0,i.jsx)(n.code,{children:'string: "1.14.0"'}),") - The tag of the Vault Docker image to use for the Vault Agent Sidecar."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"logFormat"})," (",(0,i.jsx)(n.code,{children:'string: "standard"'}),") -"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"logLevel"})," (",(0,i.jsx)(n.code,{children:'string: "info"'}),") -"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resources"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - The resource requests and limits (CPU, memory, etc.) for the agent. This should be a YAML dictionary of a Kubernetes ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#resourcerequirements-v1-core",children:"ResourceRequirements"})," object."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"resources:\n  requests:\n    memory: '256Mi'\n    cpu: '250m'\n  limits:\n    memory: '256Mi'\n    cpu: '250m'\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serverTelemetry"})," - Values the configure metrics and telemetry. Enabling these features requires setting\nthe ",(0,i.jsx)(n.code,{children:"telemetry {}"})," stanza in the Vault configuration. See the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry",children:"telemetry"}),"\n",(0,i.jsx)(n.a,{href:"/docs/internals/telemetry",children:"docs"})," for more on the Vault configuration."]}),"\n",(0,i.jsxs)(n.p,{children:["Currently, this chart does not support authenticating to Vault's metrics endpoint, so the following ",(0,i.jsx)(n.code,{children:"telemetry {}"})," block must be included in the ",(0,i.jsx)(n.code,{children:'listener "tcp" {}'})," stanza of the Vault configuration:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'listener "tcp" {\n  tls_disable = 1\n  address     = "0.0.0.0:8200"\n\n  telemetry {\n    unauthenticated_metrics_access = "true"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In addition, a top level ",(0,i.jsx)(n.code,{children:"telemetry {}"})," stanza must also be included in the Vault configuration, such as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'telemetry {\n  prometheus_retention_time = "30s",\n  disable_hostname = true\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"serviceMonitor"})," - Values that configure monitoring the Vault server"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - When set to ",(0,i.jsx)(n.code,{children:"true"}),", enable deployment of the Vault Server\nServiceMonitor CustomResource. The Prometheus operator ",(0,i.jsx)(n.em,{children:"must"})," be installed before enabling this\nfeature. If not, the chart will fail to install due to missing CustomResourceDefinitions provided by\nthe operator."]}),"\n",(0,i.jsxs)(n.p,{children:["Instructions on how to install the Helm chart can be found ",(0,i.jsx)(n.a,{href:"https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["More information can be found here in the\n",(0,i.jsx)(n.a,{href:"https://github.com/prometheus-operator/prometheus-operator",children:"these"}),"\n",(0,i.jsx)(n.a,{href:"https://github.com/prometheus-operator/kube-prometheus",children:"repositories"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"selectors"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Selector labels to add to the ServiceMonitor."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"interval"})," (",(0,i.jsx)(n.code,{children:'string: "30s"'}),") - Interval at which Prometheus scrapes metrics."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"scrapeTimeout"})," (",(0,i.jsx)(n.code,{children:'string: "10s"'}),") - Timeout for Prometheus scrapes."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"prometheusRules"})," - Values that configure Prometheus rules."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"enabled"})," (",(0,i.jsx)(n.code,{children:"boolean: false"}),") - Deploy the PrometheusRule custom resource for AlertManager-based\nalerts. Requires that AlertManager is properly deployed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"selectors"})," (",(0,i.jsx)(n.code,{children:"dictionary: {}"}),") - Selector labels to add to the Prometheus rules."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rules"}),": (",(0,i.jsx)(n.code,{children:"array: []"}),") - Prometheus rules to create."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'rules:\n  - alert: vault-HighResponseTime\n    annotations:\n      message: The response time of Vault is over 500ms on average over the last 5 minutes.\n    expr: vault_core_handle_request{quantile="0.5", namespace="mynamespace"} > 500\n    for: 5m\n    labels:\n      severity: warning\n  - alert: vault-HighResponseTime\n    annotations:\n      message: The response time of Vault is over 1s on average over the last 5 minutes.\n    expr: vault_core_handle_request{quantile="0.5", namespace="mynamespace"} > 1000\n    for: 5m\n    labels:\n      severity: critical\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var i=s(96540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);