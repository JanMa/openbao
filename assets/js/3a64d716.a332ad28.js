"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9379],{43506:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=n(74848),a=n(28453);const i={layout:"docs",page_title:"Architecture",description:"Learn about the internal architecture of OpenBao."},r="Architecture",o={id:"internals/architecture",title:"Architecture",description:"Learn about the internal architecture of OpenBao.",source:"@site/content/docs/internals/architecture.mdx",sourceDirName:"internals",slug:"/internals/architecture",permalink:"/openbao/docs/internals/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/internals/architecture.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"Architecture",description:"Learn about the internal architecture of OpenBao."},sidebar:"docs",previous:{title:"OpenBao internals",permalink:"/openbao/docs/internals/"},next:{title:"High availability",permalink:"/openbao/docs/internals/high-availability"}},c={},d=[];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(t.p,{children:"OpenBao is an intricate system with numerous distinct components. This page details the system architecture and hopes to assist OpenBao users and developers to build a mental model while understanding the theory of operation."}),"\n",(0,s.jsxs)(t.p,{children:["~> ",(0,s.jsx)(t.strong,{children:"Note:"})," This page covers the technical details of OpenBao. The descriptions and elements contained within are for users that wish to learn about OpenBao without having to reference the source code. Although not required, we encourage all users and operators to review the provided information before using OpenBao due to its significance in an environment."]}),"\n",(0,s.jsx)(t.h1,{id:"high-level-overview",children:"High-Level overview"}),"\n",(0,s.jsx)(t.p,{children:"The diagram below illustrates the intricacies and distinct components of OpenBao."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(77904).A+"",children:(0,s.jsx)(t.img,{alt:"Architecture Overview",src:n(53947).A+"",width:"1506",height:"841"})})}),"\n",(0,s.jsxs)(t.p,{children:["OpenBao\u2019s encryption layer, referred to as the ",(0,s.jsx)(t.em,{children:"barrier"}),", is responsible for encrypting and decrypting OpenBao data. When the OpenBao server starts, it writes data to its storage backend. Since the storage backend resides outside the barrier, it\u2019s considered untrusted so OpenBao will encrypt the data before it sends them to the storage backend. This mechanism ensures that if a malicious attacker attempts to gain access to the storage backend, the data cannot be compromised since it remains encrypted, until OpenBao decrypts the data. The storage backend provides a durable data persistent layer where data is secured and available across server restarts."]}),"\n",(0,s.jsxs)(t.p,{children:["When an OpenBao server is started, it begins in a ",(0,s.jsx)(t.em,{children:"sealed"})," state. Before any\noperation can be performed on OpenBao, it must be ",(0,s.jsx)(t.em,{children:"unsealed"}),". This is done by\nproviding the unseal keys. During the OpenBao initialization, it generates an\nencryption key, which is used to protect all OpenBao data. This key is protected by\na root key that is stored alongside all other OpenBao data, but is encrypted by another mechanism: the unseal key."]}),"\n",(0,s.jsxs)(t.p,{children:["By default, OpenBao uses ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing",children:"Shamir's Secret\nSharing"})," to split the\nunseal key into a configured number of shards (key shares or unseal\nkeys). A precise number of shards are required to reconstruct the unseal key,\nwhich is then used to decrypt the OpenBao's root key."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Unseal keys",src:n(6294).A+"",width:"666",height:"299"})}),"\n",(0,s.jsxs)(t.p,{children:["Refer to the ",(0,s.jsx)(t.a,{href:"/docs/concepts/seal#seal-unseal",children:"Seal/Unseal"})," documentation for\nfurther details."]}),"\n",(0,s.jsxs)(t.p,{children:["The number of shares and the minimum number of shards required can both be specified.\nShamir's technique can be disabled, and the root key can be used directly for\nunsealing. Once OpenBao retrieves the encryption key, it decrypts the\ndata in the storage backend, and enters the ",(0,s.jsx)(t.em,{children:"unsealed"})," state. Once unsealed,\nOpenBao loads the configured audit devices, auth methods, and secrets\nengines."]}),"\n",(0,s.jsxs)(t.p,{children:["~> ",(0,s.jsx)(t.strong,{children:"Note:"})," The default OpenBao configuration uses a Shamir seal; however, OpenBao can be ",(0,s.jsx)(t.a,{href:"/docs/concepts/seal#auto-unseal",children:"auto\nunsealed"})," by a trusted cloud key management\nsystem (KMS) or hardware security module (HSM) to increase security."]}),"\n",(0,s.jsx)(t.p,{children:"The configuration of the audit devices, auth methods, and secrets engines are security sensitive and are stored in OpenBao. Users with permissions can modify them and cannot be specified outside of the barrier. By storing them in OpenBao, changes are protected by the ACL system and tracked by audit logs."}),"\n",(0,s.jsx)(t.p,{children:"Requests may be processed from the HTTP API to the core once OpenBao is unsealed.\nThe core manages the flow of requests through the system,\nenforce ACLs, and ensure audit logging is done."}),"\n",(0,s.jsx)(t.p,{children:"When a client first connects to OpenBao, the client needs to authenticate. OpenBao provides\nconfigurable auth methods and offers flexibility within the authentication mechanism\nused. Mechanisms such as username/password or GitHub may be\nused for operators, while applications may use public/private keys or tokens to\nauthenticate. An authentication request that flows through the core and into an auth\nmethod determines if the request is valid and returns a list of\nassociated policies."}),"\n",(0,s.jsxs)(t.p,{children:['Policies are just a named ACL rule. For example, the "root" policy is built-in\nand permits access to all resources. You may create any number of named policies\nwith fine-grained control over paths. OpenBao operates in an allowed-access mode, meaning the action is not allowed unless access is granted via a policy explicitly. Since a user may have multiple policies associated, actions are allowed when policy permits. Policies are stored and managed by an internal\npolicy store. This internal store is affected through the system backend,\nwhich is always mounted at ',(0,s.jsx)(t.code,{children:"sys/"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Once authentication takes place and an auth method provides a set of applicable\npolicies, a new client token is generated and managed by the token store. This\nclient token is used to make future requests.\nThis token method is similar to a cookie sent by a website when a user logs in. Depending on the auth method configuration, the client\ntoken may have a lease associated with it, and may need to be renewed periodically to avoid invalidation."}),"\n",(0,s.jsx)(t.p,{children:"Once authenticated, requests are made by providing the client token. The client token is\nused to verify the client, ensuring they are authorized while loading the relevant policies. The\npolicies are used to authorize the client request. The request is then routed to the secrets engine, which is processed depending on its type. When the secrets engine returns the secret, the core registers it with the expiration manager and attaches a lease ID.  Clients use the lease ID to renew or revoke their\nsecret. The expiration manager automatically revokes the secret if a client allows the lease to expire."}),"\n",(0,s.jsx)(t.p,{children:"The core logs requests and responses to the audit broker, distributing the requests to all configured audit devices. Outside of the request\nflow, the core performs specific background activities. Lease management is critical, allowing expired client tokens or secrets to be revoked automatically. Additionally, OpenBao handles specific partial-failure cases by using write-ahead logging with a rollback manager. This is managed transparently within the core and is not user-visible."}),"\n",(0,s.jsx)(t.h1,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"To learn more about each components and sub-systems within OpenBao, select a topic from the left-navigation menu."}),"\n",(0,s.jsx)(t.li,{children:"For in depth details, consult the code."}),"\n",(0,s.jsxs)(t.li,{children:["To get started with OpenBao, try out our ",(0,s.jsx)(t.a,{href:"/tutorials/getting-started",children:"Getting Started"})," tutorial."]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},77904:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/files/layers-459352a870c8491bef9b4f33ea831ad8.png"},53947:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/layers-459352a870c8491bef9b4f33ea831ad8.png"},6294:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/vault-shamir-seal-9ba848ed9f348e03b004fc0cd92af233.png"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);