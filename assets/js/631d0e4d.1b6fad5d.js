"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[60],{53854:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var n=t(74848),s=t(28453);const r={layout:"docs",page_title:"PKI - Secrets Engine: Rotation Primitives",description:"The PKI secrets engine for OpenBao generates TLS certificates."},a="PKI secrets engine - rotation primitives",o={id:"secrets/pki/rotation-primitives",title:"PKI secrets engine - rotation primitives",description:"The PKI secrets engine for OpenBao generates TLS certificates.",source:"@site/content/docs/secrets/pki/rotation-primitives.mdx",sourceDirName:"secrets/pki",slug:"/secrets/pki/rotation-primitives",permalink:"/openbao/docs/secrets/pki/rotation-primitives",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/secrets/pki/rotation-primitives.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"PKI - Secrets Engine: Rotation Primitives",description:"The PKI secrets engine for OpenBao generates TLS certificates."},sidebar:"docs",previous:{title:"Troubleshoot PKI Secrets Engine and ACME",permalink:"/openbao/docs/secrets/pki/troubleshooting-acme"},next:{title:"RabbitMQ secrets engine",permalink:"/openbao/docs/secrets/rabbitmq"}},c={},h=[{value:"X.509 certificate fields",id:"x509-certificate-fields",level:2},{value:"X.509 rotation primitives",id:"x509-rotation-primitives",level:2},{value:"Cross-Signed primitive",id:"cross-signed-primitive",level:3},{value:"A note on Cross-Signed roots",id:"a-note-on-cross-signed-roots",level:4},{value:"Process flow",id:"process-flow",level:5},{value:"Certificate hierarchy",id:"certificate-hierarchy",level:5},{value:"Execution in OpenBao",id:"execution-in-openbao",level:4},{value:"Notes on <code>manual_chain</code>",id:"notes-on-manual_chain",level:5},{value:"Reissuance primitive",id:"reissuance-primitive",level:3},{value:"Process flow",id:"process-flow-1",level:4},{value:"Certificate hierarchy",id:"certificate-hierarchy-1",level:4},{value:"Execution in OpenBao",id:"execution-in-openbao-1",level:4},{value:"Temporal primitives",id:"temporal-primitives",level:3},{value:"Limitations of primitives",id:"limitations-of-primitives",level:3},{value:"Suggested root rotation procedure",id:"suggested-root-rotation-procedure",level:2},{value:"Tutorial",id:"tutorial",level:2},{value:"API",id:"api",level:2}];function l(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"pki-secrets-engine---rotation-primitives",children:"PKI secrets engine - rotation primitives"}),"\n",(0,n.jsx)(i.p,{children:"OpenBao's PKI Secrets Engine supports multiple issuers in a single mount point.\nBy using the certificate types below, rotation can be accomplished in various\nsituations involving both root and intermediate CAs managed by OpenBao."}),"\n",(0,n.jsx)(i.h2,{id:"x509-certificate-fields",children:"X.509 certificate fields"}),"\n",(0,n.jsxs)(i.p,{children:["X.509 is a complex specification; modern implementations tend to refer to\n",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280",children:"RFC 5280"})," for specific\ndetails. For validation of certificates, both RFC 5280 and the TLS\nvalidation ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc6125",children:"RFC 6125"})," are\nimportant for understanding how to achieve rotation."]}),"\n",(0,n.jsx)(i.p,{children:"The following is a simplification of these standards for the purpose of\nthis document."}),"\n",(0,n.jsxs)(i.p,{children:["Every X.509 certificate begins with an asymmetric key pair, using an algorithm\nlike RSA or ECDSA. This key pair is used to create a Certificate Signing\nRequest (CSR), which contains a set of fields the requester would like in the\nfinal certificate (but, it is up to the Certificate Authority (CA) to decide what\nfields to take from the CSR and which to override). The CSR also contains the\npublic key of the pair, which is signed by the private key of the key pair to\nprove possession. Usually, the requester would ask for attributes in the\nSubject field of the CSR or in the Subject Alternative Name extension CSR to\nbe respected in the final certificate. It is up to the CA if these values are\ntrusted or not. When approved by the issuing authority (which may be backed by\nthis asymmetric key itself in the case of a root self-signed certificate), the\nauthority attaches the Subject of ",(0,n.jsx)(i.em,{children:"its"})," certificate to the issued certificate in\nthe Issuer field, assigns a unique serial number to the issued certificate, and\nsigns the set of fields with its private key, thus creating the certificate."]}),"\n",(0,n.jsx)(i.p,{children:"There are some important restrictions here:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"One certificate can only have one Issuer, but this issuer is identified by\nthe Subject on the issuing certificate and its public key."}),"\n",(0,n.jsx)(i.li,{children:"One key pair can be used for multiple certificates, but one certificate can\nonly have one backing key material."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"The following fields on the final certificate are relevant to rotation:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["The backing ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.7",children:"public"}),"\nand private key material (Subject Public Key Info).","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Note that the private key is not included in the certificate but is\nuniquely determined by the public key material."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6",children:"Subject"})," of the certificate.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["This identifies the entity to which the certificate was issued. While the\nSAN values (in the ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.6",children:"Subject Alternative Name"}),"\nextension) is useful when validating TLS Server certificates against the\nnegotiated hostname and URI, it isn't generally relevant for the purposes\nof validating intermediate certificate chains or in rotation."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.5",children:"Validity"}),"\nperiod of this certificate.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Notably, RFC 5280 does not place any requirements around the issued\ncertificate's validity period relative to the validity period of the\nissuing certificate. However, it ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.5",children:"does state"}),"\nthat certificates ought to be revoked if their status cannot be maintained\nup to their notAfter date. This is why OpenBao's ",(0,n.jsx)(i.code,{children:"/pki/issuer/:issuer_ref"}),"\nconfiguration endpoint maintains the ",(0,n.jsx)(i.code,{children:"leaf_not_after_behavior"})," per-issuer\nrather than per-role."]}),"\n",(0,n.jsxs)(i.li,{children:["Additionally, some browsers will place ultimate trust in the certificates\nin their trust stores, even when these certificates are expired.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Note that this only applies to certificates in the trust store; validity\nperiods will still be enforced for certificates not in the store (such\nas intermediates)."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.4",children:"Issuer"})," and\n",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.1.3",children:"signatureValue"}),"\nof this certificate.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"In the issued certificate's Issuer field, the issuing certificate places\nits own Subject value. This allows the issuer to be identified later\n(without having to try signature validation against every known local\ncertificate), when validating the presented certificate and chain."}),"\n",(0,n.jsx)(i.li,{children:"The signature over the entire certificate (by the issuer's private key)\nis then placed in the signatureValue field."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The optional ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1",children:"Authority Key Identifier"}),"\nfield.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["This field can contain either (or both) of two values:","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"The hash of the issuer's public key. This extension is set and this\nvalue is filled in by OpenBao."}),"\n",(0,n.jsx)(i.li,{children:"The Issuer's Subject and Serial Number. This value is not set by OpenBao."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The latter is a dangerous restriction for the purposes of rotation: it\nprevents cross-signing and reissuance as the new issuing certificates\n(while having the same backing key material) will have different serial\nnumbers. See the ",(0,n.jsx)(i.a,{href:"#limitations-of-primitives",children:"Limitations of Primitives"}),"\nsection below for more information on this restriction."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.2",children:"Serial Number"}),"\nof this certificate.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"This field is unique to a specific issuer; when a certificate is\nreissued by its parent authority, it will always have a different serial\nnumber field."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.13",children:"CRL distribution"}),"\npoint field.","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"This is a field detailing where a CRL is expected to exist for this\ncertificate and under which CRL issuers (defaulting to the issuing\ncertificate itself) the CRL is expected to be signed by. This is mostly\ninformational and for server software like nginx, OpenBao's Cert Auth method,\nand Apache, CRLs are provided to the server, rather than having the\nserver fetch CRLs for certificates automatically."}),"\n",(0,n.jsx)(i.li,{children:"Note that root certificates (in browsers trust stores) are generally not\nconsidered revocable. However, if an intermediate is revoked by serial,\nit will appear on its parent's CRL, and may prevent rotation from\nhappening."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"x509-rotation-primitives",children:"X.509 rotation primitives"}),"\n",(0,n.jsxs)(i.p,{children:["Rotation (from an organizational standpoint) can only safely happen with\ncertain intermediate X.509 certificates being issued. To distinguish the two\ntypes of certificates used to achieve rotation, this document notates them\nas ",(0,n.jsx)(i.em,{children:"primitives"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Rotation of an end-entity certificate is trivial from an X.509 trust chain\nperspective; this process happens every day and should only depend on what is\nin the trust store and not the end-entity certificate itself. In OpenBao, the\nrequester would hit the various issuance endpoints (",(0,n.jsx)(i.code,{children:"/pki/issue/:name"})," or\n",(0,n.jsx)(i.code,{children:"/pki/sign/:name"})," -- or use the unsafe ",(0,n.jsx)(i.code,{children:"/pki/sign-verbatim"}),") and swap out the\nold certificate with the new certificate and reload the configuration or\nrestart the service. Other parts of the organizations might use\n",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc8555",children:"ACME"})," for certificate issuance\nand rotation, especially if the service is public-facing (and thus needs to\nbe issued by a Public CA). Given it was signed by a trusted root, any devices\nconnecting to the service would not know the difference."]}),"\n",(0,n.jsxs)(i.p,{children:["Rotation of intermediate certificates is almost as easy. Assuming a decent\noperational setup (wherein during end-entity issuance, the full certificate\nchain is updated in the service's configuration), this should be as easy as\ncreating a new intermediate CA, signing it against the root CA, and then\nbeginning issuance against the new intermediate certificate. In OpenBao, if\nthe intermediate is generated in an existing mount path (or is moved into\nsuch), the requesting entity shouldn't care much. Under ACME, Let's Encrypt\nhas successfully rotated intermediates to present a cross-signed chain\n(",(0,n.jsx)(i.a,{href:"https://letsencrypt.org/2020/12/21/extending-android-compatibility.html",children:"for older Android devices"}),").\nAssuming the old intermediate's parent(s) are still valid and trusted,\ncertificates issued under old intermediates should continue to validate."]}),"\n",(0,n.jsx)(i.p,{children:"The hard part of rotation--calling for the use of these primitives--is\nrotating root certificates. These live in every device's trust store and\nare hard to update from an organization-wide operational perspective.\nUnless the organization can swap out roots almost instantaneously and\nsimultaneously (e.g., via an agent) with no missed devices, this process\nwill likely span months."}),"\n",(0,n.jsxs)(i.p,{children:["To make this process lower risk, there are various primitive certificate\ntypes that use the ",(0,n.jsx)(i.a,{href:"#x-509-certificate-fields",children:"above certificate fields"}),".\nKey to their success is the following note:"]}),"\n",(0,n.jsx)(i.p,{children:"~> Note: While certificates are added to the trust store, it is ultimately\nthe associated key material that determines trust: two issuer certificates\nwith the same subject but different public keys cannot validate the same\nleaf certificate; only if the keys are the same can this occur."}),"\n",(0,n.jsx)(i.h3,{id:"cross-signed-primitive",children:"Cross-Signed primitive"}),"\n",(0,n.jsx)(i.p,{children:"This is the most common type of rotation primitive. A common CSR is signed by\ntwo CAs, resulting in two certificates. These certificates must have the same\nSubject (but may have different Issuers and will have different Serial Numbers)\nand the same backing key material, to allow certificates they sign to be\ntrusted by either variant."}),"\n",(0,n.jsx)(i.p,{children:"Note that, due to restrictions in how end-entity certificates are used and\nvalidated (services and validation libraries expect only one), cross-signing\nmost typically only applies to intermediate."}),"\n",(0,n.jsx)(i.h4,{id:"a-note-on-cross-signed-roots",children:"A note on Cross-Signed roots"}),"\n",(0,n.jsx)(i.p,{children:"Technically, cross-signing can occur between two roots, allowing trust bundles\nwith either root to validate certs issued through the other. However, this\nprocess creates a certificate that is effectively an intermediate (as it is\nno longer self-signed) and usually must be served alongside the trust chain.\nGiven this restriction, it's preferable to instead cross-sign the top-level\nintermediates under the root unless strictly necessary when the old root\ncertificate has been used to directly issue leaf certificates."}),"\n",(0,n.jsx)(i.p,{children:"So, the rest of this process flow assumes an intermediate is being\ncross-signed as this is more common."}),"\n",(0,n.jsx)(i.h5,{id:"process-flow",children:"Process flow"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"        -------------------\n       | generate key pair | -------------\x3e ...\n        -------------------                 ...\n           |            |                   ...\n --------------        --------------       ...\n| generate CSR |      | generate CSR |      ...\n --------------        --------------       ...\n         |                   |              ...\n    -----------         -----------         ...\n   | signed by |       | signed by |        ...\n   | root A    |       | root B    |        ...\n    -----------         -----------         ...\n"})}),"\n",(0,n.jsx)(i.p,{children:"Here, a key pair was generated at some point in time. Two CSRs are created and\nsent to two different root authorities (Root A and Root B). These result in two\nseparate certificates (potentially with different validity periods) with the\nsame Subject and same backing key material."}),"\n",(0,n.jsx)(i.p,{children:'Note that this cross-signing need not happen simultaneously; there could be a\ngap of several years between the first and second certificate. Additionally,\nthere\'s no limit on the number of cross-signed "duplicate" (used loosely--with\nthe same subject and key material) certificates: this could be cross-signed\nby many different root certificates if necessary and desired.'}),"\n",(0,n.jsx)(i.h5,{id:"certificate-hierarchy",children:"Certificate hierarchy"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:" --------                                            --------\n| root A |                                          | root B |\n --------                                            --------\n   |                                                      |\n ----------------                            ----------------\n| intermediate C |  <- same key material -> | intermediate D |\n ----------------              |             ----------------\n                               |\n                      -------------------\n                     | leaf certificates |\n                      -------------------\n"})}),"\n",(0,n.jsx)(i.p,{children:"The above process results in two trust paths: either of root A or root B (or\nboth) could exist in the client's trust stores and the leaf certificate would\nvalidate correctly. Because the same key material is used for both intermediate\ncertificates (C and D), the issued leaf certificate's signature field would\nbe the same regardless of which intermediate was contacted."}),"\n",(0,n.jsx)(i.p,{children:"Cross-signing is thus a unifying primitive; two separate trust paths now join\ninto a single one, by having leaf certificate's issuer field to point to two\nseparate paths (via duplication of the certificate in the chain) and would be\nconditionally validated based on which root is present in the trust store."}),"\n",(0,n.jsx)(i.p,{children:"This construct is documented and used in several places:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://letsencrypt.org/certificates/",children:"https://letsencrypt.org/certificates/"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://scotthelme.co.uk/cross-signing-alternate-trust-paths-how-they-work/",children:"https://scotthelme.co.uk/cross-signing-alternate-trust-paths-how-they-work/"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://security.stackexchange.com/questions/14043/what-is-the-use-of-cross-signing-certificates-in-x-509",children:"https://security.stackexchange.com/questions/14043/what-is-the-use-of-cross-signing-certificates-in-x-509"})}),"\n"]}),"\n",(0,n.jsx)(i.h4,{id:"execution-in-openbao",children:"Execution in OpenBao"}),"\n",(0,n.jsxs)(i.p,{children:["To create a cross-signed certificate in OpenBao, use the ",(0,n.jsxs)(i.a,{href:"/api-docs/secret/pki#generate-intermediate-csr",children:[(0,n.jsx)(i.code,{children:"/intermediate/cross-sign"}),"\nendpoint"]}),". Here, when creating\na cross-signature to all ",(0,n.jsx)(i.code,{children:"cert B"})," to be validated by ",(0,n.jsx)(i.code,{children:"cert A"}),", provide the values\n(",(0,n.jsx)(i.code,{children:"key_ref"}),", all Subject parts, &c) for ",(0,n.jsx)(i.code,{children:"cert B"})," during intermediate generation.\nThen sign this CSR (using the ",(0,n.jsxs)(i.a,{href:"/api-docs/secret/pki#sign-intermediate",children:[(0,n.jsx)(i.code,{children:"/issuer/:issuer_ref/sign-intermediate"}),"\nendpoint"]}),") with ",(0,n.jsx)(i.code,{children:"cert A"}),"'s reference\nand provide necessary values from ",(0,n.jsx)(i.code,{children:"cert B"})," (e.g., Subject parts). ",(0,n.jsx)(i.code,{children:"cert A"})," may\nlive outside OpenBao. Finally, import the cross-signed certificate into OpenBao\n",(0,n.jsxs)(i.a,{href:"/api-docs/secret/pki#import-ca-certificates-and-keys",children:["using the ",(0,n.jsx)(i.code,{children:"/issuers/import/cert"})," endpoint"]}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["If this process succeeded, and both ",(0,n.jsx)(i.code,{children:"cert A"})," and ",(0,n.jsx)(i.code,{children:"cert B"})," and their key\nmaterial lives in OpenBao, the newly imported cross-signed certificate\nwill have a ",(0,n.jsx)(i.code,{children:"ca_chain"})," response field ",(0,n.jsx)(i.a,{href:"/api-docs/secret/pki#read-issuer",children:"during read"}),"\ncontaining ",(0,n.jsx)(i.code,{children:"cert A"}),", and ",(0,n.jsx)(i.code,{children:"cert B"}),"'s ",(0,n.jsx)(i.code,{children:"ca_chain"})," will contain the cross-signed\ncert and its ",(0,n.jsx)(i.code,{children:"ca_chain"})," value."]}),"\n",(0,n.jsx)(i.p,{children:"~> Note: Regardless of issuer type, is important to provide all relevant\nparameters as they were originally; OpenBao does not infer e.g., the Subject\nname parameters from the existing issuer; it merely reuses the same key\nmaterial."}),"\n",(0,n.jsxs)(i.h5,{id:"notes-on-manual_chain",children:["Notes on ",(0,n.jsx)(i.code,{children:"manual_chain"})]}),"\n",(0,n.jsxs)(i.p,{children:["If an intermediate is cross-signed and imported into the same mount as its\npair, OpenBao will not detect the cross-signed pairs during automatic chain\nbuilding. As a result, leaf issuance will have a chain that only includes\none of these pairs of chains. This is because the leaf issuance's ",(0,n.jsx)(i.code,{children:"ca_chain"}),"\nparameter copies the value from signing issuer directly, rather than computing\nits own copy of the chain."]}),"\n",(0,n.jsxs)(i.p,{children:["To fix this, update the ",(0,n.jsx)(i.code,{children:"manual_chain"})," field on the ",(0,n.jsx)(i.a,{href:"/api-docs/secret/pki#update-issuer",children:"issuers"}),"\nto include the chains of both pairs. For instance, given ",(0,n.jsx)(i.code,{children:"intA"})," signed by\n",(0,n.jsx)(i.code,{children:"rootA"})," and ",(0,n.jsx)(i.code,{children:"intB"})," signed by ",(0,n.jsx)(i.code,{children:"rootB"})," as its cross-signed version, one\ncould do the following:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"$ bao patch pki/issuer/intA manual_chain=self,rootA,intB,rootB\n$ bao patch pki/issuer/intB manual_chain=self,rootB,intA,rootA\n"})}),"\n",(0,n.jsx)(i.p,{children:"This will ensure that issuance with either copy of the intermediate reports\nthe full cross-signed chain when signing leaf certs."}),"\n",(0,n.jsx)(i.h3,{id:"reissuance-primitive",children:"Reissuance primitive"}),"\n",(0,n.jsx)(i.p,{children:"The second most common type of rotation primitive. In this scheme, the existing\nkey material is used to generate a new certificate, usually at a much later\npoint in time from the existing issuance."}),"\n",(0,n.jsx)(i.p,{children:"While similar to the cross-signed primitive, this one differs in that usually\nthe reissuance happens after the original certificate expires or is close to\nexpiration and is reissued by the original root CA. In the event of a\nself-signed certificate (e.g., a root certificate), this parent certificate\nwould be itself. In both cases, this changes the contents of the certificate\n(due to the new serial number) but allows all existing leaf signatures to\nstill validate."}),"\n",(0,n.jsx)(i.p,{children:"Unlike the cross-signed primitive, this primitive type can be used on all\ntypes of certificates (including leaves, intermediates, and roots)."}),"\n",(0,n.jsx)(i.h4,{id:"process-flow-1",children:"Process flow"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"          -------------------\n         | generate key pair | ---------------\x3e ...\n          -------------------                   ...\n           |              |                     ...\n --------------           --------------        ...\n| generate CSR |   <->   | generate CSR |       ...\n --------------           --------------        ...\n         |                    |                 ...\n ------------------      ------------------     ...\n| signed by issuer | -> | signed by issuer | -> ...\n ------------------      ------------------     ...\n"})}),"\n",(0,n.jsx)(i.p,{children:"In this process flow, a single key pair is generated at some point in time\nand stored. The CSR (with same requested fields) is generated from this\ncommon key material and signed by the same issuer at multiple points in\ntime, preserving all critical fields (Subject, Issuer, &c). While there is\nstrictly no limit on the number of times a key can be reissued, at some point\nsafety would dictate the key material should be rotated instead of being\ncontinually reissued."}),"\n",(0,n.jsx)(i.h4,{id:"certificate-hierarchy-1",children:"Certificate hierarchy"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"                          ------\n              -----------| root |-------------\n             /            ------              \\\n             |                                |\n ---------------                           ---------------\n| original cert | <- same key material -> | reissued cert |\n ---------------              |            ---------------\n                              |\n                      -------------------\n                     | leaf certificates |\n                      -------------------\n"})}),"\n",(0,n.jsx)(i.p,{children:"Note that while this again results in two trust paths, depending on which\nintermediate certificate is presented and is still valid, only a root need be\ntrusted. When a reissued certificate is a root certificate, the issuance link is\nsimply self-loop. But, in this case, note that both certificates are\n(technically) valid issuers of each other. This means it should be possible to\nprovide a reissued root certificate in the TLS certificate chain and have it\nchain back to an existing root certificate in a trust store."}),"\n",(0,n.jsx)(i.p,{children:"This primitive type is thus an incrementing primitive; the life cycle of an\nexisting key is extended into the future by issuing a new certificate with the\nsame key material from the existing authority."}),"\n",(0,n.jsx)(i.h4,{id:"execution-in-openbao-1",children:"Execution in OpenBao"}),"\n",(0,n.jsxs)(i.p,{children:["To create a reissued root certificate in OpenBao, use ",(0,n.jsxs)(i.a,{href:"/api-docs/secret/pki#generate-root",children:[(0,n.jsx)(i.code,{children:"/issuers/generate/root/existing"}),"\nendpoint"]}),". This allows the generation of a new\nroot certificate with the existing key material (via the ",(0,n.jsx)(i.code,{children:"key_ref"})," request parameter).\nIf this process succeeded, when ",(0,n.jsx)(i.a,{href:"/api-docs/secret/pki#read-issuer",children:"reading the issuer"}),"\n(via ",(0,n.jsx)(i.code,{children:"GET /issuer/:issuer_ref"}),"), both issuers (old and reissued) will appear in\neach others' ",(0,n.jsx)(i.code,{children:"ca_chain"})," response field (unless prevented so by a ",(0,n.jsx)(i.code,{children:"manual_chain"}),"\nvalue)."]}),"\n",(0,n.jsx)(i.p,{children:"To create a reissued intermediate certificate in OpenBao, this is a three step\nprocess:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["Use the ",(0,n.jsxs)(i.a,{href:"/api-docs/secret/pki#generate-intermediate-csr",children:[(0,n.jsx)(i.code,{children:"/issuers/generate/intermediate/existing"}),"\nendpoint"]}),"\nto generate a new CSR with the existing key material with the ",(0,n.jsx)(i.code,{children:"key_ref"}),"\nrequest parameter."]}),"\n",(0,n.jsx)(i.li,{children:"Sign this CSR via the same signing process under the same issuer. This\nstep is specific to the parent CA, which may or may not be OpenBao."}),"\n",(0,n.jsxs)(i.li,{children:["Finally, use the ",(0,n.jsxs)(i.a,{href:"/api-docs/secret/pki#import-ca-certificates-and-keys",children:[(0,n.jsx)(i.code,{children:"/intermediate/set-signed"})," endpoint"]}),"\nto import the signed certificate from step 2."]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:["If the process to reissue an intermediate certificate succeeded, when\n",(0,n.jsx)(i.a,{href:"/api-docs/secret/pki#read-issuer",children:"reading the issuer"})," (via\n",(0,n.jsx)(i.code,{children:"GET /issuer/:issuer_ref"}),"), both issuers (old and reissued) will have\nthe same ",(0,n.jsx)(i.code,{children:"ca_chain"})," response field, except for the first entry (unless\nprevented so by a ",(0,n.jsx)(i.code,{children:"manual_chain"})," value)."]}),"\n",(0,n.jsx)(i.p,{children:"~> Note: Regardless of issuer type, is important to provide all relevant\nparameters as they were originally; OpenBao does not infer e.g., the Subject\nname parameters from the existing issuer; it merely reuses the same key\nmaterial."}),"\n",(0,n.jsx)(i.h3,{id:"temporal-primitives",children:"Temporal primitives"}),"\n",(0,n.jsx)(i.p,{children:"We can use the above primitive types to rotate roots and intermediates to new\nkeys and extend their lifetimes. This time-based rotation is what ultimately\nallows us to rotate root certificates."}),"\n",(0,n.jsxs)(i.p,{children:["There's two main variants of this: a ",(0,n.jsx)(i.strong,{children:"forward"})," primitive, wherein an old\ncertificate is used to bless new key material, and a ",(0,n.jsx)(i.strong,{children:"backwards"})," primitive,\nwherein a new certificate is used to bless old key material. Both of these\nprimitives are independently used by Let's Encrypt in the aforementioned\nchain of trust document:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"The link from DST Root CA X3 to ISRG Root X1 is an example of a forward\nprimitive."}),"\n",(0,n.jsx)(i.li,{children:"The link from ISRG Root X1 to R3 (which was originally signed by DST Root\nCA X3) is an example of a backwards primitive."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"For most organizations with a hierarchical structured CA setup, cross-signing\nall intermediates with both the new and old root CAs is sufficient for root\nrotation."}),"\n",(0,n.jsx)(i.p,{children:"However, for organizations which have directly issued leaf certificates from a\nroot, the old root will need to be reissued under the new root (with shorter\nduration) to allow these certificates to continue to validate. This combines\nboth of the above primitives (cross-signing and reissuance) into a single\nbackwards primitive step. In the future, these organizations should probably\nmove to a more standard, hierarchical setup."}),"\n",(0,n.jsx)(i.h3,{id:"limitations-of-primitives",children:"Limitations of primitives"}),"\n",(0,n.jsxs)(i.p,{children:["The certificate's ",(0,n.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.1",children:"Authority Key Identifier"}),"\nextension field may contain either or both of the issuer's keyIdentifier\n(a hash of the public key) or both the issuer's Subject and Serial Number\nfields. Generating certificates with the latter enabled (luckily not possible\nin OpenBao, especially so since OpenBao uses strictly random serial numbers)\nprevents building a proper cross-signed chain without re-issuing the same\nserial number, which will not work with most browsers' trust stores and\nvalidation engines, due to ",(0,n.jsx)(i.a,{href:"https://support.mozilla.org/en-US/kb/Certificate-contains-the-same-serial-number-as-another-certificate",children:"caching of\ncertificates"}),"\nused in successful validations. In the strictest sense, when using a\ncross-signing primitive (from a different CA), the intermediate could be reissued\nwith the same serial number, assuming no previous certificate was issued by that\nCA with that serial. This does not work when using a reissuance primitive as these\nare technically the same authority and thus this authority must issue\ncertificates with unique serial numbers."]}),"\n",(0,n.jsx)(i.h2,{id:"suggested-root-rotation-procedure",children:"Suggested root rotation procedure"}),"\n",(0,n.jsxs)(i.p,{children:["The following is a suggested process for achieving root rotation easily and\nwithout (outage) impact to the broader organization, assuming ",(0,n.jsx)(i.a,{href:"/docs/secrets/pki/considerations#use-a-ca-hierarchy",children:"best\npractices"})," are\nbeing followed. Some adaption will be necessary."]}),"\n",(0,n.jsx)(i.p,{children:"Note that this process takes time. How much time is dependent on the\nautomation level and operational awareness of the organization."}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"/api-docs/secret/pki#generate-root",children:"Generate"})," the new root\ncertificate. For clarity, it is suggested to use a new common name\nto distinguish it from the old root certificate. Key material need\nnot be the same."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"#cross-signed-primitive",children:"Cross-sign"})," all existing intermediates.\nIt is important to update the manual chain on the issuers as discussed\nin that section, as we assume servers are configured to combine the\n",(0,n.jsx)(i.code,{children:"certificate"})," field with the ",(0,n.jsx)(i.code,{children:"ca_chain"})," field on renewal and issuance,\nthus getting the cross-signed intermediates."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["Encourage rotation to pickup the new cross-signed intermediates. With\nshort-lived certificates, this should ",(0,n.jsx)(i.a,{href:"/docs/secrets/pki/considerations#automate-leaf-certificate-renewal",children:"happen\nautomatically"}),".\nHowever, for some long-lived certs, it is suggested to rotate them\nmanually and proactively. This step takes time, and depends on the\ntypes of certificates issued (e.g., server certs, code signing, or client\nauth)."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["Once ",(0,n.jsx)(i.em,{children:"all"})," chains have been updated, new systems can be brought online\nwith only the new root certificate, and connect to all existing systems."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Existing systems can now be migrated with a one-shot root switch: the\nnew root can be added and the old root can be removed at the same time.\nAssuming the above step 3 can be achieved in a reasonable amount of time,\nthis decreases the time it takes to move the majority of systems over to\nfully using the new root and no longer trusting the old root. This step\nalso takes time, depending on how quickly the organization can migrate\nroots and ensure all such systems are migrated. If some systems are\noffline and only infrequently online (or, if they have hard-coded\ncertificate stores and need to reach obsolescence first), the organization\nmight not be ready to move on to future steps."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"At this point, since all systems now use the new root, it is safe to remove\nor archive the old root and intermediates, updating the manual chain to\npoint strictly to the new intermediate+root."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"At this point, rotation is fully completed."}),"\n",(0,n.jsx)(i.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,n.jsxs)(i.p,{children:["Refer to the ",(0,n.jsx)(i.a,{href:"/tutorials/secrets-management/pki-engine",children:"Build Your Own Certificate Authority (CA)"}),"\nguide for a step-by-step tutorial."]}),"\n",(0,n.jsx)(i.h2,{id:"api",children:"API"}),"\n",(0,n.jsxs)(i.p,{children:["The PKI secrets engine has a full HTTP API. Please see the\n",(0,n.jsx)(i.a,{href:"/api-docs/secret/pki",children:"PKI secrets engine API"})," for more\ndetails."]})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var n=t(96540);const s={},r=n.createContext(s);function a(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);