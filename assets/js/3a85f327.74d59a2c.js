"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6986],{41232:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>r});var s=i(74848),t=i(28453);const a={sidebar_label:"Overview",description:"Audit devices are mountable devices that log requests and responses in OpenBao."},o="Audit devices",l={id:"audit/index",title:"Audit devices",description:"Audit devices are mountable devices that log requests and responses in OpenBao.",source:"@site/content/docs/audit/index.mdx",sourceDirName:"audit",slug:"/audit/",permalink:"/docs/audit/",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/audit/index.mdx",tags:[],version:"current",frontMatter:{sidebar_label:"Overview",description:"Audit devices are mountable devices that log requests and responses in OpenBao."},sidebar:"docs",previous:{title:"Username and Password",permalink:"/docs/auth/userpass"},next:{title:"File",permalink:"/docs/audit/file"}},d={},r=[{value:"Enabling multiple devices",id:"enabling-multiple-devices",level:2},{value:"Format",id:"format",level:2},{value:"Sensitive information",id:"sensitive-information",level:2},{value:"Enabling/Disabling audit devices",id:"enablingdisabling-audit-devices",level:2},{value:"Blocked audit devices",id:"blocked-audit-devices",level:2},{value:"Tutorial",id:"tutorial",level:2},{value:"API",id:"api",level:2},{value:"Common configuration options",id:"common-configuration-options",level:2},{value:"Eliding list response bodies",id:"eliding-list-response-bodies",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"audit-devices",children:"Audit devices"}),"\n",(0,s.jsxs)(n.p,{children:["Audit devices are the components in OpenBao that collectively keep a detailed log of all\nrequests to OpenBao, and their responses. Because every operation with OpenBao is an API\nrequest/response, when using a single audit device, the audit log contains ",(0,s.jsx)(n.em,{children:"every"})," interaction with\nthe OpenBao API, including errors - except for a few paths which do not go via the audit system."]}),"\n",(0,s.jsx)(n.p,{children:"The non-audited paths are:"}),"\n",(0,s.jsx)(n.p,{children:"sys/init\nsys/seal-status\nsys/seal\nsys/step-down\nsys/unseal\nsys/leader\nsys/health\nsys/rekey/init\nsys/rekey/update\nsys/rekey/verify\nsys/rekey-recovery-key/init\nsys/rekey-recovery-key/update\nsys/rekey-recovery-key/verify\nsys/storage/raft/bootstrap\nsys/storage/raft/join\nsys/internal/ui/feature-flags"}),"\n",(0,s.jsx)(n.p,{children:"and also, if the relevant listener configuration settings allow unauthenticated access:"}),"\n",(0,s.jsx)(n.p,{children:"sys/metrics\nsys/pprof/*\nsys/in-flight-req"}),"\n",(0,s.jsx)(n.h2,{id:"enabling-multiple-devices",children:"Enabling multiple devices"}),"\n",(0,s.jsx)(n.p,{children:"When multiple audit devices are enabled, OpenBao will attempt to send the audit\nlogs to all of them. This allows you to not only have redundant copies, but also\na way to check for data tampering in the logs themselves."}),"\n",(0,s.jsxs)(n.p,{children:["OpenBao considers a request to be successful if it can log to ",(0,s.jsx)(n.em,{children:"at least"})," one\nconfigured audit device (see: ",(0,s.jsx)(n.a,{href:"/docs/audit#blocked-audit-devices",children:"Blocked Audit\nDevices"})," section below).  Therefore in order\nto build a complete picture of all audited actions, use the aggregate/union of\nthe logs from each audit device."]}),"\n",(0,s.jsxs)(n.p,{children:["~> Note: It is ",(0,s.jsx)(n.strong,{children:"highly recommended"})," that you configure OpenBao to use multiple audit\ndevices. Audit failures can prevent OpenBao from servicing requests, so it is\nimportant to provide at least one other device."]}),"\n",(0,s.jsx)(n.h2,{id:"format",children:"Format"}),"\n",(0,s.jsxs)(n.p,{children:["Each line in the audit log is a JSON object. The ",(0,s.jsx)(n.code,{children:"type"})," field specifies what\ntype of object it is. Currently, only two types exist: ",(0,s.jsx)(n.code,{children:"request"})," and ",(0,s.jsx)(n.code,{children:"response"}),".\nThe line contains all of the information for any given request and response. By\ndefault, all the sensitive information is first hashed before logging in the\naudit logs."]}),"\n",(0,s.jsx)(n.h2,{id:"sensitive-information",children:"Sensitive information"}),"\n",(0,s.jsx)(n.p,{children:"The audit logs contain the full request and response objects for every\ninteraction with OpenBao. The request and response can be matched utilizing a\nunique identifier assigned to each request."}),"\n",(0,s.jsxs)(n.p,{children:["Most strings contained within requests and responses are hashed with a salt using HMAC-SHA256. The purpose of the hash is so that secrets aren't in plaintext within your audit logs. However, you're still able to check the value of secrets by generating HMACs yourself; this can be done with the audit device's hash function and salt by using the ",(0,s.jsx)(n.code,{children:"/sys/audit-hash"})," API endpoint (see the documentation for more details)."]}),"\n",(0,s.jsx)(n.p,{children:"~> Currently, only strings that come from JSON or returned in JSON are\nHMAC'd. Other data types, like integers, booleans, and so on, are passed\nthrough in plaintext. We recommend that all sensitive data be provided as string values\ninside all JSON sent to OpenBao (i.e., that integer values are provided in quotes)."}),"\n",(0,s.jsxs)(n.p,{children:["While most strings are hashed, OpenBao does make some exceptions, such as auth and secrets, and users can enable additional exceptions using the ",(0,s.jsx)(n.a,{href:"/docs/commands/secrets/enable",children:"secrets enable"})," command, and then tune it afterward."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"see also"}),":"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/docs/commands/secrets/tune",children:"secrets tune"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/docs/commands/auth/enable",children:"auth enable"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/docs/commands/auth/tune",children:"auth tune"})}),"\n",(0,s.jsx)(n.h2,{id:"enablingdisabling-audit-devices",children:"Enabling/Disabling audit devices"}),"\n",(0,s.jsxs)(n.p,{children:["When an OpenBao server is first initialized, no auditing is enabled. Audit\ndevices must be enabled by a root user using ",(0,s.jsx)(n.code,{children:"bao audit enable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"When enabling an audit device, options can be passed to it to configure it.\nFor example, the command below enables the file audit device:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ bao audit enable file file_path=/var/log/openbao_audit.log\n"})}),"\n",(0,s.jsx)(n.p,{children:'In the command above, we passed the "file_path" parameter to specify the path\nwhere the audit log will be written to. Each audit device has its own\nset of parameters. See the documentation to the left for more details.'}),"\n",(0,s.jsxs)(n.p,{children:["~> Note: Audit device configuration is replicated to all nodes within a cluster\nby default.  Before enabling an audit device, ensure that all nodes within the\ncluster(s) will be able to successfully log to the audit device to avoid OpenBao\nbeing blocked from serving requests.\nAn audit device can be limited to only within the node's cluster with the ",(0,s.jsx)(n.a,{href:"/api-docs/system/audit#local",children:(0,s.jsx)(n.code,{children:"local"})})," parameter."]}),"\n",(0,s.jsx)(n.p,{children:"When an audit device is disabled, it will stop receiving logs immediately.\nThe existing logs that it did store are untouched."}),"\n",(0,s.jsx)(n.p,{children:"~> Note: Once an audit device is disabled, you will no longer be able to HMAC values\nfor comparison with entries in the audit logs. This is true even if you re-enable\nthe audit device at the same path, as a new salt will be created for hashing."}),"\n",(0,s.jsx)(n.h2,{id:"blocked-audit-devices",children:"Blocked audit devices"}),"\n",(0,s.jsx)(n.p,{children:"Audit device logs are critically important and ignoring auditing failures opens an avenue for attack. OpenBao will not respond to requests when no enabled audit devices can record them."}),"\n",(0,s.jsx)(n.p,{children:"OpenBao can distinguish between two types of audit device failures."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A blocking failure is one where an attempt to write to the audit device never completes. This is unlikely with a local disk device, but could occure with a network-based audit device."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When multiple audit devices are enabled, if any of them fail in a non-blocking fashion, OpenBao requests can still complete successfully provided at least one audit device successfully writes the audit record. If any of the audit devices fail in a blocking fashion however, OpenBao requests will hang until the blocking is resolved."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In other words, OpenBao will not complete any requests until the blocked audit device can write."}),"\n",(0,s.jsx)(n.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,s.jsxs)(n.p,{children:["Refer to ",(0,s.jsx)(n.a,{href:"/tutorials/monitoring/blocked-audit-devices",children:"Blocked Audit Devices"})," for a step-by-step tutorial."]}),"\n",(0,s.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,s.jsxs)(n.p,{children:["Audit devices also have a full HTTP API. Please see the ",(0,s.jsx)(n.a,{href:"/api-docs/system/audit",children:"Audit device API\ndocs"})," for more details."]}),"\n",(0,s.jsx)(n.h2,{id:"common-configuration-options",children:"Common configuration options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"elide_list_responses"})," ",(0,s.jsx)(n.code,{children:"(bool: false)"})," - See ",(0,s.jsx)(n.a,{href:"/docs/audit#eliding-list-response-bodies",children:"Eliding list response\nbodies"})," below."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"format"})," ",(0,s.jsx)(n.code,{children:'(string: "json")'})," - Allows selecting the output format. Valid values\nare ",(0,s.jsx)(n.code,{children:'"json"'})," and ",(0,s.jsx)(n.code,{children:'"jsonx"'}),", which formats the normal log entries as XML."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hmac_accessor"})," ",(0,s.jsx)(n.code,{children:"(bool: true)"})," - If enabled, enables the hashing of token\naccessor."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"log_raw"})," ",(0,s.jsx)(n.code,{children:"(bool: false)"})," - If enabled, logs the security sensitive\ninformation without hashing, in the raw format."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"prefix"})," ",(0,s.jsx)(n.code,{children:'(string: "")'})," - A customizable string prefix to write before the\nactual log line."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"eliding-list-response-bodies",children:"Eliding list response bodies"}),"\n",(0,s.jsx)(n.p,{children:"Some OpenBao responses can be very large. Primarily, this affects list operations -\nas OpenBao lacks pagination in its APIs, listing a very large collection can result\nin a response that is tens of megabytes long. Some audit backends are unable to\nprocess individual audit records of larger sizes."}),"\n",(0,s.jsxs)(n.p,{children:['The contents of the response for a list operation is often not very interesting;\nmost contain only a "keys" field, containing a list of IDs. Select API endpoints\nadditionally return a "key_info" field, a map from ID to some additional\ninformation about the list entry - ',(0,s.jsx)(n.code,{children:"identity/entity/id/"})," is an example of this.\nEven in this case, the response to a list operation is usually less-confidential\nor public information, for which having the full response in the audit logs is of\nlesser importance."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"elide_list_responses"})," audit option provides the flexibility to not write the\nfull list response data from the audit log, to mitigate the creation of very long\nindividual audit records."]}),"\n",(0,s.jsxs)(n.p,{children:["When enabled, it affects only audit records of ",(0,s.jsx)(n.code,{children:"type=response"})," and\n",(0,s.jsx)(n.code,{children:"request.operation=list"}),". The values of ",(0,s.jsx)(n.code,{children:"response.data.keys"})," and\n",(0,s.jsx)(n.code,{children:"response.data.key_info"})," will be replaced with a simple integer, recording how\nmany entries were contained in the list (",(0,s.jsx)(n.code,{children:"keys"}),") or map (",(0,s.jsx)(n.code,{children:"key_info"}),") - therefore\neven with this feature enabled, it is still possible to see how many items were\nreturned by a list operation."]}),"\n",(0,s.jsxs)(n.p,{children:["This extra processing only affects the response data fields ",(0,s.jsx)(n.code,{children:"keys"})," and ",(0,s.jsx)(n.code,{children:"key_info"}),",\nand only when they have the expected data types - in the event a list response\ncontains data outside of the usual conventions that apply to OpenBao list responses,\nit will be left as is by this feature."]}),"\n",(0,s.jsx)(n.p,{children:"Here is an example of an audit record that has been processed by this feature\n(formatted with extra whitespace, and with fields not relevant to the example\nomitted):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": "response",\n  "request": {\n    "operation": "list"\n  },\n  "response": {\n    "data": {\n      "key_info": 4,\n      "keys": 4\n    }\n  }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(96540);const t={},a=s.createContext(t);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);