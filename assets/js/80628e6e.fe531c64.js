"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3977],{99401:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var s=t(74848),i=t(28453);const a={description:"An OpenBao must be unsealed before it can access its data. Likewise, it can be sealed to lock it down."},r="Seal/Unseal",o={id:"concepts/seal",title:"Seal/Unseal",description:"An OpenBao must be unsealed before it can access its data. Likewise, it can be sealed to lock it down.",source:"@site/content/docs/concepts/seal.mdx",sourceDirName:"concepts",slug:"/concepts/seal",permalink:"/openbao/docs/concepts/seal",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/concepts/seal.mdx",tags:[],version:"current",frontMatter:{description:"An OpenBao must be unsealed before it can access its data. Likewise, it can be sealed to lock it down."},sidebar:"docs",previous:{title:"'Dev' Server",permalink:"/openbao/docs/concepts/dev-server"},next:{title:"Lease, renew, and revoke",permalink:"/openbao/docs/concepts/lease"}},l={},h=[{value:"Why?",id:"why",level:2},{value:"Shamir seals",id:"shamir-seals",level:2},{value:"Unsealing",id:"unsealing",level:2},{value:"Sealing",id:"sealing",level:2},{value:"Auto unseal",id:"auto-unseal",level:2},{value:"Recovery key",id:"recovery-key",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Rekeying",id:"rekeying",level:3},{value:"Unseal key",id:"unseal-key",level:4},{value:"Recovery key",id:"recovery-key-1",level:4},{value:"Seal migration",id:"seal-migration",level:2},{value:"Migration steps",id:"migration-steps",level:3},{value:"Migration pre 1.5.1",id:"migration-pre-151",level:3},{value:"Migration from shamir to auto unseal",id:"migration-from-shamir-to-auto-unseal",level:4},{value:"Migration from auto unseal to shamir",id:"migration-from-auto-unseal-to-shamir",level:4},{value:"Migration from auto unseal to auto unseal",id:"migration-from-auto-unseal-to-auto-unseal",level:4},{value:"Migration with integrated storage",id:"migration-with-integrated-storage",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"sealunseal",children:"Seal/Unseal"}),"\n",(0,s.jsxs)(n.p,{children:["When an OpenBao server is started, it starts in a ",(0,s.jsx)(n.em,{children:"sealed"})," state. In this\nstate, OpenBao is configured to know where and how to access the physical\nstorage, but doesn't know how to decrypt any of it."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Unsealing"})," is the process of obtaining the plaintext root key necessary to\nread the decryption key to decrypt the data, allowing access to the OpenBao."]}),"\n",(0,s.jsx)(n.p,{children:"Prior to unsealing, almost no operations are possible with OpenBao. For\nexample authentication, managing the mount tables, etc. are all not possible.\nThe only possible operations are to unseal the OpenBao and check the status\nof the seal."}),"\n",(0,s.jsx)(n.h2,{id:"why",children:"Why?"}),"\n",(0,s.jsxs)(n.p,{children:["The data stored by OpenBao is encrypted. OpenBao needs the ",(0,s.jsx)(n.em,{children:"encryption key"})," in order\nto decrypt the data. The encryption key is also stored with the data\n(in the ",(0,s.jsx)(n.em,{children:"keyring"}),"), but encrypted with another encryption key known as the ",(0,s.jsx)(n.em,{children:"root key"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Therefore, to decrypt the data, OpenBao must decrypt the encryption key\nwhich requires the root key. Unsealing is the process of getting access to\nthis root key. The root key is stored alongside all other OpenBao data,\nbut is encrypted by yet another mechanism: the unseal key."}),"\n",(0,s.jsx)(n.p,{children:"To recap: most OpenBao data is encrypted using the encryption key in the keyring;\nthe keyring is encrypted by the root key; and the root key is encrypted by\nthe unseal key."}),"\n",(0,s.jsx)(n.h2,{id:"shamir-seals",children:"Shamir seals"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Shahir seals",src:t(6294).A+"",width:"666",height:"299"})}),"\n",(0,s.jsxs)(n.p,{children:["The default OpenBao config uses a Shamir seal. Instead of distributing the unseal\nkey as a single key to an operator, OpenBao uses an algorithm known as\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing",children:"Shamir's Secret Sharing"}),"\nto split the key into shares. A certain threshold of shares is required to\nreconstruct the unseal key, which is then used to decrypt the root key."]}),"\n",(0,s.jsxs)(n.p,{children:["This is the ",(0,s.jsx)(n.em,{children:"unseal"})," process: the shares are added one at a time (in any\norder) until enough shares are present to reconstruct the key and\ndecrypt the root key."]}),"\n",(0,s.jsx)(n.h2,{id:"unsealing",children:"Unsealing"}),"\n",(0,s.jsxs)(n.p,{children:["The unseal process is done by running ",(0,s.jsx)(n.code,{children:"bao operator unseal"})," or via the API.\nThis process is stateful: each key can be entered via multiple mechanisms from\nmultiple client machines and it will work. This allows each shares of the root\nkey to be on a distinct client machine for better security."]}),"\n",(0,s.jsx)(n.p,{children:"Note that when using the Shamir seal with multiple nodes, each node must be\nunsealed with the required threshold of shares. Partial unsealing of each node\nis not distributed across the cluster."}),"\n",(0,s.jsx)(n.p,{children:"Once an OpenBao node is unsealed, it remains unsealed until one of these things happens:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"It is resealed via the API (see below)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The server is restarted."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"OpenBao's storage layer encounters an unrecoverable error."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Note:"})," Unsealing makes the process of automating an OpenBao install\ndifficult. Automated tools can easily install, configure, and start OpenBao,\nbut unsealing it using Shamir is a very manual process. For most users\nAuto Unseal will provide a better experience."]}),"\n",(0,s.jsx)(n.h2,{id:"sealing",children:"Sealing"}),"\n",(0,s.jsx)(n.p,{children:"There is also an API to seal the OpenBao. This will throw away the root\nkey in memory and require another unseal process to restore it. Sealing\nonly requires a single operator with root privileges."}),"\n",(0,s.jsx)(n.p,{children:"This way, if there is a detected intrusion, the OpenBao data can be locked\nquickly to try to minimize damages. It can't be accessed again without\naccess to the root key shares."}),"\n",(0,s.jsx)(n.h2,{id:"auto-unseal",children:"Auto unseal"}),"\n",(0,s.jsx)(n.p,{children:"Auto Unseal was developed to aid in reducing the operational complexity of\nkeeping the unseal key secure. This feature delegates the responsibility of\nsecuring the unseal key from users to a trusted device or service. At startup\nOpenBao will connect to the device or service implementing the seal and ask it\nto decrypt the root key OpenBao read from storage."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Auto Unseal",src:t(4890).A+"",width:"625",height:"235"})}),"\n",(0,s.jsxs)(n.p,{children:["There are certain operations in OpenBao besides unsealing that\nrequire a quorum of users to perform, e.g. generating a root token. When\nusing a Shamir seal the unseal keys must be provided to authorize these\noperations. When using Auto Unseal these operations require ",(0,s.jsx)(n.em,{children:"recovery\nkeys"})," instead."]}),"\n",(0,s.jsx)(n.p,{children:"Just as the initialization process with a Shamir seal yields unseal keys,\ninitializing with an Auto Unseal yields recovery keys."}),"\n",(0,s.jsx)(n.p,{children:"It is still possible to seal an OpenBao node using the API. In this case OpenBao\nwill remain sealed until restarted, or the unseal API is used, which with Auto\nUnseal requires the recovery key fragments instead of the unseal key fragments\nthat would be provided with Shamir. The process remains the same."}),"\n",(0,s.jsxs)(n.p,{children:["For a list of examples and supported providers, please see the\n",(0,s.jsx)(n.a,{href:"/docs/configuration/seal",children:"seal documentation"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["-> ",(0,s.jsx)(n.strong,{children:"Warning:"})," Recovery keys cannot decrypt the root key, and thus are not\nsufficient to unseal OpenBao if the Auto Unseal mechanism isn't working. They\nare purely an authorization mechanism.  Using Auto Unseal\ncreates a strict OpenBao lifecycle dependency on the underlying seal mechanism.\nThis means that if the seal mechanism (such as the Cloud KMS key) becomes unavailable,\nor deleted before the seal is migrated, then there is no ability to recover\naccess to the OpenBao cluster until the mechanism is available again. ",(0,s.jsx)(n.strong,{children:"If the seal\nmechanism or its keys are permanently deleted, then the OpenBao cluster cannot be recovered, even\nfrom backups."}),"\nTo mitigate this risk, we recommend careful controls around management of the seal\nmechanism, for example using\n",(0,s.jsx)(n.a,{href:"https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_scps.html",children:"AWS Service Control Policies"}),"\nor similar."]}),"\n",(0,s.jsx)(n.h2,{id:"recovery-key",children:"Recovery key"}),"\n",(0,s.jsx)(n.p,{children:"When OpenBao is initialized while using an HSM or KMS, rather than unseal keys\nbeing returned to the operator, recovery keys are returned. These are generated\nfrom an internal recovery key that is split via Shamir's Secret Sharing, similar\nto OpenBao's treatment of unseal keys when running without an HSM or KMS."}),"\n",(0,s.jsxs)(n.p,{children:["Details about initialization and rekeying follow. When performing an operation\nthat uses recovery keys, such as ",(0,s.jsx)(n.code,{children:"generate-root"}),", selection of the recovery\nkeys for this purpose, rather than the barrier unseal keys, is automatic."]}),"\n",(0,s.jsx)(n.h3,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["When initializing, the split is performed according to the following CLI flags\nand their API equivalents in the ",(0,s.jsx)(n.a,{href:"/api-docs/system/init",children:"/sys/init"})," endpoint:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"recovery-shares"}),": The number of shares into which to split the recovery\nkey. This value is equivalent to the ",(0,s.jsx)(n.code,{children:"recovery_shares"})," value in the API\nendpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"recovery-threshold"}),": The threshold of shares required to reconstruct the\nrecovery key. This value is equivalent to the ",(0,s.jsx)(n.code,{children:"recovery_threshold"})," value in\nthe API endpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"recovery-pgp-keys"}),": The PGP keys to use to encrypt the returned recovery\nkey shares. This value is equivalent to the ",(0,s.jsx)(n.code,{children:"recovery_pgp_keys"})," value in the\nAPI endpoint, although as with ",(0,s.jsx)(n.code,{children:"pgp_keys"})," the object in the API endpoint is\nan array, not a string."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, OpenBao will refuse to initialize if the option has not been set to\ngenerate a key, and no key is found. See\n",(0,s.jsx)(n.a,{href:"/docs/configuration/seal/pkcs11",children:"Configuration"})," for more details."]}),"\n",(0,s.jsx)(n.h3,{id:"rekeying",children:"Rekeying"}),"\n",(0,s.jsx)(n.h4,{id:"unseal-key",children:"Unseal key"}),"\n",(0,s.jsxs)(n.p,{children:["OpenBao's unseal key can be rekeyed using a normal ",(0,s.jsx)(n.code,{children:"bao operator rekey"}),"\noperation from the CLI or the matching API calls. The rekey operation is\nauthorized by meeting the threshold of recovery keys. After rekeying, the new\nbarrier key is wrapped by the HSM or KMS and stored like the previous key; it is not\nreturned to the users that submitted their recovery keys."]}),"\n",(0,s.jsx)(n.h4,{id:"recovery-key-1",children:"Recovery key"}),"\n",(0,s.jsxs)(n.p,{children:["The recovery key can be rekeyed to change the number of shares/threshold or to\ntarget different key holders via different PGP keys. When using the OpenBao CLI,\nthis is performed by using the ",(0,s.jsx)(n.code,{children:"-target=recovery"})," flag to ",(0,s.jsx)(n.code,{children:"bao operator rekey"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Via the API, the rekey operation is performed with the same parameters as the\n",(0,s.jsxs)(n.a,{href:"/api-docs/system/rekey",children:["normal ",(0,s.jsx)(n.code,{children:"/sys/rekey"}),"\nendpoint"]}),"; however, the\nAPI prefix for this operation is at ",(0,s.jsx)(n.code,{children:"/sys/rekey-recovery-key"})," rather than\n",(0,s.jsx)(n.code,{children:"/sys/rekey"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"seal-migration",children:"Seal migration"}),"\n",(0,s.jsx)(n.p,{children:"The Seal migration process cannot be performed without downtime, and due to the\ntechnical underpinnings of the seal implementations, the process requires that\nyou briefly take the whole cluster down. While experiencing some downtime may\nbe unavoidable, we believe that switching seals is a rare event and that the\ninconvenience of the downtime is an acceptable trade-off."}),"\n",(0,s.jsxs)(n.p,{children:["~> ",(0,s.jsx)(n.strong,{children:"NOTE"}),": A backup should be taken before starting seal migration in case\nsomething goes wrong."]}),"\n",(0,s.jsxs)(n.p,{children:["~> ",(0,s.jsx)(n.strong,{children:"NOTE"}),": Seal migration operation will require both old and new seals to be\navailable during the migration. For example, migration from Auto Unseal to Shamir\nseal will require that the service backing the Auto Unseal is accessible during\nthe migration."]}),"\n",(0,s.jsxs)(n.p,{children:["~> ",(0,s.jsx)(n.strong,{children:"NOTE"}),": Seal migration from Auto Unseal to Auto Unseal of the same type is\nsupported in OpenBao. However, there is a current limitation that\nprevents migrating from AWSKMS to AWSKMS; all other seal migrations of the same\ntype are supported. Seal migration from One Auto Unseal type (AWS KMS) to\ndifferent Auto Unseal type (HSM, Azure KMS, etc.) is also supported on older\nversions as well."]}),"\n",(0,s.jsx)(n.h3,{id:"migration-steps",children:"Migration steps"}),"\n",(0,s.jsx)(n.p,{children:"These steps are common for seal migrations between any supported kinds and for\nany storage backend."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Take a standby node down and update the ",(0,s.jsx)(n.a,{href:"/docs/configuration/seal",children:"seal\nconfiguration"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the migration is from Shamir seal to Auto seal, add the desired new Auto\nseal block to the configuration."}),"\n",(0,s.jsxs)(n.li,{children:["If the migration is from Auto seal to Shamir seal, add ",(0,s.jsx)(n.code,{children:'disabled = "true"'}),"\nto the old seal block."]}),"\n",(0,s.jsxs)(n.li,{children:["If the migration is from Auto seal to another Auto seal, add ",(0,s.jsx)(n.code,{children:'disabled = "true"'})," to the old seal block and add the desired new Auto seal block."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Now, bring the standby node back up and run the unseal command on each key, by\nsupplying the ",(0,s.jsx)(n.code,{children:"-migrate"})," flag."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Supply Shamir unseal keys if the old seal was Shamir, which will be migrated\nas the recovery keys for the Auto seal."}),"\n",(0,s.jsx)(n.li,{children:"Supply recovery keys if the old seal is one of Auto seals, which will be\nmigrated as the recovery keys of the new Auto seal, or as Shamir unseal\nkeys if the new seal is Shamir."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Perform step 1 for all the standby nodes, one at a time. It is necessary to\nbring back the downed standby node before moving on to the other standby nodes,\nspecifically when Integrated Storage is in use for it helps to retain the\nquorum."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/docs/commands/operator/step-down",children:"Step down"})," the\nactive node. One of the standby nodes will become the new active node.\nWhen using Integrated Storage, ensure that quorum is reached and a leader is\nelected."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The new active node will perform the migration. Monitor the server log in\nthe active node to witness the completion of the seal migration process.\nWait for a little while for the migration information to replicate to all the\nnodes in case of Integrated Storage."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Seal migration is now completed. Take down the old active node, update its\nconfiguration to use the new seal blocks (completely unaware of the old seal type)\n,and bring it back up. It will be auto-unsealed if the new seal is one of the\nAuto seals, or will require unseal keys if the new seal is Shamir."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"At this point, configuration files of all the nodes can be updated to only have the\nnew seal information. Standby nodes can be restarted right away and the active\nnode can be restarted upon a leadership change."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"migration-pre-151",children:"Migration pre 1.5.1"}),"\n",(0,s.jsx)(n.h4,{id:"migration-from-shamir-to-auto-unseal",children:"Migration from shamir to auto unseal"}),"\n",(0,s.jsxs)(n.p,{children:["To migrate from Shamir keys to Auto Unseal, take your server cluster offline and\nupdate the ",(0,s.jsx)(n.a,{href:"/docs/configuration/seal",children:"seal configuration"})," with the appropriate\nseal configuration. Bring your server back up and leave the rest of the nodes\noffline if using multi-server mode, then run the unseal process with the\n",(0,s.jsx)(n.code,{children:"-migrate"})," flag and bring the rest of the cluster online."]}),"\n",(0,s.jsxs)(n.p,{children:["All unseal commands must specify the ",(0,s.jsx)(n.code,{children:"-migrate"})," flag. Once the required\nthreshold of unseal keys are entered, unseal keys will be migrated to recovery\nkeys."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"$ bao operator unseal -migrate"})}),"\n",(0,s.jsx)(n.h4,{id:"migration-from-auto-unseal-to-shamir",children:"Migration from auto unseal to shamir"}),"\n",(0,s.jsxs)(n.p,{children:["To migrate from Auto Unseal to Shamir keys, take your server cluster offline\nand update the ",(0,s.jsx)(n.a,{href:"/docs/configuration/seal",children:"seal configuration"})," and add ",(0,s.jsx)(n.code,{children:'disabled = "true"'})," to the seal block. This allows the migration to use this information\nto decrypt the key but will not unseal OpenBao. When you bring your server back\nup, run the unseal process with the ",(0,s.jsx)(n.code,{children:"-migrate"})," flag and use the Recovery Keys\nto perform the migration. All unseal commands must specify the ",(0,s.jsx)(n.code,{children:"-migrate"})," flag.\nOnce the required threshold of recovery keys are entered, the recovery keys\nwill be migrated to be used as unseal keys."]}),"\n",(0,s.jsx)(n.h4,{id:"migration-from-auto-unseal-to-auto-unseal",children:"Migration from auto unseal to auto unseal"}),"\n",(0,s.jsxs)(n.p,{children:["To migrate from Auto Unseal to a different Auto Unseal configuration, take your\nserver cluster offline and update the existing ",(0,s.jsx)(n.a,{href:"/docs/configuration/seal",children:"seal\nconfiguration"})," and add ",(0,s.jsx)(n.code,{children:'disabled = "true"'})," to the seal\nblock. Then add another seal block to describe the new seal."]}),"\n",(0,s.jsxs)(n.p,{children:["When you bring your server back up, run the unseal process with the ",(0,s.jsx)(n.code,{children:"-migrate"}),"\nflag and use the Recovery Keys to perform the migration. All unseal commands\nmust specify the ",(0,s.jsx)(n.code,{children:"-migrate"})," flag. Once the required threshold of recovery keys\nare entered, the recovery keys will be kept and used as recovery keys in the new\nseal."]}),"\n",(0,s.jsx)(n.h4,{id:"migration-with-integrated-storage",children:"Migration with integrated storage"}),"\n",(0,s.jsx)(n.p,{children:"Integrated Storage uses the Raft protocol underneath, which requires a quorum of\nservers to be online before the cluster is functional. Therefore, bringing the\ncluster back up one node at a time with the seal configuration updated, will not\nwork in this case. Follow the same steps for each kind of migration described\nabove with the exception that after the cluster is taken offline, update the\nseal configurations of all the nodes appropriately and bring them all back up.\nWhen the quorum of nodes are back up, Raft will elect a leader and the leader\nnode that will perform the migration. The migrated information will be replicated to\nall other cluster peers and when the peers eventually become the leader,\nmigration will not happen again on the peer nodes."})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},4890:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/vault-auto-unseal-be18e6bd9650dc15413a0812d025cda4.png"},6294:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/vault-shamir-seal-9ba848ed9f348e03b004fc0cd92af233.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);