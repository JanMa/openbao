"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8455],{19581:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var t=s(74848),a=s(28453);const l={description:"Vault can run directly on Kubernetes in various configurations.  For pure-Kubernetes workloads, this enables Vault to also exist purely within Kubernetes."},r="Run Vault on kubernetes",i={id:"platform/k8s/helm/run",title:"Run Vault on kubernetes",description:"Vault can run directly on Kubernetes in various configurations.  For pure-Kubernetes workloads, this enables Vault to also exist purely within Kubernetes.",source:"@site/content/docs/platform/k8s/helm/run.mdx",sourceDirName:"platform/k8s/helm",slug:"/platform/k8s/helm/run",permalink:"/openbao/docs/platform/k8s/helm/run",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/platform/k8s/helm/run.mdx",tags:[],version:"current",frontMatter:{description:"Vault can run directly on Kubernetes in various configurations.  For pure-Kubernetes workloads, this enables Vault to also exist purely within Kubernetes."},sidebar:"docs",previous:{title:"Overview",permalink:"/openbao/docs/platform/k8s/helm/"},next:{title:"Run Vault on OpenShift",permalink:"/openbao/docs/platform/k8s/helm/openshift"}},o={},d=[{value:"Helm chart",id:"helm-chart",level:2},{value:"How-To",id:"how-to",level:2},{value:"Install Vault",id:"install-vault",level:3},{value:"Dev mode",id:"dev-mode",level:4},{value:"Standalone mode",id:"standalone-mode",level:4},{value:"HA mode",id:"ha-mode",level:4},{value:"External mode",id:"external-mode",level:4},{value:"View the Vault UI",id:"view-the-vault-ui",level:3},{value:"Initialize and unseal Vault",id:"initialize-and-unseal-vault",level:3},{value:"CLI initialize and unseal",id:"cli-initialize-and-unseal",level:4},{value:"Google KMS auto unseal",id:"google-kms-auto-unseal",level:4},{value:"Create the secret",id:"create-the-secret",level:5},{value:"Config example",id:"config-example",level:5},{value:"Amazon KMS auto unseal",id:"amazon-kms-auto-unseal",level:4},{value:"Create the secret",id:"create-the-secret-1",level:5},{value:"Config example",id:"config-example-1",level:5},{value:"Probes",id:"probes",level:3},{value:"Upgrading Vault on kubernetes",id:"upgrading-vault-on-kubernetes",level:3},{value:"Upgrading Vault servers",id:"upgrading-vault-servers",level:4},{value:"Protecting sensitive Vault configurations",id:"protecting-sensitive-vault-configurations",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Production deployment checklist",id:"production-deployment-checklist",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"run-vault-on-kubernetes",children:"Run Vault on kubernetes"}),"\n",(0,t.jsxs)(n.p,{children:["Vault works with Kubernetes in various modes: ",(0,t.jsx)(n.code,{children:"dev"}),", ",(0,t.jsx)(n.code,{children:"standalone"}),", ",(0,t.jsx)(n.code,{children:"ha"}),",\nand ",(0,t.jsx)(n.code,{children:"external"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["~> ",(0,t.jsx)(n.strong,{children:"Important Note:"})," This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart."]}),"\n",(0,t.jsx)(n.h2,{id:"helm-chart",children:"Helm chart"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://github.com/hashicorp/vault-helm",children:"Vault Helm chart"}),"\nis the recommended way to install and configure Vault on Kubernetes.\nIn addition to running Vault itself, the Helm chart is the primary\nmethod for installing and configuring Vault to integrate with other\nservices such as Consul for High Availability (HA) deployments."]}),"\n",(0,t.jsxs)(n.p,{children:["While the Helm chart automatically sets up complex resources and exposes the\nconfiguration to meet your requirements, it ",(0,t.jsx)(n.strong,{children:"does not automatically operate\nVault."})," You are still responsible for learning how to monitor, backup, upgrade,\netc. the Vault cluster."]}),"\n",(0,t.jsxs)(n.p,{children:["~> ",(0,t.jsx)(n.strong,{children:"Security Warning:"})," By default, the chart runs in standalone mode. This\nmode uses a single Vault server with a file storage backend. This is a less\nsecure and less resilient installation that is ",(0,t.jsx)(n.strong,{children:"NOT"})," appropriate for a\nproduction setup. It is highly recommended to use a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/",children:"properly secured Kubernetes\ncluster"}),",\n",(0,t.jsx)(n.a,{href:"/docs/platform/k8s/helm/configuration",children:"learn the available configuration\noptions"}),", and read the ",(0,t.jsx)(n.a,{href:"/docs/platform/k8s/helm/run#architecture",children:"production deployment\nchecklist"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to",children:"How-To"}),"\n",(0,t.jsx)(n.h3,{id:"install-vault",children:"Install Vault"}),"\n",(0,t.jsxs)(n.p,{children:["Helm must be installed and configured on your machine. Please refer to the ",(0,t.jsx)(n.a,{href:"https://helm.sh/",children:"Helm\ndocumentation"})," or the ",(0,t.jsx)(n.a,{href:"/tutorials/kubernetes/kubernetes-minikube-consul",children:"Vault Installation to Minikube via\nHelm"})," tutorial."]}),"\n",(0,t.jsx)(n.p,{children:"To use the Helm chart, add the Hashicorp helm repository and check that you have\naccess to the chart:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ helm repo add hashicorp https://helm.releases.hashicorp.com\n"hashicorp" has been added to your repositories\n\n$ helm search repo hashicorp/vault\nNAME           \tCHART VERSION\tAPP VERSION\tDESCRIPTION\nhashicorp/vault\t0.25.0       \t1.14.0     \tOfficial HashiCorp Vault Chart\n'})}),"\n",(0,t.jsxs)(n.p,{children:["-> ",(0,t.jsx)(n.strong,{children:"Important:"})," The Helm chart is new and under significant development.\nPlease always run Helm with ",(0,t.jsx)(n.code,{children:"--dry-run"})," before any install or upgrade to verify\nchanges."]}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"helm install"})," to install the latest release of the Vault Helm chart."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ helm install vault hashicorp/vault\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or install a specific version of the chart."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"# List the available releases\n$ helm search repo hashicorp/vault -l\nNAME           \tCHART VERSION\tAPP VERSION\tDESCRIPTION\nhashicorp/vault\t0.25.0       \t1.14.0     \tOfficial HashiCorp Vault Chart\nhashicorp/vault\t0.24.0       \t1.13.1     \tOfficial HashiCorp Vault Chart\nhashicorp/vault\t0.23.0       \t1.12.1     \tOfficial HashiCorp Vault Chart\nhashicorp/vault\t0.22.1       \t1.12.0     \tOfficial HashiCorp Vault Chart\nhashicorp/vault\t0.22.0       \t1.11.3     \tOfficial HashiCorp Vault Chart\nhashicorp/vault\t0.21.0       \t1.11.2     \tOfficial HashiCorp Vault Chart\nhashicorp/vault\t0.20.1       \t1.10.3     \tOfficial HashiCorp Vault Chart\n...\n\n# Install version 0.25.0\n$ helm install vault hashicorp/vault --version 0.25.0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"helm install"})," command accepts parameters to override default configuration\nvalues inline or defined in a file."]}),"\n",(0,t.jsxs)(n.p,{children:["Override the ",(0,t.jsx)(n.code,{children:"server.dev.enabled"})," configuration value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ helm install vault hashicorp/vault \\\n    --set "server.dev.enabled=true"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Override all the configuration found in a file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ cat override-values.yml\nserver:\n  ha:\n    enabled: true\n    replicas: 5\n##\n$ helm install vault hashicorp/vault \\\n    --values override-values.yml\n"})}),"\n",(0,t.jsx)(n.h4,{id:"dev-mode",children:"Dev mode"}),"\n",(0,t.jsx)(n.p,{children:"The Helm chart may run a Vault server in development. This installs a single\nVault server with a memory storage backend."}),"\n",(0,t.jsxs)(n.p,{children:["-> ",(0,t.jsx)(n.strong,{children:"Dev mode:"})," This is ideal for learning and demonstration environments but\nNOT recommended for a production environment."]}),"\n",(0,t.jsx)(n.p,{children:"Install the latest Vault Helm chart in development mode."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ helm install vault hashicorp/vault \\\n    --set "server.dev.enabled=true"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"standalone-mode",children:"Standalone mode"}),"\n",(0,t.jsxs)(n.p,{children:["The Helm chart defaults to run in ",(0,t.jsx)(n.code,{children:"standalone"})," mode. This installs a single\nVault server with a file storage backend."]}),"\n",(0,t.jsx)(n.p,{children:"Install the latest Vault Helm chart in standalone mode."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ helm install vault hashicorp/vault\n"})}),"\n",(0,t.jsx)(n.h4,{id:"ha-mode",children:"HA mode"}),"\n",(0,t.jsxs)(n.p,{children:["The Helm chart may be run in high availability (HA) mode. This installs three\nVault servers with an existing Consul storage backend. It is suggested that\nConsul is installed via the ",(0,t.jsx)(n.a,{href:"https://github.com/hashicorp/consul-helm",children:"Consul Helm\nchart"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Install the latest Vault Helm chart in HA mode."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ helm install vault hashicorp/vault \\\n    --set "server.ha.enabled=true"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Refer to the ",(0,t.jsx)(n.a,{href:"/tutorials/kubernetes/kubernetes-minikube-consul",children:"Vault Installation to Minikube via\nHelm"})," tutorial\nto learn how to set up Consul and Vault in HA mode."]}),"\n",(0,t.jsx)(n.h4,{id:"external-mode",children:"External mode"}),"\n",(0,t.jsx)(n.p,{children:"The Helm chart may be run in external mode. This installs no Vault server and\nrelies on a network addressable Vault server to exist."}),"\n",(0,t.jsx)(n.p,{children:"Install the latest Vault Helm chart in external mode."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ helm install vault hashicorp/vault \\\n    --set "injector.externalVaultAddr=http://external-vault:8200"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Refer to the ",(0,t.jsx)(n.a,{href:"/tutorials/kubernetes/kubernetes-external-vault",children:"Integrate a Kubernetes Cluster with an\nExternal Vault"}),"\ntutorial to learn how to use an external Vault within a Kubernetes cluster."]}),"\n",(0,t.jsx)(n.h3,{id:"view-the-vault-ui",children:"View the Vault UI"}),"\n",(0,t.jsxs)(n.p,{children:["The Vault UI is enabled but NOT exposed as service for security reasons. The\nVault UI can also be exposed via port-forwarding or through a ",(0,t.jsxs)(n.a,{href:"/docs/platform/k8s/helm/configuration/#ui",children:[(0,t.jsx)(n.code,{children:"ui"}),"\nconfiguration value"]}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Expose the Vault UI with port-forwarding:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl port-forward vault-0 8200:8200\nForwarding from 127.0.0.1:8200 -> 8200\nForwarding from [::1]:8200 -> 8200\n##...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"initialize-and-unseal-vault",children:"Initialize and unseal Vault"}),"\n",(0,t.jsxs)(n.p,{children:["After the Vault Helm chart is installed in ",(0,t.jsx)(n.code,{children:"standalone"})," or ",(0,t.jsx)(n.code,{children:"ha"})," mode one of the\nVault servers need to be\n",(0,t.jsx)(n.a,{href:"/docs/commands/operator/init",children:"initialized"}),". The\ninitialization generates the credentials necessary to\n",(0,t.jsx)(n.a,{href:"/docs/concepts/seal#why",children:"unseal"})," all the Vault\nservers."]}),"\n",(0,t.jsx)(n.h4,{id:"cli-initialize-and-unseal",children:"CLI initialize and unseal"}),"\n",(0,t.jsx)(n.p,{children:"View all the Vault pods in the current namespace:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl get pods -l app.kubernetes.io/name=vault\nNAME                                    READY   STATUS    RESTARTS   AGE\nvault-0                                 0/1     Running   0          1m49s\nvault-1                                 0/1     Running   0          1m49s\nvault-2                                 0/1     Running   0          1m49s\n"})}),"\n",(0,t.jsx)(n.p,{children:"Initialize one Vault server with the default number of key shares and default\nkey threshold:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl exec -ti vault-0 -- vault operator init\nUnseal Key 1: MBFSDepD9E6whREc6Dj+k3pMaKJ6cCnCUWcySJQymObb\nUnseal Key 2: zQj4v22k9ixegS+94HJwmIaWLBL3nZHe1i+b/wHz25fr\nUnseal Key 3: 7dbPPeeGGW3SmeBFFo04peCKkXFuuyKc8b2DuntA4VU5\nUnseal Key 4: tLt+ME7Z7hYUATfWnuQdfCEgnKA2L173dptAwfmenCdf\nUnseal Key 5: vYt9bxLr0+OzJ8m7c7cNMFj7nvdLljj0xWRbpLezFAI9\n\nInitial Root Token: s.zJNwZlRrqISjyBHFMiEca6GF\n##...\n"})}),"\n",(0,t.jsx)(n.p,{children:"The output displays the key shares and initial root key generated."}),"\n",(0,t.jsx)(n.p,{children:"Unseal the Vault server with the key shares until the key threshold is met:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"## Unseal the first vault server until it reaches the key threshold\n$ kubectl exec -ti vault-0 -- vault operator unseal # ... Unseal Key 1\n$ kubectl exec -ti vault-0 -- vault operator unseal # ... Unseal Key 2\n$ kubectl exec -ti vault-0 -- vault operator unseal # ... Unseal Key 3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Repeat the unseal process for all Vault server pods. When all Vault server pods\nare unsealed they report READY ",(0,t.jsx)(n.code,{children:"1/1"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl get pods -l app.kubernetes.io/name=vault\nNAME                                    READY   STATUS    RESTARTS   AGE\nvault-0                                 1/1     Running   0          1m49s\nvault-1                                 1/1     Running   0          1m49s\nvault-2                                 1/1     Running   0          1m49s\n"})}),"\n",(0,t.jsx)(n.h4,{id:"google-kms-auto-unseal",children:"Google KMS auto unseal"}),"\n",(0,t.jsxs)(n.p,{children:["The Helm chart may be run with ",(0,t.jsx)(n.a,{href:"/docs/configuration/seal/gcpckms",children:"Google KMS for Auto\nUnseal"}),". This enables Vault server pods to\nauto unseal if they are rescheduled."]}),"\n",(0,t.jsxs)(n.p,{children:["Vault Helm requires the Google Cloud KMS credentials stored in\n",(0,t.jsx)(n.code,{children:"credentials.json"})," and mounted as a secret in each Vault server pod."]}),"\n",(0,t.jsx)(n.h5,{id:"create-the-secret",children:"Create the secret"}),"\n",(0,t.jsx)(n.p,{children:"First, create the secret in Kubernetes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl create secret generic kms-creds --from-file=credentials.json\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Vault Helm mounts this to ",(0,t.jsx)(n.code,{children:"/vault/userconfig/kms-creds/credentials.json"}),"."]}),"\n",(0,t.jsx)(n.h5,{id:"config-example",children:"Config example"}),"\n",(0,t.jsx)(n.p,{children:"This is a Vault Helm configuration that uses Google KMS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'global:\n  enabled: true\n\nserver:\n  extraEnvironmentVars:\n    GOOGLE_REGION: global\n    GOOGLE_PROJECT: <PROJECT NAME>\n    GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/kms-creds/credentials.json\n\n  volumes:\n    - name: userconfig-kms-creds\n      secret:\n        defaultMode: 420\n        secretName: kms-creds\n\n  volumeMounts:\n    - mountPath: /vault/userconfig/kms-creds\n      name: userconfig-kms-creds\n      readOnly: true\n\n  ha:\n    enabled: true\n    replicas: 3\n\n    config: |\n      ui = true\n\n      listener "tcp" {\n        tls_disable = 1\n        address = "[::]:8200"\n        cluster_address = "[::]:8201"\n      }\n\n      seal "gcpckms" {\n        project     = "<NAME OF PROJECT>"\n        region      = "global"\n        key_ring    = "<NAME OF KEYRING>"\n        crypto_key  = "<NAME OF KEY>"\n      }\n\n      storage "consul" {\n        path = "vault"\n        address = "HOST_IP:8500"\n      }\n'})}),"\n",(0,t.jsx)(n.h4,{id:"amazon-kms-auto-unseal",children:"Amazon KMS auto unseal"}),"\n",(0,t.jsxs)(n.p,{children:["The Helm chart may be run with ",(0,t.jsx)(n.a,{href:"/docs/configuration/seal/awskms",children:"AWS KMS for Auto\nUnseal"}),". This enables Vault server pods to auto\nunseal if they are rescheduled."]}),"\n",(0,t.jsx)(n.p,{children:"Vault Helm requires the AWS credentials stored as environment variables that\nare defined in each Vault server pod."}),"\n",(0,t.jsx)(n.h5,{id:"create-the-secret-1",children:"Create the secret"}),"\n",(0,t.jsx)(n.p,{children:"First, create a secret with your KMS access key/secret:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ kubectl create secret generic kms-creds \\\n    --from-literal=AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID?}" \\\n    --from-literal=AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY?}"\n'})}),"\n",(0,t.jsx)(n.h5,{id:"config-example-1",children:"Config example"}),"\n",(0,t.jsx)(n.p,{children:"This is a Vault Helm configuration that uses AWS KMS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'global:\n  enabled: true\n\nserver:\n  extraSecretEnvironmentVars:\n    - envName: AWS_ACCESS_KEY_ID\n      secretName: kms-creds\n      secretKey: AWS_ACCESS_KEY_ID\n    - envName: AWS_SECRET_ACCESS_KEY\n      secretName: kms-creds\n      secretKey: AWS_SECRET_ACCESS_KEY\n\n  ha:\n    enabled: true\n    config: |\n      ui = true\n\n      listener "tcp" {\n        tls_disable = 1\n        address = "[::]:8200"\n        cluster_address = "[::]:8201"\n      }\n\n      seal "awskms" {\n        region     = "KMS_REGION_HERE"\n        kms_key_id = "KMS_KEY_ID_HERE"\n      }\n\n      storage "consul" {\n        address = "HOST_IP:8500"\n        path = "vault/"\n      }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"probes",children:"Probes"}),"\n",(0,t.jsx)(n.p,{children:"Probes are essential for detecting failures, rescheduling and using pods in\nKubernetes. The helm chart offers configurable readiness and liveliness probes\nwhich can be customized for a variety of use cases."}),"\n",(0,t.jsxs)(n.p,{children:["Vault's ",(0,t.jsx)(n.a,{href:"/api-docs/system/health",children:"/sys/health`"})," endpoint can be customized to\nchange the behavior of the health check. For example, we can change the Vault\nreadiness probe to show the Vault pods are ready even if they're still uninitialized\nand sealed using the following probe:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"server:\n  readinessProbe:\n    enabled: true\n    path: '/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Using this customized probe, a ",(0,t.jsx)(n.code,{children:"postStart"})," script could automatically run once the\npod is ready for additional setup."]}),"\n",(0,t.jsx)(n.h3,{id:"upgrading-vault-on-kubernetes",children:"Upgrading Vault on kubernetes"}),"\n",(0,t.jsxs)(n.p,{children:["To upgrade Vault on Kubernetes, we follow the same pattern as\n",(0,t.jsx)(n.a,{href:"/docs/upgrading",children:"generally upgrading Vault"}),", except we can use\nthe Helm chart to update the Vault server StatefulSet. It is important to understand\nhow to ",(0,t.jsx)(n.a,{href:"/docs/upgrading",children:"generally upgrade Vault"})," before reading this\nsection."]}),"\n",(0,t.jsxs)(n.p,{children:["The Vault StatefulSet uses ",(0,t.jsx)(n.code,{children:"OnDelete"})," update strategy. It is critical to use ",(0,t.jsx)(n.code,{children:"OnDelete"})," instead\nof ",(0,t.jsx)(n.code,{children:"RollingUpdate"})," because standbys must be updated before the active primary. A\nfailover to an older version of Vault must always be avoided."]}),"\n",(0,t.jsxs)(n.p,{children:["!> ",(0,t.jsx)(n.strong,{children:"IMPORTANT NOTE:"})," Always back up your data before upgrading! Vault does not\nmake backward-compatibility guarantees for its data store. Simply replacing the\nnewly-installed Vault binary with the previous version may not cleanly\ndowngrade Vault, as upgrades may perform changes to the underlying data\nstructure that make the data incompatible with a downgrade. If you need to roll\nback to a previous version of Vault, you should roll back your data store as\nwell."]}),"\n",(0,t.jsx)(n.h4,{id:"upgrading-vault-servers",children:"Upgrading Vault servers"}),"\n",(0,t.jsxs)(n.p,{children:["!> ",(0,t.jsx)(n.strong,{children:"IMPORTANT NOTE:"})," Helm will install the latest chart found in a repo by default.\nIt's recommended to specify the chart version when upgrading."]}),"\n",(0,t.jsxs)(n.p,{children:["To initiate the upgrade, set the ",(0,t.jsx)(n.code,{children:"server.image"})," values to the desired Vault\nversion, either in a values yaml file or on the command line. For illustrative\npurposes, the example below uses ",(0,t.jsx)(n.code,{children:"vault:123.456"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"server:\n  image:\n    repository: 'vault'\n    tag: '123.456'\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next, list the Helm versions and choose the desired version to install."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ helm search repo hashicorp/vault\nNAME           \tCHART VERSION\tAPP VERSION\tDESCRIPTION\nhashicorp/vault\t0.25.0       \t1.14.0     \tOfficial HashiCorp Vault Chart\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Next, test the upgrade with ",(0,t.jsx)(n.code,{children:"--dry-run"})," first to verify the changes sent to the\nKubernetes cluster."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ helm upgrade vault hashicorp/vault --version=0.25.0 \\\n    --set='server.image.repository=vault' \\\n    --set='server.image.tag=123.456' \\\n    --dry-run\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This should cause no changes (although the resources are updated). If\neverything is stable, ",(0,t.jsx)(n.code,{children:"helm upgrade"})," can be run."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"helm upgrade"})," command should have updated the StatefulSet template for\nthe Vault servers, however, no pods have been deleted. The pods must be manually\ndeleted to upgrade. Deleting the pods does not delete any persisted data."]}),"\n",(0,t.jsxs)(n.p,{children:["If Vault is not deployed using ",(0,t.jsx)(n.code,{children:"ha"})," mode, the single Vault server may be deleted by\nrunning:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl delete pod <name of Vault pod>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If Vault is deployed using ",(0,t.jsx)(n.code,{children:"ha"})," mode, the standby pods must be upgraded first.\nVault has K8s service discovery built in (when enabled in the server configuration) and\nwill automatically change the labels of the pod with its current leader status. These labels\ncan be used to filter the pods."]}),"\n",(0,t.jsx)(n.p,{children:"For example, select all pods that are Vault standbys:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl get pods -l vault-active=false\n"})}),"\n",(0,t.jsx)(n.p,{children:"Select the active Vault pod:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl get pods -l vault-active=true\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next, sequentially delete every pod that is not the active primary, ensuring the quorum is maintained at all times:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl delete pod <name of Vault pod>\n"})}),"\n",(0,t.jsx)(n.p,{children:"If auto-unseal is not being used, the newly scheduled Vault standby pods needs\nto be unsealed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl exec -ti <name of pod> -- vault operator unseal\n"})}),"\n",(0,t.jsx)(n.p,{children:"Finally, once the standby nodes have been updated and unsealed, delete the active\nprimary:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl delete pod <name of Vault primary>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Similar to the standby nodes, the former primary also needs to be unsealed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl exec -ti <name of pod> -- vault operator unseal\n"})}),"\n",(0,t.jsx)(n.p,{children:"After a few moments the Vault cluster should elect a new active primary. The Vault\ncluster is now upgraded!"}),"\n",(0,t.jsx)(n.h3,{id:"protecting-sensitive-vault-configurations",children:"Protecting sensitive Vault configurations"}),"\n",(0,t.jsx)(n.p,{children:"Vault Helm renders a Vault configuration file during installation and stores the\nfile in a Kubernetes configmap. Some configurations require sensitive data to be\nincluded in the configuration file and would not be encrypted at rest once created\nin Kubernetes."}),"\n",(0,t.jsx)(n.p,{children:"The following example shows how to add extra configuration files to Vault Helm\nto protect sensitive configurations from being in plaintext at rest using Kubernetes\nsecrets."}),"\n",(0,t.jsx)(n.p,{children:"First, create a partial Vault configuration with the sensitive settings Vault\nloads during startup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:'$ cat <<EOF >>config.hcl\nstorage "mysql" {\nusername = "user1234"\npassword = "secret123!"\ndatabase = "vault"\n}\nEOF\n'})}),"\n",(0,t.jsx)(n.p,{children:"Next, create a Kubernetes secret containing this partial configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl create secret generic vault-storage-config \\\n    --from-file=config.hcl\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Finally, mount this secret as an extra volume and add an additional ",(0,t.jsx)(n.code,{children:"-config"})," flag\nto the Vault startup command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell-session",children:"$ helm install vault hashicorp/vault \\\n  --set='server.volumes[0].name=userconfig-vault-storage-config' \\\n  --set='server.volumes[0].secret.defaultMode=420' \\\n  --set='server.volumes[0].secret.secretName=vault-storage-config' \\\n  --set='server.volumeMounts[0].mountPath=/vault/userconfig/vault-storage-config' \\\n  --set='server.volumeMounts[0].name=userconfig-vault-storage-config' \\\n  --set='server.volumeMounts[0].readOnly=true' \\\n  --set='server.extraArgs=-config=/vault/userconfig/vault-storage-config/config.hcl'\n"})}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsxs)(n.p,{children:["We recommend running Vault on Kubernetes with the same\n",(0,t.jsx)(n.a,{href:"/docs/internals/architecture",children:"general architecture"}),"\nas running it anywhere else. There are some benefits Kubernetes can provide\nthat eases operating a Vault cluster and we document those below. The standard\n",(0,t.jsx)(n.a,{href:"/tutorials/operations/production-hardening",children:"production deployment"})," tutorial is still an\nimportant read even if running Vault within Kubernetes."]}),"\n",(0,t.jsx)(n.h3,{id:"production-deployment-checklist",children:"Production deployment checklist"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"End-to-End TLS."})," Vault should always be used with TLS in production. If\nintermediate load balancers or reverse proxies are used to front Vault,\nthey should not terminate TLS. This way traffic is always encrypted in transit\nto Vault and minimizes risks introduced by intermediate layers. See the\n",(0,t.jsx)(n.a,{href:"/docs/platform/k8s/helm/examples/standalone-tls/",children:"official documentation"}),"\nfor example on configuring Vault Helm to use TLS."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Single Tenancy."})," Vault should be the only main process running on a machine.\nThis reduces the risk that another process running on the same machine is\ncompromised and can interact with Vault. This can be accomplished by using Vault\nHelm's ",(0,t.jsx)(n.code,{children:"affinity"})," configurable. See the\n",(0,t.jsx)(n.a,{href:"/docs/platform/k8s/helm/examples/ha-with-consul/",children:"official documentation"}),"\nfor example on configuring Vault Helm to use affinity rules."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Enable Auditing."})," Vault supports several auditing backends. Enabling auditing\nprovides a history of all operations performed by Vault and provides a forensics\ntrail in the case of misuse or compromise. Audit logs securely hash any sensitive\ndata, but access should still be restricted to prevent any unintended disclosures.\nVault Helm includes a configurable ",(0,t.jsx)(n.code,{children:"auditStorage"})," option that provisions a persistent\nvolume to store audit logs. See the\n",(0,t.jsx)(n.a,{href:"/docs/platform/k8s/helm/examples/standalone-audit/",children:"official documentation"}),"\nfor an example on configuring Vault Helm to use auditing."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Immutable Upgrades."})," Vault relies on an external storage backend for persistence,\nand this decoupling allows the servers running Vault to be managed immutably.\nWhen upgrading to new versions, new servers with the upgraded version of Vault\nare brought online. They are attached to the same shared storage backend and\nunsealed. Then the old servers are destroyed. This reduces the need for remote\naccess and upgrade orchestration which may introduce security gaps. See the\n",(0,t.jsx)(n.a,{href:"#how-to",children:"upgrade section"})," for instructions\non upgrading Vault on Kubernetes."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Upgrade Frequently."})," Vault is actively developed, and updating frequently is\nimportant to incorporate security fixes and any changes in default settings such\nas key lengths or cipher suites. Subscribe to the Vault mailing list and\nGitHub CHANGELOG for updates."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Restrict Storage Access."})," Vault encrypts all data at rest, regardless of which\nstorage backend is used. Although the data is encrypted, an attacker with arbitrary\ncontrol can cause data corruption or loss by modifying or deleting keys. Access\nto the storage backend should be restricted to only Vault to avoid unauthorized\naccess or operations."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>i});var t=s(96540);const a={},l=t.createContext(a);function r(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);