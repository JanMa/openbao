"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7913],{84965:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var t=i(74848),a=i(28453);const o={layout:"docs",page_title:"OpenBao Migration Policy",sidebar_title:"Migration Policy",description:"The OpenBao policy around migration from upstream to OpenBao."},s="Migration policy",r={id:"policies/migration",title:"Migration policy",description:"The OpenBao policy around migration from upstream to OpenBao.",source:"@site/content/docs/policies/migration.mdx",sourceDirName:"policies",slug:"/policies/migration",permalink:"/openbao/docs/policies/migration",draft:!1,unlisted:!1,editUrl:"https://github.com/openbao/openbao/tree/main/website/content/docs/policies/migration.mdx",tags:[],version:"current",frontMatter:{layout:"docs",page_title:"OpenBao Migration Policy",sidebar_title:"Migration Policy",description:"The OpenBao policy around migration from upstream to OpenBao."}},l={},c=[{value:"Definitions",id:"definitions",level:2},{value:"Observations",id:"observations",level:2},{value:"Proposal",id:"proposal",level:2},{value:"Migration path",id:"migration-path",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"migration-policy",children:"Migration policy"}),"\n",(0,t.jsxs)(n.p,{children:["This policy was original ",(0,t.jsx)(n.a,{href:"https://github.com/orgs/openbao/discussions/55",children:"discussed on\nGitHub"})," and ratified on\nthe ",(0,t.jsx)(n.a,{href:"https://wiki.lfedge.org/display/OH/OpenBao+Meetings",children:"February 8th, 2024 meeting"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"definitions",children:"Definitions"}),"\n",(0,t.jsx)(n.p,{children:"From a consumption perspective, there are three personas we can define:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bao Operators"}),". These are the people tasked with deploying updates to\nthe ",(0,t.jsx)(n.code,{children:"bao"})," binary, handling outages, &c. They might typically access ",(0,t.jsx)(n.code,{children:"/sys"}),",\nsetup new mounts, get high-privileged root tokens temporarily to setup\nadditional clusters or change quotas, &c, but aren't (for this discussion)\ndirect consumers of many secrets methods. They likely also interface with\nOpenBao's configuration, logging, and auditing interfaces, and may interact\nbriefly (during outages &c) with storage directly. They'd be in charge\nof handling any migration which needs to occur during an upgrade or change\nevent from upstream to OpenBao. While a breaking change, these are most\nlikely to have a flexible enough deployment & workflow to accept change."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Connection Operators"}),". These are individuals who deploy applications\nwhich talk to OpenBao. They might directly interact with ",(0,t.jsx)(n.code,{children:"bao"}),"'s API\nnamespace, to set up new accounts, services, potentially (if delegated by\nBao operators) creating new secrets engines, and configuration any existing\nsecrets engines in their purview. They may do this directly (via CLI or\nUI) or indirectly (via a centralized management service like OpenTofu).\nThese types of users can accept a moderate amount of change, but changes\nto APIs (especially unexpectedly) can cause issues."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Applications & end-users"}),". These are individuals (broadly speaking)\nwhich only interface with the API of authentication and secrets engines to\nget secrets (again, broadly speaking -- a PKI certificate is not a\ntraditional secret nor does Transit expose a similar interface that grants\nleases). These typically have the least flexible workflow and are hesitant\nto change."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We can also talk about compatibility on several layers:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Seal compatibility"}),". Is encrypted data drop-in compatible with\nupstream, for a given combination of ",(0,t.jsx)(n.code,{children:"(seal mechanism, storage provider, plugin)"}),". Can this storage layout be read (i.e., is the disk tree similar)\nby core and can the resulting plugin be loaded and function equivalently\nto API consumers? This implies no to minimal migration necessary."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Storage compatibility"}),". For unencrypted data (i.e., using an unencrypted\nbackup/one-time migration bundle or using the unsupported-but-useful\n",(0,t.jsx)(n.code,{children:"sys/raw"})," interface), can this be migrated from an upstream instance\ndirectly into downstream at an equivalent path without rewriting the\ndata itself. This means all the rest of the core (minus the initial\nencryption layer and potentially meaning a different physical storage\nbackend) are compatible with  upstream."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"API compatibility"}),". For consumers of upstream's secret's or auth\nplugin's API only, would they be able to point interchangeably at an\nupstream or OpenBao instance without caring about which, assuming suitable\ndata & plugins are available in both locations. This usage does not extend\nto non-plugin APIs (e.g., under ",(0,t.jsx)(n.code,{children:"/sys"}),"), but should include the GRPC\nexternal plugin communication mechanism."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"(In this hierarchy it is implied that 1 implies 2 implies 3, i.e., a seal\nor storage compatible fork would imply API compatibility, and likewise\nseal compatibility implies storage compatibility)."}),"\n",(0,t.jsx)(n.h2,{id:"observations",children:"Observations"}),"\n",(0,t.jsx)(n.p,{children:"Notably, API compatibility is most aligned with the connection operators' and\napplication & end-users' goals: minimize API change. While seal and storage\ncompatibility are cool from a Bao operator's perspective, breaking either\n(w.r.t. upstream -- likely ahead of initial GA) results in a one-time\nmigration, but difficult from a Bao development community perspective. This\ntype of compatibility helps cross-adoption but becomes hard to support,\nespecially as several key portions are impossible to do without reverse\nengineering Vault Enterprise (e.g., auto-unseal, seal wrapping, replication,\ncertain secret engine features, ...)."}),"\n",(0,t.jsx)(n.h2,{id:"proposal",children:"Proposal"}),"\n",(0,t.jsxs)(n.p,{children:["Aim for API compatibility only, with limited seal compatibility when using remaining\nseal, storage, and plugins ",(0,t.jsx)(n.a,{href:"https://github.com/orgs/openbao/discussions/64",children:"as discussed in that proposal"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This allows us to prune unnecessary features, create alternative,\nnon-compatible implementations of various upstream, Enterprise features, and\ndecreases maintenance burdens. This allows us to create a more healthy,\nseparate but welcoming community from upstream."}),"\n",(0,t.jsx)(n.p,{children:"It also recognizes that OpenBao (by discussing removing support for already\ndeprecated changes or removing plugins that no maintainer has stepped up to\nsupport) will inevitably, intentionally or otherwise, deviate from upstream.\nIt provides support commitment to portions of the organization most resistant\nto change, and allows Bao operators to decide whether or not to make the\nmigration. It also recognizes that upstream may or may not make other decisions\nand potentially backwards-incompatible changes of their own, allowing us to\ntake a different approach if necessary."}),"\n",(0,t.jsx)(n.p,{children:"This still allows us to take advantage of the broader secrets & auth engine\necosystem, as GRPC compatibility is still encouraged. And third-party client\ntooling should continue to function between the two, unless they were using\nunsupported, internal implementation details and crossing the API boundary."}),"\n",(0,t.jsx)(n.p,{children:"However, it walks a fine line that, when a user's existing usage of upstream aligns\nwith OpenBao's goals, the two should be drop-in compatible at the initial release.\nThis then allows a smoother migration between the two projects."}),"\n",(0,t.jsx)(n.h3,{id:"migration-path",children:"Migration path"}),"\n",(0,t.jsx)(n.p,{children:"This means that some operators will need to make a conscious, one-time migration\nfrom a compatible upstream version to an OpenBao version. This likely warrants\nthe creation of documentation and tools to help aid this migration, on a\nper-plugin basis. It means that OpenBao's server will not be drop-in binary\nequivalent from upstream's, and that we should likely place some marker to\ndetect and prevent incompatible, unsupported usage."}),"\n",(0,t.jsx)(n.p,{children:"The remaining operators (who use a supported subset) will be able to\ndrop-in replace like a regular upgrade."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var t=i(96540);const a={},o=t.createContext(a);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);