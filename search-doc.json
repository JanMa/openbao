{"searchDocs":[{"title":"HTTP API","type":0,"sectionRef":"#","url":"/openbao/api-docs/","content":"","keywords":"","version":"Next"},{"title":"Transport​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#transport","content":" The API is expected to be accessed over a TLS connection at all times, with a valid certificate that is verified by a well-behaved client. It is possible to disable TLS verification for listeners, however, so API clients should expect to have to do both depending on user settings.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#authentication","content":" Once OpenBao is unsealed, almost every other operation requires a client token. A user may have a client token sent to them. The client token must be sent as either the X-Vault-Token HTTP Header or as Authorization HTTP Header using the Bearer &lt;token&gt; scheme.  Otherwise, a client token can be retrieved using an authentication engine.  Each auth method has one or more unauthenticated login endpoints. These endpoints can be reached without any authentication, and are used for authentication to OpenBao itself. These endpoints are specific to each auth method.  Responses from auth login methods that generate an authentication token are sent back to the client in JSON. The resulting token should be saved on the client or passed via the X-Vault-Token or Authorization header for future requests.  ","version":"Next","tagName":"h2"},{"title":"Parameter restrictions​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#parameter-restrictions","content":" Several OpenBao APIs require specifying path parameters. The path parameter cannot end in periods. Otherwise, OpenBao will return a 404 unsupported path error.  ","version":"Next","tagName":"h2"},{"title":"API operations​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#api-operations","content":" Typically the request data, body and response data to and from OpenBao is in JSON. OpenBao sets the Content-Type header appropriately with its response and does not require it from the clients request.  The demonstration below uses the KVv1 secrets engine, which is a simple Key/Value store. Please read the API documentation of KV secret enginesfor details of KVv1 compared to KVv2 and how they differ in their URI paths as well as the features available in version 2 of the KV secrets engine.  For KVv1, reading a secret using the HTTP API is done by issuing a GET:  /v1/secret/foo   This maps to secret/foo where foo is the key in the secret/ mount, which is mounted by default on a fresh OpenBao install and is of type kv.  Here is an example of reading a secret using cURL:  $ curl \\ -H &quot;X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6&quot; \\ -X GET \\ http://127.0.0.1:8200/v1/secret/foo   A few endpoints consume calls with GET query string parameters, but only if those parameters are not sensitive, especially since some load balancers will be able log these. Most endpoints that accept POST query string parameters expect those parameters in the request body.  You can list secrets as well. To do this, either issue a GET with the query string parameter list=true, or you use the LIST HTTP verb. For the kv secrets engine, listing is allowed on directories only, which returns the keys at the requested path:  $ curl \\ -H &quot;X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6&quot; \\ -X LIST \\ http://127.0.0.1:8200/v1/secret/   The API documentation uses LIST as the HTTP verb, but you can still use GETwith the ?list=true query string.  To make an API with specific data in request body, issue a POST:  /v1/secret/foo   with a JSON body like:  { &quot;value&quot;: &quot;bar&quot; }   Here is an example of writing a secret using cURL:  $ curl \\ -H &quot;X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -X POST \\ -d '{&quot;data&quot;:{&quot;value&quot;:&quot;bar&quot;}}' \\ http://127.0.0.1:8200/v1/secret/baz   OpenBao currently considers PUT and POST to be synonyms. Rather than trust a client's stated intentions, OpenBao engines can implement an existence check to discover whether an operation is actually a create or update operation based on the data already stored within OpenBao. This makes permission management via ACLs more flexible.  A KVv2 example for the engine path of secret requires that URI is appended with data/ prior to the secret name (baz) such as:  $ curl \\ -H &quot;X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -X POST \\ -d '{&quot;data&quot;:{&quot;value&quot;:&quot;bar&quot;}}' \\ http://127.0.0.1:8200/v1/secret/data/baz   For more examples, please look at the OpenBao API client.  ","version":"Next","tagName":"h2"},{"title":"The X-Vault-Request header​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#the-x-vault-request-header","content":" Requests that are sent to a OpenBao Proxy that is configured to use therequire_request_header option must include the X-Vault-Request header entry, e.g.:  $ curl \\ -H &quot;X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6&quot; \\ -H &quot;X-Vault-Request: true&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -X POST \\ -d '{&quot;value&quot;:&quot;bar&quot;}' \\ http://127.0.0.1:8200/v1/secret/baz   The OpenBao CLI always adds this header to every request, regardless of whether the request is being sent to an OpenBao Agent or directly to an OpenBao Server. In addition, the OpenBao SDK always adds this header to every request.  ","version":"Next","tagName":"h2"},{"title":"Help​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#help","content":" To retrieve the help for any API within OpenBao, including mounted engines, auth methods, etc. then append ?help=1 to any URL. If you have valid permission to access the path, then the help text will be returned as a markdown-formatted block in the help attribute of the response.  Additionally, with the OpenAPI generation in OpenBao, you will get back a small OpenAPI document in the openapi attribute. This document is relevant for the path you're looking up and any paths under it - also note paths in the OpenAPI document are relative to the initial path queried.  Example request:  $ curl \\ -H &quot;X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6&quot; \\ http://127.0.0.1:8200/v1/secret?help=1   Example response:  { &quot;help&quot;: &quot;## DESCRIPTION\\n\\nThis backend provides a versioned key-value store. The kv backend reads and\\nwrites arbitrary secrets to the storage backend. The secrets are\\nencrypted/decrypted by OpenBao: they are never stored unencrypted in the backend\\nand the backend never has an opportunity to see the unencrypted value. Each key\\ncan have a configured number of versions, and versions can be retrieved based on\\ntheir version numbers.\\n\\n## PATHS\\n\\nThe following paths are supported by this backend. To view help for\\nany of the paths below, use the help command with any route matching\\nthe path pattern. Note that depending on the policy of your auth token,\\nyou may or may not be able to access certain paths.\\n\\n ^.*$\\n\\n\\n ^config$\\n Configures settings for the KV store\\n\\n ^data/(?P&lt;path&gt;.*)$\\n Write, Read, and Delete data in the Key-Value Store.\\n\\n ^delete/(?P&lt;path&gt;.*)$\\n Marks one or more versions as deleted in the KV store.\\n\\n ^destroy/(?P&lt;path&gt;.*)$\\n Permanently removes one or more versions in the KV store\\n\\n ^metadata/(?P&lt;path&gt;.*)$\\n Configures settings for the KV store\\n\\n ^undelete/(?P&lt;path&gt;.*)$\\n Undeletes one or more versions from the KV store.&quot;, &quot;openapi&quot;: { &quot;openapi&quot;: &quot;3.0.2&quot;, &quot;info&quot;: { &quot;title&quot;: &quot;OpenBao API&quot;, &quot;description&quot;: &quot;HTTP API that gives you full access to OpenBao. All API routes are prefixed with `/v1/`.&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;license&quot;: { &quot;name&quot;: &quot;Mozilla Public License 2.0&quot;, &quot;url&quot;: &quot;https://www.mozilla.org/en-US/MPL/2.0&quot; } }, &quot;paths&quot;: { &quot;/.*&quot;: {}, &quot;/config&quot;: { &quot;description&quot;: &quot;Configures settings for the KV store&quot;, &quot;x-vault-create-supported&quot;: true, &quot;get&quot;: { &quot;summary&quot;: &quot;Read the backend level settings.&quot;, &quot;tags&quot;: [ &quot;secrets&quot; ], &quot;responses&quot;: { &quot;200&quot;: { &quot;description&quot;: &quot;OK&quot; } } }, ...[output truncated]... } } }   ","version":"Next","tagName":"h2"},{"title":"Error response​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#error-response","content":" A common JSON structure is always returned to return errors:  { &quot;errors&quot;: [ &quot;message&quot;, &quot;another message&quot; ] }   This structure will be returned for any HTTP status greater than or equal to 400.  ","version":"Next","tagName":"h2"},{"title":"HTTP status codes​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#http-status-codes","content":" The following HTTP status codes are used throughout the API. OpenBao tries to adhere to these whenever possible, but in case it doesn't -- then feel free toraise a bug for our attention!  warning Note: Applications should be prepared to accept both 200 and 204 as success. 204 is simply an indication that there is no response body to parse, but API endpoints that indicate that they return a 204 may return a 200 if warnings are generated during the operation.  200 - Success with data.204 - Success, no data returned.400 - Invalid request, missing or invalid data.403 - Forbidden, your authentication details are either incorrect, you don't have access to this feature, or - if CORS is enabled - you made a cross-origin request from an origin that is not allowed to make such requests.404 - Invalid path. This can both mean that the path truly doesn't exist or that you don't have permission to view a specific path. We use 404 in some cases to avoid state leakage.405 - Unsupported operation. You tried to use a method inappropriate to the request path, e.g. a POST on an endpoint that only accepts GETs.429 - Default return code for health status of standby nodes. This will likely change in the future.500 - Internal server error. An internal error has occurred, try again later. If the error persists, report a bug.502 - A request to OpenBao required OpenBao making a request to a third party; the third party responded with an error of some kind.503 - OpenBao is down for maintenance or is currently sealed. Try again later.  ","version":"Next","tagName":"h2"},{"title":"Limits​","type":1,"pageTitle":"HTTP API","url":"/openbao/api-docs/#limits","content":" A maximum request size of 32MB is imposed to prevent a denial of service attack with arbitrarily large requests; this can be tuned per listener block in OpenBao's server configuration file. ","version":"Next","tagName":"h2"},{"title":"Auth methods","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/","content":"Auth methods Each auth method publishes its own set of API paths and methods. These endpoints are documented in this section. Auth methods are enabled at a path, but the documentation will assume the default paths for simplicity. If you are enabling at a different path, you should adjust your API calls accordingly. For the API documentation for a specific auth method, please choose a auth method from the navigation.","keywords":"","version":"Next"},{"title":"TLS certificate auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/cert/","content":"","keywords":"","version":"Next"},{"title":"Create CA certificate role​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#create-ca-certificate-role","content":" Sets a CA cert and associated parameters in a role name.  Method\tPathPOST\t/auth/cert/certs/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters","content":" name (string: &lt;required&gt;) - The name of the certificate role. certificate (string: &lt;required&gt;) - The PEM-format CA certificate. allowed_names (string: &quot;&quot;) - DEPRECATED: Please use the individualallowed_X_sans parameters instead. Constrain the Common and Alternative Names in the client certificate with a globbed pattern. Value is a comma-separated list of patterns. Authentication requires at least one Name matching at least one pattern. If not set, defaults to allowing all names. allowed_common_names (string: &quot;&quot; or array: []) - Constrain the Common Names in the client certificate with a globbed pattern. Value is a comma-separated list of patterns. Authentication requires at least one Name matching at least one pattern. If not set, defaults to allowing all names. allowed_dns_sans (string: &quot;&quot; or array: []) - Constrain the Alternative Names in the client certificate with a globbed pattern. Value is a comma-separated list of patterns. Authentication requires at least one DNS matching at least one pattern. If not set, defaults to allowing all dns. allowed_email_sans (string: &quot;&quot; or array: []) - Constrain the Alternative Names in the client certificate with a globbed pattern. Value is a comma-separated list of patterns. Authentication requires at least one Email matching at least one pattern. If not set, defaults to allowing all emails. allowed_uri_sans (string: &quot;&quot; or array: []) - Constrain the Alternative Names in the client certificate with a globbed pattern. Value is a comma-separated list of URI patterns. Authentication requires at least one URI matching at least one pattern. If not set, defaults to allowing all URIs. allowed_organizational_units (string: &quot;&quot; or array: []) - Constrain the Organizational Units (OU) in the client certificate with a globbed pattern. Value is a comma-separated list of OU patterns. Authentication requires at least one OU matching at least one pattern. If not set, defaults to allowing all OUs. required_extensions (string: &quot;&quot; or array: []) - Require specific Custom Extension OIDs to exist and match the pattern. Value is a comma separated string or array of oid:value. Expects the extension value to be some type of ASN1 encoded string. All conditions must be met. Supports globbing onvalue. allowed_metadata_extensions (array:[]) - A comma separated string or array of oid extensions. Upon successful authentication, these extensions will be added as metadata if they are present in the certificate. The metadata key will be the string consisting of the oid numbers separated by a dash (-) instead of a dot (.) to allow usage in ACL templates. ocsp_enabled (bool: false) - If enabled, validate certificates' revocation status using OCSP. ocsp_ca_certificates (string: &quot;&quot;) Any additional CA certificates needed to verify OCSP responses. Provided as base64 encoded PEM data. ocsp_servers_override (array: []): A comma-separated list of OCSP server addresses. If unset, the OCSP server is determined from the AuthorityInformationAccess extension on the certificate being inspected. ocsp_fail_open (bool: false) - If true and an OCSP response cannot be fetched or is of an unknown status, the login will proceed as if the certificate has not been revoked. ocsp_query_all_servers (bool: false) - If set to true, rather than accepting the first successful OCSP response, query all servers and consider the certificate valid only if all servers agree. display_name (string: &quot;&quot;) - The display_name to set on tokens issued when authenticating against this CA certificate. If not set, defaults to the name of the role.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-payload","content":" { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIEtzCCA5+.......ZRtAfQ6r\\nwlW975rYa1ZqEdA=\\n-----END CERTIFICATE-----&quot;, &quot;display_name&quot;: &quot;test&quot;, &quot;bound_cidrs&quot;: [&quot;127.0.0.1/32&quot;, &quot;128.252.0.0/16&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --cacert openbao-ca.pem \\ --data @payload.json https://127.0.0.1:8200/v1/auth/cert/certs/test-ca   ","version":"Next","tagName":"h3"},{"title":"Read CA certificate role​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#read-ca-certificate-role","content":" Gets information associated with the named role.  Method\tPathGET\t/auth/cert/certs/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-1","content":" name (string: &lt;required&gt;) - The name of the certificate role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --cacert openbao-ca.pem \\ https://127.0.0.1:8200/v1/auth/cert/certs/test-ca   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-response","content":" { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIEtzCCA5+.......ZRtAfQ6r\\nwlW975rYa1ZqEdA=\\n-----END CERTIFICATE-----&quot;, &quot;display_name&quot;: &quot;test&quot;, &quot;policies&quot;: &quot;&quot;, &quot;allowed_names&quot;: &quot;&quot;, &quot;required_extensions&quot;: &quot;&quot;, &quot;ttl&quot;: 2764800, &quot;max_ttl&quot;: 2764800, &quot;period&quot;: 0 }, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"List certificate roles​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#list-certificate-roles","content":" Lists configured certificate names.  Method\tPathLIST\t/auth/cert/certs  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ --cacert openbao-ca.pem \\ https://127.0.0.1:8200/v1/auth/cert/certs   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;cert1&quot;, &quot;cert2&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Delete certificate role​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#delete-certificate-role","content":" Deletes the named role and CA cert from the method mount.  Method\tPathDELETE\t/auth/cert/certs/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-2","content":" name (string: &lt;required&gt;) - The name of the certificate role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ --cacert openbao-ca.pem \\ https://127.0.0.1:8200/v1/auth/cert/certs/cert1   ","version":"Next","tagName":"h3"},{"title":"List CRLs​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#list-crls","content":" Lists configured certificate revocation lists.  Method\tPathLIST\t/auth/cert/crls  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ --cacert openbao-ca.pem \\ https://127.0.0.1:8200/v1/auth/cert/crls   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-response-2","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;crl1&quot;, &quot;crl2&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Create CRL​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#create-crl","content":" Sets a named CRL.  Method\tPathPOST\t/auth/cert/crls/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-3","content":" name (string: &lt;required&gt;) - The name of the CRL.crl (string: &quot;&quot;) - The PEM format CRL.url (string: &quot;&quot;) - The URL of a CRL distribution point.  Note: Either 'crl' or 'url' parameters must be provided, if both are provided, 'crl' is used.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-payload-1","content":" { &quot;crl&quot;: &quot;-----BEGIN X509 CRL-----\\n...\\n-----END X509 CRL-----&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --cacert openbao-ca.pem \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/cert/crls/custom-crl   ","version":"Next","tagName":"h3"},{"title":"Read CRL​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#read-crl","content":" Gets information associated with the named CRL (currently, the serial numbers contained within). As the serials can be integers up to an arbitrary size, these are returned as strings.  Method\tPathGET\t/auth/cert/crls/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-4","content":" name (string: &lt;required&gt;) - The name of the CRL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --cacert openbao-ca.pem \\ https://127.0.0.1:8200/v1/auth/cert/crls/custom-crl   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-response-3","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;serials&quot;: { &quot;13&quot;: {} } }, &quot;lease_duration&quot;: 0, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Delete CRL​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#delete-crl","content":" Deletes the named CRL from the auth method mount.  Method\tPathDELETE\t/auth/cert/crls/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-5","content":" name (string: &lt;required&gt;) - The name of the CRL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ --cacert openbao-ca.pem \\ https://127.0.0.1:8200/v1/auth/cert/crls/cert1   ","version":"Next","tagName":"h3"},{"title":"Configure TLS certificate method​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#configure-tls-certificate-method","content":" Configuration options for the method.  Method\tPathPOST\t/auth/cert/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-6","content":" disable_binding (boolean: false) - If set, during renewal, skips the matching of presented client identity with the client identity used during login.enable_identity_alias_metadata (boolean: false) - If set, metadata of the certificate including the metadata corresponding toallowed_metadata_extensions will be stored in the aliasocsp_cache_size (int: 100) - The size of the OCSP response LRU cache. Note that this cache is used for all configured certificates.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-payload-2","content":" { &quot;disable_binding&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --cacert openbao-ca.pem \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/cert/certs/cert1   ","version":"Next","tagName":"h3"},{"title":"Login with TLS certificate method​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#login-with-tls-certificate-method","content":" Log in and fetch a token. If there is a valid chain to a CA configured in the method and all role constraints are matched, a token will be issued. If the certificate has DNS SANs in it, each of those will be verified. If Common Name is required to be verified, then it should be a fully qualified DNS domain name and must be duplicated as a DNS SAN (seehttps://tools.ietf.org/html/rfc6125#section-2.3)  Method\tPathPOST\t/auth/cert/login  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#parameters-7","content":" name (string: &quot;&quot;) - Authenticate against only the named certificate role, returning its policy list if successful. If not set, defaults to trying all certificate roles and returning any one that matches.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-payload-3","content":" { &quot;name&quot;: &quot;cert1&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-request-9","content":" warning NOTE The --cacert value used here is for the OpenBao TLS Listener CA certificate, not the CA that issued the client authentication certificate. This can be omitted if the CA used to issue the OpenBao server certificate is trusted by the local system executing this command.  $ curl \\ --request POST \\ --cacert openbao-ca.pem \\ --cert cert.pem \\ --key key.pem \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/cert/login   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TLS certificate auth method (API)","url":"/openbao/api-docs/auth/cert/#sample-response-4","content":" { &quot;auth&quot;: { &quot;client_token&quot;: &quot;cf95f87d-f95b-47ff-b1f5-ba7bff850425&quot;, &quot;policies&quot;: [&quot;web&quot;, &quot;stage&quot;], &quot;lease_duration&quot;: 3600, &quot;renewable&quot;: true } }  ","version":"Next","tagName":"h3"},{"title":"JWT/OIDC auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/jwt/","content":"","keywords":"","version":"Next"},{"title":"Configure​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#configure","content":" Configures the validation information to be used globally across all roles. One (and only one) of oidc_discovery_url, jwks_url, and jwt_validation_pubkeys must be set.  Method\tPathPOST\t/auth/jwt/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters","content":" oidc_discovery_url (string: &lt;optional&gt;) - The OIDC Discovery URL, without any .well-known component (base path). Cannot be used with &quot;jwks_url&quot; or &quot;jwt_validation_pubkeys&quot;.oidc_discovery_ca_pem (string: &lt;optional&gt;) - The contents of a CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used.oidc_client_id (string: &lt;optional&gt;) - The OAuth Client ID from the provider for OIDC roles.oidc_client_secret (string: &lt;optional&gt;) - The OAuth Client Secret from the provider for OIDC roles.oidc_response_mode (string: &lt;optional&gt;) - The response mode to be used in the OAuth2 request. Allowed values are &quot;query&quot; and &quot;form_post&quot;. Defaults to &quot;query&quot;.oidc_response_types (comma-separated string, or array of strings: &lt;optional&gt;) - The response types to request. Allowed values are &quot;code&quot; and &quot;id_token&quot;. Defaults to &quot;code&quot;. Note: &quot;id_token&quot; may only be used if &quot;oidc_response_mode&quot; is set to &quot;form_post&quot;.jwks_url (string: &lt;optional&gt;) - JWKS URL to use to authenticate signatures. Cannot be used with &quot;oidc_discovery_url&quot; or &quot;jwt_validation_pubkeys&quot;.jwks_ca_pem (string: &lt;optional&gt;) - The contents of a CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.jwt_validation_pubkeys (comma-separated string, or array of strings: &lt;optional&gt;) - A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used with &quot;jwks_url&quot; or &quot;oidc_discovery_url&quot;.bound_issuer (string: &lt;optional&gt;) - The value against which to match the iss claim in a JWT.jwt_supported_algs (comma-separated string, or array of strings: &lt;optional&gt;) - A list of supported signing algorithms. Defaults to [RS256] for OIDC roles. Defaults to all available algorithms for JWT roles.default_role (string: &lt;optional&gt;) - The default role to use if none is provided during login.provider_config (map: &lt;optional&gt;) - Configuration options for provider-specific handling. Providers with specific handling include: Azure, Google, SecureAuth, IBM ISAM. The options are described in each provider's section in OIDC Provider Setup.namespace_in_state (bool: true) - Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in OpenBao and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-payload","content":" { &quot;oidc_discovery_url&quot;: &quot;https://myco.auth0.com/&quot;, &quot;bound_issuer&quot;: &quot;https://myco.auth0.com/&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/jwt/config   ","version":"Next","tagName":"h3"},{"title":"Read config​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#read-config","content":" Returns the previously configured config.  Method\tPathGET\t/auth/jwt/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/auth/jwt/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-response","content":" { &quot;data&quot;:{ &quot;oidc_discovery_url&quot;: &quot;https://myco.auth0.com/&quot;, &quot;oidc_discovery_ca_pem&quot;: [], &quot;bound_issuer&quot;: &quot;https://myco.auth0.com/&quot;, &quot;jwt_validation_pubkeys&quot;: [] }, ... }   ","version":"Next","tagName":"h3"},{"title":"Create/Update role​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#createupdate-role","content":" Registers a role in the method. Role types have specific entities that can perform login operations against this endpoint. Constraints specific to the role type must be set on the role. These are applied to the authenticated entities attempting to login. At least one of the bound values must be set.  Method\tPathPOST\t/auth/jwt/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters-1","content":" name (string: &lt;required&gt;) - Name of the role.role_type (string: &lt;optional&gt;) - Type of role, either &quot;oidc&quot; (default) or &quot;jwt&quot;.bound_audiences (array: &lt;optional&gt;) - List of aud claims to match against. Any match is sufficient. For &quot;jwt&quot; roles, at least one of bound_audiences, bound_subject,bound_claims or token_bound_cidrs is required. Optional for &quot;oidc&quot; roles.user_claim (string: &lt;required&gt;) - The claim to use to uniquely identify the user; this will be used as the name for the Identity entity alias created due to a successful login. The claim value must be a string.user_claim_json_pointer (bool: false) - Specifies if the user_claim value usesJSON pointer syntax for referencing claims. By default, the user_claim value will not use JSON pointer.clock_skew_leeway (int or string: &lt;optional&gt;) - The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Accepts an integer number of seconds, or a Go duration format string. Only applicable with &quot;jwt&quot; roles.expiration_leeway (int or string: &lt;optional&gt;) - The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 150 seconds if set to 0 and can be disabled if set to -1. Accepts an integer number of seconds, or a Go duration format string. Only applicable with &quot;jwt&quot; roles.not_before_leeway (int or string: &lt;optional&gt;) - The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if set to 0 and can be disabled if set to -1. Accepts an integer number of seconds, or a Go duration format string. Only applicable with &quot;jwt&quot; roles.bound_subject (string: &lt;optional&gt;) - If set, requires that the subclaim matches this value.bound_claims (map: &lt;optional&gt;) - If set, a map of claims (keys) to match against respective claim values (values). The expected value may be a single string or a list of strings. The interpretation of the bound claim values is configured with bound_claims_type. Keys support JSON pointersyntax for referencing claims.bound_claims_type (string: &quot;string&quot;) - Configures the interpretation of the bound_claims values. If &quot;string&quot; (the default), the values will treated as string literals and must match exactly. If set to &quot;glob&quot;, the values will be interpreted as globs, with * matching any number of characters.groups_claim (string: &lt;optional&gt;) - The claim to use to uniquely identify the set of groups to which the user belongs; this will be used as the names for the Identity group aliases created due to a successful login. The claim value must be a list of strings. Supports JSON pointersyntax for referencing claims.claim_mappings (map: &lt;optional&gt;) - If set, a map of claims (keys) to be copied to specified metadata fields (values). Keys support JSON pointersyntax for referencing claims.oidc_scopes (list: &lt;optional&gt;) - If set, a list of OIDC scopes to be used with an OIDC role. The standard scope &quot;openid&quot; is automatically included and need not be specified.allowed_redirect_uris (list: &lt;required&gt;) - The list of allowed values for redirect_uri during OIDC logins.verbose_oidc_logging (bool: false) - Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses.max_age (int or string: &lt;optional&gt;) - Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated with the OIDC provider. If set, the max_age request parameter will be included in the authentication request. See AuthRequestfor additional details. Accepts an integer number of seconds, or a Go duration format string.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-payload-1","content":" { &quot;policies&quot;: [&quot;dev&quot;, &quot;prod&quot;], &quot;bound_subject&quot;: &quot;sl29dlldsfj3uECzsU3Sbmh0F29Fios1@clients&quot;, &quot;bound_audiences&quot;: &quot;https://myco.test&quot;, &quot;user_claim&quot;: &quot;https://openbao/user&quot;, &quot;groups_claim&quot;: &quot;https://openbao/groups&quot;, &quot;bound_claims&quot;: { &quot;department&quot;: &quot;engineering&quot;, &quot;sector&quot;: &quot;7g&quot; }, &quot;claim_mappings&quot;: { &quot;preferred_language&quot;: &quot;language&quot;, &quot;group&quot;: &quot;group&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/jwt/role/dev-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#read-role","content":" Returns the previously registered role configuration.  Method\tPathGET\t/auth/jwt/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters-2","content":" name (string: &lt;required&gt;) - Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/auth/jwt/role/dev-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-response-1","content":" { &quot;data&quot;:{ &quot;bound_subject&quot;: &quot;sl29dlldsfj3uECzsU3Sbmh0F29Fios1@clients&quot;, &quot;bound_audiences&quot;: [ &quot;https://myco.test&quot; ], &quot;bound_cidrs&quot;: [], &quot;user_claim&quot;: &quot;https://openbao/user&quot;, &quot;groups_claim&quot;: &quot;https://openbao/groups&quot;, &quot;policies&quot;: [ &quot;dev&quot;, &quot;prod&quot; ], &quot;period&quot;: 0, &quot;ttl&quot;: 0, &quot;num_uses&quot;: 0, &quot;max_ttl&quot;: 0 }, ... }   ","version":"Next","tagName":"h3"},{"title":"List roles​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#list-roles","content":" Lists all the roles that are registered with the plugin.  Method\tPathLIST\t/auth/jwt/role  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ https://127.0.0.1:8200/v1/auth/jwt/role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-response-2","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;dev-role&quot;, &quot;prod-role&quot; ] }, ... }   ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#delete-role","content":" Deletes the previously registered role.  Method\tPathDELETE\t/auth/jwt/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters-3","content":" name (string: &lt;required&gt;) - Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ https://127.0.0.1:8200/v1/auth/jwt/role/dev-role   ","version":"Next","tagName":"h3"},{"title":"OIDC authorization URL request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#oidc-authorization-url-request","content":" Obtain an authorization URL from OpenBao to start an OIDC login flow.  Method\tPathPOST\t/auth/jwt/oidc/auth_url  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters-4","content":" role (string: &lt;optional&gt;) - Name of the role against which the login is being attempted. Defaults to configured default_role if not provided.redirect_uri (string: &lt;required&gt;) - Path to the callback to complete the login. This will be of the form, &quot;https://.../oidc/callback&quot; where the leading portion is dependent on your OpenBao server location, port, and the mount of the JWT plugin. This must be configured with OpenBao and the provider. See Redirect URIs for more information.client_nonce (string: &lt;optional&gt;) - Optional client-provided nonce that must match the client_nonce value provided during a subsequent request to thecallback API.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-payload-2","content":" { &quot;role&quot;: &quot;dev-role&quot;, &quot;redirect_uri&quot;: &quot;https://openbao.myco.com:8200/ui/openbao/auth/jwt/oidc/callback&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-6","content":" $ curl \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/jwt/oidc/auth_url   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-response-3","content":" { &quot;request_id&quot;: &quot;c701169c-64f8-26cc-0315-078e8c3ce897&quot;, &quot;data&quot;: { &quot;auth_url&quot;: &quot;https://myco.auth0.com/authorize?client_id=r3qXcK2bezU3Sbmh0K16fatW6&amp;nonce=851b69a9bfa5a6a5668111314414e3687891a599&amp;redirect_uri=https%3A%2F%2Fopenbao.myco.com3A8200%2Fui%2Fopenbao%2Fauth%2Fjwt%2Foidc%2Fcallback&amp;response_type=code&amp;scope=openid+email+profile&amp;state=1011e726d24960e09cfca2e04b36b38593cb6a22&quot; }, ... }   ","version":"Next","tagName":"h3"},{"title":"OIDC callback​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#oidc-callback","content":" Exchange an authorization code for an OIDC ID Token. The ID token will be further validated against any bound claims, and if valid an OpenBao token will be returned.  Method\tPathGET\t/auth/jwt/oidc/callback  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters-5","content":" state (string: &lt;required&gt;) - Opaque state ID that is part of the Authorization URL and will be included in the the redirect following successful authentication on the provider.nonce (string: &lt;required&gt;) - Opaque nonce that is part of the Authorization URL and will be included in the the redirect following successful authentication on the provider.code (string: &lt;required&gt;) - Provider-generated authorization code that OpenBao will exchange for an ID token.client_nonce (string: &lt;optional&gt;) - Optional client-provided nonce that must match the client_nonce value provided during the prior request to theauth_url API.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-7","content":" $ curl \\ https://127.0.0.1:8200/v1/auth/jwt/oidc/callback?state=n2kfh3nsl&amp;code=mn2ldl2nv98h2jl&amp;nonce=ni42i2idj2jj   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-response-4","content":" { &quot;auth&quot;:{ &quot;client_token&quot;:&quot;f33f8c72-924e-11f8-cb43-ac59d697597c&quot;, &quot;accessor&quot;:&quot;0e9e354a-520f-df04-6867-ee81cae3d42d&quot;, &quot;policies&quot;:[ &quot;default&quot;, &quot;dev&quot;, &quot;prod&quot; ], &quot;lease_duration&quot;:2764800, &quot;renewable&quot;:true }, ... }   ","version":"Next","tagName":"h3"},{"title":"JWT login​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#jwt-login","content":" Fetch a token. This endpoint takes a signed JSON Web Token (JWT) and a role name for some entity. It verifies the JWT signature to authenticate that entity and then authorizes the entity for the given role.  Method\tPathPOST\t/auth/jwt/login  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#parameters-6","content":" role (string: &lt;optional&gt;) - Name of the role against which the login is being attempted. Defaults to configured default_role if not provided.jwt (string: &lt;required&gt;) - Signed JSON Web Token (JWT).  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-payload-3","content":" { &quot;role&quot;: &quot;dev-role&quot;, &quot;jwt&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-request-8","content":" $ curl \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/auth/jwt/login   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"JWT/OIDC auth method (API)","url":"/openbao/api-docs/auth/jwt/#sample-response-5","content":" { &quot;auth&quot;:{ &quot;client_token&quot;:&quot;f33f8c72-924e-11f8-cb43-ac59d697597c&quot;, &quot;accessor&quot;:&quot;0e9e354a-520f-df04-6867-ee81cae3d42d&quot;, &quot;policies&quot;:[ &quot;default&quot;, &quot;dev&quot;, &quot;prod&quot; ], &quot;lease_duration&quot;:2764800, &quot;renewable&quot;:true }, ... }  ","version":"Next","tagName":"h3"},{"title":"Kerberos auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/kerberos/","content":"","keywords":"","version":"Next"},{"title":"Configure OpenBao Kerberos​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#configure-openbao-kerberos","content":" This endpoint configures the keytab and service account to be used by OpenBao for verifying inbound SPNEGO tokens.  Method\tPathPOST\t/auth/kerberos/config  keytab (string: &lt;required&gt;) – A base 64 representation of the contents of the Kerberos keytab that will be used for verifying inbound SPNEGO tokens. It should contain an entry matching the service account given. This can be created through the following command: $ base64 openbao.keytab &gt; openbao.keytab.base64.service_account (string: &lt;required&gt;) – The service account associated with both the keytab entry and an LDAP service account created for OpenBao. Ex.:&quot;openbao_svc&quot;.remove_instance_name - Removes any instance names from a Kerberos service principal name when parsing the keytab file. For example when this is set to true, if a keytab has the service principal name foo/localhost@example.com, OpenBao will strip the service principal name to just be foo@example.com.add_group_aliases - When set to true, OpenBao will add any LDAP groups found for the user as group aliases.  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/kerberos/config   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-payload","content":" { &quot;add_group_aliases&quot;: false, &quot;keytab&quot;: &quot;BQIAAAA6AAEACk1BVFJJWC5MQU4ACXZhdWx0X3N2YwAAAAFdzZSjAgAXABDwhEyRR9nRqkpP8KTn2A83AAAAAg==&quot;, &quot;remove_instance_name&quot;: false, &quot;service_account&quot;: &quot;openbao_svc&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read OpenBao Kerberos​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#read-openbao-kerberos","content":" This endpoint retrieves the service account for the Kerberos auth method. The keytab is not returned because it is sensitive information.  Method\tPathGET\t/auth/kerberos/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/kerberos/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-response","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;add_group_aliases&quot;: false, &quot;remove_instance_name&quot;: false, &quot;service_account&quot;: &quot;openbao_svc&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Configure Kerberos LDAP​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#configure-kerberos-ldap","content":" This endpoint configures LDAP in the Kerberos auth method.  Method\tPathPOST\t/auth/kerberos/config/ldap  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#parameters","content":" url (string: &lt;required&gt;) – The LDAP server to connect to. Examples:ldap://ldap.myorg.com, ldaps://ldap.myorg.com:636. Multiple URLs can be specified with commas, e.g. ldap://ldap.myorg.com,ldap://ldap2.myorg.com; these will be tried in-order.case_sensitive_names (bool: false) – If set, user and group names assigned to policies within the backend will be case sensitive. Otherwise, names will be normalized to lower case. Case will still be preserved when sending the username to the LDAP server at login time; this is only for matching local user/group definitions.starttls (bool: false) – If true, issues a StartTLS command after establishing an unencrypted connection.tls_min_version (string: tls12) – Minimum TLS version to use. Accepted values are tls10, tls11, tls12 or tls13.tls_max_version (string: tls12) – Maximum TLS version to use. Accepted values are tls10, tls11, tls12 or tls13.insecure_tls (bool: false) – If true, skips LDAP server SSL certificate verification - insecure, use with caution!certificate (string: &quot;&quot;) – CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.binddn (string: &quot;&quot;) – Distinguished name of object to bind when performing user search. Example: cn=openbao,ou=Users,dc=example,dc=combindpass (string: &quot;&quot;) – Password to use along with binddn when performing user search.userdn (string: &quot;&quot;) – Base DN under which to perform user search. Example:ou=Users,dc=example,dc=comuserattr (string: &quot;&quot;) – Attribute on user attribute object matching the username passed when authenticating. Examples: sAMAccountName, cn, uiddiscoverdn (bool: false) – Use anonymous bind to discover the bind DN of a user.deny_null_bind (bool: true) – This option prevents users from bypassing authentication when providing an empty password.upndomain (string: &quot;&quot;) – The userPrincipalDomain used to construct the UPN string for the authenticating user. The constructed UPN will appear as[username]@UPNDomain. Example: example.com, which will cause openbao to bind as username@example.com.groupfilter (string: &quot;&quot;) – Go template used when constructing the group membership query. The template can access the following context variables: [UserDN, Username]. The default is(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}})), which is compatible with several common directory schemas. To support nested group resolution for Active Directory, instead use the following query: (&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})).groupdn (string: &quot;&quot;) – LDAP search base to use for group membership search. This can be the root containing either groups or users. Example:ou=Groups,dc=example,dc=comgroupattr (string: &quot;&quot;) – LDAP attribute to follow on objects returned bygroupfilter in order to enumerate user group membership. Examples: for groupfilter queries returning group objects, use: cn. For queries returning user objects, use: memberOf. The default is cn.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/kerberos/config/ldap   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-payload-1","content":" { &quot;binddn&quot;: &quot;cn=openbao,ou=Users,dc=example,dc=com&quot;, &quot;deny_null_bind&quot;: true, &quot;discoverdn&quot;: false, &quot;groupattr&quot;: &quot;cn&quot;, &quot;groupdn&quot;: &quot;ou=Groups,dc=example,dc=com&quot;, &quot;groupfilter&quot;: &quot;(\\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))&quot;, &quot;insecure_tls&quot;: false, &quot;starttls&quot;: false, &quot;tls_max_version&quot;: &quot;tls12&quot;, &quot;tls_min_version&quot;: &quot;tls12&quot;, &quot;url&quot;: &quot;ldaps://ldap.myorg.com:636&quot;, &quot;userattr&quot;: &quot;samaccountname&quot;, &quot;userdn&quot;: &quot;ou=Users,dc=example,dc=com&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read Kerberos LDAP configuration​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#read-kerberos-ldap-configuration","content":" This endpoint retrieves the LDAP configuration for the Kerberos auth method.  Method\tPathGET\t/auth/kerberos/config/ldap  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/kerberos/config/ldap   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;binddn&quot;: &quot;cn=openbao,ou=Users,dc=example,dc=com&quot;, &quot;bindpass&quot;: &quot;&quot;, &quot;certificate&quot;: &quot;&quot;, &quot;deny_null_bind&quot;: true, &quot;discoverdn&quot;: false, &quot;groupattr&quot;: &quot;cn&quot;, &quot;groupdn&quot;: &quot;ou=Groups,dc=example,dc=com&quot;, &quot;groupfilter&quot;: &quot;(\\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))&quot;, &quot;insecure_tls&quot;: false, &quot;starttls&quot;: false, &quot;tls_max_version&quot;: &quot;tls12&quot;, &quot;tls_min_version&quot;: &quot;tls12&quot;, &quot;upndomain&quot;: &quot;&quot;, &quot;url&quot;: &quot;ldaps://ldap.myorg.com:636&quot;, &quot;userattr&quot;: &quot;samaccountname&quot;, &quot;userdn&quot;: &quot;ou=Users,dc=example,dc=com&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"List Kerberos LDAP groups​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#list-kerberos-ldap-groups","content":" This endpoint returns a list of existing LDAP groups in the Kerberos auth method.  Method\tPathLIST\t/auth/kerberos/groups  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/kerberos/groups   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-response-2","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;scientists&quot;, &quot;engineers&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read Kerberos LDAP group​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#read-kerberos-ldap-group","content":" This endpoint returns the policies associated with a Kerberos LDAP group.  Method\tPathGET\t/auth/kerberos/groups/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#parameters-1","content":" name (string: &lt;required&gt;) – The name of the LDAP group.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/kerberos/groups/admins   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-response-3","content":" { &quot;data&quot;: { &quot;policies&quot;: [&quot;admin&quot;, &quot;default&quot;] }, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Create/Update Kerberos LDAP group​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#createupdate-kerberos-ldap-group","content":" This endpoint creates or updates LDAP group policies.  Method\tPathPOST\t/auth/kerberos/groups/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#parameters-2","content":" name (string: &lt;required&gt;) – The name of the LDAP group.policies (string: &quot;&quot;) – Comma-separated list of policies associated to the group.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-payload-2","content":" { &quot;policies&quot;: &quot;admin,default&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/kerberos/groups/admins   ","version":"Next","tagName":"h3"},{"title":"Delete Kerberos LDAP group​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#delete-kerberos-ldap-group","content":" This endpoint deletes the LDAP group and policy association.  Method\tPathDELETE\t/auth/kerberos/groups/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#parameters-3","content":" name (string: &lt;required&gt;) – The name of the LDAP group.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/kerberos/groups/admins   ","version":"Next","tagName":"h3"},{"title":"Login with Kerberos​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#login-with-kerberos","content":" This endpoint allows you to log in with a valid Kerberos SPNEGO token. This token is obtained by the client, marshalled, and converted to base 64 using standard encoding.  Example SPNEGO token (newlines added for readability):  YIIFSwYGKwYBBQUCoIIFPzCCBTugDTALBgkqhkiG9xIBAgKiggUoBIIFJGCCBSAGCSq GSIb3EgECAgEAboIFDzCCBQugAwIBBaEDAgEOogcDBQAgAAAAo4IEB2GCBAMwggP/oA MCAQWhDBsKTUFUUklYLkxBTqIvMC2gAwIBA6EmMCQbBEhUVFAbHDdlZmNjZTg4MGVkM y5tYXRyaXgubGFuOjgyMDCjggO3MIIDs6ADAgEXoQMCAQKiggOlBIIDoXky+VDSMXqT Z8XqUiIfzX3+t1ROgO49WYQPoqW1EJLA6vOVtsLITTuDUw8WaLIexki07up3wiO7bKn unPFN3Y6VaKZfGoubVBFnLwrxqiEqytk19fiuc0bUJD5fNX+BUeHjePPmE73kRcuchC L5+WkbY0X37cH5uKwCWI6TxpuEc74+mvmGOdAOdisC31MO6EBnOpTlxvKOXzShVk5Xa rkkHjTJyjoUslgm8JVdj/uB/+x16k0bFVOuWybfeCkn4FY7OeIxypxDJgk6uHU+5jpy XsdXK4w5GG+TK5BI6LXW8ZH6NOhcTZnRyt1/S4Wihd6HKhL8lH6H+wPWAnN4Ym8jiSg 7O0nIkp9su1l/umJWnLnyUdsC9ekKmCYS9MLrmaUREnKMFfrYOF283gWVmfuSWd832Q 9PIE93vUVTfetw1OwbJXEbG7ex3BotXPJ8yaDUAz4Zv0a6zQlj6JutE7LF3JvuuQeot QnwPhrZTrmv7ZbmGO3GmkzbMzIwcTXCCKX8ocOo8GLmtEigAPK23FOW2Y0p1meYjF0U xPzU6MPxfQWiXTWflqabXug7uZh8u76rzSEEceosPxoBqMm6hSmGc85+0bzy/E7AGJM 5ELa2Ny2KpyniPiYCap44GsFZbGM1FwJeh1bG3dJungIn7po4X2wlg00wZVlbHsBzhP Hys0oxVzOQfrvx88G0fH80+vyzQiQAq4ZqmZqkO0zFSsdqG8ReJvpY0eGzN6/lGwcRl eav7Vum/s5MalXhYUdOjB4K3A5yQArHbbLfeZlhb7d4vttzPNkmaZ9ZNTyW1GSuqDtd +YJ0g70aN82KQMWiK3cbJcx/1jcmaN5gjSDm0xk19G2eb8VlRpwLFAazOlpPGozPl0Y PD45h3Yv3AA5aMVXvEi+NvSYR3z9VXxk6A8wFJxV5NZxV2hYwmxt0S+TYXFeudXzT+W ySoykcsxIU6rUevmJlEqZDyD3VcdnUOE9pxrIY/cqpdBBwatorF+jIK/ytcTBjvoM6c LL4g4n/isWMu8Xs6lSMxZzrC3Ewv9VYMzOEFxaHUXlyIC8GCN6t9DHZNzT91TC0u5Rj XuLqXENczg33dACvr+yhvin/0QNBQG+EXz/E4NiBBWqtTFa0BiTVTwyrKL5OyiLcIVe v4l8l9vyj/ABwDacr9ZGjhFbOShCTuFFWBPNnBwPqiRBV4y1gPP4abYBmeboLrUiqwZ 81UrP2L8rCTEtYu9q3GmW/pIHqMIHnoAMCAReigd8EgdxwBViqyCyL0+J/k2bw0upNL h+4wzJcFBFC/wxX2aMvvIYdQv5nWwdNLMII3l/zQ0+eRdzpKfg1ZRT6x0D5278eQLto 9r1CqKNW515u4kD5+pE8VOwZJMVe3FmduaH2gnTLAcoYXkBUE24hcr0ExSY6kTTBWPj U5dsmUsj3+qrN9JruEADqw99t/EWnN3iTsHh1rOQOd9jIJ1wCIkgvnLB8Rad+q5jguG 8qQh1WDObTlNOnezDtiuLtRb03QDo8Q4Sm72IIcLDlffVvl7WAog5TpC8qM97+Wmv0C sWw   Method\tPathPOST\t/auth/kerberos/login  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kerberos auth method (API)","url":"/openbao/api-docs/auth/kerberos/#sample-request-8","content":" $ curl \\ --header &quot;Authorization: Negotiate YIIFSw...sWw&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/auth/kerberos/login  ","version":"Next","tagName":"h3"},{"title":"AppRole auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/approle/","content":"","keywords":"","version":"Next"},{"title":"List roles​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#list-roles","content":" This endpoint returns a list the existing AppRoles in the method.  Method\tPathLIST\t/auth/approle/role  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/approle/role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;dev&quot;, &quot;prod&quot;, &quot;test&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Create/Update AppRole​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#createupdate-approle","content":" Creates a new AppRole or updates an existing AppRole. This endpoint supports both create and update capabilities. There can be one or more constraints enabled on the role. It is required to have at least one of them enabled while creating or updating a role.  Method\tPathPOST\t/auth/approle/role/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes, accepted characters include a-Z, 0-9, space, hyphen, underscore and periods.bind_secret_id (bool: true) - Require secret_id to be presented when logging in using this AppRole.secret_id_bound_cidrs (array: []) - Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can perform the login operation.secret_id_num_uses (integer: 0) - Number of times any particular SecretID can be used to fetch a token from this AppRole, after which the SecretID by default will expire. A value of zero will allow unlimited uses. However, this option may be overridden by the request's 'num_uses' field when generating a SecretID.secret_id_ttl (string: &quot;&quot;) - Duration in either an integer number of seconds (3600) or an integer time unit (60m) after which by default any SecretID expires. A value of zero will allow the SecretID to not expire. However, this option may be overridden by the request's 'ttl' field when generating a SecretID.local_secret_ids (bool: false) - If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload","content":" { &quot;token_ttl&quot;: &quot;10m&quot;, &quot;token_max_ttl&quot;: &quot;15m&quot;, &quot;token_policies&quot;: [&quot;default&quot;], &quot;period&quot;: 0, &quot;bind_secret_id&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1   ","version":"Next","tagName":"h3"},{"title":"Read AppRole​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#read-approle","content":" Reads the properties of an existing AppRole.  Method\tPathGET\t/auth/approle/role/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-1","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/approle/role/application1   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;token_ttl&quot;: 1200, &quot;token_max_ttl&quot;: 1800, &quot;secret_id_ttl&quot;: 600, &quot;secret_id_num_uses&quot;: 40, &quot;token_policies&quot;: [&quot;default&quot;], &quot;period&quot;: 0, &quot;bind_secret_id&quot;: true, &quot;secret_id_bound_cidrs&quot;: [] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Delete AppRole​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#delete-approle","content":" Deletes an existing AppRole from the method.  Method\tPathDELETE\t/auth/approle/role/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-2","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/approle/role/application1   ","version":"Next","tagName":"h3"},{"title":"Read AppRole role ID​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#read-approle-role-id","content":" Reads the RoleID of an existing AppRole.  Method\tPathGET\t/auth/approle/role/:role_name/role-id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-3","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/role-id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-2","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;role_id&quot;: &quot;e5a7b66e-5d08-da9c-7075-71984634b882&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Update AppRole role ID​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#update-approle-role-id","content":" Updates the RoleID of an existing AppRole to a custom value.  Method\tPathPOST\t/auth/approle/role/:role_name/role-id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-4","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.role_id (string: &lt;required&gt;) - Value to be set as RoleID.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-1","content":" { &quot;role_id&quot;: &quot;custom-role-id&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/role-id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-3","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;role_id&quot;: &quot;e5a7b66e-5d08-da9c-7075-71984634b882&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Generate new secret ID​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#generate-new-secret-id","content":" Generates and issues a new SecretID on an existing AppRole. Similar to tokens, the response will also contain a secret_id_accessor value which can be used to read the properties of the SecretID without divulging the SecretID itself, and also to delete the SecretID from the AppRole.  Method\tPathPOST\t/auth/approle/role/:role_name/secret-id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-5","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.metadata (string: &quot;&quot;) - Metadata to be tied to the SecretID. This should be a JSON-formatted string containing the metadata in key-value pairs. This metadata will be set on tokens issued with this SecretID, and is logged in audit logs in plaintext.cidr_list (array: []) - Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. Ifsecret_id_bound_cidrs is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.token_bound_cidrs (array: []) - Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can use the auth tokens generated by this SecretID. Overrides any role-set value but must be a subset.num_uses (integer: 0) - Number of times this SecretID can be used, after which the SecretID expires. A value of zero will allow unlimited uses. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses.ttl (string: &quot;&quot;) - Duration in seconds (3600) or an integer time unit (60m) after which this SecretID expires. A value of zero will allow the SecretID to not expire. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-2","content":" { &quot;metadata&quot;: &quot;{ \\&quot;tag1\\&quot;: \\&quot;production\\&quot; }&quot;, &quot;ttl&quot;: 600, &quot;num_uses&quot;: 50 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/secret-id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-4","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;secret_id_accessor&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot;, &quot;secret_id&quot;: &quot;841771dc-11c9-bbc7-bcac-6a3945a69cd9&quot;, &quot;secret_id_ttl&quot;: 600, &quot;secret_id_num_uses&quot;: 50 }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"List secret ID accessors​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#list-secret-id-accessors","content":" Lists the accessors of all the SecretIDs issued against the AppRole. This includes the accessors for &quot;custom&quot; SecretIDs as well.  Method\tPathLIST\t/auth/approle/role/:role_name/secret-id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-6","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/secret-id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-5","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [ &quot;ce102d2a-8253-c437-bf9a-aceed4241491&quot;, &quot;a1c8dee4-b869-e68d-3520-2040c1a0849a&quot;, &quot;be83b7e2-044c-7244-07e1-47560ca1c787&quot;, &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot;, &quot;239b1328-6523-15e7-403a-a48038cdc45a&quot; ] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read AppRole secret ID​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#read-approle-secret-id","content":" Reads out the properties of a SecretID.  Method\tPathPOST\t/auth/approle/role/:role_name/secret-id/lookup  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-7","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.secret_id (string: &lt;required&gt;) - Secret ID attached to the role.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-3","content":" { &quot;secret_id&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/secret-id/lookup   ","version":"Next","tagName":"h3"},{"title":"Sample Response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-6","content":" { &quot;request_id&quot;: &quot;74752925-f309-6859-3d2d-0fcded95150e&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;cidr_list&quot;: [], &quot;creation_time&quot;: &quot;2023-02-10T18:17:27.089757383Z&quot;, &quot;expiration_time&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;last_updated_time&quot;: &quot;2023-02-10T18:17:27.089757383Z&quot;, &quot;metadata&quot;: { &quot;tag1&quot;: &quot;production&quot; }, &quot;secret_id_accessor&quot;: &quot;2be760a4-86bb-2fa9-1637-1b7fa9ba2896&quot;, &quot;secret_id_num_uses&quot;: 0, &quot;secret_id_ttl&quot;: 0, &quot;token_bound_cidrs&quot;: [] }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Destroy AppRole Secret ID​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#destroy-approle-secret-id","content":" Destroy an AppRole secret ID.  Method\tPathPOST\t/auth/approle/role/:role_name/secret-id/destroy  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-8","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.secret_id (string: &lt;required&gt;) - Secret ID attached to the role.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-4","content":" { &quot;secret_id&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/secret-id/destroy   ","version":"Next","tagName":"h3"},{"title":"Read AppRole secret ID accessor​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#read-approle-secret-id-accessor","content":" Reads out the properties of a SecretID.  Method\tPathPOST\t/auth/approle/role/:role_name/secret-id-accessor/lookup  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-9","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.secret_id_accessor (string: &lt;required&gt;) - Secret ID accessor attached to the role.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-5","content":" { &quot;secret_id_accessor&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/secret-id-accessor/lookup   ","version":"Next","tagName":"h3"},{"title":"Sample Response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-7","content":" { &quot;request_id&quot;: &quot;72836cd1-139c-fe66-1402-8bb5ca4044b8&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;cidr_list&quot;: [], &quot;creation_time&quot;: &quot;2023-02-10T18:17:27.089757383Z&quot;, &quot;expiration_time&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;last_updated_time&quot;: &quot;2023-02-10T18:17:27.089757383Z&quot;, &quot;metadata&quot;: { &quot;tag1&quot;: &quot;production&quot; }, &quot;secret_id_accessor&quot;: &quot;2be760a4-86bb-2fa9-1637-1b7fa9ba2896&quot;, &quot;secret_id_num_uses&quot;: 0, &quot;secret_id_ttl&quot;: 0, &quot;token_bound_cidrs&quot;: [] }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Destroy AppRole Secret ID Accessor​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#destroy-approle-secret-id-accessor","content":" Destroy an AppRole secret ID by its accessor.  Method\tPathPOST\t/auth/approle/role/:role_name/secret-id-accessor/destroy  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-10","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.secret_id_accessor (string: &lt;required&gt;) - Secret ID accessor attached to the role.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-6","content":" { &quot;secret_id_accessor&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/secret-id-accessor/destroy   ","version":"Next","tagName":"h3"},{"title":"Create custom AppRole secret ID​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#create-custom-approle-secret-id","content":" Assigns a &quot;custom&quot; SecretID against an existing AppRole. This is used in the &quot;Push&quot; model of operation.  Method\tPathPOST\t/auth/approle/role/:role_name/custom-secret-id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-11","content":" role_name (string: &lt;required&gt;) - Name of the AppRole. Must be less than 4096 bytes.secret_id (string: &lt;required&gt;) - SecretID to be attached to the Role.metadata (string: &quot;&quot;) - Metadata to be tied to the SecretID. This should be a JSON-formatted string containing the metadata in key-value pairs. This metadata will be set on tokens issued with this SecretID, and is logged in audit logs in plaintext.cidr_list (array: []) - Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. Ifsecret_id_bound_cidrs is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.token_bound_cidrs (array: []) - Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can use the auth tokens generated by this SecretID. Overrides any role-set value but must be a subset.num_uses (integer: 0) - Number of times this SecretID can be used, after which the SecretID expires. A value of zero will allow unlimited uses. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses.ttl (string: &quot;&quot;) - Duration in seconds (3600) or an integer time unit (60m) after which this SecretID expires. A value of zero will allow the SecretID to not expire. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-7","content":" { &quot;secret_id&quot;: &quot;testsecretid&quot;, &quot;ttl&quot;: 600, &quot;num_uses&quot;: 50 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/role/application1/custom-secret-id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-8","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;secret_id&quot;: &quot;testsecretid&quot;, &quot;secret_id_accessor&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot;, &quot;secret_id_ttl&quot;: 600, &quot;secret_id_num_uses&quot;: 50 }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Login with AppRole​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#login-with-approle","content":" Issues an OpenBao token based on the presented credentials. role_id is always required; if bind_secret_id is enabled (the default) on the AppRole,secret_id is required too. Any other bound authentication values on the AppRole (such as client IP CIDR) are also evaluated.  Method\tPathPOST\t/auth/approle/login  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#parameters-12","content":" role_id (string: &lt;required&gt;) - RoleID of the AppRole.secret_id (string: &lt;required&gt;) - SecretID belonging to AppRole.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-payload-8","content":" { &quot;role_id&quot;: &quot;59d6d1ca-47bb-4e7e-a40b-8be3bc5a0ba8&quot;, &quot;secret_id&quot;: &quot;84896a0c-1347-aa90-a4f6-aca8b7558780&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-13","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/approle/login   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-9","content":" { &quot;auth&quot;: { &quot;renewable&quot;: true, &quot;lease_duration&quot;: 1200, &quot;metadata&quot;: null, &quot;token_policies&quot;: [&quot;default&quot;], &quot;accessor&quot;: &quot;fd6c9a00-d2dc-3b11-0be5-af7ae0e1d374&quot;, &quot;client_token&quot;: &quot;5b1a0318-679c-9c45-e5c6-d1b9a9035d49&quot; }, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: null, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read, update, or delete AppRole properties​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#read-update-or-delete-approle-properties","content":" Updates the respective property in the existing AppRole. All of these parameters of the AppRole can be updated using the /auth/approle/role/:role_nameendpoint directly. The endpoints for each field is provided separately to be able to delegate specific endpoints using OpenBao's ACL system.  | Method | Path | | :---------------- | :---------------------------------------------------- | --------- | | GET/POST/DELETE | /auth/approle/role/:role_name/policies | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/secret-id-num-uses | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/secret-id-ttl | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/token-ttl | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/token-max-ttl | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/bind-secret-id | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/secret-id-bound-cidrs | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/token-bound-cidrs | 200/204 | | GET/POST/DELETE | /auth/approle/role/:role_name/period | 200/204 |  Refer to /auth/approle/role/:role_name endpoint.  ","version":"Next","tagName":"h2"},{"title":"Tidy tokens​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#tidy-tokens","content":" Performs some maintenance tasks to clean up invalid entries that may remain in the token store. Generally, running this is not needed unless upgrade notes or support personnel suggest it. This may perform a lot of I/O to the storage method so should be used sparingly.  Method\tPathPOST\t/auth/approle/tidy/secret-id  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/auth/approle/tidy/secret-id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"AppRole auth method (API)","url":"/openbao/api-docs/auth/approle/#sample-response-10","content":" { &quot;request_id&quot;: &quot;b20b56e3-4699-5b19-cc6b-e74f7b787bbf&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;wrap_info&quot;: null, &quot;warnings&quot;: [ &quot;Tidy operation successfully started. Any information from the operation will be printed to OpenBao's server logs.&quot; ], &quot;auth&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"Kubernetes auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Configure method​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#configure-method","content":" The Kubernetes auth method validates service account JWTs and verifies their existence with the Kubernetes TokenReview API. This endpoint configures the public key used to validate the JWT signature and the necessary information to access the Kubernetes API.  Method\tPathPOST\t/auth/kubernetes/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#parameters","content":" kubernetes_host (string: &lt;required&gt;) - Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.kubernetes_ca_cert (string: &quot;&quot;) - PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API. NOTE: Every line must end with a newline: \\nIf not set, the local CA cert will be used if running in a Kubernetes pod.token_reviewer_jwt (string: &quot;&quot;) - A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set, the local service account token is used if running in a Kubernetes pod, otherwise the JWT submitted in the login payload will be used to access the Kubernetes TokenReview API.pem_keys (array: []) - Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.disable_local_ca_jwt (bool: false) - Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod.  ","version":"Next","tagName":"h3"},{"title":"Deprecated parameters​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#deprecated-parameters","content":" info The following fields have been deprecated and will be removed in a future release:  disable_iss_validation (bool: true) Deprecated Disable JWT issuer validation. Allows to skip ISS validation. issuer (string: &quot;&quot;) Deprecated Optional JWT issuer. If no issuer is specified, then this plugin will use kubernetes/serviceaccount as the default issuer. See these instructions for looking up the issuer for a given Kubernetes cluster.  ","version":"Next","tagName":"h3"},{"title":"Caveats​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#caveats","content":" If OpenBao is running in a Kubernetes Pod, the kubernetes_ca_cert andtoken_reviewer_jwt parameters will automatically default to the local CA cert (/var/run/secrets/kubernetes.io/serviceaccount/ca.crt) and local service account JWT (/var/run/secrets/kubernetes.io/serviceaccount/token). This behavior may be disabled by setting disable_local_ca_jwt to true.  When OpenBao is running in a non-Kubernetes environment, eitherkubernetes_ca_cert or pem_keys must be set by the user.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-payload","content":" { &quot;kubernetes_host&quot;: &quot;https://192.168.99.100:8443&quot;, &quot;kubernetes_ca_cert&quot;: &quot;-----BEGIN CERTIFICATE-----\\n.....\\n-----END CERTIFICATE-----&quot;, &quot;pem_keys&quot;: &quot;-----BEGIN CERTIFICATE-----\\n.....\\n-----END CERTIFICATE-----&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/kubernetes/config   ","version":"Next","tagName":"h3"},{"title":"Read config​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#read-config","content":" Returns the previously configured config, excluding credentials.  Method\tPathGET\t/auth/kubernetes/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/kubernetes/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-response","content":" { &quot;data&quot;:{ &quot;kubernetes_host&quot;: &quot;https://192.168.99.100:8443&quot;, &quot;kubernetes_ca_cert&quot;: &quot;-----BEGIN CERTIFICATE-----.....-----END CERTIFICATE-----&quot;, &quot;pem_keys&quot;: [&quot;-----BEGIN CERTIFICATE-----.....&quot;, .....], &quot;disable_local_ca_jwt&quot;: false } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update role​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#createupdate-role","content":" Registers a role in the auth method. Role types have specific entities that can perform login operations against this endpoint. Constraints specific to the role type must be set on the role. These are applied to the authenticated entities attempting to login.  Method\tPathPOST\t/auth/kubernetes/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#parameters-1","content":" name (string: &lt;required&gt;) - Name of the role.bound_service_account_names (array: &lt;required&gt;) - List of service account names able to access this role. If set to &quot;*&quot; all names are allowed.bound_service_account_namespaces (array: &lt;required&gt;) - List of namespaces allowed to access this role. If set to &quot;*&quot; all namespaces are allowed.audience (string: &quot;&quot;) - Optional Audience claim to verify in the JWT.alias_name_source (string: &quot;serviceaccount_uid&quot;) - Configures how identity aliases are generated. Valid choices are: serviceaccount_uid, serviceaccount_nameWhen serviceaccount_uid is specified, the machine generated UID from the service account will be used as the identity alias name. When serviceaccount_name is specified, the service account's namespace and name will be used as the identity alias name e.g openbao/openbao-auth. While it is strongly advised that you use serviceaccount_uid, you may also use serviceaccount_name in cases where you want to set the alias ahead of time, and the risks are mitigated or otherwise acceptable given your use case. It is very important to limit who is able to delete/create service accounts within a given cluster. See the Create an Entity Alias document which further expands on the potential security implications mentioned above.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-payload-1","content":" { &quot;bound_service_account_names&quot;: &quot;openbao-auth&quot;, &quot;bound_service_account_namespaces&quot;: &quot;default&quot;, &quot;policies&quot;: [&quot;dev&quot;, &quot;prod&quot;], &quot;max_ttl&quot;: 1800000 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/kubernetes/role/dev-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#read-role","content":" Returns the previously registered role configuration.  Method\tPathGET\t/auth/kubernetes/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#parameters-2","content":" name (string: &lt;required&gt;) - Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/kubernetes/role/dev-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-response-1","content":" { &quot;data&quot;: { &quot;bound_service_account_names&quot;: &quot;openbao-auth&quot;, &quot;bound_service_account_namespaces&quot;: &quot;default&quot;, &quot;max_ttl&quot;: 1800000, &quot;ttl&quot;: 0, &quot;period&quot;: 0, &quot;policies&quot;: [&quot;dev&quot;, &quot;prod&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"List roles​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#list-roles","content":" Lists all the roles that are registered with the auth method.  Method\tPathLIST\t/auth/kubernetes/role GET\t/auth/kubernetes/role?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/kubernetes/role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-response-2","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;dev-role&quot;, &quot;prod-role&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#delete-role","content":" Deletes the previously registered role.  Method\tPathDELETE\t/auth/kubernetes/role/:role  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#parameters-3","content":" role (string: &lt;required&gt;) - Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/kubernetes/role/dev-role   ","version":"Next","tagName":"h3"},{"title":"Login​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#login","content":" Fetch a token. This endpoint takes a signed JSON Web Token (JWT) and a role name for some entity. It verifies the JWT signature to authenticate that entity and then authorizes the entity for the given role.  Method\tPathPOST\t/auth/kubernetes/login  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#parameters-4","content":" role (string: &lt;required&gt;) - Name of the role against which the login is being attempted.jwt (string: &lt;required&gt;) - Signed JSON Web Token (JWT) for authenticating a service account.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-payload-2","content":" { &quot;role&quot;: &quot;dev-role&quot;, &quot;jwt&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-request-6","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/kubernetes/login   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes auth method (API)","url":"/openbao/api-docs/auth/kubernetes/#sample-response-3","content":" { &quot;auth&quot;: { &quot;client_token&quot;: &quot;62b858f9-529c-6b26-e0b8-0457b6aacdb4&quot;, &quot;accessor&quot;: &quot;afa306d0-be3d-c8d2-b0d7-2676e1c0d9b4&quot;, &quot;policies&quot;: [&quot;default&quot;], &quot;metadata&quot;: { &quot;role&quot;: &quot;test&quot;, &quot;service_account_name&quot;: &quot;openbao-auth&quot;, &quot;service_account_namespace&quot;: &quot;default&quot;, &quot;service_account_secret_name&quot;: &quot;openbao-auth-token-pd21c&quot;, &quot;service_account_uid&quot;: &quot;aa9aa8ff-98d0-11e7-9bb7-0800276d99bf&quot; }, &quot;lease_duration&quot;: 2764800, &quot;renewable&quot;: true } }  ","version":"Next","tagName":"h3"},{"title":"RADIUS auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/radius/","content":"","keywords":"","version":"Next"},{"title":"Configure RADIUS​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#configure-radius","content":" Configures the connection parameters and shared secret used to communicate with RADIUS.  Method\tPathPOST\t/auth/radius/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#parameters","content":" host (string: &lt;required&gt;) - The RADIUS server to connect to. Examples:radius.myorg.com, 127.0.0.1port (integer: 1812) - The UDP port where the RADIUS server is listening on. Defaults is 1812.secret (string: &lt;required&gt;) - The RADIUS shared secret.unregistered_user_policies (string: &quot;&quot;) - A comma-separated list of policies to be granted to unregistered users.dial_timeout (integer: 10) - Number of second to wait for a backend connection before timing out. Default is 10.nas_port (integer: 10) - The NAS-Port attribute of the RADIUS request. Defaults is 10.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-payload","content":" { &quot;host&quot;: &quot;radius.myorg.com&quot;, &quot;port&quot;: 1812, &quot;secret&quot;: &quot;mySecret&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/radius/config   ","version":"Next","tagName":"h3"},{"title":"Register user​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#register-user","content":" Registers a new user and maps a set of policies to it. This path honors the distinction between the create and update capabilities inside ACL policies.  Method\tPathPOST\t/auth/radius/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#parameters-1","content":" username (string: &lt;required&gt;) - Username for this user.policies (string: &quot;&quot;) - Comma-separated list of policies. If set to empty string, only the default policy will be applicable to the user.  { &quot;policies&quot;: &quot;dev,prod&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/radius/users/test-user   ","version":"Next","tagName":"h3"},{"title":"Read user​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#read-user","content":" Reads the properties of an existing username.  Method\tPathGET\t/auth/radius/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#parameters-2","content":" username (string: &lt;required&gt;) - Username for this user.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/radius/users/test-user   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-response","content":" { &quot;request_id&quot;: &quot;812229d7-a82e-0b20-c35b-81ce8c1b9fa6&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;policies&quot;: &quot;default,dev&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Delete user​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#delete-user","content":" Deletes an existing username from the method.  Method\tPathDELETE\t/auth/radius/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#parameters-3","content":" username (string: &lt;required&gt;) - Username for this user.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/radius/users/test-user   ","version":"Next","tagName":"h3"},{"title":"List users​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#list-users","content":" List the users registered with the method.  Method\tPathLIST\t/auth/radius/users  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/radius/users   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;devuser&quot;, &quot;produser&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Login​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#login","content":" Login with the username and password.  Method\tPathPOST\t/auth/radius/login POST\t/auth/radius/login/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#parameters-4","content":" username (string: &lt;required&gt;) - Username for this user.password (string: &lt;required&gt;) - Password for the authenticating user.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-payload-1","content":" { &quot;password&quot;: &quot;Password!&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-request-5","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/radius/login/test-user   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"RADIUS auth method (API)","url":"/openbao/api-docs/auth/radius/#sample-response-2","content":" { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: { &quot;client_token&quot;: &quot;64d2a8f2-2a2f-5688-102b-e6088b76e344&quot;, &quot;accessor&quot;: &quot;18bb8f89-826a-56ee-c65b-1736dc5ea27d&quot;, &quot;policies&quot;: [&quot;default&quot;], &quot;metadata&quot;: { &quot;username&quot;: &quot;vishal&quot; }, }, &quot;lease_duration&quot;: 7200, &quot;renewable&quot;: true }  ","version":"Next","tagName":"h3"},{"title":"LDAP auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/ldap/","content":"","keywords":"","version":"Next"},{"title":"Configure LDAP​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#configure-ldap","content":" This endpoint configures the LDAP auth method.  Method\tPathPOST\t/auth/ldap/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters","content":" url (string: ldap://127.0.0.1) – The LDAP server to connect to. Examples:ldap://ldap.myorg.com, ldaps://ldap.myorg.com:636. Multiple URLs can be specified with commas, e.g. ldap://ldap.myorg.com,ldap://ldap2.myorg.com; these will be tried in-order.case_sensitive_names (bool: false) – If set, user and group names assigned to policies within the backend will be case sensitive. Otherwise, names will be normalized to lower case. Case will still be preserved when sending the username to the LDAP server at login time; this is only for matching local user/group definitions.connection_timeout (integer: 30 or string: &quot;30s&quot;) - Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.request_timeout (integer: 90 or string: &quot;90s&quot;) - Timeout, in seconds, for the connection when making requests against the server before returning back an error.starttls (bool: false) – If true, issues a StartTLS command after establishing an unencrypted connection.tls_min_version (string: tls12) – Minimum TLS version to use. Accepted values are tls10, tls11, tls12 or tls13.tls_max_version (string: tls12) – Maximum TLS version to use. Accepted values are tls10, tls11, tls12 or tls13.insecure_tls (bool: false) – If true, skips LDAP server SSL certificate verification - insecure, use with caution!certificate (string: &quot;&quot;) – CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.client_tls_cert (string &quot;&quot;) - Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional).client_tls_key (string &quot;&quot;) - Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional).binddn (string: &quot;&quot;) – Distinguished name of object to bind when performing user search. Example: cn=openbao,ou=Users,dc=example,dc=combindpass (string: &quot;&quot;) – Password to use along with binddn when performing user search.userdn (string: &quot;&quot;) – Base DN under which to perform user search. Example:ou=Users,dc=example,dc=comuserattr (string: &quot;cn&quot;) – Attribute on user attribute object matching the username passed when authenticating. Examples: sAMAccountName, cn, uiddiscoverdn (bool: false) – Use anonymous bind to discover the bind DN of a user.deny_null_bind (bool: true) – This option prevents users from bypassing authentication when providing an empty password.upndomain (string: &quot;&quot;) – The userPrincipalDomain used to construct the UPN string for the authenticating user. The constructed UPN will appear as[username]@UPNDomain. Example: example.com, which will cause openbao to bind as username@example.com.userfilter (string: &quot;&quot;) – An optional LDAP user search filter. The template can access the following context variables: UserAttr, Username. The default is ({{.UserAttr}}={{.Username}}), or ({{.UserAttr}}={{.Username@.upndomain}})if upndomain is set.anonymous_group_search (bool: false) - Use anonymous binds when performing LDAP group searches (note: even when true, the initial credentials will still be used for the initial connection test).groupfilter (string: &quot;&quot;) – Go template used when constructing the group membership query. The template can access the following context variables: [UserDN, Username]. The default is(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}})), which is compatible with several common directory schemas. To support nested group resolution for Active Directory, instead use the following query: (&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})).groupdn (string: &quot;&quot;) – LDAP search base to use for group membership search. This can be the root containing either groups or users. Example:ou=Groups,dc=example,dc=comgroupattr (string: &quot;&quot;) – LDAP attribute to follow on objects returned bygroupfilter in order to enumerate user group membership. Examples: for groupfilter queries returning group objects, use: cn. For queries returning user objects, use: memberOf. The default is cn.username_as_alias (bool: false) - If set to true, forces the auth method to use the username passed by the user as the alias name.dereference_aliases (string: never) - When aliases should be dereferenced on search operations. Accepted values are 'never', 'finding', 'searching', 'always'. Defaults to 'never'.max_page_size (int: 0) - If set to a value greater than 0, the LDAP backend will use the LDAP server's paged search control to request pages of up to the given size. This can be used to avoid hitting the LDAP server's maximum result size limit. Otherwise, the LDAP backend will not use the paged search control.use_token_groups (bool: true) - (Optional) Use the Active Directory tokenGroups constructed attribute of the user to find the group memberships.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  warning When specifying a userfilter, either the templated value {{.UserAttr}} or the literal value that matches userattr should be present in the filter to ensure that the search returns a unique result that takes userattr into consideration for entity alias mapping purposes and avoid possible collisions on login.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/ldap/config   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-payload","content":" { &quot;binddn&quot;: &quot;cn=openbao,ou=Users,dc=example,dc=com&quot;, &quot;deny_null_bind&quot;: true, &quot;discoverdn&quot;: false, &quot;groupattr&quot;: &quot;cn&quot;, &quot;groupdn&quot;: &quot;ou=Groups,dc=example,dc=com&quot;, &quot;groupfilter&quot;: &quot;(\\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))&quot;, &quot;insecure_tls&quot;: false, &quot;starttls&quot;: false, &quot;tls_max_version&quot;: &quot;tls12&quot;, &quot;tls_min_version&quot;: &quot;tls12&quot;, &quot;url&quot;: &quot;ldaps://ldap.myorg.com:636&quot;, &quot;username_as_alias&quot;: false, &quot;userattr&quot;: &quot;samaccountname&quot;, &quot;userdn&quot;: &quot;ou=Users,dc=example,dc=com&quot;, &quot;max_page_size&quot;: 1000 }   ","version":"Next","tagName":"h3"},{"title":"Read LDAP configuration​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#read-ldap-configuration","content":" This endpoint retrieves the LDAP configuration for the auth method.  Method\tPathGET\t/auth/ldap/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/ldap/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-response","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;binddn&quot;: &quot;cn=openbao,ou=Users,dc=example,dc=com&quot;, &quot;bindpass&quot;: &quot;&quot;, &quot;certificate&quot;: &quot;&quot;, &quot;deny_null_bind&quot;: true, &quot;discoverdn&quot;: false, &quot;groupattr&quot;: &quot;cn&quot;, &quot;groupdn&quot;: &quot;ou=Groups,dc=example,dc=com&quot;, &quot;groupfilter&quot;: &quot;(\\u0026(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))&quot;, &quot;insecure_tls&quot;: false, &quot;starttls&quot;: false, &quot;tls_max_version&quot;: &quot;tls12&quot;, &quot;tls_min_version&quot;: &quot;tls12&quot;, &quot;upndomain&quot;: &quot;&quot;, &quot;url&quot;: &quot;ldaps://ldap.myorg.com:636&quot;, &quot;username_as_alias&quot;: false, &quot;userattr&quot;: &quot;samaccountname&quot;, &quot;userdn&quot;: &quot;ou=Users,dc=example,dc=com&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"List LDAP groups​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#list-ldap-groups","content":" This endpoint returns a list of existing groups in the method.  Method\tPathLIST\t/auth/ldap/groups  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/ldap/groups   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;scientists&quot;, &quot;engineers&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read LDAP group​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#read-ldap-group","content":" This endpoint returns the policies associated with a LDAP group.  Method\tPathGET\t/auth/ldap/groups/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-1","content":" name (string: &lt;required&gt;) – The name of the LDAP group  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/ldap/groups/admins   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-response-2","content":" { &quot;data&quot;: { &quot;policies&quot;: [ &quot;admin&quot;, &quot;default&quot; ] }, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; &quot;lease_duration&quot;: 0, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Create/Update LDAP group​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#createupdate-ldap-group","content":" This endpoint creates or updates LDAP group policies.  Method\tPathPOST\t/auth/ldap/groups/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-2","content":" name (string: &lt;required&gt;) – The name of the LDAP grouppolicies (string: &quot;&quot;) – Comma-separated list of policies associated to the group.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-payload-1","content":" { &quot;policies&quot;: &quot;admin,default&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/ldap/groups/admins   ","version":"Next","tagName":"h3"},{"title":"Delete LDAP group​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#delete-ldap-group","content":" This endpoint deletes the LDAP group and policy association.  Method\tPathDELETE\t/auth/ldap/groups/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-3","content":" name (string: &lt;required&gt;) – The name of the LDAP group  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/ldap/groups/admins   ","version":"Next","tagName":"h3"},{"title":"List LDAP users​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#list-ldap-users","content":" This endpoint returns a list of existing users in the method.  Method\tPathLIST\t/auth/ldap/users  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/ldap/users   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-response-3","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;mitchellh&quot;, &quot;armon&quot;] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read LDAP user​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#read-ldap-user","content":" This endpoint returns the policies associated with a LDAP user.  Method\tPathGET\t/auth/ldap/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-4","content":" username (string: &lt;required&gt;) – The username of the LDAP user  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/ldap/users/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-response-4","content":" { &quot;data&quot;: { &quot;policies&quot;: [ &quot;admin&quot;, &quot;default&quot; ], &quot;groups&quot;: &quot;&quot; }, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; &quot;lease_duration&quot;: 0, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Create/Update LDAP user​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#createupdate-ldap-user","content":" This endpoint creates or updates LDAP users policies and group associations.  Method\tPathPOST\t/auth/ldap/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-5","content":" username (string: &lt;required&gt;) – The username of the LDAP userpolicies (string: &quot;&quot;) – Comma-separated list of policies associated to the user.groups (string: &quot;&quot;) – Comma-separated list of groups associated to the user.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-payload-2","content":" { &quot;policies&quot;: &quot;admin,default&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/ldap/users/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Delete LDAP user​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#delete-ldap-user","content":" This endpoint deletes the LDAP user and policy association.  Method\tPathDELETE\t/auth/ldap/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-6","content":" username (string: &lt;required&gt;) – The username of the LDAP user  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/ldap/users/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Login with LDAP user​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#login-with-ldap-user","content":" This endpoint allows you to log in with LDAP credentials  Method\tPathPOST\t/auth/ldap/login/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#parameters-7","content":" username (string: &lt;required&gt;) – The username of the LDAP userpassword (string: &lt;required&gt;) – The password for the LDAP user  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-payload-3","content":" { &quot;password&quot;: &quot;MyPassword1&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-request-10","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/ldap/login/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP auth method (API)","url":"/openbao/api-docs/auth/ldap/#sample-response-5","content":" { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;auth&quot;: { &quot;client_token&quot;: &quot;c4f280f6-fdb2-18eb-89d3-589e2e834cdb&quot;, &quot;policies&quot;: [&quot;admins&quot;, &quot;default&quot;], &quot;metadata&quot;: { &quot;username&quot;: &quot;mitchellh&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false } }  ","version":"Next","tagName":"h3"},{"title":"Libraries","type":0,"sectionRef":"#","url":"/openbao/api-docs/libraries/","content":"","keywords":"","version":"Next"},{"title":"Official​","type":1,"pageTitle":"Libraries","url":"/openbao/api-docs/libraries/#official","content":" These libraries are officially maintained by OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Go​","type":1,"pageTitle":"Libraries","url":"/openbao/api-docs/libraries/#go","content":" OpenBao Go Client  $ go get github.com/openbao/openbao/api  ","version":"Next","tagName":"h3"},{"title":"Userpass auth method (HTTP API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/userpass/","content":"","keywords":"","version":"Next"},{"title":"Create/Update user​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#createupdate-user","content":" Create a new user or update an existing user. This path honors the distinction between the create and update capabilities inside ACL policies.  Method\tPathPOST\t/auth/userpass/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#parameters","content":" username (string: &lt;required&gt;) – The username for the user. Accepted characters: alphanumeric plus &quot;_&quot;, &quot;-&quot;, &quot;.&quot; (underscore, hyphen and period); username cannot begin with a hyphen, nor can it begin or end with a period.password (string: &lt;required&gt;) - The password for the user. Only required when creating the user.  token_ttl (integer: 0 or string: &quot;&quot;) - The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time.token_max_ttl (integer: 0 or string: &quot;&quot;) - The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.policies (array: [] or comma-delimited string: &quot;&quot;) - DEPRECATED: Please use the token_policies parameter instead. List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-payload","content":" { &quot;password&quot;: &quot;superSecretPassword&quot;, &quot;token_policies&quot;: [&quot;admin&quot;, &quot;default&quot;], &quot;token_bound_cidrs&quot;: [&quot;127.0.0.1/32&quot;, &quot;128.252.0.0/16&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/userpass/users/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Read user​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#read-user","content":" Reads the properties of an existing username.  Method\tPathGET\t/auth/userpass/users/:username  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/userpass/users/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-response","content":" { &quot;request_id&quot;: &quot;0ad1be52-9398-4b3c-f58b-98e427406471&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;token_bound_cidrs&quot;: [ &quot;127.0.0.1&quot;, &quot;128.252.0.0/16&quot; ], &quot;token_explicit_max_ttl&quot;: 0, &quot;token_max_ttl&quot;: 0, &quot;token_no_default_policy&quot;: false, &quot;token_num_uses&quot;: 0, &quot;token_period&quot;: 0, &quot;token_policies&quot;: [ &quot;admin&quot;, &quot;default&quot; ], &quot;token_ttl&quot;: 0, &quot;token_type&quot;: &quot;default&quot; }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Delete user​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#delete-user","content":" This endpoint deletes the user from the method.  Method\tPathDELETE\t/auth/userpass/users/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#parameters-1","content":" username (string: &lt;required&gt;) - The username for the user.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/userpass/users/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Update password on user​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#update-password-on-user","content":" Update password for an existing user.  Method\tPathPOST\t/auth/userpass/users/:username/password  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#parameters-2","content":" username (string: &lt;required&gt;) – The username for the user.password (string: &lt;required&gt;) - The password for the user.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-payload-1","content":" { &quot;password&quot;: &quot;superSecretPassword2&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/userpass/users/mitchellh/password   ","version":"Next","tagName":"h3"},{"title":"Update policies on user​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#update-policies-on-user","content":" Update policies for an existing user.  Method\tPathPOST\t/auth/userpass/users/:username/policies  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#parameters-3","content":" username (string: &lt;required&gt;) – The username for the user.token_policies (array: [] or comma-delimited string: &quot;&quot;) - List of policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-payload-2","content":" { &quot;token_policies&quot;: [&quot;policy1&quot;, &quot;policy2&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/userpass/users/mitchellh/policies   ","version":"Next","tagName":"h3"},{"title":"List users​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#list-users","content":" List available userpass users.  Method\tPathLIST\t/auth/userpass/users  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/userpass/users   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;mitchellh&quot;, &quot;armon&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Login​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#login","content":" Login with the username and password.  Method\tPathPOST\t/auth/userpass/login/:username  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#parameters-4","content":" username (string: &lt;required&gt;) – The username for the user.password (string: &lt;required&gt;) - The password for the user.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-payload-3","content":" { &quot;password&quot;: &quot;superSecretPassword2&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-request-6","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/userpass/login/mitchellh   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Userpass auth method (HTTP API)","url":"/openbao/api-docs/auth/userpass/#sample-response-2","content":" { &quot;request_id&quot;: &quot;ae1882ba-f60a-7629-ce1a-6618c482de3e&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: { &quot;client_token&quot;: &quot;hvs.CAESIJyeFmhLYRWVXPJStT3fDP1ZdFkon_otuk1sJUpkfk_WGh4KHGh2cy5xdW9XVHBnVUwwbzB1ZEhzZkpkRmVoU08&quot;, &quot;accessor&quot;: &quot;iP2Lw1JXpjlALbgJSeIx51n7&quot;, &quot;policies&quot;: [ &quot;default&quot;, &quot;policy1&quot;, &quot;policy2&quot; ], &quot;token_policies&quot;: [ &quot;default&quot;, &quot;policy1&quot;, &quot;policy2&quot; ], &quot;metadata&quot;: { &quot;username&quot;: &quot;mitchellh&quot; }, &quot;lease_duration&quot;: 2764800, &quot;renewable&quot;: true, &quot;entity_id&quot;: &quot;0660dce5-4f2c-926a-8b15-158901557d9d&quot;, &quot;token_type&quot;: &quot;service&quot;, &quot;orphan&quot;: true, &quot;mfa_requirement&quot;: null, &quot;num_uses&quot;: 0 } }  ","version":"Next","tagName":"h3"},{"title":"Secrets engines","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/","content":"Secrets engines Each secrets engine publishes its own set of API paths and methods. These endpoints are documented in this section. secrets engines are enabled at a path, but the documentation will assume the default paths for simplicity. If you are enabled at a different path, you should adjust your API calls accordingly. For the API documentation for a specific secrets engine, please choose a secrets engine from the navigation.","keywords":"","version":"Next"},{"title":"Related tools","type":0,"sectionRef":"#","url":"/openbao/api-docs/relatedtools/","content":"Related tools warning Note: OpenBao intends to remain API compatible with HashiCorp Vault. This means that most of the existing tooling for Vault should also work with OpenBao. OpenBao Agent can render OpenBao secrets either to files or directly into a child process as environment variables using consul-template templating syntaxOpenBao Proxy acts as an API Proxy for OpenBao, and can optionally allow or force interacting clients to use its automatically authenticated token Want to add your own project, or one that you use? Additions are welcome via pull requests.","keywords":"","version":"Next"},{"title":"Cubbyhole secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/cubbyhole/","content":"","keywords":"","version":"Next"},{"title":"Read secret​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#read-secret","content":" This endpoint retrieves the secret at the specified location.  Method\tPathGET\t/cubbyhole/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path of the secret to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/cubbyhole/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-response","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;foo&quot;: &quot;bar&quot; }, &quot;lease_duration&quot;: 0, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"List secrets​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#list-secrets","content":" This endpoint returns a list of secret entries at the specified location. Folders are suffixed with /. The input must be a folder; list on a file will not return a value. The values themselves are not accessible via this command.  Method\tPathLIST\t/cubbyhole/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#parameters-1","content":" path (string: &lt;required&gt;) – Specifies the path of the secrets to list. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/cubbyhole/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-response-1","content":" The example below shows output for a query path of cubbyhole/ when there are secrets at cubbyhole/foo and cubbyhole/foo/bar; note the difference in the two entries.  { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;foo&quot;, &quot;foo/&quot;] }, &quot;lease_duration&quot;: 2764800, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Create/Update secret​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#createupdate-secret","content":" This endpoint stores a secret at the specified location.  Method\tPathPOST\t/cubbyhole/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#parameters-2","content":" path (string: &lt;required&gt;) – Specifies the path of the secrets to create/update. This is specified as part of the URL. :key (string: &quot;&quot;) – Specifies a key in the payload, paired with an associated value, to be held at the given location. Multiple key/value pairs can be specified, and all will be returned on a read operation.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-payload","content":" { &quot;foo&quot;: &quot;bar&quot;, &quot;zip&quot;: &quot;zap&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/cubbyhole/my-secret   ","version":"Next","tagName":"h3"},{"title":"Delete secret​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#delete-secret","content":" This endpoint deletes the secret at the specified location.  Method\tPathDELETE\t/cubbyhole/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#parameters-3","content":" path (string: &lt;required&gt;) – Specifies the path of the secret to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Cubbyhole secrets engine (API)","url":"/openbao/api-docs/secret/cubbyhole/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/cubbyhole/my-secret  ","version":"Next","tagName":"h3"},{"title":"Influxdb database plugin HTTP API","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/databases/influxdb/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"Influxdb database plugin HTTP API","url":"/openbao/api-docs/secret/databases/influxdb/#configure-connection","content":" In addition to the parameters defined by the Database Secrets Engine, this plugin has a number of parameters to further configure a connection.  Method\tPathPOST\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Influxdb database plugin HTTP API","url":"/openbao/api-docs/secret/databases/influxdb/#parameters","content":" host (string: &lt;required&gt;) – Specifies a Influxdb host to connect to. port (int: 8086) – Specifies the default port to use if none is provided as part of the host URI. Defaults to Influxdb's default transport port, 8086. username (string: &lt;required&gt;) – Specifies the username to use for superuser access. password (string: &lt;required&gt;) – Specifies the password corresponding to the given username. tls (bool: true) – Specifies whether to use TLS when connecting to Influxdb. insecure_tls (bool: false) – Specifies whether to skip verification of the server certificate when using TLS. pem_bundle (string: &quot;&quot;) – Specifies concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate. pem_json (string: &quot;&quot;) – Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate. For convenience format is the same as the output of theissue command from the pki secrets engine; seethe pki documentation. connect_timeout (string: &quot;5s&quot;) – Specifies the connection timeout to use. username_template (string) - Template describing how dynamic usernames are generated.  TLS works as follows:  If tls is set to true, the connection will use TLS; this happens automatically if pem_bundle, pem_json, or insecure_tls is set If insecure_tls is set to true, the connection will not perform verification of the server certificate; this also sets tls to true If only issuing_ca is set in pem_json, or the only certificate inpem_bundle is a CA certificate, the given CA certificate will be used for server certificate verification; otherwise the system CA certificates will be used If certificate and private_key are set in pem_bundle or pem_json, client auth will be turned on for the connection  pem_bundle should be a PEM-concatenated bundle of a private key + client certificate, an issuing CA certificate, or both. pem_json should contain the same information; for convenience, the JSON format is the same as that output by the issue command from the PKI secrets engine.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Influxdb database plugin HTTP API","url":"/openbao/api-docs/secret/databases/influxdb/#sample-payload","content":" { &quot;plugin_name&quot;: &quot;influxdb-database-plugin&quot;, &quot;allowed_roles&quot;: &quot;readonly&quot;, &quot;host&quot;: &quot;influxdb1.local&quot;, &quot;username&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Influxdb database plugin HTTP API","url":"/openbao/api-docs/secret/databases/influxdb/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/influxdb/config/connection   ","version":"Next","tagName":"h3"},{"title":"Statements​","type":1,"pageTitle":"Influxdb database plugin HTTP API","url":"/openbao/api-docs/secret/databases/influxdb/#statements","content":" Statements are configured during role creation and are used by the plugin to determine what is sent to the database on user creation, renewing, and revocation. For more information on configuring roles see the Role API in the database secrets engine docs.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Influxdb database plugin HTTP API","url":"/openbao/api-docs/secret/databases/influxdb/#parameters-1","content":" The following are the statements used by this plugin. If not mentioned in this list the plugin does not support that statement type.  creation_statements (list: []) – Specifies the database statements executed to create and configure a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} and {{password}} values will be substituted. If not provided, defaults to a generic create user statements that creates a non-superuser. revocation_statements (list: []) – Specifies the database statements to be executed to revoke a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} value will be substituted. If not provided defaults to a generic drop user statement. rollback_statements (list: []) – Specifies the database statements to be executed to rollback a create operation in the event of an error. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} value will be substituted. If not provided, defaults to a generic drop user statement. ","version":"Next","tagName":"h3"},{"title":"Cassandra database plugin HTTP API","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/databases/cassandra/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"Cassandra database plugin HTTP API","url":"/openbao/api-docs/secret/databases/cassandra/#configure-connection","content":" In addition to the parameters defined by the Database Secrets Engine, this plugin has a number of parameters to further configure a connection.  Method\tPathPOST\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Cassandra database plugin HTTP API","url":"/openbao/api-docs/secret/databases/cassandra/#parameters","content":" hosts (string: &lt;required&gt;) – Specifies a set of comma-delineated Cassandra hosts to connect to. port (int: 9042) – Specifies the default port to use if none is provided as part of the host URI. Defaults to Cassandra's default transport port, 9042. username (string: &lt;required&gt;) – Specifies the username to use for superuser access. password (string: &lt;required&gt;) – Specifies the password corresponding to the given username. tls (bool: true) – Specifies whether to use TLS when connecting to Cassandra. insecure_tls (bool: false) – Specifies whether to skip verification of the server certificate when using TLS. tls_server_name (string: &quot;&quot;) – Specifies the name to use as the SNI host when connecting to the Cassandra server via TLS. pem_bundle (string: &quot;&quot;) – Specifies concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate. Only one of pem_bundle or pem_json can be specified. pem_json (string: &quot;&quot;) – Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate. The value in this field must be an encoded JSON object. For convenience format is the same as the output of the issue command from the pki secrets engine; seethe pki documentation. Only one of pem_bundle or pem_json can be specified.  pem_json example { &quot;certificate&quot;: &quot;&lt;client certificate as a PEM&gt;&quot;, &quot;private_key&quot;: &quot;&lt;private key as a PEM&gt;&quot;, &quot;ca_chain&quot;: [&quot;&lt;CA as a PEM&gt;&quot;, &quot;&lt;Additional PEM for the CA chain if needed&quot;] } If using the OpenBao CLI, it's probably easiest to write the JSON to a file and then reference the file: openbao write database/config/cassandra-example &lt;...other fields&gt; pem_json=@/path/to/file.json   skip_verification (bool: false) - Skip permissions checks when a connection to Cassandra is first created. These checks ensure that OpenBao is able to create roles, but can be resource intensive in clusters with many roles. protocol_version (int: 2) – Specifies the CQL protocol version to use. connect_timeout (string: &quot;5s&quot;) – Specifies the timeout to use, both for connections and in general. local_datacenter (string: &quot;&quot;) – If set, enables host selection policy which will prioritize and use hosts which are in the local datacenter before hosts in all other datacenters (for example dc-01). socket_keep_alive (string: &quot;0s&quot;) – the keep-alive period for an active network connection. If zero, keep-alives are not enabled. consistency (string: &quot;&quot;) – Specifies the consistency option to use. See the gocql definition for valid options. username_template (string) - Template describing how dynamic usernames are generated.  Default Username Template {{ printf &quot;v_%s_%s_%s_%s&quot; (.DisplayName | truncate 15) (.RoleName | truncate 15) (random 20) (unix_time) | truncate 100 | replace &quot;-&quot; &quot;_&quot; | lowercase }} Example Usernames: Example\tDisplayName\ttoken RoleName\tmyrolename Username\tv_token_myrolename_uszt1n4cyhal4m0xtgx3_1614294836Example\tDisplayName\tamuchlonger_dispname RoleName\trole-name-with-dashes Username\tv_amuchlonger_dis_role_name_with__s0t9xb0jsab9nqz7yj40_1614294836  TLS works as follows:  If tls is set to true, the connection will use TLS; this happens automatically if pem_bundle, pem_json, or insecure_tls is set If insecure_tls is set to true, the connection will not perform verification of the server certificate; this also sets tls to true If only issuing_ca is set in pem_json, or the only certificate inpem_bundle is a CA certificate, the given CA certificate will be used for server certificate verification; otherwise the system CA certificates will be used If certificate and private_key are set in pem_bundle or pem_json, client auth will be turned on for the connection  pem_bundle should be a PEM-concatenated bundle of a private key + client certificate, an issuing CA certificate, or both. pem_json should contain the same information; for convenience, the JSON format is the same as that output by the issue command from the PKI secrets engine.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Cassandra database plugin HTTP API","url":"/openbao/api-docs/secret/databases/cassandra/#sample-payload","content":" { &quot;plugin_name&quot;: &quot;cassandra-database-plugin&quot;, &quot;allowed_roles&quot;: &quot;readonly&quot;, &quot;hosts&quot;: &quot;cassandra1.local&quot;, &quot;username&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Cassandra database plugin HTTP API","url":"/openbao/api-docs/secret/databases/cassandra/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/cassandra/config/connection   ","version":"Next","tagName":"h3"},{"title":"Statements​","type":1,"pageTitle":"Cassandra database plugin HTTP API","url":"/openbao/api-docs/secret/databases/cassandra/#statements","content":" Statements are configured during role creation and are used by the plugin to determine what is sent to the database on user creation, renewing, and revocation. For more information on configuring roles see the Role API in the database secrets engine docs.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Cassandra database plugin HTTP API","url":"/openbao/api-docs/secret/databases/cassandra/#parameters-1","content":" The following are the statements used by this plugin. If not mentioned in this list the plugin does not support that statement type.  creation_statements (list: []) – Specifies the database statements executed to create and configure a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} and {{password}} values will be substituted. If not provided, defaults to a generic create user statements that creates a non-superuser. revocation_statements (list: []) – Specifies the database statements to be executed to revoke a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} value will be substituted. If not provided defaults to a generic drop user statement. rollback_statements (list: []) – Specifies the database statements to be executed to rollback a create operation in the event of an error. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} value will be substituted. If not provided, defaults to a generic drop user statement root_rotation_statements (list: []) - Specifies the database statements to be executed when rotating the root user's password. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{username}} value will be substituted. If not provided, defaults to a reasonable default alter user statement. ","version":"Next","tagName":"h3"},{"title":"MySQL/MariaDB database plugin HTTP API","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/databases/mysql-maria/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"MySQL/MariaDB database plugin HTTP API","url":"/openbao/api-docs/secret/databases/mysql-maria/#configure-connection","content":" In addition to the parameters defined by the Database Backend, this plugin has a number of parameters to further configure a connection.  Method\tPathPOST\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"MySQL/MariaDB database plugin HTTP API","url":"/openbao/api-docs/secret/databases/mysql-maria/#parameters","content":" connection_url (string: &lt;required&gt;) - Specifies the MySQL DSN. This field can be templated and supports passing the username and password parameters in the following format {{field_name}}. A templated connection URL is required when using root credential rotation. max_open_connections (int: 4) - Specifies the maximum number of open connections to the database. max_idle_connections (int: 0) - Specifies the maximum number of idle connections to the database. A zero uses the value of max_open_connectionsand a negative value disables idle connections. If larger thanmax_open_connections it will be reduced to be equal. max_connection_lifetime (string: &quot;0s&quot;) - Specifies the maximum amount of time a connection may be reused. If ≤ 0s connections are reused forever. username (string: &quot;&quot;) - The root credential username used in the connection URL. password (string: &quot;&quot;) - The root credential password used in the connection URL. tls_certificate_key (string: &quot;&quot;) - x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined. tls_ca (string: &quot;&quot;) - x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded. tls_server_name (string: &quot;&quot;) - Specifies the subject alternative name should be present in the server's certificate. tls_skip_verify (boolean: false) - When set to true, disables the server certificate verification. Setting this to true is not recommended for production. username_template (string) - Template describing how dynamic usernames are generated. disable_escaping (boolean: false) - Turns off the escaping of special characters inside of the username and password fields. See the databases secrets engine docsfor more information. Defaults to false.  Default Username Templates:  mysql-database-plugin {{ printf &quot;v-%s-%s-%s-%s&quot; (.DisplayName | truncate 10) (.RoleName | truncate 10) (random 20) (unix_time) | truncate 32 }} Example Usernames: Example\tDisplayName\ttoken RoleName\tmyrolename Username\tv-token-myrolename-jNFRlKsZZMxJEExample\tDisplayName\tamuchlonger_dispname RoleName\trole-name-with-dashes Username\tv-amuchlonge-role-name--LUHU9xqm    mysql-aurora-database-plugin, mysql-rds-database-plugin, mysql-legacy-database-plugin {{ printf &quot;v-%s-%s-%s&quot; (.RoleName | truncate 4) (random 20) | truncate 16 }} Example Usernames: Example\tDisplayName\ttoken RoleName\tmyrolename Username\tv-myro-jNFRlKsZZExample\tDisplayName\tamuchlonger_dispname RoleName\trole-name-with-dashes Username\tv-role-b9ODeKsfl  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"MySQL/MariaDB database plugin HTTP API","url":"/openbao/api-docs/secret/databases/mysql-maria/#sample-payload","content":" { &quot;plugin_name&quot;: &quot;mysql-database-plugin&quot;, &quot;allowed_roles&quot;: &quot;readonly&quot;, &quot;connection_url&quot;: &quot;{{username}}:{{password}}@tcp(127.0.0.1:3306)/&quot;, &quot;max_open_connections&quot;: 5, &quot;max_connection_lifetime&quot;: &quot;5s&quot;, &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;mysql&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"MySQL/MariaDB database plugin HTTP API","url":"/openbao/api-docs/secret/databases/mysql-maria/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/database/config/mysql   ","version":"Next","tagName":"h3"},{"title":"Statements​","type":1,"pageTitle":"MySQL/MariaDB database plugin HTTP API","url":"/openbao/api-docs/secret/databases/mysql-maria/#statements","content":" Statements are configured during role creation and are used by the plugin to determine what is sent to the database on user creation, renewing, and revocation. For more information on configuring roles see the Role API in the database secrets engine docs.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"MySQL/MariaDB database plugin HTTP API","url":"/openbao/api-docs/secret/databases/mysql-maria/#parameters-1","content":" The following are the statements used by this plugin. If not mentioned in this list the plugin does not support that statement type.  creation_statements (list: &lt;required&gt;) – Specifies the database statements executed to create and configure a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}} and {{password}} values will be substituted. The generated password will be a random alphanumeric 20 character string. revocation_statements (list: []) – Specifies the database statements to be executed to revoke a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}} value will be substituted. If not provided defaults to a generic drop user statement. ","version":"Next","tagName":"h3"},{"title":"Database secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/databases/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#configure-connection","content":" This endpoint configures the connection string used to communicate with the desired database. In addition to the parameters listed here, each Database plugin has additional, database plugin specific, parameters for this endpoint. Please read the HTTP API for the plugin you'd wish to configure to see the full list of additional parameters.  warning This endpoint distinguishes between create and update ACL capabilities.  Method\tPathPOST\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name for this database connection. This is specified as part of the URL. plugin_name (string: &lt;required&gt;) - Specifies the name of the plugin to use for this connection. plugin_version (string: &quot;&quot;) - Specifies the semantic version of the plugin to use for this connection. verify_connection (bool: true) – Specifies if the connection is verified during initial configuration. Defaults to true. allowed_roles (list: []) - List of the roles allowed to use this connection. Defaults to empty (no roles), if contains a * any role can use this connection. root_rotation_statements (list: []) - Specifies the database statements to be executed to rotate the root user's credentials. See the plugin's API page for more information on support and formatting for this parameter. password_policy (string: &quot;&quot;) - The name of thepassword policy to use when generating passwords for this database. If not specified, this will use a default policy defined as: 20 characters with at least 1 uppercase, 1 lowercase, 1 number, and 1 dash character.  warning We highly recommended that you use an OpenBao-specific user rather than the admin user in your database when configuring the plugin. This user will be used to create/update/delete users within the database so it will need to have the appropriate permissions to do so. If the plugin supportsrotating the root credentials, we highly recommended you perform that action after configuring the plugin. This will change the password of the user configured in this step. The new password will not be viewable by users.  ","version":"Next","tagName":"h3"},{"title":"Common fields​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#common-fields","content":" There are several common fields that you will see across many of the database plugins. Please reference the individual plugin documentation for details on whether these fields are supported and any additional details about them.  connection_url (string) - Specifies the connection string used to connect to the database. Some plugins use url rather than connection_url. This allows for simple templating of the username and password of the root user. Typically, this is done by including a {{username}}, {{name}}, and/or {{password}} field within the string. These fields are typically be replaced with the values in the username andpassword fields. username (string) - Specifies the name of the user to use as the &quot;root&quot; user when connecting to the database. This &quot;root&quot; user is used to create/update/delete users managed by these plugins, so you will need to ensure that this user has permissions to manipulate users appropriate to the database. This is typically used in theconnection_url field via the templating directive {{username}} or {{name}}. password (string) - Specifies the password to use when connecting with theusername. This value will not be returned by OpenBao when performing a read upon the configuration. This is typically used in the connection_url field via the templating directive {{password}}. disable_escaping (boolean: false) - Determines whether special characters in the username and password fields will be escaped. Useful for alternate connection string formats like ADO. More information regarding this parameter can be found on thedatabases secrets engine docs.Defaults to false.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-payload","content":" { &quot;plugin_name&quot;: &quot;mysql-database-plugin&quot;, &quot;allowed_roles&quot;: &quot;readonly&quot;, &quot;connection_url&quot;: &quot;{{username}}:{{password}}@tcp(127.0.0.1:3306)/&quot;, &quot;username&quot;: &quot;openbaouser&quot;, &quot;password&quot;: &quot;secretpassword&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample cURL request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-curl-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/database/config/mysql   ","version":"Next","tagName":"h3"},{"title":"Sample CLI request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-cli-request","content":" $ openbao write database/config/mysql \\ plugin_name=&quot;mysql-database-plugin&quot; \\ allowed_roles=&quot;readonly&quot; \\ connection_url=&quot;{{username}}:{{password}}@tcp(127.0.0.1:3306)/&quot; \\ username=&quot;openbaouser&quot; \\ password=&quot;secretpassword&quot;   ","version":"Next","tagName":"h3"},{"title":"Sample CLI request with ADO-style connection string​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-cli-request-with-ado-style-connection-string","content":" $ openbao write database/config/mysql \\ plugin_name=&quot;mysql-database-plugin&quot; \\ connection_url='server=localhost;port=3306;user id={{username}};password={{password}};database=mysql;' \\ username=&quot;openbaouser&quot; \\ password='your#StrongPassword%' \\ disable_escaping=&quot;true&quot;   ","version":"Next","tagName":"h3"},{"title":"Read connection​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#read-connection","content":" This endpoint returns the configuration settings for a connection.  Method\tPathGET\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the connection to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/database/config/mysql   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response","content":" { &quot;data&quot;: { &quot;allowed_roles&quot;: [&quot;readonly&quot;], &quot;connection_details&quot;: { &quot;connection_url&quot;: &quot;{{username}}:{{password}}@tcp(127.0.0.1:3306)/&quot;, &quot;username&quot;: &quot;openbaouser&quot; }, &quot;password_policy&quot;: &quot;&quot;, &quot;plugin_name&quot;: &quot;mysql-database-plugin&quot;, &quot;plugin_version&quot;: &quot;&quot;, &quot;root_credentials_rotate_statements&quot;: [] } }   ","version":"Next","tagName":"h3"},{"title":"List connections​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#list-connections","content":" This endpoint returns a list of available connections. Only the connection names are returned, not any values.  Method\tPathLIST\t/database/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/database/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;db-one&quot;, &quot;db-two&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Delete connection​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#delete-connection","content":" This endpoint deletes a connection.  Method\tPathDELETE\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the connection to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/database/config/mysql   ","version":"Next","tagName":"h3"},{"title":"Reset connection​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#reset-connection","content":" This endpoint closes a connection and it's underlying plugin and restarts it with the configuration stored in the barrier.  Method\tPathPOST\t/database/reset/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-3","content":" name (string: &lt;required&gt;) – Specifies the name of the connection to reset. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/database/reset/mysql   ","version":"Next","tagName":"h3"},{"title":"Rotate root credentials​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#rotate-root-credentials","content":" This endpoint is used to rotate the &quot;root&quot; user credentials stored for the database connection. This user must have permissions to update its own password.  Method\tPathPOST\t/database/rotate-root/:name  danger Use caution: the root user's password will not be accessible once rotated so it is highly recommended that you create a user for OpenBao to utilize rather than using the actual root user.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-4","content":" name (string: &lt;required&gt;) – Specifies the name of the connection to rotate. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/database/rotate-root/mysql   ","version":"Next","tagName":"h3"},{"title":"Create role​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#create-role","content":" This endpoint creates or updates a role definition.  warning This endpoint distinguishes between create and update ACL capabilities.  Method\tPathPOST\t/database/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-5","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create. This is specified as part of the URL. db_name (string: &lt;required&gt;) - The name of the database connection to use for this role. default_ttl (string/int: 0) - Specifies the TTL for the leases associated with this role. Accepts time suffixed strings (1h) or an integer number of seconds. Defaults to system/engine default TTL time. max_ttl (string/int: 0) - Specifies the maximum TTL for the leases associated with this role. Accepts time suffixed strings (1h) or an integer number of seconds. Defaults to sys/mounts's default TTL time; this value is allowed to be less than the mount max TTL (or, if not set, the system max TTL), but it is not allowed to be longer. See also The TTL General Case. creation_statements (list: &lt;required&gt;) – Specifies the database statements executed to create and configure a user. See the plugin's API page for more information on support and formatting for this parameter. revocation_statements (list: []) – Specifies the database statements to be executed to revoke a user. See the plugin's API page for more information on support and formatting for this parameter. rollback_statements (list: []) – Specifies the database statements to be executed to rollback a create operation in the event of an error. Not every plugin type will support this functionality. See the plugin's API page for more information on support and formatting for this parameter. renew_statements (list: []) – Specifies the database statements to be executed to renew a user. Not every plugin type will support this functionality. See the plugin's API page for more information on support and formatting for this parameter.  credential_type (string: &quot;password&quot;) – Specifies the type of credential that will be generated for the role. Options include: password, rsa_private_key, client_certificate. See the plugin's API page for credential types supported by individual databases. credential_config (map&lt;string|string&gt;: &lt;optional&gt;) – Specifies the configuration for the given credential_type. The following options are available for each credential_type value: password password_policy (string: &lt;optional&gt;) - The policyused for password generation. If not provided, defaults to the password policy of the database configuration. rsa_private_key key_bits (int: 2048) - The bit size of the RSA key to generate. Options include:2048, 3072, 4096.format (string: &quot;pkcs8&quot;) - The output format of the generated private key credential. The private key will be returned from the API in PEM encoding. Options include: pkcs8. client_certificate common_name_template (string: &quot;&quot;) - A username templateto be used for the client certificate common name.ca_cert (string: &quot;&quot;) - The PEM-encoded CA certificate.ca_private_key (string: &quot;&quot;) - The PEM-encoded private key for the given ca_cert.key_type (string: &lt;required&gt;&quot;) - Specifies the desired key type. Options include:rsa, ed25519, ec.key_bits (int: 2048) - Number of bits to use for the generated keys. Options include:2048 (default), 3072, 4096; with key_type=ec, allowed values are: 224, 256 (default),384, 521; ignored with key_type=ed25519.signature_bits (int: 256) - The number of bits to use in the signature algorithm. Options include:256 (default), 384, 512.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-payload-1","content":" { &quot;db_name&quot;: &quot;mysql&quot;, &quot;creation_statements&quot;: [ &quot;CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}'&quot;, &quot;GRANT SELECT ON *.* TO '{{name}}'@'%'&quot; ], &quot;default_ttl&quot;: &quot;1h&quot;, &quot;max_ttl&quot;: &quot;24h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/database/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#read-role","content":" This endpoint queries the role definition.  Method\tPathGET\t/database/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-6","content":" name (string: &lt;required&gt;) – Specifies the name of the role to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/database/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-2","content":" { &quot;data&quot;: { &quot;creation_statements&quot;: [ &quot;CREATE ROLE \\&quot;{{name}}\\&quot; WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';&quot;, &quot;GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\&quot;{{name}}\\&quot;;&quot; ], &quot;credential_type&quot;: &quot;password&quot;, &quot;db_name&quot;: &quot;mysql&quot;, &quot;default_ttl&quot;: 3600, &quot;max_ttl&quot;: 86400, &quot;renew_statements&quot;: [], &quot;revocation_statements&quot;: [], &quot;rollback_statements&quot;: [] } }   ","version":"Next","tagName":"h3"},{"title":"List roles​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#list-roles","content":" This endpoint returns a list of available roles. Only the role names are returned, not any values.  Method\tPathLIST\t/database/roles  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/database/roles   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-3","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;dev&quot;, &quot;prod&quot;] }, &quot;lease_duration&quot;: 2764800, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#delete-role","content":" This endpoint deletes the role definition.  Method\tPathDELETE\t/database/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-7","content":" name (string: &lt;required&gt;) – Specifies the name of the role to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/database/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Generate credentials​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#generate-credentials","content":" This endpoint generates a new set of dynamic credentials based on the named role.  Method\tPathGET\t/database/creds/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-8","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create credentials against. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/database/creds/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-4","content":" { &quot;data&quot;: { &quot;username&quot;: &quot;root-1430158508-126&quot;, &quot;password&quot;: &quot;132ae3ef-5a64-7499-351e-bfe59f3a2a21&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Create static role​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#create-static-role","content":" This endpoint creates or updates a static role definition. Static Roles are a 1-to-1 mapping of an OpenBao Role to a user in a database which are automatically rotated based on the configured rotation_period.  warning This endpoint distinguishes between create and update ACL capabilities.  warning OpenBao will rotate the password when creating a static role. OpenBao must do this in order to know the password.  Method\tPathPOST\t/database/static-roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-9","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create. This is specified as part of the URL. username (string: &lt;required&gt;) – Specifies the database username that this OpenBao role corresponds to. rotation_period (string/int: &lt;required&gt;) – Specifies the amount of time OpenBao should wait before rotating the password. The minimum is 5 seconds. db_name (string: &lt;required&gt;) - The name of the database connection to use for this role. rotation_statements (list: []) – Specifies the database statements to be executed to rotate the password for the configured database user. Not every plugin type will support this functionality. See the plugin's API page for more information on support and formatting for this parameter.  credential_type (string: &quot;password&quot;) – Specifies the type of credential that will be generated for the role. Options include: password, rsa_private_key, client_certificate. See the plugin's API page for credential types supported by individual databases. credential_config (map&lt;string|string&gt;: &lt;optional&gt;) – Specifies the configuration for the given credential_type. The following options are available for each credential_type value: password password_policy (string: &lt;optional&gt;) - The policyused for password generation. If not provided, defaults to the password policy of the database configuration. rsa_private_key key_bits (int: 2048) - The bit size of the RSA key to generate. Options include:2048, 3072, 4096.format (string: &quot;pkcs8&quot;) - The output format of the generated private key credential. The private key will be returned from the API in PEM encoding. Options include: pkcs8. client_certificate common_name_template (string: &quot;&quot;) - A username templateto be used for the client certificate common name.ca_cert (string: &quot;&quot;) - The PEM-encoded CA certificate.ca_private_key (string: &quot;&quot;) - The PEM-encoded private key for the given ca_cert.key_type (string: &lt;required&gt;&quot;) - Specifies the desired key type. Options include:rsa, ed25519, ec.key_bits (int: 2048) - Number of bits to use for the generated keys. Options include:2048 (default), 3072, 4096; with key_type=ec, allowed values are: 224, 256 (default),384, 521; ignored with key_type=ed25519.signature_bits (int: 256) - The number of bits to use in the signature algorithm. Options include:256 (default), 384, 512.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-payload-2","content":" { &quot;db_name&quot;: &quot;mysql&quot;, &quot;username&quot;: &quot;static-database-user&quot;, &quot;rotation_statements&quot;: [ &quot;ALTER USER \\&quot;{{name}}\\&quot; IDENTIFIED BY '{{password}}';&quot; ], &quot;rotation_period&quot;: &quot;1h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/database/static-roles/my-static-role   ","version":"Next","tagName":"h3"},{"title":"Read static role​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#read-static-role","content":" This endpoint queries the static role definition.  Method\tPathGET\t/database/static-roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-10","content":" name (string: &lt;required&gt;) – Specifies the name of the static role to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/database/static-roles/my-static-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-5","content":" { &quot;data&quot;: { &quot;credential_type&quot;: &quot;password&quot;, &quot;db_name&quot;: &quot;mysql&quot;, &quot;username&quot;: &quot;static-user&quot;, &quot;rotation_statements&quot;: [ &quot;ALTER USER \\&quot;{{name}}\\&quot; IDENTIFIED BY '{{password}}';&quot; ], &quot;rotation_period&quot;: &quot;1h&quot; } }   ","version":"Next","tagName":"h3"},{"title":"List static roles​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#list-static-roles","content":" This endpoint returns a list of available static roles. Only the role names are returned, not any values.  Method\tPathLIST\t/database/static-roles  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/database/static-roles   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-6","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;dev-static&quot;, &quot;prod-static&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Delete static role​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#delete-static-role","content":" This endpoint deletes the static role definition. The user, having been defined externally, must be cleaned up manually.  Method\tPathDELETE\t/database/static-roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-11","content":" name (string: &lt;required&gt;) – Specifies the name of the static role to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-13","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/database/static-roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Get static credentials​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#get-static-credentials","content":" This endpoint returns the current credentials based on the named static role.  Method\tPathGET\t/database/static-creds/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-12","content":" name (string: &lt;required&gt;) – Specifies the name of the static role to get credentials for. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/database/static-creds/my-static-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-response-7","content":" { &quot;data&quot;: { &quot;username&quot;: &quot;static-user&quot;, &quot;password&quot;: &quot;132ae3ef-5a64-7499-351e-bfe59f3a2a21&quot;, &quot;last_openbao_rotation&quot;: &quot;2019-05-06T15:26:42.525302-05:00&quot;, &quot;rotation_period&quot;: 30, &quot;ttl&quot;: 28 } }   ","version":"Next","tagName":"h3"},{"title":"Rotate static role credentials​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#rotate-static-role-credentials","content":" This endpoint is used to rotate the Static Role credentials stored for a given role name. While Static Roles are rotated automatically by OpenBao at configured rotation periods, users can use this endpoint to manually trigger a rotation to change the stored password and reset the TTL of the Static Role's password.  Method\tPathPOST\t/database/rotate-role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#parameters-13","content":" name (string: &lt;required&gt;) – Specifies the name of the Static Role to trigger the password rotation for. The name is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Database secrets engine (API)","url":"/openbao/api-docs/secret/databases/#sample-request-15","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/database/rotate-role/my-static-role  ","version":"Next","tagName":"h3"},{"title":"Token auth method (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/auth/token/","content":"","keywords":"","version":"Next"},{"title":"List accessors​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#list-accessors","content":" This endpoint lists token accessor. This requires sudo capability, and access to it should be tightly controlled as the accessors can be used to revoke very large numbers of tokens and their associated leases at once.  Method\tPathLIST\t/auth/token/accessors  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/auth/token/accessors   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response","content":" { &quot;auth&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [ &quot;476ea048-ded5-4d07-eeea-938c6b4e43ec&quot;, &quot;bb00c093-b7d3-b0e9-69cc-c4d85081165b&quot; ] }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;lease_id&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Create token​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#create-token","content":" Creates a new token. Certain options are only available when called by a root token. If used via the /auth/token/create-orphan endpoint, a root token is not required to create an orphan token (otherwise set with theno_parent option). If used with a role name in the path, the token will be created against the specified role name; this may override options set during this call.  Method\tPathPOST\t/auth/token/create POST\t/auth/token/create-orphan POST\t/auth/token/create/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters","content":" id (string: &quot;&quot;) – The ID of the client token. Can only be specified by a root token. The ID provided may not contain a . character. Otherwise, the token ID is a randomly generated value. Note: The ID should not start with the s. prefix. role_name (string: &quot;&quot;) – The name of the token role. policies (array: &quot;&quot;) – A list of policies for the token. This must be a subset of the policies belonging to the token making the request, unless the calling token is root or contains sudo capabilities to auth/token/create. If not specified, defaults to all the policies of the calling token. meta (map: {}) – A map of string to string valued metadata. This is passed through to the audit devices. no_parent (bool: false) - This argument only has effect if used by a root or sudo caller. When set to true, the token created will not have a parent. no_default_policy (bool: false) - If true the default policy will not be contained in this token's policy set. renewable (bool: true) - Set to false to disable the ability of the token to be renewed past its initial TTL. Setting the value to true will allow the token to be renewable up to the system/mount maximum TTL. lease (string: &quot;&quot;) - DEPRECATED; use ttl instead ttl (string: &quot;&quot;) - The TTL period of the token, provided as &quot;1h&quot;, where hour is the largest suffix. If not provided, the token is valid for thedefault lease TTL, or indefinitely if the root policy is used. type (string: &quot;&quot;) - The token type. Can be &quot;batch&quot; or &quot;service&quot;. Defaults to the type specified by the role configuration named by role_name. explicit_max_ttl (string: &quot;&quot;) - If set, the token will have an explicit max TTL set upon it. This maximum token TTL cannot be changed later, and unlike with normal tokens, updates to the system/mount max TTL value will have no effect at renewal time -- the token will never be able to be renewed or used past the value set at issue time. display_name (string: &quot;token&quot;) - The display name of the token. num_uses (integer: 0) - The maximum uses for the given token. This can be used to create a one-time-token or limited use token. The value of 0 has no limit to the number of uses. period (string: &quot;&quot;) - If specified, the token will be periodic; it will have no maximum TTL (unless an &quot;explicit-max-ttl&quot; is also set) but every renewal will use the given period. Requires a root token or one with the sudo capability. entity_alias (string: &quot;&quot;) - Name of the entity alias to associate with during token creation. Only works in combination with role_name argument and used entity alias must be listed in allowed_entity_aliases. If this has been specified, the entity will not be inherited from the parent.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload","content":" { &quot;policies&quot;: [&quot;web&quot;, &quot;stage&quot;], &quot;meta&quot;: { &quot;user&quot;: &quot;armon&quot; }, &quot;ttl&quot;: &quot;1h&quot;, &quot;renewable&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/create   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-1","content":" { &quot;request_id&quot;: &quot;f00341c1-fad5-f6e6-13fd-235617f858a1&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;wrap_info&quot;: null, &quot;warnings&quot;: [ &quot;Policy \\&quot;stage\\&quot; does not exist&quot;, &quot;Policy \\&quot;web\\&quot; does not exist&quot; ], &quot;auth&quot;: { &quot;client_token&quot;: &quot;s.wOrq9dO9kzOcuvB06CMviJhZ&quot;, &quot;accessor&quot;: &quot;B6oixijqmeR4bsLOJH88Ska9&quot;, &quot;policies&quot;: [&quot;default&quot;, &quot;stage&quot;, &quot;web&quot;], &quot;token_policies&quot;: [&quot;default&quot;, &quot;stage&quot;, &quot;web&quot;], &quot;metadata&quot;: { &quot;user&quot;: &quot;armon&quot; }, &quot;lease_duration&quot;: 3600, &quot;renewable&quot;: true, &quot;entity_id&quot;: &quot;&quot;, &quot;token_type&quot;: &quot;service&quot;, &quot;orphan&quot;: false, &quot;num_uses&quot;: 0 } }   ","version":"Next","tagName":"h3"},{"title":"Lookup a token​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#lookup-a-token","content":" Returns information about the client token.  Method\tPathPOST\t/auth/token/lookup  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-1","content":" token (string: &lt;required&gt;) - Token to lookup.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-1","content":" { &quot;token&quot;: &quot;ClientToken&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/lookup   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-2","content":" { &quot;data&quot;: { &quot;accessor&quot;: &quot;8609694a-cdbc-db9b-d345-e782dbb562ed&quot;, &quot;creation_time&quot;: 1523979354, &quot;creation_ttl&quot;: 2764800, &quot;display_name&quot;: &quot;ldap2-tesla&quot;, &quot;entity_id&quot;: &quot;7d2e3179-f69b-450c-7179-ac8ee8bd8ca9&quot;, &quot;expire_time&quot;: &quot;2018-05-19T11:35:54.466476215-04:00&quot;, &quot;explicit_max_ttl&quot;: 0, &quot;id&quot;: &quot;cf64a70f-3a12-3f6c-791d-6cef6d390eed&quot;, &quot;identity_policies&quot;: [&quot;dev-group-policy&quot;], &quot;issue_time&quot;: &quot;2018-04-17T11:35:54.466476078-04:00&quot;, &quot;meta&quot;: { &quot;username&quot;: &quot;tesla&quot; }, &quot;num_uses&quot;: 0, &quot;orphan&quot;: true, &quot;path&quot;: &quot;auth/ldap2/login/tesla&quot;, &quot;policies&quot;: [&quot;default&quot;, &quot;testgroup2-policy&quot;], &quot;renewable&quot;: true, &quot;ttl&quot;: 2764790 } }   ","version":"Next","tagName":"h3"},{"title":"Lookup a token (Self)​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#lookup-a-token-self","content":" Returns information about the current client token.  Method\tPathGET\t/auth/token/lookup-self  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/token/lookup-self   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-3","content":" { &quot;data&quot;: { &quot;accessor&quot;: &quot;8609694a-cdbc-db9b-d345-e782dbb562ed&quot;, &quot;creation_time&quot;: 1523979354, &quot;creation_ttl&quot;: 2764800, &quot;display_name&quot;: &quot;ldap2-tesla&quot;, &quot;entity_id&quot;: &quot;7d2e3179-f69b-450c-7179-ac8ee8bd8ca9&quot;, &quot;expire_time&quot;: &quot;2018-05-19T11:35:54.466476215-04:00&quot;, &quot;explicit_max_ttl&quot;: 0, &quot;id&quot;: &quot;cf64a70f-3a12-3f6c-791d-6cef6d390eed&quot;, &quot;identity_policies&quot;: [&quot;dev-group-policy&quot;], &quot;issue_time&quot;: &quot;2018-04-17T11:35:54.466476078-04:00&quot;, &quot;meta&quot;: { &quot;username&quot;: &quot;tesla&quot; }, &quot;num_uses&quot;: 0, &quot;orphan&quot;: true, &quot;path&quot;: &quot;auth/ldap2/login/tesla&quot;, &quot;policies&quot;: [&quot;default&quot;, &quot;testgroup2-policy&quot;], &quot;renewable&quot;: true, &quot;ttl&quot;: 2764790 } }   ","version":"Next","tagName":"h3"},{"title":"Lookup a token (Accessor)​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#lookup-a-token-accessor","content":" Returns information about the client token from the accessor.  Method\tPathPOST\t/auth/token/lookup-accessor  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-2","content":" accessor (string: &lt;required&gt;) - Token accessor to lookup.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-2","content":" { &quot;accessor&quot;: &quot;8609694a-cdbc-db9b-d345-e782dbb562ed&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/lookup-accessor   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-4","content":" { &quot;data&quot;: { &quot;accessor&quot;: &quot;8609694a-cdbc-db9b-d345-e782dbb562ed&quot;, &quot;creation_time&quot;: 1523979354, &quot;creation_ttl&quot;: 2764800, &quot;display_name&quot;: &quot;ldap2-tesla&quot;, &quot;entity_id&quot;: &quot;7d2e3179-f69b-450c-7179-ac8ee8bd8ca9&quot;, &quot;expire_time&quot;: &quot;2018-05-19T11:35:54.466476215-04:00&quot;, &quot;explicit_max_ttl&quot;: 0, &quot;id&quot;: &quot;&quot;, &quot;identity_policies&quot;: [&quot;dev-group-policy&quot;], &quot;issue_time&quot;: &quot;2018-04-17T11:35:54.466476078-04:00&quot;, &quot;meta&quot;: { &quot;username&quot;: &quot;tesla&quot; }, &quot;num_uses&quot;: 0, &quot;orphan&quot;: true, &quot;path&quot;: &quot;auth/ldap2/login/tesla&quot;, &quot;policies&quot;: [&quot;default&quot;, &quot;testgroup2-policy&quot;], &quot;renewable&quot;: true, &quot;ttl&quot;: 2763902 } }   ","version":"Next","tagName":"h3"},{"title":"Renew a token​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#renew-a-token","content":" Renews a lease associated with a token. This is used to prevent the expiration of a token, and the automatic revocation of it. Token renewal is possible only if there is a lease associated with it.  Method\tPathPOST\t/auth/token/renew  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-3","content":" token (string: &lt;required&gt;) - Token to renew. This can be part of the URL or the body.increment (string: &quot;&quot;) - An optional requested increment duration can be provided. This increment may not be honored, for instance in the case of periodic tokens. If not supplied, OpenBao will use the default TTL. This is specified as a numeric string with suffix like &quot;30s&quot; or &quot;5m&quot;.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-3","content":" { &quot;token&quot;: &quot;ClientToken&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/renew   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-5","content":" { &quot;auth&quot;: { &quot;client_token&quot;: &quot;ABCD&quot;, &quot;policies&quot;: [&quot;web&quot;, &quot;stage&quot;], &quot;metadata&quot;: { &quot;user&quot;: &quot;armon&quot; }, &quot;lease_duration&quot;: 3600, &quot;renewable&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Renew a token (Self)​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#renew-a-token-self","content":" Renews a lease associated with the calling token. This is used to prevent the expiration of a token, and the automatic revocation of it. Token renewal is possible only if there is a lease associated with it.  Method\tPathPOST\t/auth/token/renew-self  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-4","content":" increment (string: &quot;&quot;) - An optional requested increment duration can be provided. This increment may not be honored, for instance in the case of periodic tokens. If not supplied, OpenBao will use the default TTL. This is specified as a numeric string with suffix like &quot;30s&quot; or &quot;5m&quot;.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-4","content":" { &quot;increment&quot;: &quot;1h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/renew-self   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-6","content":" { &quot;auth&quot;: { &quot;client_token&quot;: &quot;ABCD&quot;, &quot;policies&quot;: [&quot;web&quot;, &quot;stage&quot;], &quot;metadata&quot;: { &quot;user&quot;: &quot;armon&quot; }, &quot;lease_duration&quot;: 3600, &quot;renewable&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Renew a token (Accessor)​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#renew-a-token-accessor","content":" Renews a lease associated with a token using its accessor. This is used to prevent the expiration of a token, and the automatic revocation of it. Token renewal is possible only if there is a lease associated with it.  Method\tPathPOST\t/auth/token/renew-accessor  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-5","content":" accessor (string: &lt;required&gt;) - Accessor associated with the token to renew.increment (string: &quot;&quot;) - An optional requested lease increment can be provided. This increment may be ignored.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-5","content":" { &quot;accessor&quot;: &quot;7JFKXuXKXa2D44YfDiovZ9aq&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/renew-accessor   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-7","content":" { &quot;auth&quot;: { &quot;client_token&quot;: &quot;&quot;, &quot;policies&quot;: [&quot;web&quot;, &quot;stage&quot;], &quot;metadata&quot;: { &quot;user&quot;: &quot;armon&quot; }, &quot;lease_duration&quot;: 3600, &quot;renewable&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Revoke a token​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#revoke-a-token","content":" Revokes a token and all child tokens. When the token is revoked, all dynamic secrets generated with it are also revoked.  Method\tPathPOST\t/auth/token/revoke  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-6","content":" token (string: &lt;required&gt;) - Token to revoke.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-6","content":" { &quot;token&quot;: &quot;ClientToken&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/revoke   ","version":"Next","tagName":"h3"},{"title":"Revoke a token (Self)​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#revoke-a-token-self","content":" Revokes the token used to call it and all child tokens. When the token is revoked, all dynamic secrets generated with it are also revoked.  Method\tPathPOST\t/auth/token/revoke-self  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/auth/token/revoke-self   ","version":"Next","tagName":"h3"},{"title":"Revoke a token accessor​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#revoke-a-token-accessor","content":" Revoke the token associated with the accessor and all the child tokens. This is meant for purposes where there is no access to token ID but there is need to revoke a token and its children.  Method\tPathPOST\t/auth/token/revoke-accessor  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-7","content":" accessor (string: &lt;required&gt;) - Accessor of the token.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-7","content":" { &quot;accessor&quot;: &quot;2c84f488-2133-4ced-87b0-570f93a76830&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/revoke-accessor   ","version":"Next","tagName":"h3"},{"title":"Revoke token and orphan children​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#revoke-token-and-orphan-children","content":" Revokes a token but not its child tokens. When the token is revoked, all secrets generated with it are also revoked. All child tokens are orphaned, but can be revoked sub-sequently using /auth/token/revoke/. This is a root-protected endpoint.  Method\tPathPOST\t/auth/token/revoke-orphan  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-8","content":" token (string: &lt;required&gt;) - Token to revoke. This can be part of the URL or the body.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-8","content":" { &quot;token&quot;: &quot;ClientToken&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/auth/token/revoke-orphan   ","version":"Next","tagName":"h3"},{"title":"Read token role​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#read-token-role","content":" Fetches the named role configuration.  Method\tPathGET\t/auth/token/roles/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-9","content":" role_name (string: &lt;required&gt;) - The name of the token role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/token/roles/nomad   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-8","content":" { &quot;request_id&quot;: &quot;075a19cd-4e56-a3ca-d956-7609819831ec&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;allowed_entity_aliases&quot;: [ &quot;my-entity-alias&quot; ], &quot;allowed_policies&quot;: [], &quot;disallowed_policies&quot;: [], &quot;allowed_policies_glob&quot;: [], &quot;disallowed_policies_glob&quot;: [], &quot;explicit_max_ttl&quot;: 0, &quot;name&quot;: &quot;nomad&quot;, &quot;orphan&quot;: false, &quot;path_suffix&quot;: &quot;&quot;, &quot;period&quot;: 0, &quot;renewable&quot;: true, &quot;token_explicit_max_ttl&quot;: 0, &quot;token_no_default_policy&quot;: false, &quot;token_period&quot;: 0, &quot;token_type&quot;: &quot;default-service&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"List token roles​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#list-token-roles","content":" List available token roles.  Method\tPathLIST\t/auth/token/roles  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-13","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST http://127.0.0.1:8200/v1/auth/token/roles   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-9","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;role1&quot;, &quot;role2&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update token role​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#createupdate-token-role","content":" Creates (or replaces) the named role. Roles enforce specific behavior when creating tokens that allow token functionality that is otherwise not available or would require sudo/root privileges to access. Role parameters, when set, override any provided options to the createendpoints. The role name is also included in the token path, allowing all tokens created against a role to be revoked using the/sys/leases/revoke-prefix endpoint.  Method\tPathPOST\t/auth/token/roles/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-10","content":" role_name (string: &lt;required&gt;) – The name of the token role.allowed_policies (list: []) – If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names. If at creation timeno_default_policy is not set and &quot;default&quot; is not contained indisallowed_policies or glob matched in disallowed_policies_glob, the &quot;default&quot; policy will be added to the created token automatically.disallowed_policies (list: []) – If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names. Adding &quot;default&quot; to this list will prevent &quot;default&quot; from being added automatically to created tokens.allowed_policies_glob (list: []) – If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs. If at creation timeno_default_policy is not set and &quot;default&quot; is not contained indisallowed_policies or glob matched in disallowed_policies_glob, the &quot;default&quot; policy will be added to the created token automatically. If combined with allowed_policies policies need to only match one of the two lists to be permitted. Note that unlike allowed_policies the policies listed in allowed_policies_glob will not be added to the token when no policies are specified in the call to /auth/token/create/:role_name.disallowed_policies_glob (list: []) – If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs. Adding any glob that matches &quot;default&quot; to this list will prevent &quot;default&quot;from being added automatically to created tokens. If combined with disallowed_policies policies need to only match one of the two lists to be blocked.orphan (bool: false) - If true, tokens created against this policy will be orphan tokens (they will have no parent). As such, they will not be automatically revoked by the revocation of any other token.renewable (bool: true) - Set to false to disable the ability of the token to be renewed past its initial TTL. Setting the value to true will allow the token to be renewable up to the system/mount maximum TTL.path_suffix (string: &quot;&quot;) - If set, tokens created against this role will have the given suffix as part of their path in addition to the role name. This can be useful in certain scenarios, such as keeping the same role name in the future but revoking all tokens created against it before some point in time. The suffix can be changed, allowing new callers to have the new suffix as part of their path, and then tokens with the old suffix can be revoked via/sys/leases/revoke-prefix.allowed_entity_aliases (string: &quot;&quot;, or list: []) - String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing. Note that allowed_entity_aliases is not case sensitive.  token_bound_cidrs (array: [] or comma-delimited string: &quot;&quot;) - List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.token_explicit_max_ttl (integer: 0 or string: &quot;&quot;) - If set, will encode an explicit max TTLonto the token. This is a hard cap even if token_ttl and token_max_ttlwould otherwise allow a renewal.token_no_default_policy (bool: false) - If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies.token_num_uses (integer: 0) - The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0.token_period (integer: 0 or string: &quot;&quot;) - The maximum allowed period value when a periodic token is requested from this role.token_type (string: &quot;&quot;) - The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-payload-9","content":"  &quot;allowed_policies&quot;: [ &quot;dev&quot; ], &quot;name&quot;: &quot;nomad&quot;, &quot;orphan&quot;: false, &quot;bound_cidrs&quot;: [&quot;127.0.0.1/32&quot;, &quot;128.252.0.0/16&quot;], &quot;renewable&quot;: true, &quot;allowed_entity_aliases&quot;: [&quot;web-entity-alias&quot;, &quot;app-entity-*&quot;]   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST --data @payload.json http://127.0.0.1:8200/v1/auth/token/roles/nomad   ","version":"Next","tagName":"h3"},{"title":"Delete token role​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#delete-token-role","content":" This endpoint deletes the named token role.  Method\tPathDELETE\t/auth/token/roles/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#parameters-11","content":" role_name (string: &lt;required&gt;) - The name of the token role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-15","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/auth/token/roles/admins   ","version":"Next","tagName":"h3"},{"title":"Tidy tokens​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#tidy-tokens","content":" Performs some maintenance tasks to clean up invalid entries that may remain in the token store.  Generally, running this is not needed unless upgrade notes or support personnel suggest it. There are two potential dangers to running tidy: first, this will perform a lot of read I/O to the storage method, as it will essentially reload the entirety of the token store into memory. Depending on how much cleanup is required (usually very little) there may also be a large number of writes. Second, this will cause OpenBao's memory usage to balloon up, because the default OpenBao internal cache is unlimited in size and every value read from storage will be cached. Listing the /auth/token/accessors endpoint is a good way to get some sense of the potential impact: tidy does this and more, so if this call creates problems for your cluster, it would be wise to give OpenBao more resources before attempting tidy. Note that the request may time out depending onmax durationand your client's timeout configuration, make sure to allow it run to completion to properly judge the impact.  Tidy will load every token accessor and cubbyhole, as well as all the secondary index entries that are used to group tokens into trees so that parent token revocation also revokes child tokens.  For each parent token listed in the secondary index, tidy will check if the token still exists in storage, and if not its child tokens that still exist will be made orphans, then the parent token will be removed from the secondary index.  For each accessor found, tidy will check if the corresponding token still exists in storage, and if not will delete the accessor. If the token still exists in storage but shouldn't, tidy will try to revoke it and any child leases it might have, then delete the accessor.  Finally, any cubbyhole entries that are associated with tokens which weren't deemed valid in the above steps will be deleted.  Method\tPathPOST\t/auth/token/tidy  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-request-16","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/auth/token/tidy   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Token auth method (API)","url":"/openbao/api-docs/auth/token/#sample-response-10","content":" { &quot;request_id&quot;: &quot;84437c7f-36a1-6c1d-381d-14ec99217e94&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;wrap_info&quot;: null, &quot;warnings&quot;: [ &quot;Tidy operation successfully started. Any information from the operation will be printed to OpenBao's server logs.&quot; ], &quot;auth&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"Redis database plugin HTTP API","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/databases/redis/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"Redis database plugin HTTP API","url":"/openbao/api-docs/secret/databases/redis/#configure-connection","content":" In addition to the parameters defined by the Database Secrets Engine, this plugin has a number of parameters to further configure a connection.  Method\tPathPOST\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Redis database plugin HTTP API","url":"/openbao/api-docs/secret/databases/redis/#parameters","content":" host (string: &lt;required&gt;) – Specifies the host to connect to. port (int: &lt;required&gt;) – Specifies the port number of the connection. username (string: &lt;required&gt;) – Specifies the username for OpenBao to use. password (string: &lt;required&gt;) – Specifies the password corresponding to the given username. tls (bool: false) – Specifies whether to use TLS when connecting to Redis. insecure_tls (bool: false) – Specifies whether to skip verification of the server certificate when using TLS.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Redis database plugin HTTP API","url":"/openbao/api-docs/secret/databases/redis/#sample-payload","content":" { &quot;plugin_name&quot;: &quot;redis-database-plugin&quot;, &quot;host&quot;: &quot;localhost://127.0.0.1&quot;, &quot;username&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass&quot;, &quot;allowed-roles&quot;: &quot;my-*-role&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Redis database plugin HTTP API","url":"/openbao/api-docs/secret/databases/redis/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/database/config/redis   ","version":"Next","tagName":"h3"},{"title":"Statements​","type":1,"pageTitle":"Redis database plugin HTTP API","url":"/openbao/api-docs/secret/databases/redis/#statements","content":" Statements are configured during role creation and are used by the plugin to determine what is sent to the database on user creation, renewing, and revocation. For more information on configuring roles see the Role API in the database secrets engine docs.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Redis database plugin HTTP API","url":"/openbao/api-docs/secret/databases/redis/#parameters-1","content":" The following are the statements used by this plugin. If not mentioned in this list the plugin does not support that statement type.  creation_statements (list: []) – Specifies a JSON string containingRedis ACL rules to assign to created users. If not provided, defaults to a read-only user that can read any key. ","version":"Next","tagName":"h3"},{"title":"PostgreSQL database plugin HTTP API","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/databases/postgresql/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#configure-connection","content":" In addition to the parameters defined by the Database Backend, this plugin has a number of parameters to further configure a connection.  Method\tPathPOST\t/database/config/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#parameters","content":" connection_url (string: &lt;required&gt;) - Specifies the PostgreSQL DSN. This field can be templated and supports passing the username and password parameters in the following format {{field_name}}. Certificate authentication can be used by setting ?sslmode= to be any of the applicable values as outlined in the Postgres SQL documentationand giving the SSL credentials in the sslrootcert, sslcert and sslkey credentials. A templated connection URL is required when using root credential rotation. This field supports both format string types, URI and keyword/value. Both formats support multiple host connection strings. Due to how pgx works, parameters such as sslrootcert, sslcert, sslkey are treated as paths on the OpenBao server. max_open_connections (int: 4) - Specifies the maximum number of open connections to the database. max_idle_connections (int: 0) - Specifies the maximum number of idle connections to the database. A zero uses the value of max_open_connectionsand a negative value disables idle connections. If larger thanmax_open_connections it will be reduced to be equal. max_connection_lifetime (string: &quot;0s&quot;) - Specifies the maximum amount of time a connection may be reused. If &lt;= 0s, connections are reused forever. username (string: &quot;&quot;) - The root credential username used in the connection URL. password (string: &quot;&quot;) - The root credential password used in the connection URL. username_template (string) - Template describing how dynamic usernames are generated. disable_escaping (boolean: false) - Turns off the escaping of special characters inside of the username and password fields. See the databases secrets engine docsfor more information. Defaults to false. password_authentication (string: &quot;password&quot;) - When set to &quot;scram-sha-256&quot;, passwords will be hashed by OpenBao and stored as-is by PostgreSQL. Using &quot;scram-sha-256&quot; requires a minimum version of PostgreSQL 10. Available options are &quot;scram-sha-256&quot; and &quot;password&quot;. The default is &quot;password&quot;. When set to &quot;password&quot;, passwords will be sent to PostgresSQL in plaintext format and may appear in PostgreSQL logs as-is. For more information, please refer to the PostgreSQL documentation.  Default Username Template {{ printf &quot;v-%s-%s-%s-%s&quot; (.DisplayName | truncate 8) (.RoleName | truncate 8) (random 20) (unix_time) | truncate 63 }} Example Usernames: Example\tDisplayName\ttoken RoleName\tmyrolename Username\tv-token-myrolena-jNFRlKsZZMxJEx60o66i-1614294836Example\tDisplayName\tamuchlonger_dispname RoleName\trole-name-with-dashes Username\tv-amuchlon-role-nam-LUHU9xqm6YNisikA3iCQ-1614294836  ","version":"Next","tagName":"h3"},{"title":"Sample payload with URI-format connection string​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#sample-payload-with-uri-format-connection-string","content":" { &quot;plugin_name&quot;: &quot;postgresql-database-plugin&quot;, &quot;allowed_roles&quot;: &quot;readonly&quot;, &quot;connection_url&quot;: &quot;postgresql://{{username}}:{{password}}@localhost:5432/postgres&quot;, &quot;max_open_connections&quot;: 5, &quot;max_connection_lifetime&quot;: &quot;5s&quot;, &quot;username&quot;: &quot;username&quot;, &quot;password&quot;: &quot;password&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample payload with Keyword/Value-format connection string​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#sample-payload-with-keywordvalue-format-connection-string","content":" { &quot;plugin_name&quot;: &quot;postgresql-database-plugin&quot;, &quot;allowed_roles&quot;: &quot;readonly&quot;, &quot;connection_url&quot;: &quot;host=localhost port=5432 user={{username}} password={{password}}&quot;, &quot;max_open_connections&quot;: 5, &quot;max_connection_lifetime&quot;: &quot;5s&quot;, &quot;username&quot;: &quot;username&quot;, &quot;password&quot;: &quot;password&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/database/config/postgresql   ","version":"Next","tagName":"h3"},{"title":"Connection strings with multiple hosts​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#connection-strings-with-multiple-hosts","content":" Postgres supports multiple hosts in the connection string. An example use-case for this might be having Postgres set up with Replication Manager. However, there are some formatting rules to consider when using this feature. Please refer to the &quot;Specifying Multiple Hosts&quot; section of the official Postgres documentationfor more information. Below are two small examples.  URI-format Multi-Host string:​  { &quot;connection_url&quot;: &quot;postgresql://{{username}}:{{password}}@hostone:5432,hosttwo:5432,hostthree:9999/postgres&quot; }   Keyword/Value-format Multi-Host string:​  { &quot;connection_url&quot;: &quot;host=hostone,hosttwo,hostthree port=5432,5432,9999 user={{username}} password={{password}} dbname=postgres&quot; }   ","version":"Next","tagName":"h3"},{"title":"Statements​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#statements","content":" Statements are configured during role creation and are used by the plugin to determine what is sent to the database on user creation, renewing, and revocation. For more information on configuring roles see the Role API in the database secrets engine docs.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"PostgreSQL database plugin HTTP API","url":"/openbao/api-docs/secret/databases/postgresql/#parameters-1","content":" The following are the statements used by this plugin. If not mentioned in this list the plugin does not support that statement type.  creation_statements (list: &lt;required&gt;) – Specifies the database statements executed to create and configure a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}}, {{password}} and {{expiration}} values will be substituted. The generated password will be a random alphanumeric 20 character string. revocation_statements (list: []) – Specifies the database statements to be executed to revoke a user. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}} value will be substituted. If not provided defaults to a generic drop user statement. rollback_statements (list: []) – Specifies the database statements to be executed rollback a create operation in the event of an error. Not every plugin type will support this functionality. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}} value will be substituted. renew_statements (list: []) – Specifies the database statements to be executed to renew a user. Not every plugin type will support this functionality. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}} and{{expiration}} values will be substituted. rotation_statements (list: []) – Specifies the database statements to be executed to rotate the password for a given username. Must be a semicolon-separated string, a base64-encoded semicolon-separated string, a serialized JSON string array, or a base64-encoded serialized JSON string array. The {{name}} and {{password}} values will be substituted. The generated password will be a random alphanumeric 20 character string. ","version":"Next","tagName":"h3"},{"title":"Identity secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/","content":"","keywords":"","version":"Next"},{"title":"API sections​","type":1,"pageTitle":"Identity secrets engine (API)","url":"/openbao/api-docs/secret/identity/#api-sections","content":" EntityEntity AliasGroupGroup AliasIdentity TokensLookupOIDC ProviderMFA ","version":"Next","tagName":"h2"},{"title":"entity-alias","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/entity-alias/","content":"","keywords":"","version":"Next"},{"title":"Create an entity alias​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#create-an-entity-alias","content":" warning IMPORTANT NOTE: Prior to creating any alias it is important to consider the cardinality of the alias' name, since there are potential security issues to be aware of. The main one revolves around alias reuse. It is possible for multiple authenticated entities to be bound to the same alias, and therefore gain access to all of its privileges. It is recommended, whenever possible, to create a unique alias for each entity. This is especially true in the case of machine generated entities.  This endpoint creates a new alias for an entity.  Method\tPathPOST\t/identity/entity-alias  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#parameters","content":" name (string: &lt;required&gt;) - Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to GitHub, it should be the GitHub username. If the alias belongs to an approle auth method, the name should be a valid RoleID. id (string: &lt;optional&gt;) - ID of the entity alias. If set, updates the corresponding entity alias. canonical_id (string: &lt;required&gt;) - Entity ID to which this alias belongs to. mount_accessor (string: &lt;required&gt;) - Accessor of the mount to which the alias should belong to. custom_metadata (map&lt;string|string&gt;: &lt;optional&gt;) - A map of arbitrary string to string valued user-provided metadata meant to describe the alias.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-payload","content":" { &quot;name&quot;: &quot;testuser&quot;, &quot;canonical_id&quot;: &quot;404e57bc-a0b1-a80f-0a73-b6e92e8a52d3&quot;, &quot;mount_accessor&quot;: &quot;auth_userpass_e50b1a44&quot;, &quot;custom_metadata&quot;: { &quot;contact_email&quot;: &quot;james_updated@example.com&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity-alias   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-response","content":" { &quot;data&quot;: { &quot;canonical_id&quot;: &quot;404e57bc-a0b1-a80f-0a73-b6e92e8a52d3&quot;, &quot;id&quot;: &quot;34982d3d-e3ce-5d8b-6e5f-b9bb34246c31&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Read entity alias by ID​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#read-entity-alias-by-id","content":" This endpoint queries the entity alias by its identifier.  Method\tPathGET\t/identity/entity-alias/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#parameters-1","content":" id (string: &lt;required&gt;) – Identifier of entity alias.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/entity-alias/id/34982d3d-e3ce-5d8b-6e5f-b9bb34246c31   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-response-1","content":" { &quot;data&quot;: { &quot;creation_time&quot;: &quot;2017-07-25T21:41:09.820717636Z&quot;, &quot;canonical_id&quot;: &quot;404e57bc-a0b1-a80f-0a73-b6e92e8a52d3&quot;, &quot;custom_metadata&quot;: { &quot;contact_email&quot;:&quot;james@example.com&quot; }, &quot;id&quot;: &quot;34982d3d-e3ce-5d8b-6e5f-b9bb34246c31&quot;, &quot;last_update_time&quot;: &quot;2017-07-25T21:41:09.820717636Z&quot;, &quot;local&quot;: false, &quot;metadata&quot;: { &quot;group&quot;: &quot;san_francisco&quot;, &quot;region&quot;: &quot;west&quot; }, &quot;mount_accessor&quot;: &quot;auth_userpass_e50b1a44&quot;, &quot;mount_path&quot;: &quot;userpass/&quot;, &quot;mount_type&quot;: &quot;userpass&quot;, &quot;name&quot;: &quot;testuser&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Update entity alias by ID​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#update-entity-alias-by-id","content":" This endpoint is used to update an existing entity alias.  Method\tPathPOST\t/identity/entity-alias/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#parameters-2","content":" id (string: &lt;required&gt;) – Identifier of the entity alias. name (string: &quot;&quot;) - Name of the alias. Name should be the identifier of the client in the authentication source. For example, if the alias belongs to userpass backend, the name should be a valid username within userpass backend. If alias belongs to GitHub, it should be the GitHub username. canonical_id (string: &quot;&quot;) - Entity ID to which this alias belongs to. mount_accessor (string: &quot;&quot;) - Accessor of the mount to which the alias should belong to. custom_metadata (map&lt;string|string&gt;: &lt;optional&gt;) - A map of arbitrary string to string valued user-provided metadata meant to describe the alias.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-payload-1","content":" { &quot;name&quot;: &quot;testuser&quot;, &quot;canonical_id&quot;: &quot;404e57bc-a0b1-a80f-0a73-b6e92e8a52d3&quot;, &quot;mount_accessor&quot;: &quot;auth_userpass_e50b1a44&quot; &quot;custom_metadata&quot;: { &quot;contact_email&quot;: &quot;james@example.com&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity-alias/id/34982d3d-e3ce-5d8b-6e5f-b9bb34246c31   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-response-2","content":" { &quot;data&quot;: { &quot;canonical_id&quot;: &quot;404e57bc-a0b1-a80f-0a73-b6e92e8a52d3&quot;, &quot;id&quot;: &quot;34982d3d-e3ce-5d8b-6e5f-b9bb34246c31&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete entity alias by ID​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#delete-entity-alias-by-id","content":" This endpoint deletes an alias from its corresponding entity.  Method\tPathDELETE\t/identity/entity-alias/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#parameters-3","content":" id (string: &lt;required&gt;) – Identifier of the entity alias.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/entity-alias/id/34982d3d-e3ce-5d8b-6e5f-b9bb34246c31   ","version":"Next","tagName":"h3"},{"title":"List entity aliases by ID​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#list-entity-aliases-by-id","content":" The list by ID endpoint returns the available entity aliases and key data by their identifiers.  Method\tPathLIST\t/identity/entity-alias/id GET\t/identity/entity-alias/id?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/entity-alias/id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity-alias","url":"/openbao/api-docs/secret/identity/entity-alias/#sample-response-3","content":" { &quot;data&quot;: { &quot;key_info&quot;: { &quot;35405f3c-884a-a3ff-4176-bac57f220811&quot;: { &quot;canonical_id&quot;: &quot;0c34f097-6313-9597-3b22-91e34072ad28&quot;, &quot;custom_metadata&quot;: null, &quot;local&quot;: false, &quot;mount_accessor&quot;: &quot;auth_jwt_e47c5220&quot;, &quot;mount_path&quot;: &quot;auth/tfc_jwt/&quot;, &quot;mount_type&quot;: &quot;jwt&quot;, &quot;name&quot;: &quot;app-alias-1&quot; }, &quot;4065d8c7-4fa6-db9d-e190-f9644c09638a&quot;: { &quot;canonical_id&quot;: &quot;21c6f2bf-b9b0-db44-242f-18bf76cb9ff0&quot;, &quot;custom_metadata&quot;: null, &quot;local&quot;: false, &quot;mount_accessor&quot;: &quot;auth_ns_token_79c4d932&quot;, &quot;mount_path&quot;: &quot;auth/token/&quot;, &quot;mount_type&quot;: &quot;ns_token&quot;, &quot;name&quot;: &quot;app-alias-2&quot; } }, &quot;keys&quot;: [ &quot;35405f3c-884a-a3ff-4176-bac57f220811&quot;, &quot;4065d8c7-4fa6-db9d-e190-f9644c09638a&quot; ] } }  ","version":"Next","tagName":"h3"},{"title":"group-alias","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/group-alias/","content":"","keywords":"","version":"Next"},{"title":"Create a group alias​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#create-a-group-alias","content":" This endpoint creates or updates a group alias.  Method\tPathPOST\t/identity/group-alias  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#parameters","content":" name (string: entity-&lt;UUID&gt;) – Name of the group alias. id (string: &lt;optional&gt;) - ID of the group alias. If set, updates the corresponding existing group alias. mount_accessor (string: &quot;&quot;) – Mount accessor which this alias belongs to. canonical_id (string: &quot;&quot;) - ID of the group to which this is an alias.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-payload","content":" { &quot;canonical_id&quot;: &quot;b86920ea-2831-00ff-15c5-a3f923f1ee3b&quot;, &quot;mount_accessor&quot;: &quot;auth_github_232a90dc&quot;, &quot;name&quot;: &quot;dev-team&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/group-alias   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-response","content":" { &quot;data&quot;: { &quot;canonical_id&quot;: &quot;b86920ea-2831-00ff-15c5-a3f923f1ee3b&quot;, &quot;id&quot;: &quot;ca726050-d8ac-6f1f-4210-3b5c5b613824&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Update group alias by ID​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#update-group-alias-by-id","content":" This endpoint is used to update an existing group alias.  Method\tPathPOST\t/identity/group-alias/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#parameters-1","content":" id (string: &lt;optional&gt;) - ID of the group alias. name (string: entity-&lt;UUID&gt;) – Name of the group alias. mount_accessor (string: &quot;&quot;) – Mount accessor which this alias belongs to. canonical_id (string: &quot;&quot;) - ID of the group to which this is an alias.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-payload-1","content":" { &quot;canonical_id&quot;: &quot;b86920ea-2831-00ff-15c5-a3f923f1ee3b&quot;, &quot;mount_accessor&quot;: &quot;auth_github_232a90dc&quot;, &quot;name&quot;: &quot;dev-team&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/group-alias/id/ca726050-d8ac-6f1f-4210-3b5c5b613824   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-response-1","content":" { &quot;data&quot;: { &quot;canonical_id&quot;: &quot;b86920ea-2831-00ff-15c5-a3f923f1ee3b&quot;, &quot;id&quot;: &quot;ca726050-d8ac-6f1f-4210-3b5c5b613824&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Read group alias by ID​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#read-group-alias-by-id","content":" This endpoint queries the group alias by its identifier.  Method\tPathGET\t/identity/group-alias/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#parameters-2","content":" id (string: &lt;required&gt;) – ID of the group alias.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/group-alias/id/ca726050-d8ac-6f1f-4210-3b5c5b613824   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-response-2","content":" { &quot;data&quot;: { &quot;canonical_id&quot;: &quot;b86920ea-2831-00ff-15c5-a3f923f1ee3b&quot;, &quot;creation_time&quot;: &quot;2017-11-13T20:09:41.661694Z&quot;, &quot;id&quot;: &quot;ca726050-d8ac-6f1f-4210-3b5c5b613824&quot;, &quot;last_update_time&quot;: &quot;2017-11-13T20:09:41.661694Z&quot;, &quot;merged_from_canonical_ids&quot;: null, &quot;metadata&quot;: null, &quot;mount_accessor&quot;: &quot;auth_github_232a90dc&quot;, &quot;mount_path&quot;: &quot;&quot;, &quot;mount_type&quot;: &quot;github&quot;, &quot;name&quot;: &quot;dev-team&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete group alias by ID​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#delete-group-alias-by-id","content":" This endpoint deletes a group alias.  Method\tPathDELETE\t/identity/group-alias/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#parameters-3","content":" id (string: &lt;required&gt;) – ID of the group alias.  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/group-alias/id/ca726050-d8ac-6f1f-4210-3b5c5b613824   ","version":"Next","tagName":"h3"},{"title":"List group alias by ID​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#list-group-alias-by-id","content":" This endpoint returns a list of available group aliases by their identifiers.  Method\tPathLIST\t/identity/group-alias/id GET\t/identity/group-alias/id?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/group-alias/id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group-alias","url":"/openbao/api-docs/secret/identity/group-alias/#sample-response-3","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;ca726050-d8ac-6f1f-4210-3b5c5b613824&quot;] } }  ","version":"Next","tagName":"h3"},{"title":"/identity/mfa","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/mfa/","content":"","keywords":"","version":"Next"},{"title":"Supported MFA types.​","type":1,"pageTitle":"/identity/mfa","url":"/openbao/api-docs/secret/identity/mfa/#supported-mfa-types","content":" TOTP Okta Duo PingID  ","version":"Next","tagName":"h2"},{"title":"Other​","type":1,"pageTitle":"/identity/mfa","url":"/openbao/api-docs/secret/identity/mfa/#other","content":" Login EnforcementMFA Validate ","version":"Next","tagName":"h2"},{"title":"lookup","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/lookup/","content":"","keywords":"","version":"Next"},{"title":"Lookup an entity​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#lookup-an-entity","content":" This endpoint looks up an entity based on the given criteria. The criteria can be name, id, alias_id, or a combination of alias_name andalias_mount_accessor.  Method\tPathPOST\t/identity/lookup/entity  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#parameters","content":" name (string: &quot;&quot;) – Name of the entity. id (string: &quot;&quot;) - ID of the entity. alias_id (string: &quot;&quot;) - ID of the alias. alias_name (string: &quot;&quot;) - Name of the alias. This should be supplied in conjunction with alias_mount_accessor. alias_mount_accessor (string: &quot;&quot;) - Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with alias_name.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#sample-payload","content":" { &quot;id&quot;: &quot;043fedec-967d-b2c9-d3af-0c467b04e1fd&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/lookup/entity   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#sample-response","content":" { &quot;data&quot;: { &quot;aliases&quot;: [], &quot;creation_time&quot;: &quot;2017-11-13T21:01:33.543497Z&quot;, &quot;direct_group_ids&quot;: [], &quot;group_ids&quot;: [], &quot;id&quot;: &quot;043fedec-967d-b2c9-d3af-0c467b04e1fd&quot;, &quot;inherited_group_ids&quot;: [], &quot;last_update_time&quot;: &quot;2017-11-13T21:01:33.543497Z&quot;, &quot;merged_entity_ids&quot;: null, &quot;metadata&quot;: null, &quot;name&quot;: &quot;entity_43cc451b&quot;, &quot;policies&quot;: null } }   ","version":"Next","tagName":"h3"},{"title":"Lookup a group​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#lookup-a-group","content":" This endpoint looks up a group based on the given criteria. The criteria can be name, id, alias_id, or a combination of alias_name andalias_mount_accessor.  Method\tPathPOST\t/identity/lookup/group  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#parameters-1","content":" name (string: &quot;&quot;) – Name of the group. id (string: &quot;&quot;) - ID of the group. alias_id (string: &quot;&quot;) - ID of the alias. alias_name (string: &quot;&quot;) - Name of the alias. This should be supplied in conjunction with alias_mount_accessor. alias_mount_accessor (string: &quot;&quot;) - Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with alias_name.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#sample-payload-1","content":" { &quot;id&quot;: &quot;70a4bdef-9da3-4460-b524-bb08542eef25&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/lookup/group   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"lookup","url":"/openbao/api-docs/secret/identity/lookup/#sample-response-1","content":" { &quot;data&quot;: { &quot;alias&quot;: {}, &quot;creation_time&quot;: &quot;2017-11-13T21:06:44.475587Z&quot;, &quot;id&quot;: &quot;70a4bdef-9da3-4460-b524-bb08542eef25&quot;, &quot;last_update_time&quot;: &quot;2017-11-13T21:06:44.475587Z&quot;, &quot;member_entity_ids&quot;: [], &quot;member_group_ids&quot;: null, &quot;metadata&quot;: null, &quot;modify_index&quot;: 1, &quot;name&quot;: &quot;group_eaf2aab1&quot;, &quot;policies&quot;: null, &quot;type&quot;: &quot;internal&quot; } }  ","version":"Next","tagName":"h3"},{"title":"entity","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/entity/","content":"","keywords":"","version":"Next"},{"title":"Create an entity​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#create-an-entity","content":" This endpoint creates or updates an Entity.  Method\tPathPOST\t/identity/entity  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters","content":" name (string: entity-&lt;UUID&gt;) – Name of the entity. id (string: &lt;optional&gt;) - ID of the entity. If set, updates the corresponding existing entity. metadata (key-value-map: {}) – Metadata to be associated with the entity. policies (list of strings: []) – Policies to be tied to the entity. disabled (bool: false) – Whether the entity is disabled. Disabled entities' associated tokens cannot be used, but are not revoked.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-payload","content":" { &quot;metadata&quot;: { &quot;organization&quot;: &quot;openbao&quot;, &quot;team&quot;: &quot;openbao&quot; }, &quot;policies&quot;: [&quot;eng-dev&quot;, &quot;infra-dev&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response","content":" { &quot;data&quot;: { &quot;id&quot;: &quot;8d6a45e5-572f-8f13-d226-cd0d1ec57297&quot;, &quot;aliases&quot;: null } }   ","version":"Next","tagName":"h3"},{"title":"Read entity by ID​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#read-entity-by-id","content":" This endpoint queries the entity by its identifier.  Method\tPathGET\t/identity/entity/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-1","content":" id (string: &lt;required&gt;) – Identifier of the entity.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/entity/id/8d6a45e5-572f-8f13-d226-cd0d1ec57297   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response-1","content":" { &quot;data&quot;: { &quot;bucket_key_hash&quot;: &quot;177553e4c58987f4cc5d7e530136c642&quot;, &quot;creation_time&quot;: &quot;2017-07-25T20:29:22.614756844Z&quot;, &quot;disabled&quot;: false, &quot;id&quot;: &quot;8d6a45e5-572f-8f13-d226-cd0d1ec57297&quot;, &quot;last_update_time&quot;: &quot;2017-07-25T20:29:22.614756844Z&quot;, &quot;metadata&quot;: { &quot;organization&quot;: &quot;openbao&quot;, &quot;team&quot;: &quot;openbao&quot; }, &quot;name&quot;: &quot;entity-c323de27-2ad2-5ded-dbf3-0c7ef98bc613&quot;, &quot;aliases&quot;: [], &quot;policies&quot;: [&quot;eng-dev&quot;, &quot;infra-dev&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Update entity by ID​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#update-entity-by-id","content":" This endpoint is used to update an existing entity.  Method\tPathPOST\t/identity/entity/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-2","content":" id (string: &lt;required&gt;) – Identifier of the entity.name (string: entity-&lt;UUID&gt;) – Name of the entity.metadata (key-value-map: {}) – Metadata to be associated with the entity.policies (list of strings: []) – Policies to be tied to the entity.disabled (bool: false) – Whether the entity is disabled. Disabled entities' associated tokens cannot be used, but are not revoked.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-payload-1","content":" { &quot;name&quot;: &quot;updatedEntityName&quot;, &quot;metadata&quot;: { &quot;organization&quot;: &quot;openbao&quot;, &quot;team&quot;: &quot;nomad&quot; }, &quot;policies&quot;: [&quot;eng-developers&quot;, &quot;infra-developers&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity/id/8d6a45e5-572f-8f13-d226-cd0d1ec57297   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response-2","content":" { &quot;data&quot;: { &quot;id&quot;: &quot;8d6a45e5-572f-8f13-d226-cd0d1ec57297&quot;, &quot;aliases&quot;: null } }   ","version":"Next","tagName":"h3"},{"title":"Delete entity by ID​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#delete-entity-by-id","content":" This endpoint deletes an entity and all its associated aliases.  Method\tPathDELETE\t/identity/entity/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-3","content":" id (string: &lt;required&gt;) – Identifier of the entity.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/entity/id/8d6a45e5-572f-8f13-d226-cd0d1ec57297   ","version":"Next","tagName":"h3"},{"title":"Batch delete entities​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#batch-delete-entities","content":" This endpoint deletes all entities provided.  Method\tPathPOST\t/identity/entity/batch-delete  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-4","content":" entity_ids ([]string: &lt;required&gt;) – List of entity identifiers to delete.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-payload-2","content":" { &quot;entity_ids&quot;: [ &quot;02fe5a88-912b-6794-62ed-db873ef86a95&quot;, &quot;3bf81bc9-44df-8138-57f9-724a9ae36d04&quot;, &quot;627fba68-98c9-c012-71ba-bfb349585ce1&quot;, &quot;6c4c805b-b384-3d0e-4d51-44d349887b96&quot;, &quot;70a72feb-35d1-c775-0813-8efaa8b4b9b5&quot;, &quot;f1092a67-ce34-48fd-161d-c13a367bc1cd&quot;, &quot;faedd89a-0d82-c197-c8f9-93a3e6cf0cd0&quot; ] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity/batch-delete   ","version":"Next","tagName":"h3"},{"title":"List entities by ID​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#list-entities-by-id","content":" This endpoint returns a list of available entities by their identifiers.  Method\tPathLIST\t/identity/entity/id GET\t/identity/entity/id?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/entity/id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response-3","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;02fe5a88-912b-6794-62ed-db873ef86a95&quot;, &quot;3bf81bc9-44df-8138-57f9-724a9ae36d04&quot;, &quot;627fba68-98c9-c012-71ba-bfb349585ce1&quot;, &quot;6c4c805b-b384-3d0e-4d51-44d349887b96&quot;, &quot;70a72feb-35d1-c775-0813-8efaa8b4b9b5&quot;, &quot;f1092a67-ce34-48fd-161d-c13a367bc1cd&quot;, &quot;faedd89a-0d82-c197-c8f9-93a3e6cf0cd0&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update entity by name​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#createupdate-entity-by-name","content":" This endpoint is used to create or update an entity by a given name.  Method\tPathPOST\t/identity/entity/name/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-5","content":" name (string: entity-&lt;UUID&gt;) – Name of the entity. metadata (key-value-map: {}) – Metadata to be associated with the entity. policies (list of strings: []) – Policies to be tied to the entity. disabled (bool: false) – Whether the entity is disabled. Disabled entities' associated tokens cannot be used, but are not revoked.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-payload-3","content":" { &quot;metadata&quot;: { &quot;organization&quot;: &quot;openbao&quot;, &quot;team&quot;: &quot;nomad&quot; }, &quot;policies&quot;: [&quot;eng-developers&quot;, &quot;infra-developers&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity/name/testentityname   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response-4","content":" { &quot;data&quot;: { &quot;aliases&quot;: null, &quot;id&quot;: &quot;0826be06-577c-a076-3942-2f92da0310ce&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Read entity by name​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#read-entity-by-name","content":" This endpoint queries the entity by its name.  Method\tPathGET\t/identity/entity/name/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-6","content":" name (string: &lt;required&gt;) – Name of the entity.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/entity/name/testentityname   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response-5","content":" { &quot;data&quot;: { &quot;aliases&quot;: [], &quot;creation_time&quot;: &quot;2018-09-19T17:20:27.705389973Z&quot;, &quot;direct_group_ids&quot;: [], &quot;disabled&quot;: false, &quot;group_ids&quot;: [], &quot;id&quot;: &quot;0826be06-577c-a076-3942-2f92da0310ce&quot;, &quot;inherited_group_ids&quot;: [], &quot;last_update_time&quot;: &quot;2018-09-19T17:20:27.705389973Z&quot;, &quot;merged_entity_ids&quot;: null, &quot;metadata&quot;: { &quot;organization&quot;: &quot;openbao&quot;, &quot;team&quot;: &quot;nomad&quot; }, &quot;name&quot;: &quot;testentityname&quot;, &quot;policies&quot;: [&quot;eng-developers&quot;, &quot;infra-developers&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Delete entity by name​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#delete-entity-by-name","content":" This endpoint deletes an entity and all its associated aliases, given the entity name.  Method\tPathDELETE\t/identity/entity/name/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-7","content":" name (string: &lt;required&gt;) – Name of the entity.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/entity/name/testentityname   ","version":"Next","tagName":"h3"},{"title":"List entities by name​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#list-entities-by-name","content":" This endpoint returns a list of available entities by their names.  Method\tPathLIST\t/identity/entity/name GET\t/identity/entity/name?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/entity/name   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-response-6","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;testentityname&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Merge entities​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#merge-entities","content":" This endpoint merges many entities into one entity. Additionally, all groups associated with from_entity_ids are merged with those of to_entity_id. Note that if these entities contain aliases sharing the same mount accessor, the merge will fail unless conflicting_alias_ids_to_keep is present, and entities must be merged one at a time. This is because each entity can only have one alias with each mount accessor - for more information, see the identity concepts page.  Method\tPathPOST\t/identity/entity/merge  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#parameters-8","content":" from_entity_ids (list of strings: &lt;required&gt;) - Entity IDs which need to get merged. to_entity_id (string: &lt;required&gt;) - Entity ID into which all the other entities need to get merged. force (bool: false) - Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts. conflicting_alias_ids_to_keep (list of strings: []) - A list of entity aliases to keep in the case where the to-Entity and from-Entity have aliases with the same mount accessor. In the case where alias share mount accessors, the alias ID given in this list will be kept or merged, and the other alias will be deleted. Note that merges requiring this parameter must have only one from-Entity.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-payload-4","content":" { &quot;to_entity_id&quot;: &quot;f2cdefbe-f510-a226-77fa-989a48ba6abc&quot;, &quot;from_entity_ids&quot;: [ &quot;1ade80ec-ba5c-8eed-91e2-b9dcd41d6fff&quot;, &quot;270976d0-9bab-14a5-4b92-3861805ef73d&quot; ] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"entity","url":"/openbao/api-docs/secret/identity/entity/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/entity/merge  ","version":"Next","tagName":"h3"},{"title":"group","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/group/","content":"","keywords":"","version":"Next"},{"title":"Create a group​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#create-a-group","content":" This endpoint creates or updates a Group.  Method\tPathPOST\t/identity/group  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters","content":" name (string: entity-&lt;UUID&gt;) – Name of the group. If set (and ID is not set), updates the corresponding existing group. id (string: &lt;optional&gt;) - ID of the group. If set, updates the corresponding existing group. type (string: &quot;internal&quot;) - Type of the group, internal or external. Defaults to internal. metadata (key-value-map: {}) – Metadata to be associated with the group. policies (list of strings: []) – Policies to be tied to the group. member_group_ids (list of strings: []) - Group IDs to be assigned as group members. member_entity_ids (list of strings: []) - Entity IDs to be assigned as group members.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-payload","content":" { &quot;metadata&quot;: { &quot;hello&quot;: &quot;world&quot; }, &quot;policies&quot;: [&quot;grouppolicy1&quot;, &quot;grouppolicy2&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/group   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response","content":" { &quot;data&quot;: { &quot;id&quot;: &quot;363926d8-dd8b-c9f0-21f8-7b248be80ce1&quot;, &quot;name&quot;: &quot;group_ab813d63&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Read group by ID​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#read-group-by-id","content":" This endpoint queries the group by its identifier.  Method\tPathGET\t/identity/group/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters-1","content":" id (string: &lt;required&gt;) – Identifier of the group.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/group/id/363926d8-dd8b-c9f0-21f8-7b248be80ce1   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response-1","content":" { &quot;data&quot;: { &quot;alias&quot;: {}, &quot;creation_time&quot;: &quot;2017-11-13T19:36:47.102945Z&quot;, &quot;id&quot;: &quot;363926d8-dd8b-c9f0-21f8-7b248be80ce1&quot;, &quot;last_update_time&quot;: &quot;2017-11-13T19:36:47.102945Z&quot;, &quot;member_entity_ids&quot;: [], &quot;member_group_ids&quot;: null, &quot;metadata&quot;: { &quot;hello&quot;: &quot;world&quot; }, &quot;modify_index&quot;: 1, &quot;name&quot;: &quot;group_ab813d63&quot;, &quot;policies&quot;: [&quot;grouppolicy1&quot;, &quot;grouppolicy2&quot;], &quot;type&quot;: &quot;internal&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Update group by ID​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#update-group-by-id","content":" This endpoint is used to update an existing group.  Method\tPathPOST\t/identity/group/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters-2","content":" id (string: &lt;required&gt;) – Identifier of the entity. name (string: entity-&lt;UUID&gt;) – Name of the group. type (string: &quot;internal&quot;) - Type of the group, internal or external. Defaults to internal. metadata (key-value-map: {}) – Metadata to be associated with the group. policies (list of strings: []) – Policies to be tied to the group. member_group_ids (list of strings: []) - Group IDs to be assigned as group members. member_entity_ids (list of strings: []) - Entity IDs to be assigned as group members.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-payload-1","content":" { &quot;name&quot;: &quot;testgroupname&quot;, &quot;metadata&quot;: { &quot;hello&quot;: &quot;everyone&quot; }, &quot;policies&quot;: [&quot;grouppolicy2&quot;, &quot;grouppolicy3&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/group/id/363926d8-dd8b-c9f0-21f8-7b248be80ce1   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response-2","content":" { &quot;data&quot;: { &quot;id&quot;: &quot;363926d8-dd8b-c9f0-21f8-7b248be80ce1&quot;, &quot;name&quot;: &quot;testgroupname&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete group by ID​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#delete-group-by-id","content":" This endpoint deletes a group.  Method\tPathDELETE\t/identity/group/id/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters-3","content":" id (string: &lt;required&gt;) – Identifier of the group.  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/group/id/363926d8-dd8b-c9f0-21f8-7b248be80ce1   ","version":"Next","tagName":"h3"},{"title":"List groups by ID​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#list-groups-by-id","content":" This endpoint returns a list of available groups by their identifiers.  Method\tPathLIST\t/identity/group/id GET\t/identity/group/id?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/group/id   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response-3","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;052567cf-1580-6f20-50c8-d38bc46dae6e&quot;, &quot;26da8035-6691-b89e-67ac-ebf9ea7f9893&quot;, &quot;363926d8-dd8b-c9f0-21f8-7b248be80ce1&quot;, &quot;5c4a5720-7408-c113-1dcc-9ede725d0ac8&quot;, &quot;d55e0f34-5c16-38ae-87af-324c9b656c43&quot;, &quot;e4e56e04-0dec-9b68-9b20-a450975d898e&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update group by name​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#createupdate-group-by-name","content":" This endpoint is used to create or update a group by its name.  Method\tPathPOST\t/identity/group/name/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters-4","content":" name (string: entity-&lt;UUID&gt;) – Name of the group. type (string: &quot;internal&quot;) - Type of the group, internal or external. Defaults to internal. metadata (key-value-map: {}) – Metadata to be associated with the group. policies (list of strings: []) – Policies to be tied to the group. member_group_ids (list of strings: []) - Group IDs to be assigned as group members. member_entity_ids (list of strings: []) - Entity IDs to be assigned as group members.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-payload-2","content":" { &quot;metadata&quot;: { &quot;hello&quot;: &quot;everyone&quot; }, &quot;policies&quot;: [&quot;grouppolicy2&quot;, &quot;grouppolicy3&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/group/name/testgroupname   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response-4","content":" { &quot;request_id&quot;: &quot;b98b4a3d-a9f1-e151-11e1-ad91cfb08351&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;id&quot;: &quot;5a3a04a0-0c3a-a4c3-74e8-26b1adbeaece&quot;, &quot;name&quot;: &quot;testgroupname&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Read group by name​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#read-group-by-name","content":" This endpoint queries the group by its name.  Method\tPathGET\t/identity/group/name/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters-5","content":" name (string: &lt;required&gt;) – Name of the group.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/group/name/testgroupname   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response-5","content":" { &quot;data&quot;: { &quot;alias&quot;: {}, &quot;creation_time&quot;: &quot;2018-09-19T22:02:04.395128091Z&quot;, &quot;id&quot;: &quot;5a3a04a0-0c3a-a4c3-74e8-26b1adbeaece&quot;, &quot;last_update_time&quot;: &quot;2018-09-19T22:02:04.395128091Z&quot;, &quot;member_entity_ids&quot;: [], &quot;member_group_ids&quot;: null, &quot;metadata&quot;: { &quot;foo&quot;: &quot;bar&quot; }, &quot;modify_index&quot;: 1, &quot;name&quot;: &quot;testgroupname&quot;, &quot;parent_group_ids&quot;: null, &quot;policies&quot;: [&quot;grouppolicy1&quot;, &quot;grouppolicy2&quot;], &quot;type&quot;: &quot;internal&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete group by name​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#delete-group-by-name","content":" This endpoint deletes a group, given its name.  Method\tPathDELETE\t/identity/group/name/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#parameters-6","content":" name (string: &lt;required&gt;) – Name of the group.  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/group/name/testgroupname   ","version":"Next","tagName":"h3"},{"title":"List groups by name​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#list-groups-by-name","content":" This endpoint returns a list of available groups by their names.  Method\tPathLIST\t/identity/group/name GET\t/identity/group/name?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/group/name   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"group","url":"/openbao/api-docs/secret/identity/group/#sample-response-6","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;testgroupname&quot;] } }  ","version":"Next","tagName":"h3"},{"title":"login-enforcement","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/","content":"","keywords":"","version":"Next"},{"title":"Create a login enforcement​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#create-a-login-enforcement","content":" This endpoint creates or updates a login enforcement that specifies which MFA methods should be used when logging into OpenBao. If there are multiple login enforcements, each one needs to be satisfied before a login attempt succeeds.  Method\tPathPOST\t/identity/mfa/login-enforcement/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#parameters","content":" name (string: &lt;required&gt;) - Name for this login enforcement configuration. mfa_method_ids ([]string: &lt;required&gt;) - Array of MFA method UUIDs to use. These will be ORed together, meaning if several IDs are specified, any one of them is sufficient to login. auth_method_accessors ([]string: []) - Array of auth mount accessor IDs. If present, only auth methods corresponding to the given accessors are checked during login. auth_method_types ([]string: []) - Array of auth method types. If present, only auth methods corresponding to the given types are checked during login. identity_group_ids ([]string: []) - Array of identity group IDs. If present, only entities belonging to one of the given groups are checked during login. identity_entity_ids ([]string: []) - Array of identity entity IDs. If present, only entities with the given IDs are checked during login.  Note that while none of auth_method_accessors, auth_method_types, identity_group_ids, or identity_entity_ids is individually required, at least one of those four fields must be present to create a login enforcement.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-payload","content":" { &quot;mfa_method_ids&quot;: [&quot;134f7ce9-feae-4c6c-9ed7-ab3e413dbfce&quot;], &quot;auth_method_accessors&quot;: [&quot;auth_userpass_337fdb6a&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/login-enforcement/foo   ","version":"Next","tagName":"h3"},{"title":"Read login enforcement​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#read-login-enforcement","content":" This endpoint reads the login enforcement configuration for a given name.  Method\tPathGET\t/identity/mfa/login-enforcement/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#parameters-1","content":" name (string: &lt;required&gt;) – Name of the login enforcement.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/mfa/login-enforcement/foo   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-response","content":" { &quot;data&quot;: { &quot;auth_method_accessors&quot;: [ &quot;auth_userpass_337fdb6a&quot; ], &quot;auth_method_types&quot;: [], &quot;id&quot;: &quot;24167a6c-759a-c596-6d48-391c89c4befc&quot;, &quot;identity_entity_ids&quot;: [], &quot;identity_group_ids&quot;: [], &quot;mfa_method_ids&quot;: [ &quot;c1372abf-bf64-1f26-c2a4-cbcfa135b775&quot; ], &quot;name&quot;: &quot;foo&quot;, &quot;namespace_id&quot;: &quot;root&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete login enforcement​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#delete-login-enforcement","content":" This endpoint deletes a login enforcement configuration by the given name.  Method\tPathDELETE\t/identity/mfa/login-enforcement/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#parameters-2","content":" name (string: &lt;required&gt;) - Name of the login enforcement.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/mfa/login-enforcement/foo   ","version":"Next","tagName":"h3"},{"title":"List login enforcements​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#list-login-enforcements","content":" This endpoint lists login enforcements that are visible.  Method\tPathLIST\t/identity/mfa/login-enforcement  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/mfa/login-enforcement   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"login-enforcement","url":"/openbao/api-docs/secret/identity/mfa/login-enforcement/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;foo&quot; ] } }  ","version":"Next","tagName":"h3"},{"title":"okta","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/mfa/okta/","content":"","keywords":"","version":"Next"},{"title":"Configure okta MFA method​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#configure-okta-mfa-method","content":" This endpoint defines an MFA method of type Okta.  Method\tPathPOST\t/identity/mfa/method/okta/:method_id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#parameters","content":" method_id (string: &quot;&quot;) - Optional UUID to specify if updating an existing method. method_name (string) - The unique name identifier for this MFA method. username_format (string) - A format string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, &quot;{{identity.entity.name}}@example.com&quot;. If blank, the Entity's Name field is used as-is. org_name (string: &lt;required&gt;) - Name of the organization to be used in the Okta API. api_token (string: &lt;required&gt;) - Okta API key. base_url (string) - If set, will be used as the base domain for API requests. Examples are okta.com, oktapreview.com, and okta-emea.com. primary_email (bool: false) - If set, the username will only match the primary email for the account.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-payload","content":" { &quot;username_format&quot;: &quot;{{identity.entity.aliases.auth_userpass_1793464a.name}}&quot;, &quot;org_name&quot;: &quot;dev-262778&quot;, &quot;api_token&quot;: &quot;0081u7KrReNkzmABZJAP2oDyIXccveqx9vIOEyCZDC&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/okta   $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/okta/1db034b5-81f1-4a2b-8c2b-0f51ed0bd9fc   ","version":"Next","tagName":"h3"},{"title":"Read okta MFA method​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#read-okta-mfa-method","content":" This endpoint queries the MFA configuration of Okta type for a given method name.  Method\tPathGET\t/identity/mfa/method/okta/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#parameters-1","content":" id (string: &lt;required&gt;) – UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/mfa/method/okta/1db034b5-81f1-4a2b-8c2b-0f51ed0bd9fc   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-response","content":" { &quot;data&quot;: { &quot;api_token&quot;: &quot;0081u7KrReNkzmABZJAP2oDyIXccveqx9vIOEyCZDC&quot;, &quot;id&quot;: &quot;1db034b5-81f1-4a2b-8c2b-0f51ed0bd9fc&quot;, &quot;name&quot;: &quot;my_okta&quot;, &quot;org_name&quot;: &quot;dev-262778&quot;, &quot;type&quot;: &quot;okta&quot;, &quot;username_format&quot;: &quot;{{identity.entity.aliases.auth_userpass_1793464a.name}}&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete okta MFA method​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#delete-okta-mfa-method","content":" This endpoint deletes a Okta MFA method. The MFA methods can only be deleted if they're not currently in use by a login enforcement.  Method\tPathDELETE\t/identity/mfa/method/okta/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#parameters-2","content":" id (string: &lt;required&gt;) - UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/mfa/method/okta/1db034b5-81f1-4a2b-8c2b-0f51ed0bd9fc   ","version":"Next","tagName":"h3"},{"title":"List okta MFA methods​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#list-okta-mfa-methods","content":" This endpoint lists Okta MFA methods that are visible.  Method\tPathLIST\t/identity/mfa/method/okta  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/mfa/method/okta   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"okta","url":"/openbao/api-docs/secret/identity/mfa/okta/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;1db034b5-81f1-4a2b-8c2b-0f51ed0bd9fc&quot; ] } }  ","version":"Next","tagName":"h3"},{"title":"duo","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/mfa/duo/","content":"","keywords":"","version":"Next"},{"title":"Configure Duo MFA method​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#configure-duo-mfa-method","content":" This endpoint defines an MFA method of type Duo.  Method\tPathPOST\t/identity/mfa/method/duo/:method_id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#parameters","content":" method_id (string: &quot;&quot;) - Optional UUID to specify if updating an existing method. method_name (string) - The unique name identifier for this MFA method. username_format (string) - A template string for mapping Identity names to MFA methods. Values to substitute should be placed in {{}}. For example, &quot;{{identity.entity.name}}&quot;. If blank, the Entity's Name field is used as-is. secret_key (string: &lt;required&gt;) - Secret key for Duo. integration_key (string: &lt;required&gt;) - Integration key for Duo. api_hostname (string: &lt;required&gt;) - API hostname for Duo. push_info (string) - Push information for Duo. use_passcode (bool: false) - If true, the user is reminded to use the passcode upon MFA validation.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-payload","content":" { &quot;username_format&quot;: &quot;{{identity.entity.aliases.auth_userpass_1793464a.name}}&quot;, &quot;secret_key&quot;: &quot;BIACEUEAXI20BNWTEYXT&quot;, &quot;integration_key&quot;: &quot;8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz&quot;, &quot;api_hostname&quot;: &quot;api-2b5c39f5.duosecurity.com&quot;, &quot;method_name&quot;: &quot;ns1_duo&quot;, }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/duo   $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/duo/4194659f-139b-400b-b5dd-86bfb726759d   ","version":"Next","tagName":"h3"},{"title":"Read Duo MFA method​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#read-duo-mfa-method","content":" This endpoint queries the MFA configuration of Duo type for a given method ID.  Method\tPathGET\t/identity/mfa/method/duo/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#parameters-1","content":" id (string: &lt;required&gt;) – UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/mfa/method/duo/4194659f-139b-400b-b5dd-86bfb726759d   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-response","content":" { &quot;data&quot;: { &quot;api_hostname&quot;: &quot;api-2b5c39f5.duosecurity.com&quot;, &quot;id&quot;: &quot;4194659f-139b-400b-b5dd-86bfb726759d&quot;, &quot;integration_key&quot;: &quot;BIACEUEAXI20BNWTEYXT&quot;, &quot;pushinfo&quot;: &quot;&quot;, &quot;secret_key&quot;: &quot;8C7THtrIigh2rPZQMbguugt8IUftWhMRCOBzbuyz&quot;, &quot;type&quot;: &quot;duo&quot;, &quot;username_format&quot;: &quot;{{identity.entity.aliases.auth_userpass_1793464a.name}}&quot;, &quot;use_passcode&quot;: false } }   ","version":"Next","tagName":"h3"},{"title":"Delete Duo MFA method​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#delete-duo-mfa-method","content":" This endpoint deletes a Duo MFA method. MFA methods can only be deleted if they're not currently in use by a login enforcement.  Method\tPathDELETE\t/identity/mfa/method/duo/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#parameters-2","content":" id (string: &lt;required&gt;) - UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/mfa/method/duo/4194659f-139b-400b-b5dd-86bfb726759d   ","version":"Next","tagName":"h3"},{"title":"List Duo MFA methods​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#list-duo-mfa-methods","content":" This endpoint lists Duo MFA methods that are visible.  Method\tPathLIST\t/identity/mfa/method/duo  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/mfa/method/duo   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"duo","url":"/openbao/api-docs/secret/identity/mfa/duo/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;4194659f-139b-400b-b5dd-86bfb726759d&quot; ] } }  ","version":"Next","tagName":"h3"},{"title":"pingid","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/mfa/pingid/","content":"","keywords":"","version":"Next"},{"title":"Configure PingID MFA method​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#configure-pingid-mfa-method","content":" This endpoint defines an MFA method of type PingID.  Method\tPathPOST\t/identity/mfa/method/pingid/:method_id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#parameters","content":" method_id (string: &quot;&quot;) - Optional UUID to specify if updating an existing method. method_name (string) - The unique name identifier for this MFA method. username_format (string) - A template string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, &quot;{{identity.entity.name}}@example.com&quot;. If blank, the Entity's Name field is used as-is. settings_file_base64 (string: &lt;required&gt;) - A base64-encoded third-party settings file retrieved from PingID's configuration page.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-payload","content":" { &quot;username_format&quot;: &quot;{{identity.entity.aliases.auth_userpass_1793464a.name}}&quot;, &quot;settings_file_base64&quot;: &quot;AA8owj3...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/pingid   $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/pingid/f8381105-67f0-4105-8662-4b07ae5c1233   ","version":"Next","tagName":"h3"},{"title":"Read PingID MFA method​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#read-pingid-mfa-method","content":" This endpoint queries the MFA configuration of PingID type for a given method name.  Method\tPathGET\t/identity/mfa/method/pingid/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#parameters-1","content":" id (string: &lt;required&gt;) – UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/mfa/method/pingid/f8381105-67f0-4105-8662-4b07ae5c1233   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-response","content":" { &quot;data&quot;: { &quot;use_signature&quot;: true, &quot;idp_url&quot;: &quot;https://idpxnyl3m.pingidentity.com/pingid&quot;, &quot;admin_url&quot;: &quot;https://idpxnyl3m.pingidentity.com/pingid&quot;, &quot;authenticator_url&quot;: &quot;https://authenticator.pingone.com/pingid/ppm&quot;, &quot;id&quot;: &quot;f8381105-67f0-4105-8662-4b07ae5c1233&quot;, &quot;org_alias&quot;: &quot;181459b0-9fb1-4938-8c86...&quot;, &quot;type&quot;: &quot;pingid&quot;, } }   ","version":"Next","tagName":"h3"},{"title":"Delete PingID MFA method​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#delete-pingid-mfa-method","content":" This endpoint deletes a PingID MFA method. MFA methods can only be deleted if they're not currently in use by a login enforcement.  Method\tPathDELETE\t/identity/mfa/method/pingid/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#parameters-2","content":" id (string: &lt;required&gt;) - UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/mfa/method/pingid/f8381105-67f0-4105-8662-4b07ae5c1233   ","version":"Next","tagName":"h3"},{"title":"List PingID MFA methods​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#list-pingid-mfa-methods","content":" This endpoint lists PingID MFA methods that are visible.  Method\tPathLIST\t/identity/mfa/method/pingid  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/mfa/method/pingid   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"pingid","url":"/openbao/api-docs/secret/identity/mfa/pingid/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;f8381105-67f0-4105-8662-4b07ae5c1233&quot; ] } }  ","version":"Next","tagName":"h3"},{"title":"totp","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/mfa/totp/","content":"","keywords":"","version":"Next"},{"title":"Configure TOTP MFA method​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#configure-totp-mfa-method","content":" This endpoint defines an MFA method of type TOTP.  Method\tPathPOST\t/identity/mfa/method/totp/:method_id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#parameters","content":" method_id (string: &quot;&quot;) - Optional UUID to specify if updating an existing method. method_name (string) - The unique name identifier for this MFA method. issuer (string: &lt;required&gt;) - The name of the key's issuing organization. period (int or duration format string: 30) - The length of time used to generate a counter for the TOTP token calculation. key_size (int: 20) – Specifies the size in bytes of the generated key. qr_size (int: 200) - The pixel size of the generated square QR code. algorithm (string: &quot;SHA1&quot;) – Specifies the hashing algorithm used to generate the TOTP code. Options include &quot;SHA1&quot;, &quot;SHA256&quot; and &quot;SHA512&quot;. digits (int: 6) - The number of digits in the generated TOTP token. This value can either be 6 or 8. skew (int: 1) - The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1. max_validation_attempts (int: 5) - The maximum number of consecutive failed validation attempts.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-payload","content":" { &quot;issuer&quot;: &quot;openbao&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp   $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp/1f36d4cf-52c9-475d-a5cd-49c573c54e55   ","version":"Next","tagName":"h3"},{"title":"Read TOTP MFA method​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#read-totp-mfa-method","content":" This endpoint queries the MFA configuration of TOTP type for a given method ID.  Method\tPathGET\t/identity/mfa/method/totp/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#parameters-1","content":" id (string: &lt;required&gt;) – UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp/4c6b1968-b385-4c46-ac5e-9b74e7b206be   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-response","content":" { &quot;data&quot;: { &quot;algorithm&quot;: &quot;SHA1&quot;, &quot;digits&quot;: 6, &quot;id&quot;: &quot;4c6b1968-b385-4c46-ac5e-9b74e7b206be&quot;, &quot;issuer&quot;: &quot;openbao&quot;, &quot;key_size&quot;: 20, &quot;period&quot;: 30, &quot;qr_size&quot;: 200, &quot;skew&quot;: 1, &quot;type&quot;: &quot;totp&quot;, &quot;namespace&quot;: &quot;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete TOTP MFA method​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#delete-totp-mfa-method","content":" This endpoint deletes a TOTP MFA method. MFA methods can only be deleted if they're not currently in use by a login enforcement.  Method\tPathDELETE\t/identity/mfa/method/totp/:id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#parameters-2","content":" id (string: &lt;required&gt;) - UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp/4c6b1968-b385-4c46-ac5e-9b74e7b206be   ","version":"Next","tagName":"h3"},{"title":"List TOTP MFA methods​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#list-totp-mfa-methods","content":" This endpoint lists TOTP MFA methods that are visible.  Method\tPathLIST\t/identity/mfa/method/totp  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;1f36d4cf-52c9-475d-a5cd-49c573c54e55&quot;, &quot;4c6b1968-b385-4c46-ac5e-9b74e7b206be&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Generate a TOTP MFA secret​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#generate-a-totp-mfa-secret","content":" This endpoint generates an MFA secret in the entity of the calling token, if it doesn't exist already, using the configuration stored under the given MFA method ID.  Method\tPathPOST\t/identity/mfa/method/totp/generate  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#parameters-3","content":" method_id (string: &lt;required&gt;) - UUID of the MFA method.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-payload-1","content":" { &quot;method_id&quot;: &quot;1f36d4cf-52c9-475d-a5cd-49c573c54e55&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp/generate   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-response-2","content":" { &quot;data&quot;: { &quot;barcode&quot;: &quot;iVBORw0KGgoAAAANSUhEUgAAAMgAAADIEAAAAADYoy0BAAAGc0lEQVR4nOyd244bOQxEZxbz/7+cRQI4sLWiyCLlTU1wzkMAu1uXTIGSxUv3148fH2DEP396AvDK189/Pj97jR/W9Wi/fs7uz/pZya5H92dk40fzjeY1+XtiIWYgiBkIYsbX84dba7O6B0z3hmgPqO5Z6/WsH3VvynjuDwsxA0HMQBAzvnZfZueI6Pvs93r2+z6ax7qWZ+2zPSP7PutfPW8of08sxAwEMQNBzNjuISqRLyc7X6jnkex8UPVBqXtJxk2PORZiBoKYgSBmXNlDsriIeq6J+umeG1RfVjav7L4JWIgZCGIGgpix3UO6a6MaU4/OD9Fnda2P2qnxl2ge1fbKOFiIGQhiBoKY8bKHdH052V5Q3VPUz9n42XhR++zzStWXVgELMQNBzEAQM37tIbd9MtX4Qvc8EI13q32210Sfb8wHCzEDQcxAEDM+f6532e/86nmiPYk31X2sZP1Pz0PVGP+pPRZiBoKYgSBmbPeQ/9xUvP6geg7p9leNj3RrH7v1K+reRm7vNwBBzEAQM471IVmt3oN31V9E93Xr3KNx1BrD7t+jMl8sxAwEMQNBzDjm9lZj5d04gZoLHPX3rjjFu3J5T/8/LMQMBDEDQcyQ6kPUHNsH1TU+Gi/qr+rLmo6zfq6eTzr9YiFmIIgZCGLG5/M69y5fzfr9Ol613bQ/NaYe9bui5gKczmNYiBkIYgaCmHF85mK01t2KO2Q1h9l43dzgbhxG7b+zZ2EhZiCIGQhiRuvZ77dygNVY+3q9es5Qv1+vT2sIlb0OCzEDQcxAEDMkX1bXN7S2z8brxl2q40b3rXR9bxn4sr4RCGIGgpjxUh8S0a2feFdNYrd/Ndad9Xsrpv/cHgsxA0HMQBAzPk/reXdN7fqA3ln/PZnndE9SxsFCzEAQMxDEjJd4iJqrqtYiPlBr9qZE81znk7V/F8TUjUEQMxDEjO1ze9U1PqtFzO5X87VW1H6i+XXqyneQl/UXgSBmIIgZpdzebgxdPWdMfVnr/dHn23XsWb18VpP4DBZiBoKYgSBmbPOyukzr2Lvnlu781FzkaF7deezAQsxAEDMQxIxjTP33TcN8JpXqOOp9qg8tm586n8qehYWYgSBmIIgZrfcYZvGPW2tztZ0aj8nGzb7Prnfr5z+wED8QxAwEMaP0PvVpzV63zru6pld//6t7SvRZzXmO5rPrBwsxA0HMQBAzpGeddH08WT/VNTv6vZ/NJxp/Wh8S9ZvN5/T/x0LMQBAzEMSMY0y9mpdV3YPU+pNsnGm+1v9dyxhBjaExCGIGgpixPYdUzwUdf/8JNV+qu3dE/aj9Z/Un0XzWcTiHGIMgZiCIGaX3qf+++fLe0f0dP83FVfO0VNS9jXOIMQhiBoKY8esc0vUBqb4ttY49Q13js/uzPKsuSr4XFmIGgpiBIGaM8rKmz0bJxo36nZ5Xov6zcbvnFqWWEQsxA0HMQBAzSs9cXKneH8ULpnUV0/lle0Y3DqOOv2uPhZiBIGYgiBnbOvVunfdKNyf2to9L9UV1Y/Tr/ep5iXiIIQhiBoKYcczLys4P1b2lGwNf23dr99Q8rqnvrOvr+sBC/EAQMxDEjG1M/UHXFxWhxAUq31evd5nmjWU+MvKyvgEIYgaCmLF9F+7Ul7TSrbdQzw/qeOv9K7f+v0o7LMQMBDEDQcw4vj8kYlpf3vUFZe2jeVbbVX1Y1fE6eyAWYgaCmIEgZmyfdVL9XT7NAb5F9xyh7n3Tc1IlToKFmIEgZiCIGaV3UHXrv6P23fyubj1K1l80zwg17yq6vhsfCzE DQcxAEDOOz+2troUZaq1hNP40lr/eP61TicbP5nO6joWYgSBmIIgZx7ysiNu+ruj6dB5q7D4ii5Oo82EP+UYgiBkIYob0/pCV2/Uda7/TunX1PJHNq9qvGvN/HgcLMQNBzEAQM1p5WdM6kI mv5zReNo9uvtet+WTz+sBC/EAQMxDEjO0zF99dA9it+6jOM7qe+dKqde7V/qP5nP5eWIgZCGIGgpix3UNUbsXkq/Xd2Thd35zqE5v66Hb9YCFmIIgZCGLGlT3kwS1fUbcGsVq3HvUXnY/U+ ExEZW/DQsxAEDMQxIzS+0Mybq3REd1c3ur5qBs7z/a4zjNWsBAzEMQMBDHjZQ+Z+oAeqGv42o9aq5j1m5HN51ZdfWX+WIgZCGIGgpixfX8I/DmwEDP+DQAA//9kwGH4xZewMgAAAABJRU5E rkJggg==&quot;, &quot;url&quot;: &quot;otpauth://totp/openbao:4746fb81-028c-cd4e-026b-7dd18fe4c2f4?algorithm=SHA1&amp;digits=6&amp;issuer=openbao&amp;period=30&amp;secret=XVE7TOZWJVEWQOATOD7 U53IEAJG72Z2I&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Administratively generate a TOTP MFA secret​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#administratively-generate-a-totp-mfa-secret","content":" This endpoint can be used to generate a TOTP MFA secret. Unlike the generateAPI which stores the generated secret on the entity ID of the calling token, the admin-generate API stores the generated secret on the given entity ID.  Method\tPathPOST\t/identity/mfa/method/totp/admin-generate  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#parameters-4","content":" method_id (string: &lt;required&gt;) - UUID of the MFA method. entity_id (string: &lt;required&gt;) - Entity ID on which the generated secret needs to get stored.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-payload-2","content":" { &quot;method_id&quot;: &quot;4746fb81-028c-cd4e-026b-7dd18fe4c2f4&quot;, &quot;entity_id&quot;: &quot;9189f7fd-e3f5-436b-a835-cb14864b1e01&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json http://127.0.0.1:8200/v1/identity/mfa/method/totp/admin-generate   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-response-3","content":" { &quot;data&quot;: { &quot;barcode&quot;: &quot;iVBORw0KGgoAAAANSUhEUgAAAMgAAADIEAAAAADYoy0BAAAGZElEQVR4nOyd7W4jNwxFkyLv/8pbpMAAHnUo8pJyc1Oc82OB2KOP9QVFSyTlrz9/PsCIv356AnDn6/ufz89e48i6ov6u59f319ezfqtWnf2/snHX19XnVL7bYyFmIIgZCGLG5/e61V2b37WWXkRr9+lxonEvqv1XfeHK6/NYiBkIYgaCmPH19GK2j4ieX9/P9h0R2T6l+pzqYzKfmM0zQvk8sRAzEMQMBDHj0YdMqa6Z1TOvyDdF/VTPnqLnVzIfePLEHAsxA0HMQBAz3uJDqvuVbO1Vv/934yzReNV4ykmwEDMQxAwEMePRh5xeG6fxjNXnVM+Y1HHVM7Tq56R8nliIGQhiBoKYcfMhp2LT6hp7UY2hV8dTY/KZT1N9SufzxELMQBAzEMSMf3zI6X2HembUXbuz8dT9g+qLIiafJxZiBoKYgSBm3OpDunlMartTubrdeEUWI1dzAqa5wK9gIWYgiBkIYsaReIi6P1jbqd/7qznDqm9SfcKJs6sVLMQMBDEDQcz43K3z3fqLaf336fiFymQf8dRe8aVYiBkIYgaCmHHzIdW8pGo8QT1rOuULTvkc9a6TqD+lTgULMQNBzEAQMx7jIRdqjV7ULvpbrReJxl/nodYodseLxu/GWz6wED8QxAwEMeN2X9ZK9/4neRLDNfrUc919yPp8t/8PLMQPBDEDQcyQ6tTVO0JWqvGT6PWu75jub6L+T/kg4iHGIIgZCGLGKB5yKn5SpVuDWKXrI0/4jgssxAwEMQNBzNieZWV0v/erZ0Knxp3OYxoXqoyPhZiBIGYgiBmPub1q7m7G6fiB2n+3niSbZwT7kP8RCGIGgpjxeF9W5iPU8/+ofUY1r6q6ZkfzmtbJV2skozw04iHGIIgZCGKGlJeVvZ61V+MX07OiqJ9oftE41fGm9TD4EEMQxAwEMaN010lW1zGNoVfX+OrZl/rcfx0P2c0XCzEDQcxAEDMe87K68YBubH7tdxonmcb0q+2qZ2DK/gkLMQNBzEAQM2516lXUs6GIbA3v+qruPinrX/Ud0Xx288JCzEAQMxDEjG2NYXf/odztsXuuEoOu9BO93933RONm86n0h4WYgSBmIIgZt9+gqtaDq7m3K2rObnc+UT/Z36f2MZ28MCzEDAQxA0HMaJ1lTevBo/5OxRsysv1O9Fx1nO4Z3QcW4geCmIEgZki/H1Klu+Z369PVeVXHexfEQ34RCGIGgpjxWGN40c1VXdtXaxW79SLTOvqonVpDqdavkNv7C0AQMxDEjNK9vdP4gFq3ntV1Z+NEf099ZEZ1vrv+sBAzEMQMBDFjW2PYjT9U4xqqT1D7/ak4j5rn9QoWYgaCmIEgZpTu7e2u5Vk/4aQO3XFSHUc9s1rnNfVdr/1hIWYgiBkIYsZtH6LGA9Z20d8Z3fuq1HyqUznC1fZVX0c8xBgEMQNBzNje2xvxrlzYan1K1H82fjXOUfU12XzW5yufBxZiBoKYgSBmSL+FezE9s1lR9yHq2VvUT7fefOpjd58fFmIGgpiBIGZId52sr6u5u9M7RtTn1Hmr8ZzqnSvK2R4WYgaCmIEgZmzjIdHr3Rzfi278I3pdvStFrWVUfU52d8quPRZiBoKYgSBmbOvU//Xwobr1U7FpNV8qatetm4+onvU9jYuFmIEgZiCIGbf7srLv1d01vLsWqzmzapymeyaWfQ5qXtsrWIgZCGIGgphR+g2q9f0V9Y6SartsXtP8qOmZWDTe5AwMCzEDQcxAEDMeY+rVfUj0fLddN9Y+3feodfPd+pnKvLAQMxDEDAQxY1unPo11q+2i8adxCXV+an/qfHbzwELMQBAzEMQMKaYediL6FDVmruaBTWsU1bMwdT67/zcWYgaCmIEgZrR+g+piPata18Tu9/Zurq5aTxLNV833qs6nMg8sxAwEMQNBzHisD8lQ6y3W/qt3kpyuS8/ez3xiNL/qfMjL+oUgiBkIYkYppn7R9THd56s5tBGn60myfcSJ3GMsxAwEMQNBzGjdlxXRja1068mj9tla3c3DysaLxon+fgILMQNBzEAQM476kG5c5aJ7BnS6bqX6+jS/jLysXwCCmIEgZmx/x7DK6btCurF31WdMawPfkXOMhZiBIGYgiBmPvx+iUo2RV/vp3llSpZuXpfqgbNwnsBAzEMQMBDHjSH0InAMLMePvAAAA//8x2VnbmmL6HQAAAABJRU5ErkJggg==&quot;, &quot;url&quot;: &quot;otpauth://totp/openbao:4746fb81-028c-cd4e-026b-7dd18fe4c2f4?algorithm=SHA1&amp;digits=6&amp;issuer=openbao&amp;period=30&amp;secret=6HQ4RZ7GM6MMLRKVDCI23LXNZF7UDZ2U&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Administratively destroy TOTP MFA secret​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#administratively-destroy-totp-mfa-secret","content":" This endpoint deletes a TOTP MFA secret from the given entity ID.  To overwrite a secret on the entity, explicitly deleting the secret first is required. This API can be used to delete the secret and the generate or admin-generate APIs should be used to regenerate a new secret.  Method\tPathPOST\t/identity/mfa/method/totp/admin-destroy  ","version":"Next","tagName":"h3"},{"title":"Parameters​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#parameters-5","content":" method_id (string: &lt;required&gt;) - UUID of the MFA method. entity_id (string: &lt;required&gt;) - Entity ID from which the MFA secret should be removed.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-payload-3","content":" { &quot;method_id&quot;: &quot;4746fb81-028c-cd4e-026b-7dd18fe4c2f4&quot;, &quot;entity_id&quot;: &quot;9189f7fd-e3f5-436b-a835-cb14864b1e01&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"totp","url":"/openbao/api-docs/secret/identity/mfa/totp/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/mfa/method/totp/admin-destroy  ","version":"Next","tagName":"h3"},{"title":"oidc-provider","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/oidc-provider/","content":"","keywords":"","version":"Next"},{"title":"Create or update a provider​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#create-or-update-a-provider","content":" This endpoint creates or updates a Provider.  Method\tPathPOST\tidentity/oidc/provider/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters","content":" name (string: &lt;required&gt;) – The name of the provider. This parameter is specified as part of the URL. issuer (string: &lt;optional&gt;) - Specifies what will be used as the scheme://host:port component for the iss claim of ID tokens. This defaults to a URL with OpenBao's api_addr as the scheme://host:port component and /v1/identity/oidc/provider/:name as the path component. If provided explicitly, it must point to an OpenBao instance that is network reachable by clients for ID token validation. allowed_client_ids ([]string: &lt;optional&gt;) – The client IDs that are permitted to use the provider. If empty, no clients are allowed. If &quot;*&quot; is provided, all clients are allowed. scopes_supported ([]string: &lt;optional&gt;) – The scopes available for requesting on the provider.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-payload","content":" { &quot;allowed_client_ids&quot;: [&quot;*&quot;], &quot;scopes_supported&quot;: [&quot;test-scope&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider   ","version":"Next","tagName":"h3"},{"title":"Read provider by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#read-provider-by-name","content":" This endpoint queries the OIDC provider by its name.  Method\tPathGET\t/identity/oidc/provider/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-1","content":" name (string: &lt;required&gt;) – The name of the provider.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response","content":" { &quot;data&quot;: { &quot;allowed_client_ids&quot;:[&quot;*&quot;], &quot;issuer&quot;:&quot;&quot;, &quot;scopes_supported&quot;:[&quot;test-scope&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"List providers​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#list-providers","content":" This endpoint returns a list of all OIDC providers.  Method\tPathLIST\t/identity/oidc/provider  ","version":"Next","tagName":"h2"},{"title":"Query parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#query-parameters","content":" allowed_client_id (string: &lt;optional&gt;) – Filters the list of OIDC providers to those that allow the given client ID in their set of allowed_client_ids.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/oidc/provider   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-1","content":" { &quot;data&quot;: { &quot;key_info&quot;: { &quot;default&quot;: { &quot;allowed_client_ids&quot;: [ &quot;*&quot; ], &quot;issuer&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/default&quot;, &quot;scopes_supported&quot;: [] } }, &quot;keys&quot;: [ &quot;default&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Delete provider by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#delete-provider-by-name","content":" This endpoint deletes an OIDC provider.  Method\tPathDELETE\t/identity/oidc/provider/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-2","content":" name (string: &lt;required&gt;) – The name of the provider.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider   ","version":"Next","tagName":"h3"},{"title":"Create or update a scope​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#create-or-update-a-scope","content":" This endpoint creates or updates a scope.  Method\tPathPOST\tidentity/oidc/scope/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-3","content":" name (string: &lt;required&gt;) – The name of the scope. This parameter is specified as part of the URL. The openid scope name is reserved. template (string: &lt;optional&gt;) - The JSON templatestring for the scope. This may be provided as escaped JSON or base64 encoded JSON. description (string: &lt;optional&gt;) – A description of the scope.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-payload-1","content":" { &quot;template&quot;:&quot;{ \\&quot;groups\\&quot;: {{identity.entity.groups.names}} }&quot;, &quot;description&quot;:&quot;A simple scope example.&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/scope/test-scope   ","version":"Next","tagName":"h3"},{"title":"Read scope by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#read-scope-by-name","content":" This endpoint queries a scope by its name.  Method\tPathGET\t/identity/oidc/scope/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-4","content":" name (string: &lt;required&gt;) – The name of the scope.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/scope/test-scope   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-2","content":" { &quot;data&quot;: { &quot;description&quot;:&quot;A simple scope example.&quot;, &quot;template&quot;:&quot;{ \\&quot;groups\\&quot;: {{identity.entity.groups.names}} }&quot; } }   ","version":"Next","tagName":"h3"},{"title":"List scopes​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#list-scopes","content":" This endpoint returns a list of all configured scopes.  Method\tPathLIST\t/identity/oidc/scope  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/oidc/scope   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-3","content":" { &quot;data&quot;: { &quot;keys&quot;:[ &quot;test-scope&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Delete scope by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#delete-scope-by-name","content":" This endpoint deletes a scope.  Method\tPathDELETE\t/identity/oidc/scope/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-5","content":" name (string: &lt;required&gt;) – The name of the scope.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/oidc/scope/test-scope   ","version":"Next","tagName":"h3"},{"title":"Create or update a client​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#create-or-update-a-client","content":" This endpoint creates or updates a client.  Method\tPathPOST\tidentity/oidc/client/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-6","content":" name (string: &lt;required&gt;) – The name of the client. This parameter is specified as part of the URL. key (string: &quot;default&quot;) – A reference to a named keyresource. This key will be used to sign ID tokens for the client. This cannot be modified after creation. If not supplied, defaults to the built-in default key. redirect_uris ([]string: &lt;optional&gt;) - Redirection URI values used by the client. One of these values must exactly match the redirect_uri parameter value used in each authentication request. assignments ([]string: &lt;optional&gt;) – A list of assignment resources associated with the client. Client assignments limit the OpenBao entities and groups that are allowed to authenticate through the client. By default, no OpenBao entities are allowed. To allow all OpenBao entities to authenticate through the client, supply the built-inallow_all assignment. client_type (string: &quot;confidential&quot;) – The client typebased on its ability to maintain confidentiality of credentials. This cannot be modified after creation. The following list details the differences between confidential and public clients in OpenBao: confidential Capable of maintaining the confidentiality of its credentialsHas a client secretUses the client_secret_basic or client_secret_post client authentication methodMay use Proof Key for Code Exchange (PKCE) for the authorization code flow public Not capable of maintaining the confidentiality of its credentialsDoes not have a client secretUses the none client authentication methodMust use Proof Key for Code Exchange (PKCE) for the authorization code flow id_token_ttl (int or duration: &quot;24h&quot;) – The time-to-live for ID tokens obtained by the client. Accepts duration format strings. The value should be less than the verification_ttlon the key. access_token_ttl (int or duration: &quot;24h&quot;) – The time-to-live for access tokens obtained by the client. Accepts duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-payload-2","content":" { &quot;key&quot;:&quot;test-key&quot;, &quot;access_token_ttl&quot;:&quot;30m&quot;, &quot;id_token_ttl&quot;:&quot;1h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/client/test-client   ","version":"Next","tagName":"h3"},{"title":"Read client by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#read-client-by-name","content":" This endpoint queries a client by its name.  Method\tPathGET\t/identity/oidc/client/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-7","content":" name (string: &lt;required&gt;) – The name of the client.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/client/test-client   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-4","content":" { &quot;data&quot;:{ &quot;access_token_ttl&quot;:1800, &quot;assignments&quot;:[], &quot;client_id&quot;:&quot;014zXvcvbvIZWwD5NfD1Uzmv7c5JBRMb&quot;, &quot;client_secret&quot;:&quot;hvo_secret_bZtgQPBZaJXK7F5vOI7JlvEuLOfOUS7DmwynFjE3xKcsen7TyowqPFfYFXG2tbWM&quot;, &quot;client_type&quot;: &quot;confidential&quot;, &quot;id_token_ttl&quot;:3600, &quot;key&quot;:&quot;test-key&quot;, &quot;redirect_uris&quot;:[] } }   ","version":"Next","tagName":"h3"},{"title":"List clients​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#list-clients","content":" This endpoint returns a list of all configured clients.  Method\tPathLIST\t/identity/oidc/client  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/oidc/client   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-5","content":" { &quot;data&quot;: { &quot;key_info&quot;: { &quot;my-app&quot;: { &quot;access_token_ttl&quot;: 86400, &quot;assignments&quot;: [ &quot;allow_all&quot; ], &quot;client_id&quot;: &quot;wGr981oYLJbcr4zrUriYxjxSc80JL7HW&quot;, &quot;client_type&quot;: &quot;confidential&quot;, &quot;id_token_ttl&quot;: 86400, &quot;key&quot;: &quot;default&quot;, &quot;redirect_uris&quot;: [ &quot;http://localhost:5555/callback&quot; ] } }, &quot;keys&quot;: [ &quot;my-app&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Delete client by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#delete-client-by-name","content":" This endpoint deletes a client.  Method\tPathDELETE\t/identity/oidc/client/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-8","content":" name (string: &lt;required&gt;) – The name of the client.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/oidc/client/test-client   ","version":"Next","tagName":"h3"},{"title":"Create or update an assignment​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#create-or-update-an-assignment","content":" This endpoint creates or updates an assignment.  Method\tPathPOST\tidentity/oidc/assignment/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-9","content":" name (string: &lt;required&gt;) – The name of the assignment. This parameter is specified as part of the URL. entity_ids ([]string: &lt;optional&gt;) - A list of OpenBao entity IDs. group_ids ([]string: &lt;optional&gt;) – A list of OpenBao group IDs.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-payload-3","content":" { &quot;group_ids&quot;:[&quot;262ca5b9-7b69-0a84-446a-303dc7d778af&quot;], &quot;entity_ids&quot;:[&quot;b6094ac6-baf4-6520-b05a-2bd9f07c66da&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/assignment/test-assignment   ","version":"Next","tagName":"h3"},{"title":"Read assignment by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#read-assignment-by-name","content":" This endpoint queries an assignment by its name.  Method\tPathGET\t/identity/oidc/assignment/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-10","content":" name (string: &lt;required&gt;) – The name of the assignment.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-13","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/assignment/test-assignment   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-6","content":" { &quot;data&quot;:{ &quot;entity_ids&quot;:[ &quot;b6094ac6-baf4-6520-b05a-2bd9f07c66da&quot; ], &quot;group_ids&quot;:[ &quot;262ca5b9-7b69-0a84-446a-303dc7d778af&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"List assignments​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#list-assignments","content":" This endpoint returns a list of all configured assignments.  Method\tPathLIST\t/identity/oidc/assignment  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/oidc/assignment   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-7","content":" { &quot;data&quot;: { &quot;keys&quot;:[ &quot;test-assignment&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Delete assignment by name​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#delete-assignment-by-name","content":" This endpoint deletes an assignment.  Method\tPathDELETE\t/identity/oidc/assignment/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-11","content":" name (string: &lt;required&gt;) – The name of the assignment.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-15","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/oidc/assignment/test-assignment   ","version":"Next","tagName":"h3"},{"title":"Read provider OpenID configuration​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#read-provider-openid-configuration","content":" Returns OpenID Connect Metadata for a named OIDC provider. The response is a compliant OpenID Provider Configuration Response.  Method\tPathGET\t/identity/oidc/provider/:name/.well-known/openid-configuration  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-12","content":" name (string: &lt;required&gt;) – The name of the provider. This parameter is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-16","content":" $ curl \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/.well-known/openid-configuration   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-8","content":" { &quot;issuer&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider&quot;, &quot;jwks_uri&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/.well-known/keys&quot;, &quot;authorization_endpoint&quot;: &quot;http://127.0.0.1:8200/ui/identity/oidc/provider/test-provider/authorize&quot;, &quot;token_endpoint&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/token&quot;, &quot;userinfo_endpoint&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/userinfo&quot;, &quot;request_parameter_supported&quot;: false, &quot;request_uri_parameter_supported&quot;: false, &quot;id_token_signing_alg_values_supported&quot;: [ &quot;RS256&quot;, &quot;RS384&quot;, &quot;RS512&quot;, &quot;ES256&quot;, &quot;ES384&quot;, &quot;ES512&quot;, &quot;EdDSA&quot; ], &quot;response_types_supported&quot;: [ &quot;code&quot; ], &quot;scopes_supported&quot;: [ &quot;openid&quot; ], &quot;subject_types_supported&quot;: [ &quot;public&quot; ], &quot;grant_types_supported&quot;: [ &quot;authorization_code&quot; ], &quot;token_endpoint_auth_methods_supported&quot;: [ &quot;client_secret_basic&quot;, &quot;client_secret_post&quot;, &quot;none&quot; ]}   ","version":"Next","tagName":"h3"},{"title":"Read provider public keys​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#read-provider-public-keys","content":" Query this path to retrieve the public portion of keys for an OIDC provider. Clients can use them to validate the authenticity of an identity token.  Method\tPathGET\t/identity/oidc/provider/:name/.well-known/keys  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-13","content":" name (string: &lt;required&gt;) – The name of the provider. This parameter is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-17","content":" $ curl \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/.well-known/keys   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-9","content":" { &quot;keys&quot;: [ { &quot;use&quot;: &quot;sig&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;kid&quot;: &quot;ee7c0920-fdb9-5c1a-9c69-6dab710d1a09&quot;, &quot;alg&quot;: &quot;RS256&quot;, &quot;n&quot;: &quot;zdFjUV9lBw5nQPvTtwH-gzKgRG7iepvYbFoc2hNB0-inJL25oh-mvNW3GS8jPY5XHLsiWa_1TKKE99JrKQgane2C96soFeOvR7SozbCeH8_FpZelH1Pym1NV038j05Vp87uB9FeKPsy1PNOLPTs_Fp42JIAenly7ojYwPp1s61p9V0U9rOhtldY7GkXHLN9s8v3aJjxqrTS3Puhs9MFS7EgRrEDAc69uiLXCoYXKygjXddvJi6j446XxnO2eTRMGl1f2t04s_vDgVnFQgjQSKYWPbOMhf2slkeR47fqE3qqUDzINxauqMbkW-PlLP9IN0crR2uC07cG2os4RxN4YHw&quot;, &quot;e&quot;: &quot;AQAB&quot; }, { &quot;use&quot;: &quot;sig&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;kid&quot;: &quot;6e468221-b7c2-9d2d-744d-33b7ae0357cb&quot;, &quot;alg&quot;: &quot;RS256&quot;, &quot;n&quot;: &quot;rMaucILJKiFg_lkCE8ZEV_8jiYdaVDjKkc-8XPBW8S34wIRl1EbsgCYfMHtJnIJ_3eUgOVorW5KVeN9C8W16LR3lhqRWS9y4qlt0AcWpOvsmxr5q5dS_QqgCjeftCKwJzUsMi5bMW8wKjRZdd-qLz6X1rVSZWX82G0So8nRBg9d3MNJbKcdIJrRbrxWkm8U9xMqRouzbyQ2Hsp2rRVgGh7yjEA6daI5Ao8UsPdBmlCM9oKZ1_Kje5JTfZKeHlT-58vn_ylCjMVlapLuUsDN6He2kPVyOzGbie297VOfjmB7QX0ah1f7Ni1UJFJYHrVK9wMfCLTltSFZBcQ9--FlVdQ&quot;, &quot;e&quot;: &quot;AQAB&quot; } ]}   ","version":"Next","tagName":"h3"},{"title":"Authorization endpoint​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#authorization-endpoint","content":" Provides the Authorization Endpointfor an OIDC provider. This allows OIDC clients to request an authorization code to be used for the Authorization Code Flow.  Method\tPathGET/POST\t/identity/oidc/provider/:name/authorize  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-14","content":" name (string: &lt;required&gt;) - The name of the provider. This parameter is specified as part of the URL. scope (string: &lt;required&gt;) - A space-delimited list of scopes to be requested. The openid scope is required. response_type (string: &lt;required&gt;) - The OIDC authentication flow to be used. The following response types are supported: code. client_id (string: &lt;required&gt;) - The ID of the requesting client. redirect_uri (string: &lt;required&gt;) - The redirection URI to which the response will be sent. state (string: &lt;optional&gt;) - A value used to maintain state between the authentication request and client. nonce (string: &lt;optional&gt;) - A value that is returned in the ID token nonce claim. It is used to mitigate replay attacks, so we strongly encourage providing this optional parameter. max_age (integer: &lt;optional&gt;) - The allowable elapsed time in seconds since the last time the end-user was actively authenticated. code_challenge (string: &lt;optional&gt;) - The PKCEcode challenge derived from the client's code verifier. Optional for confidential clients. Required for public clients. code_challenge_method (string: &quot;plain&quot;) - The method that was used to derive thePKCE code challenge. The following methods are supported: S256, plain.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-18","content":" $ curl \\ --request GET \\ --header &quot;X-Vault-Token: ...&quot; \\ -G \\ -d &quot;response_type=code&quot; \\ -d &quot;client_id=$CLIENT_ID&quot; \\ -d &quot;state=af0ifjsldkj&quot; \\ -d &quot;nonce=abcdefghijk&quot; \\ --data-urlencode &quot;scope=openid&quot; \\ --data-urlencode &quot;redirect_uri=http://127.0.0.1:8251/callback&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/authorize   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-10","content":" { &quot;code&quot;: &quot;BDSc9kVYljxND93YpveBuJtSvguM3AWe&quot;, &quot;state&quot;: &quot;af0ifjsldkj&quot; }   ","version":"Next","tagName":"h3"},{"title":"Token endpoint​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#token-endpoint","content":" Provides the Token Endpointfor an OIDC provider.  Method\tPathPOST\t/identity/oidc/provider/:name/token  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-15","content":" name (string: &lt;required&gt;) - The name of the provider. This parameter is specified as part of the URL. code (string: &lt;required&gt;) - The authorization code received from the provider's authorization endpoint. grant_type (string: &lt;required&gt;) - The authorization grant type. The following grant types are supported: authorization_code. redirect_uri (string: &lt;required&gt;) - The callback location where the authorization request was sent. This must match the redirect_uri used when the original authorization code was generated. client_id (string: &lt;optional&gt;) - The ID of the requesting client. This parameter is required for public clients which do not have a client secret or confidentialclients using the client_secret_post client authentication method. client_secret (string: &lt;optional&gt;) - The secret of the requesting client. This parameter is required for confidential clients using the client_secret_post client authentication method. code_verifier (string: &lt;optional&gt;) - The code verifier associated with the givencode. Required for authorization codes that were granted using PKCE. Required for public clients.  ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#headers","content":" Authorization: Basic (string: &lt;optional&gt;) - An HTTP Basic authentication scheme header including the client_id and client_secret as described in the client_secret_basicauthentication method. This header is only required for confidential clients using the client_secret_basic client authentication method.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-19","content":" $ BASIC_AUTH_CREDS=$(printf &quot;%s:%s&quot; &quot;$CLIENT_ID&quot; &quot;$CLIENT_SECRET&quot; | base64) $ curl \\ --request POST \\ --header &quot;Authorization: Basic $BASIC_AUTH_CREDS&quot; \\ -H 'Content-Type: application/x-www-form-urlencoded' \\ -d &quot;code=4RL50r78p8HsNJY0GVUNGfjLHnpkRf3N&quot; \\ -d &quot;grant_type=authorization_code&quot; \\ -d &quot;redirect_uri=http://127.0.0.1:8251/callback&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/token   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-11","content":" { &quot;access_token&quot;: &quot;b.AAAAAQJEH5VXjfjUESCwySTKk2MS1MGVNc9oU-N2EyoLKVo9SYa-NnOWAXloYfrlO45UWC3R1PC5ZShl3JdmRJ0264julNnlBduSNXJkYjgCQsFQwXTKHcjhqdNsmJNMWiPaHPn5NLSpNQVtzAxfHADt4r9rmX-UEG5seOWbmK_Z5WwS_4a8-wcVPB7FpOGzfBydP7yMxHu-3H1TWyQvYVr28XUfYxcBbdlzxhJn0yqkWItgmZ25xEOp7SW7Pg4tYB7AXfk&quot;, &quot;expires_in&quot;: 3600, &quot;id_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6ImEzMjk5ZWVmLTllNDEtOGNiYS1kNWExLTZmZWM2NjIyODRjYyJ9.eyJhdF9oYXNoIjoiMUdlQlEzUFdtUjJ2ajZVU2swSW42USIsImF1ZCI6InpTSktMVmk0R1BYS1o3TTZzUUEwY3FNc05VaHNPYkVTIiwiY19oYXNoIjoiN09SOUszNmhNdllENzJkUkFLUHhNdyIsImNvbnRhY3QiOnsiZW1haWwiOiJ2YXVsdEBoYXNoaWNvcnAuY29tIiwicGhvbmVfbnVtYmVyIjoiMTIzLTQ1Ni03ODkwIn0sImV4cCI6MTYzMzEwNjI5NCwiZ3JvdXBzIjpbImVuZ2luZWVyaW5nIl0sImlhdCI6MTYzMzEwNDQ5NCwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo4MjAwL3YxL2lkZW50aXR5L29pZGMvcHJvdmlkZXIvbXktcHJvdmlkZXIiLCJuYW1lc3BhY2UiOiJyb290Iiwibm9uY2UiOiJhYmNkZWZnaGlqayIsInN1YiI6IjUwMDA3OTZlLTM2ZGYtMGQ4Yy02NDYwLTgxODUzZDliMjY2NyIsInVzZXJuYW1lIjoiZW5kLXVzZXIifQ.ehdLj6jnrJvltar1kkVSyNK48w2M5vkh5DTFJFZDqatnDWhQbbKGLZnVgd3wD6KPboXRaUwhGe4jDiTIiSoJaovOhsia77NKukym_ROLvGZw-LG7xaYkzJLnmEfeQhelLxWe0DHPROB7VXcFqBx8vX5hkuoVyqrB87vwiobK42pDPZ9MRsmbM2yzBC3wrnT7RQFtT4q2Bbyt9YIAHUaq9rU0PwJRoNISw6of1uQHo3_UzLdpwth7PEOEcI47OBGFA5vR_Gw3ocREfSrUWfCWOInAKCT43cImvg4Bts6qiZYfv9n-iNBq4AihGqq_VEF-hB1Hrprn7VgnEZ1VjUHaQQ&quot;, &quot;token_type&quot;: &quot;Bearer&quot; }   ","version":"Next","tagName":"h3"},{"title":"UserInfo endpoint​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#userinfo-endpoint","content":" Provides the UserInfo Endpointfor an OIDC provider. The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns Claims about the authenticated End-User.  Method\tPathPOST\t/identity/oidc/provider/:name/userinfo  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#parameters-16","content":" name (string: &lt;required&gt;) - The name of the provider. This parameter is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#headers-1","content":" Access Token (string: &lt;required&gt;) - The access token provided by theAuthorization: Bearer &lt;access_token&gt; HTTP header acquired from the authorization endpoint.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-request-20","content":" $ curl \\ -X GET \\ --header &quot;Authorization: Bearer $ACCESS_TOKEN&quot; \\ http://127.0.0.1:8200/v1/identity/oidc/provider/test-provider/userinfo   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"oidc-provider","url":"/openbao/api-docs/secret/identity/oidc-provider/#sample-response-12","content":" { &quot;contact&quot;: { &quot;email&quot;: &quot;openbao@lists.lfedge.org&quot;, &quot;phone_number&quot;: &quot;123-456-7890&quot; }, &quot;groups&quot;: [ &quot;engineering&quot; ], &quot;sub&quot;: &quot;5000796e-36df-0d8c-6460-81853d9b2667&quot;, &quot;username&quot;: &quot;end-user&quot;}  ","version":"Next","tagName":"h3"},{"title":"tokens","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/identity/tokens/","content":"","keywords":"","version":"Next"},{"title":"Configure the identity tokens backend​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#configure-the-identity-tokens-backend","content":" This endpoint updates configurations for OIDC-compliant identity tokens issued by OpenBao.  Method\tPathPOST\tidentity/oidc/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters","content":" issuer (string: &quot;&quot;) – Issuer URL to be used in the iss claim of the token. If not set, OpenBao's api_addr will be used. The issuer is a case sensitive URL using the https scheme that contains scheme, host, and an optional port number.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-payload","content":" { &quot;issuer&quot;: &quot;https://example.com:1234&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response","content":" { &quot;data&quot;: null, &quot;warnings&quot;: [ &quot;If \\&quot;issuer\\&quot; is set explicitly, all tokens must be validated against that address, including those issued by secondary clusters. Setting issuer to \\&quot;\\&quot; will restore the default behavior of using the cluster's api_addr as the issuer.&quot; ] }   ","version":"Next","tagName":"h3"},{"title":"Read configurations for the identity tokens backend​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#read-configurations-for-the-identity-tokens-backend","content":" This endpoint queries OpenBao identity tokens configurations.  Method\tPathGET\tidentity/oidc/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-1","content":" { &quot;data&quot;: { &quot;issuer&quot;: &quot;https://example.com:1234&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Create a named key​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#create-a-named-key","content":" This endpoint creates or updates a named key which is used by a role to sign tokens.  Method\tPathPOST\tidentity/oidc/key/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-1","content":" name (string) – Name of the named key. rotation_period (int or time string: &quot;24h&quot;) - How often to generate a new signing key. Uses duration format strings. verification_ttl (int or time string: &quot;24h&quot;) - Controls how long the public portion of a signing key will be available for verification after being rotated. Uses duration format strings. allowed_client_ids (list: []) - Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If &quot;*&quot;, all roles are allowed. algorithm (string: &quot;RS256&quot;) - Signing algorithm to use. Allowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-payload-1","content":" { &quot;rotation_period&quot;: &quot;12h&quot;, &quot;verification_ttl&quot;: 43200 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/key/named-key-001   ","version":"Next","tagName":"h3"},{"title":"Read a named key​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#read-a-named-key","content":" This endpoint queries a named key and returns its configurations.  Method\tPathGET\tidentity/oidc/key/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-2","content":" name (string) – Name of the key.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/key/named-key-001   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-2","content":" { &quot;data&quot;: { &quot;algorithm&quot;: &quot;RS256&quot;, &quot;rotation_period&quot;: 43200, &quot;verification_ttl&quot;: 43200 } }   ","version":"Next","tagName":"h3"},{"title":"Delete a named key​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#delete-a-named-key","content":" This endpoint deletes a named key.  Method\tPathDELETE\tidentity/oidc/key/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-3","content":" name (string) – Name of the key.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/oidc/key/named-key-001   ","version":"Next","tagName":"h3"},{"title":"List named keys​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#list-named-keys","content":" This endpoint will List all named keys.  Method\tPathLIST\tidentity/oidc/key  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/oidc/key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-3","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;named-key-001&quot;, &quot;named-key-002&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Rotate a named key​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#rotate-a-named-key","content":" This endpoint rotates a named key.  Method\tPathPOST\tidentity/oidc/key/:name/rotate  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-4","content":" name (string) – Name of the key to be rotated. verification_ttl (string: &lt;optional&gt;) - Controls how long the public portion of the key will be available for verification after being rotated. Setting verification_ttl here will override the verification_ttl set on the key.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-payload-2","content":" { &quot;verification_ttl&quot;: 0 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/key/named-key-001/rotate   ","version":"Next","tagName":"h3"},{"title":"Create or update a role​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#create-or-update-a-role","content":" Create or update a role. ID tokens are generated against a role and signed against a named key.  Method\tPathPOST\tidentity/oidc/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-5","content":" name (string) – Name of the role. key (string) – A configured named key, the key must already exist. template (string: &lt;optional&gt;) - The template string to use for generating tokens. This may be in string-ified JSON or base64 format. client_id (string: &lt;optional&gt;) - Optional client ID. A random ID will be generated if left unset. ttl (int or time string: &quot;24h&quot;) - TTL of the tokens generated against the role. Uses duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-payload-3","content":" { &quot;key&quot;: &quot;named-key-001&quot;, &quot;ttl&quot;: &quot;12h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/role/role-001   ","version":"Next","tagName":"h3"},{"title":"Read a role​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#read-a-role","content":" This endpoint queries a role and returs its configuration.  Method\tPathGET\tidentity/oidc/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-6","content":" name (string) – Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/role/role-001   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-4","content":" { &quot;data&quot;: { &quot;client_id&quot;: &quot;PGE8tf4RmJkDwvjI1FgARkXEmH&quot;, &quot;key&quot;: &quot;named-key-001&quot;, &quot;template&quot;: &quot;&quot;, &quot;ttl&quot;: 43200 } }   ","version":"Next","tagName":"h3"},{"title":"Delete a role​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#delete-a-role","content":" This endpoint deletes a role.  Method\tPathDELETE\tidentity/oidc/role/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-7","content":" name (string) – Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/identity/oidc/role/role-001   ","version":"Next","tagName":"h3"},{"title":"List roles​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#list-roles","content":" This endpoint will list all signing keys.  Method\tPathLIST\tidentity/oidc/role  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/identity/oidc/role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-5","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;role-001&quot;, &quot;role-002&quot;, &quot;testrole&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Generate a signed ID token​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#generate-a-signed-id-token","content":" Use this endpoint to generate a signed ID (OIDC) token.  Method\tPathGET\tidentity/oidc/token/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-8","content":" name (string: &quot;&quot;) – The name of the role against which to generate a signed ID token  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/token/role-001   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-6","content":" { &quot;data&quot;: { &quot;client_id&quot;: &quot;P6CfCzyHsQY4pMcA6kWAOCItA7&quot;, &quot;token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IjJkMGI4YjlkLWYwNGQtNzFlYy1iNjc0LWM3MzU4NDMyYmM1YiJ9.eyJhdWQiOiJQNkNmQ3p5SHNRWTRwTWNBNmtXQU9DSXRBNyIsImV4cCI6MTU2MTQ4ODQxMiwiaWF0IjoxNTYxNDAyMDEyLCJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tOjEyMzQiLCJzdWIiOiI2YzY1ZWFmNy1kNGY0LTEzMzMtMDJiYy0xYzc1MjE5YzMxMDIifQ.IcbWTmks7P5eVtwmIBl5rL1B88MI55a9JJuYVLIlwE9aP_ilXpX5fE38CDm5PixDDVJb8TI2Q_FO4GMMH0ymHDO25ZvA917WcyHCSBGaQlgcS-WUL2fYTqFjSh-pezszaYBgPuGvH7hJjlTZO6g0LPCyUWat3zcRIjIQdXZum-OyhWAelQlveEL8sOG_ldyZ8v7fy7GXDxfJOK1kpw5AX9DXJKylbwZTBS8tLb-7edq8uZ0lNQyWy9VPEW_EEIZvGWy0AHua-Loa2l59GRRP8mPxuMYxH_c88x1lsSw0vH9E3rU8AXLyF3n4d40PASXEjZ-7dnIf4w4hf2P4L0xs_g&quot;, &quot;ttl&quot;: 86400 } }   ","version":"Next","tagName":"h3"},{"title":"Introspect a signed ID token​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#introspect-a-signed-id-token","content":" This endpoint can verify the authenticity and active state of a signed ID token.  Method\tPathPOST\tidentity/oidc/introspect  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#parameters-9","content":" token (string) – A signed OIDC compliant ID token client_id (string: &lt;optional&gt;) - Specifying the client ID additionally requires the token to contain a matching aud claim  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-payload-4","content":" { &quot;token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6ImE4NDQ4YmVkLTk4ZTMtMDNhMC01ODY4LTdmOWYyZDc5NWY2NSJ9.eyJhdWQiOiJpUDdyV1A4dmhDVFFpOTAydGhaR0hUazJMbyIsImV4cCI6MTU2MTQ4OTE0OSwiaWF0IjoxNTYxNDAyNzQ5LCJpc3MiOiJodHRwOi8vMTI3LjAuMC4xOjgyMDAvdjEvaWRlbnRpdHkvb2lkYyIsInN1YiI6IjQ1NDQxZTg3LWMyMWQtYzY5NS0wNGM3LWU0YmU4MGU1M2Y0ZiJ9.IYZx1bBofBgwphLZggugFUE7V3ZLFDNr0UYv3hhc4RlIu5WgFZPRjpKVXPdORozYJJB_37aJW6qm5j8nNSz4WrWUmMcrVxoZi2VBExu-GcHHniEPRryR9t_45rqP2MycLBz0dICOjFDWvfkp6ddyCsQfkRnplPGCaN67MUEdgYQf5QNyxaG-yabRPiATY_OtXSjiNsMhJe6ZloYTZZc9gTTfKcKQf4mfy5yRY6471qkqeTuYNhKjwdkEnCSaEjHmCdZOYC5DAet16eQ7ankcwBno17_zs7vbPmkXNttALOrjSQgGe1td1SCfZeg5UOs7_IPk0qqdwOdyQ8wsrDmSyg&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/identity/oidc/introspect   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-7","content":" { &quot;active&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Read .well-known configurations​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#read-well-known-configurations","content":" Query this path to retrieve a set of claims about the identity tokens' configuration. The response is a compliant OpenID Provider Configuration Response.  Method\tPathGET\tidentity/oidc/.well-known/openid-configuration  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-13","content":" $ curl \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/.well-known/openid-configuration   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-8","content":" { &quot;issuer&quot;: &quot;https://example.com:1234&quot;, &quot;authorization_endpoint&quot;: &quot;&quot;, &quot;token_endpoint&quot;: &quot;&quot;, &quot;jwks_uri&quot;: &quot;https://example.com:1234/.well-known/keys&quot;, &quot;response_types_supported&quot;: null, &quot;subject_types_supported&quot;: [&quot;public&quot;], &quot;id_token_signing_alg_values_supported&quot;: [&quot;RS256&quot;], &quot;scopes_supported&quot;: null, &quot;token_endpoint_auth_methods_supported&quot;: null, &quot;claims_supported&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Read active public keys​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#read-active-public-keys","content":" Query this path to retrieve the public portion of named keys. Clients can use this to validate the authenticity of an identity token.  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-request-14","content":" $ curl \\ --request GET \\ http://127.0.0.1:8200/v1/identity/oidc/.well-known/keys   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"tokens","url":"/openbao/api-docs/secret/identity/tokens/#sample-response-9","content":" { &quot;keys&quot;: [ { &quot;use&quot;: &quot;sig&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;kid&quot;: &quot;94178020-55b5-e18d-b32b-1010ba5a35b4&quot;, &quot;alg&quot;: &quot;RS256&quot;, &quot;n&quot;: &quot;1bt-V8T7g0zr7koNbdppFrUM5YrnybPDOt-cK3MKmL1FcN3aOltCw9tCYStHgm8mIz_DJ1HgIjA-DcK_O9gacEGFCidUuudV8O4TixToHEVyRe1yXu-Q98hwkm9JtFF9PvMzDXhn4s3bLanOZzO15JAdVCo0JnwSIT9Ay3LxPLbWHYbPj7ROScuvic99OyvWz87qBK-AoXmxo9lRNY39LtieMr1D2iq0HvtjHkfiarr34CSTcuksknOsY49BU5ktrs_YJSEVpeRQ8RywY1sWrq8w_UmGsNFfPr--crXQw0ekJCXzmotsRHE5jwMuhjuucVlnyQFBYEdfDB_iPbC7Hw&quot;, &quot;e&quot;: &quot;AQAB&quot; } ] }  ","version":"Next","tagName":"h3"},{"title":"Kubernetes secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Write configuration​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#write-configuration","content":" This endpoint configures the plugin with the necessary information to reach the Kubernetes API and authenticate with it.  Method\tPathPOST\t/kubernetes/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#parameters","content":" kubernetes_host (string: &quot;https://$KUBERNETES_SERVICE_HOST:KUBERNETES_SERVICE_PORT_HTTPS&quot;) - Kubernetes API URL to connect to. Must be specified if the standard pod environment variables KUBERNETES_SERVICE_HOST or KUBERNETES_SERVICE_PORT_HTTPS are not set.kubernetes_ca_cert (string: &quot;&quot;) - PEM encoded CA certificate to verify the Kubernetes API server certificate. Defaults to the local pod's CA certificate at /var/run/secrets/kubernetes.io/serviceaccount/ca.crt if found, or otherwise the host's root CA set.service_account_jwt (string: &quot;&quot;) - The JSON web token of the service account used by the secrets engine to manage Kubernetes credentials. Defaults to the local pod's JWT at /var/run/secrets/kubernetes.io/serviceaccount/token if found.disable_local_ca_jwt (bool: false) - Disable defaulting to the local CA certificate and service account JWT when running in a Kubernetes pod.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload","content":" { &quot;kubernetes_host&quot;: &quot;https://192.168.99.100:8443&quot;, &quot;kubernetes_ca_cert&quot;: &quot;-----BEGIN CERTIFICATE-----\\n.....\\n-----END CERTIFICATE-----&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/kubernetes/config   ","version":"Next","tagName":"h3"},{"title":"Read configuration​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#read-configuration","content":" Returns the config previously set, excluding credentials.  Method\tPathGET\t/kubernetes/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/kubernetes/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-response","content":" { &quot;data&quot;:{ &quot;kubernetes_host&quot;: &quot;https://192.168.99.100:8443&quot;, &quot;kubernetes_ca_cert&quot;: &quot;-----BEGIN CERTIFICATE-----.....-----END CERTIFICATE-----&quot;, &quot;disable_local_ca_jwt&quot;: false } }   ","version":"Next","tagName":"h3"},{"title":"Delete configuration​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#delete-configuration","content":" Deletes the config previously set.  Method\tPathDELETE\t/kubernetes/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE http://127.0.0.1:8200/v1/kubernetes/config   ","version":"Next","tagName":"h3"},{"title":"Create role​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#create-role","content":" A role configures what service account tokens can be generated, and what permissions will be attached to them. The permissions attached to a service account token depend on the Kubernetes roles applied to its service account.  Each Kubernetes secrets engine role can operate in one of 3 modes. Each successive mode generates more Kubernetes objects, and therefore requires more permissions for OpenBao's own Kubernetes service account.  Generate a service account token for a pre-existing service account - set service_account_name.Generate a service account and a token, and bind a pre-existing Kubernetes role - set kubernetes_role_name.Generate a Kubernetes role, role binding, service account and token - set generated_role_rules.  Only one of service_account_name, kubernetes_role_name orgenerated_role_rules can be set.  Method\tPathPOST\t/kubernetes/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#parameters-1","content":" name (string: &lt;required&gt;) - The name of the role. Included in the path.allowed_kubernetes_namespaces (array: []) - The list of Kubernetes namespaces this role can generate credentials for. If set to &quot;*&quot; all namespaces are allowed. If set with allowed_kubernetes_namespace_selector, the conditions areORed.allowed_kubernetes_namespace_selector (string: &quot;&quot;) - A label selector for Kubernetes namespaces in which credentials can be generated. Accepts either a JSON or YAML object. The value should be of typeLabelSelectoras illustrated in Sample Payload 4 andSample Payload 5 below. If set with allowed_kubernetes_namespaces, the conditions are ORed.token_max_ttl (string: &quot;&quot;) - The maximum TTL for generated Kubernetes tokens, specified in seconds or as a Go duration format string, e.g. &quot;1h&quot;. If not set or set to 0, the system default will be used.token_default_ttl (string: &quot;&quot;) - The default TTL for generated Kubernetes tokens, specified in seconds or as a Go duration format string, e.g. &quot;1h&quot;. If not set or set to 0, the system default will be used.token_default_audiences (string: &quot;&quot;) - The default intended audiences for generated Kubernetes tokens, specified by a comma separated string. e.g &quot;custom-audience-0,custom-audience-1&quot;. If not set or set to &quot;&quot;, the Kubernetes cluster default for audiences of service account tokens will be used.service_account_name (string: &quot;&quot;) - The pre-existing service account to generate tokens for. Mutually exclusive with all role parameters. If set, only a Kubernetes token will be created when credentials are requested. See theKubernetes service account documentationfor more details on service accounts.kubernetes_role_name (string: &quot;&quot;) - The pre-existing Role or ClusterRole to bind a generated service account to. If set, Kubernetes token, service account, and role binding objects will be created when credentials are requested. See the Kubernetes roles documentationfor more details on Kubernetes roles.kubernetes_role_type (string: &quot;Role&quot;) - Specifies whether the Kubernetes role is a Role or ClusterRole.generated_role_rules (string: &quot;&quot;) - The Role or ClusterRole rules to use when generating a role. Accepts either JSON or YAML formatted rules. If set, the entire chain of Kubernetes objects will be generated when credentials are requested. The value should be a rules key with an array ofPolicyRuleobjects, as illustrated in theKubernetes RBAC documentationand Sample Payload 3 below.name_template (string: &quot;&quot;) - The name template to use when generating service accounts, roles and role bindings. If unset, a default template is used. See username templatingfor details on how to write a custom template.extra_annotations (map&lt;string|string&gt;: nil) - Additional annotations to apply to all generated Kubernetes objects. See theKubernetes annotations documentationfor more details on annotations.extra_labels (map&lt;string|string&gt;: nil) - Additional labels to apply to all generated Kubernetes objects. See theKubernetes labels documentationfor more details on labels.  ","version":"Next","tagName":"h3"},{"title":"Sample payload 1​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload-1","content":" To generate tokens for a pre-existing service account:  { &quot;allowed_kubernetes_namespaces&quot;: &quot;*&quot;, &quot;service_account_name&quot;: &quot;default&quot;, &quot;token_max_ttl&quot;: &quot;24h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample payload 2​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload-2","content":" To generate tokens for a pre-existing ClusterRole:  { &quot;allowed_kubernetes_namespaces&quot;: &quot;*&quot;, &quot;kubernetes_role_type&quot;: &quot;ClusterRole&quot;, &quot;kubernetes_role_name&quot;: &quot;openbao-k8s-secrets-role&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample payload 3​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload-3","content":" To generate tokens for a defined set of Kubernetes role rules:  { &quot;allowed_kubernetes_namespaces&quot;: &quot;*&quot;, &quot;generated_role_rules&quot;: &quot;rules:\\n- apiGroups: [\\&quot;\\&quot;]\\n resources: [\\&quot;pods\\&quot;]\\n verbs: [\\&quot;list\\&quot;]\\n&quot;, }   Or to define the same rules as JSON:  { &quot;allowed_kubernetes_namespaces&quot;: &quot;*&quot;, &quot;generated_role_rules&quot;: &quot;'rules': [{'apiGroups': [''],'resources': ['pods'],'verbs': ['list']}]&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample payload 4​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload-4","content":" To generate tokens in namespaces based on a label selector for the namespaces:  { &quot;allowed_kubernetes_namespace_selector&quot;: &quot;matchLabels:\\n stage: prod\\n sa-generator: openbao&quot;, &quot;service_account_name&quot;: &quot;default&quot;, }   Or to define the same selector as JSON:  { &quot;allowed_kubernetes_namespace_selector&quot;: &quot;'{'matchLabels':{'stage':'prod','sa-generator':'openbao'}}&quot;, &quot;service_account_name&quot;: &quot;default&quot;, }   ","version":"Next","tagName":"h3"},{"title":"Sample payload 5​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload-5","content":" To generate tokens in namespaces based on a label selector for the namespaces and via a normal namespace array:  { &quot;allowed_kubernetes_namespaces&quot;: &quot;openbao-system,testing&quot;, &quot;allowed_kubernetes_namespace_selector&quot;: &quot;'{'matchLabels':{'stage':'prod','sa-generator':'openbao'}}&quot;, &quot;service_account_name&quot;: &quot;default&quot;, }   In the payload above, the token can be generated for any namespace that either contains the labels defined in the selector, or is named openbao-system or testing.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/kubernetes/roles/default-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#read-role","content":" Returns the previously configured role.  Method\tPathGET\t/kubernetes/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#parameters-2","content":" name (string: &lt;required&gt;) - Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/kubernetes/role/default-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-response-1","content":" { &quot;data&quot;: { &quot;additional_metadata&quot;: {}, &quot;allowed_kubernetes_namespaces&quot;: [ &quot;*&quot; ], &quot;generated_role_rules&quot;: &quot;&quot;, &quot;kubernetes_role_name&quot;: &quot;&quot;, &quot;kubernetes_role_type&quot;: &quot;Role&quot;, &quot;name&quot;: &quot;default-role&quot;, &quot;name_template&quot;: &quot;&quot;, &quot;service_account_name&quot;: &quot;default&quot;, &quot;token_default_ttl&quot;: 0, &quot;token_max_ttl&quot;: 86400 } }   ","version":"Next","tagName":"h3"},{"title":"List roles​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#list-roles","content":" Lists all the roles that are configured.  Method\tPathLIST\t/kubernetes/roles GET\t/kubernetes/roles?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/kubernetes/roles   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-response-2","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;default-role&quot;, &quot;prod-role&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#delete-role","content":" Deletes the previously configured role.  Method\tPathDELETE\t/kubernetes/roles/:role  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#parameters-3","content":" role (string: &lt;required&gt;) - Name of the role.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/kubernetes/role/default-role   ","version":"Next","tagName":"h3"},{"title":"Generate credentials​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#generate-credentials","content":" Generate a service account token.  Method\tPathPOST\t/kubernetes/creds/:role  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#parameters-4","content":" role (string: &lt;required&gt;) - Name of the role to generate credentials for.kubernetes_namespace (string) - The name of the Kubernetes namespace in which to generate the credentials. Optional if the OpenBao role is configured with a single namespace that is not &quot;*&quot;; required otherwise.cluster_role_binding (bool: false) - If true, generate a ClusterRoleBinding to grant permissions across the whole cluster instead of within a namespace. Requires the OpenBao role to have kubernetes_role_type set to ClusterRole.ttl (string: &quot;&quot;) - The TTL of the generated Kubernetes service account token, specified in seconds or as a Go duration format string, e.g. &quot;1h&quot;. The TTL returned may be different from the TTL specified due to limits specified in Kubernetes, OpenBao system-wide controls, or role-specific controls.audiences (string: &quot;&quot;) - A comma separated string containing the intended audiences of the generated Kubernetes service account the token, e.g. &quot;custom-audience-0,custom-audience-1&quot;. If not set or set to &quot;&quot;, the token_default_audiences will be used.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-payload-6","content":" { &quot;kubernetes_namespace&quot;: &quot;default&quot;, &quot;ttl&quot;: &quot;1h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-request-7","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/kubernetes/creds/default-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Kubernetes secrets engine (API)","url":"/openbao/api-docs/secret/kubernetes/#sample-response-3","content":" { &quot;request_id&quot;: &quot;58fefc6c-5195-c17a-94f2-8f889f3df57c&quot;, &quot;lease_id&quot;: &quot;kubernetes/creds/default-role/aWczfcfJ7NKUdiirJrPXIs38&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 3600, &quot;data&quot;: { &quot;service_account_name&quot;: &quot;default&quot;, &quot;service_account_namespace&quot;: &quot;default&quot;, &quot;service_account_token&quot;: &quot;eyJhbG...&quot; } }  ","version":"Next","tagName":"h3"},{"title":"KV secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/kv/","content":"KV secrets engine (API) This backend can be run in one of two versions. Each of which have a distinct API. Choose the version below you are running. For more information on the KV secrets engine see the OpenBao kv documentation. KV Version 1 API KV Version 2 API","keywords":"","version":"Next"},{"title":"KV secrets engine - version 1 (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/kv/kv-v1/","content":"","keywords":"","version":"Next"},{"title":"Read secret​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#read-secret","content":" This endpoint retrieves the secret at the specified location.  Method\tPathGET\t/secret/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path of the secret to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/secret/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-response","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;foo&quot;: &quot;bar&quot;, &quot;ttl&quot;: &quot;1h&quot; }, &quot;lease_duration&quot;: 3600, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   Note: the lease_duration field, which will be populated if a &quot;ttl&quot; field was included in the data, is advisory. No lease is created. This is a way for writers to indicate how often a given value should be re-read by the client. See the OpenBao KV secrets engine documentationfor more details.  ","version":"Next","tagName":"h3"},{"title":"List secrets​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#list-secrets","content":" This endpoint returns a list of key names at the specified location. Folders are suffixed with /. The input must be a folder; list on a file will not return a value. Note that no policy-based filtering is performed on keys; do not encode sensitive information in key names. The values themselves are not accessible via this API.  Method\tPathLIST\t/secret/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#parameters-1","content":" path (string: &lt;required&gt;) – Specifies the path of the secrets to list. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ https://127.0.0.1:8200/v1/secret/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-response-1","content":" The example below shows output for a query path of secret/ when there are secrets at secret/foo and secret/foo/bar; note the difference in the two entries.  { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;foo&quot;, &quot;foo/&quot;] }, &quot;lease_duration&quot;: 2764800, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Create/Update secret​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#createupdate-secret","content":" This endpoint stores a secret at the specified location. If the value does not yet exist, the calling token must have an ACL policy granting the createcapability. If the value already exists, the calling token must have an ACL policy granting the update capability.  Method\tPathPOST\t/secret/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#parameters-2","content":" path (string: &lt;required&gt;) – Specifies the path of the secrets to create/update. This is specified as part of the URL. :key (string: &quot;&quot;) – Specifies a key in the payload, paired with an associated value, to be held at the given location. Multiple key/value pairs can be specified, and all will be returned on a read operation. A key called ttl will trigger some special behavior. See the OpenBao KV secrets engine documentation for details.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-payload","content":" { &quot;foo&quot;: &quot;bar&quot;, &quot;zip&quot;: &quot;zap&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/my-secret   ","version":"Next","tagName":"h3"},{"title":"Delete secret​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#delete-secret","content":" This endpoint deletes the secret at the specified location.  Method\tPathDELETE\t/secret/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#parameters-3","content":" path (string: &lt;required&gt;) – Specifies the path of the secret to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 1 (API)","url":"/openbao/api-docs/secret/kv/kv-v1/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ https://127.0.0.1:8200/v1/secret/my-secret  ","version":"Next","tagName":"h3"},{"title":"RabbitMQ secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/rabbitmq/","content":"","keywords":"","version":"Next"},{"title":"Configure connection​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#configure-connection","content":" This endpoint configures the connection string used to communicate with RabbitMQ.  Method\tPathPOST\t/rabbitmq/config/connection  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#parameters","content":" connection_uri (string: &lt;required&gt;) – Specifies the RabbitMQ connection URI. username (string: &lt;required&gt;) – Specifies the RabbitMQ management administrator username. password (string: &lt;required&gt;) – Specifies the RabbitMQ management administrator password. verify_connection (bool: true) – Specifies whether to verify connection URI, username, and password. password_policy (string: &quot;&quot;) - Specifies a password policy to use when creating dynamic credentials. Defaults to generating an alphanumeric password if not set. username_template (string) - Template describing how dynamic usernames are generated.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-payload","content":" { &quot;connection_uri&quot;: &quot;https://...&quot;, &quot;username&quot;: &quot;user&quot;, &quot;password&quot;: &quot;password&quot;, &quot;password_policy&quot;: &quot;rabbitmq_policy&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-request","content":" cURLCLI $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/rabbitmq/config/connection   ","version":"Next","tagName":"h3"},{"title":"Configure lease​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#configure-lease","content":" This endpoint configures the lease settings for generated credentials.  Method\tPathPOST\t/rabbitmq/config/lease  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#parameters-1","content":" ttl (int: 0) – Specifies the lease ttl provided in seconds. max_ttl (int: 0) – Specifies the maximum ttl provided in seconds.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-payload-1","content":" { &quot;ttl&quot;: 1800, &quot;max_ttl&quot;: 3600 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-request-1","content":" cURLCLI $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/rabbitmq/config/lease   ","version":"Next","tagName":"h3"},{"title":"Create role​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#create-role","content":" This endpoint creates or updates the role definition.  Method\tPathPOST\t/rabbitmq/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create. This is specified as part of the URL. tags (string: &quot;&quot;) – Specifies a comma-separated RabbitMQ management tags. vhosts (string: &quot;&quot;) – Specifies a map of virtual hosts to permissions. vhost_topics (string: &quot;&quot;) – Specifies a map of virtual hosts and exchanges to topic permissions. This option requires RabbitMQ 3.7.0 or later.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-payload-2","content":" { &quot;tags&quot;: &quot;tag1,tag2&quot;, &quot;vhosts&quot;: &quot;{\\&quot;/\\&quot;: {\\&quot;configure\\&quot;:\\&quot;.*\\&quot;, \\&quot;write\\&quot;:\\&quot;.*\\&quot;, \\&quot;read\\&quot;: \\&quot;.*\\&quot;}}&quot;, &quot;vhost_topics&quot;: &quot;{\\&quot;/\\&quot;: {\\&quot;amq.topic\\&quot;: {\\&quot;write\\&quot;:\\&quot;.*\\&quot;, \\&quot;read\\&quot;: \\&quot;.*\\&quot;}}}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-request-2","content":" cURLCLI $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/rabbitmq/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#read-role","content":" This endpoint queries the role definition.  Method\tPathGET\t/rabbitmq/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#parameters-3","content":" name (string: &lt;required&gt;) – Specifies the name of the role to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-request-3","content":" cURLCLI $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/rabbitmq/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-response","content":" { &quot;data&quot;: { &quot;tags&quot;: &quot;&quot;, &quot;vhosts&quot;: &quot;{\\&quot;/\\&quot;: {\\&quot;configure\\&quot;:\\&quot;.*\\&quot;, \\&quot;write\\&quot;:\\&quot;.*\\&quot;, \\&quot;read\\&quot;: \\&quot;.*\\&quot;}}&quot;, &quot;vhost_topics&quot;: &quot;{\\&quot;/\\&quot;: {\\&quot;amq.topic\\&quot;: {\\&quot;write\\&quot;:\\&quot;.*\\&quot;, \\&quot;read\\&quot;: \\&quot;.*\\&quot;}}}&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#delete-role","content":" This endpoint deletes the role definition.  Method\tPathDELETE\t/rabbitmq/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#parameters-4","content":" name (string: &lt;required&gt;) – Specifies the name of the role to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-request-4","content":" cURLCLI $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/rabbitmq/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Generate credentials​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#generate-credentials","content":" This endpoint generates a new set of dynamic credentials based on the named role.  Method\tPathGET\t/rabbitmq/creds/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#parameters-5","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create credentials against. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-request-5","content":" cURLCLI $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/rabbitmq/creds/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"RabbitMQ secrets engine (API)","url":"/openbao/api-docs/secret/rabbitmq/#sample-response-1","content":" { &quot;data&quot;: { &quot;username&quot;: &quot;root-4b95bf47-281d-dcb5-8a60-9594f8056092&quot;, &quot;password&quot;: &quot;e1b6c159-ca63-4c6a-3886-6639eae06c30&quot; } }  ","version":"Next","tagName":"h3"},{"title":"KV secrets engine - version 2 (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/kv/kv-v2/","content":"","keywords":"","version":"Next"},{"title":"Configure the KV engine​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#configure-the-kv-engine","content":" This path configures backend level settings that are applied to every key in the key-value store.  Method\tPathPOST\t/:secret-mount-path/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount to config, such as secret. This is specified as part of the URL. max_versions (int: 0) – The number of versions to keep per key. This value applies to all keys, but a key's metadata setting can overwrite this value. Once a key has more than the configured allowed versions, the oldest version will be permanently deleted. When 0 is used or the value is unset, OpenBao will keep 10 versions. cas_required (bool: false) – If true all keys will require the cas parameter to be set on all write requests. delete_version_after (string:&quot;0s&quot;) – If set, specifies the length of time before a version is deleted. Accepts duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload","content":" { &quot;max_versions&quot;: 5, &quot;cas_required&quot;: false, &quot;delete_version_after&quot;: &quot;3h25m19s&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/config   ","version":"Next","tagName":"h3"},{"title":"Read KV engine configuration​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#read-kv-engine-configuration","content":" This path retrieves the current configuration for the secrets backend at the given path.  Method\tPathGET\t/:secret-mount-path/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-1","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount to read the config, of, such as secret. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/secret/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response","content":" { &quot;data&quot;: { &quot;cas_required&quot;: false, &quot;delete_version_after&quot;: &quot;3h25m19s&quot;, &quot;max_versions&quot;: 0 } }   ","version":"Next","tagName":"h3"},{"title":"Read secret version​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#read-secret-version","content":" This endpoint retrieves the secret at the specified location. The metadata fields created_time, deletion_time, destroyed, and version are version specific. The custom_metadata field is part of the secret's key metadata and is included in the response whether or not the calling token has read access to the associated metadata endpoint.  Method\tPathGET\t/:secret-mount-path/data/:path?version=:version-number  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-2","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to read, such as secret. This is specified as part of the URL.path (string: &lt;required&gt;) – Specifies the path of the secret to read. This is specified as part of the URL.version (int: 0) - Specifies the version to return. If not set the latest version is returned.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/secret/data/my-secret?version=2   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response-1","content":" { &quot;data&quot;: { &quot;data&quot;: { &quot;foo&quot;: &quot;bar&quot; }, &quot;metadata&quot;: { &quot;created_time&quot;: &quot;2018-03-22T02:24:06.945319214Z&quot;, &quot;custom_metadata&quot;: { &quot;owner&quot;: &quot;jdoe&quot;, &quot;mission_critical&quot;: &quot;false&quot; }, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false, &quot;version&quot;: 2 } } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update secret​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#createupdate-secret","content":" This endpoint creates a new version of a secret at the specified location. If the value does not yet exist, the calling token must have an ACL policy granting the create capability. If the value already exists, the calling token must have an ACL policy granting the update capability.  Method\tPathPOST\t/:secret-mount-path/data/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-3","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to update, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to update. This is specified as part of the URL. options (Map: &lt;optional&gt;) – An object that holds option settings. cas (int: &lt;optional&gt;) - This flag is required if cas_required is set to true on either the secret or the engine's config. If not set the write will be allowed. In order for a write to be successful, cas must be set to the current version of the secret. If set to 0 a write will only be allowed if the key doesn't exist as unset keys do not have any version information. Also remember that soft deletes do not remove any underlying version data from storage. In order to write to a soft deleted key, the cas parameter must match the key's current version. data (Map: &lt;required&gt;) – The contents of the data map will be stored and returned on read.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-1","content":" { &quot;options&quot;: { &quot;cas&quot;: 0 }, &quot;data&quot;: { &quot;foo&quot;: &quot;bar&quot;, &quot;zip&quot;: &quot;zap&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/data/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response-2","content":" { &quot;data&quot;: { &quot;created_time&quot;: &quot;2018-03-22T02:36:43.986212308Z&quot;, &quot;custom_metadata&quot;: { &quot;owner&quot;: &quot;jdoe&quot;, &quot;mission_critical&quot;: &quot;false&quot; }, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false, &quot;version&quot;: 1 } }   ","version":"Next","tagName":"h3"},{"title":"Patch secret​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#patch-secret","content":" This endpoint provides the ability to patch an existing secret at the specified location. The secret must neither be deleted nor destroyed. The calling token must have an ACL policy granting the patch capability. Currently, onlyJSON merge patchis supported and must be specified using a Content-Type header value ofapplication/merge-patch+json. A new version will be created upon successfully applying a patch with the provided data.  Method\tPathPATCH\t/:secret-mount-path/data/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-4","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to patch, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to patch. This is specified as part of the URL. options (Map: &lt;optional&gt;) – An object that holds option settings. cas (int: &lt;optional&gt;) - This flag is required if cas_required is set to true on either the secret or the engine's config. In order for a write to be successful, cas must be set to the current version of the secret. A patch operation must be attempted on an existing key, thus the provided cas value must be greater than 0. data (Map: &lt;required&gt;) – The contents of the data map will be applied as a partial update to the existing entry via a JSON merge patch to the existing entry.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-2","content":" { &quot;options&quot;: { &quot;cas&quot;: 1 }, &quot;data&quot;: { &quot;foo&quot;: &quot;a&quot;, &quot;bar&quot;: { &quot;baz&quot;: &quot;b&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;Content-Type: application/merge-patch+json&quot; --request PATCH \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/data/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response-3","content":" { &quot;data&quot;: { &quot;created_time&quot;: &quot;2021-09-10T15:26:08.684999Z&quot;, &quot;custom_metadata&quot;: { &quot;owner&quot;: &quot;jdoe&quot;, &quot;mission_critical&quot;: &quot;false&quot; }, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false, &quot;version&quot;: 2 } }   ","version":"Next","tagName":"h3"},{"title":"Read secret subkeys​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#read-secret-subkeys","content":" This endpoint provides the subkeys within a secret entry that exists at the requested path. The secret entry at this path will be retrieved and stripped of all data by replacing underlying values of leaf keys (i.e. non-map keys or map keys with no underlying subkeys) with null.  Method\tPathGET\t/:secret-mount-path/subkeys/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-5","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to read, such as secret. This is specified as part of the URL.path (string: &lt;required&gt;) – Specifies the path of the secret to read. This is specified as part of the URL.version (int: 0) - Specifies the version to return. If not set the latest version is returned.depth (int: 0) - Specifies the deepest nesting level to provide in the output. The default value 0 will not impose any limit. If non-zero, keys that reside at the specified depth value will be artificially treated as leaves and will thus be nulleven if further underlying subkeys exist.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/secret/subkeys/my-secret?version=1   ","version":"Next","tagName":"h3"},{"title":"Sample secret data​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-secret-data","content":" { &quot;foo&quot;: &quot;abc&quot;, &quot;bar&quot;: { &quot;baz&quot;: &quot;def&quot; }, &quot;quux&quot;: {} }   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response-4","content":" { &quot;subkeys&quot;: { &quot;foo&quot;: null, &quot;bar&quot;: { &quot;baz&quot;: null }, &quot;quux&quot;: null }, &quot;metadata&quot;: { &quot;created_time&quot;: &quot;2021-12-14T20:28:00.773477Z&quot;, &quot;custom_metadata&quot;: null, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false, &quot;version&quot;: 1 } }   ","version":"Next","tagName":"h3"},{"title":"Delete latest version of secret​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#delete-latest-version-of-secret","content":" This endpoint issues a soft delete of the secret's latest version at the specified location. This marks the version as deleted and will stop it from being returned from reads, but the underlying data will not be removed. A delete can be undone using the undelete path.  Method\tPathDELETE\t/:secret-mount-path/data/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-6","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to delete, such as secret. This is specified as part of the URL.path (string: &lt;required&gt;) – Specifies the path of the secret to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ https://127.0.0.1:8200/v1/secret/data/my-secret   ","version":"Next","tagName":"h3"},{"title":"Delete secret versions​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#delete-secret-versions","content":" This endpoint issues a soft delete of the specified versions of the secret. This marks the versions as deleted and will stop them from being returned from reads, but the underlying data will not be removed. A delete can be undone using theundelete path.  Method\tPathPOST\t/:secret-mount-path/delete/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-7","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to delete, such as secret. This is specified as part of the URL.path (string: &lt;required&gt;) – Specifies the path of the secret to delete. This is specified as part of the URL.versions ([]int: &lt;required&gt;) - The versions to be deleted. The versioned data will not be deleted, but it will no longer be returned in normal get requests.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-3","content":" { &quot;versions&quot;: [1, 2] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/delete/my-secret   ","version":"Next","tagName":"h3"},{"title":"Undelete secret versions​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#undelete-secret-versions","content":" Undeletes the data for the provided version and path in the key-value store. This restores the data, allowing it to be returned on get requests.  Method\tPathPOST\t/:secret-mount-path/undelete/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-8","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to undelete, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to undelete. This is specified as part of the URL. versions ([]int: &lt;required&gt;) - The versions to undelete. The versions will be restored and their data will be returned on normal get requests.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-4","content":" { &quot;versions&quot;: [1, 2] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/undelete/my-secret   ","version":"Next","tagName":"h3"},{"title":"Destroy secret versions​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#destroy-secret-versions","content":" Permanently removes the specified version data for the provided key and version numbers from the key-value store.  Method\tPathPUT\t/:secret-mount-path/destroy/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-9","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to destroy, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to destroy. This is specified as part of the URL. versions ([]int: &lt;required&gt;) - The versions to destroy. Their data will be permanently deleted.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-5","content":" { &quot;versions&quot;: [1, 2] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request PUT \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/destroy/my-secret   ","version":"Next","tagName":"h3"},{"title":"List secrets​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#list-secrets","content":" This endpoint returns a list of key names at the specified location. Folders are suffixed with /. The input must be a folder; list on a file will not return a value. Note that no policy-based filtering is performed on keys; do not encode sensitive information in key names. The values themselves are not accessible via this command.  Method\tPathLIST\t/:secret-mount-path/metadata/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-10","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to list, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secrets to list. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ https://127.0.0.1:8200/v1/secret/metadata/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response-5","content":" The example below shows output for a query path of secret/ when there are secrets at secret/foo and secret/foo/bar; note the difference in the two entries.  { &quot;data&quot;: { &quot;keys&quot;: [&quot;foo&quot;, &quot;foo/&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Read secret metadata​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#read-secret-metadata","content":" This endpoint retrieves the metadata and versions for the secret at the specified path. Metadata is version-agnostic.  Method\tPathGET\t/:secret-mount-path/metadata/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-11","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to read, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/secret/metadata/my-secret   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-response-6","content":" { &quot;data&quot;: { &quot;cas_required&quot;: false, &quot;created_time&quot;: &quot;2018-03-22T02:24:06.945319214Z&quot;, &quot;current_version&quot;: 3, &quot;delete_version_after&quot;: &quot;3h25m19s&quot;, &quot;max_versions&quot;: 0, &quot;oldest_version&quot;: 0, &quot;updated_time&quot;: &quot;2018-03-22T02:36:43.986212308Z&quot;, &quot;custom_metadata&quot;: { &quot;foo&quot;: &quot;abc&quot;, &quot;bar&quot;: &quot;123&quot;, &quot;baz&quot;: &quot;5c07d823-3810-48f6-a147-4c06b5219e84&quot; }, &quot;versions&quot;: { &quot;1&quot;: { &quot;created_time&quot;: &quot;2018-03-22T02:24:06.945319214Z&quot;, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false }, &quot;2&quot;: { &quot;created_time&quot;: &quot;2018-03-22T02:36:33.954880664Z&quot;, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false }, &quot;3&quot;: { &quot;created_time&quot;: &quot;2018-03-22T02:36:43.986212308Z&quot;, &quot;deletion_time&quot;: &quot;&quot;, &quot;destroyed&quot;: false } } } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update metadata​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#createupdate-metadata","content":" This endpoint creates or updates the metadata of a secret at the specified location. It does not create a new version.  Method\tPathPOST\t/:secret-mount-path/metadata/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-12","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to update, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to update. This is specified as part of the URL. max_versions (int: 0) – The number of versions to keep per key. If not set, the backend’s configured max version is used. Once a key has more than the configured allowed versions, the oldest version will be permanently deleted. cas_required (bool: false) – If true, the key will require the casparameter to be set on all write requests. If false, the backend’s configuration will be used. delete_version_after (string:&quot;0s&quot;) – Set the delete_version_after value to a duration to specify the deletion_time for all new versions written to this key. If not set, the backend's delete_version_after will be used. If the value is greater than the backend's delete_version_after, the backend's delete_version_after will be used. Accepts duration format strings. custom_metadata (map&lt;string|string&gt;: nil) - A map of arbitrary string to string valued user-provided metadata meant to describe the secret.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-6","content":" { &quot;max_versions&quot;: 5, &quot;cas_required&quot;: false, &quot;delete_version_after&quot;: &quot;3h25m19s&quot;, &quot;custom_metadata&quot;: { &quot;foo&quot;: &quot;abc&quot;, &quot;bar&quot;: &quot;123&quot;, &quot;baz&quot;: &quot;5c07d823-3810-48f6-a147-4c06b5219e84&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/metadata/my-secret   ","version":"Next","tagName":"h3"},{"title":"Patch metadata​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#patch-metadata","content":" This endpoint patches an existing metadata entry of a secret at the specified location. The calling token must have an ACL policy granting the patchcapability. Currently, only JSON merge patch is supported and must be specified using a Content-Type header value of application/merge-patch+json. It does not create a new version.  Method\tPathPATCH\t/:secret-mount-path/metadata/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-13","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to patch, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to patch. This is specified as part of the URL. max_versions (int: 0) – The number of versions to keep per key. If not set, the backend’s configured max version is used. Once a key has more than the configured allowed versions, the oldest version will be permanently deleted. cas_required (bool: false) – If true, the key will require the casparameter to be set on all write requests. If false, the backend’s configuration will be used. delete_version_after (string:&quot;0s&quot;) – Set the delete_version_after value to a duration to specify the deletion_time for all new versions written to this key. If not set, the backend's delete_version_after will be used. If the value is greater than the backend's delete_version_after, the backend's delete_version_after will be used. Accepts duration format strings. custom_metadata (map&lt;string|string&gt;: nil) - A map of arbitrary string to string valued user-provided metadata meant to describe the secret.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-payload-7","content":" { &quot;max_versions&quot;: 5, &quot;custom_metadata&quot;: { &quot;bar&quot;: &quot;123&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-13","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;Content-Type: application/merge-patch+json&quot; --request PATCH \\ --data @payload.json \\ https://127.0.0.1:8200/v1/secret/metadata/my-secret   ","version":"Next","tagName":"h3"},{"title":"Delete metadata and all versions​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#delete-metadata-and-all-versions","content":" This endpoint permanently deletes the key metadata and all version data for the specified key. All version history will be removed.  Method\tPathDELETE\t/:secret-mount-path/metadata/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#parameters-14","content":" secret-mount-path (string: &lt;required&gt;) - The path to the KV mount containing the secret to delete, such as secret. This is specified as part of the URL. path (string: &lt;required&gt;) – Specifies the path of the secret to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"KV secrets engine - version 2 (API)","url":"/openbao/api-docs/secret/kv/kv-v2/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ https://127.0.0.1:8200/v1/secret/metadata/my-secret  ","version":"Next","tagName":"h3"},{"title":"LDAP secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/ldap/","content":"","keywords":"","version":"Next"},{"title":"Configuration management​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#configuration-management","content":" This endpoint configures the LDAP secret engine to manage user entries.  Method\tPathPOST\t/ldap/config GET\t/ldap/config DELETE\t/ldap/config  info Note: The LDAP entry used by config should have the necessary privileges to search and change entry passwords in LDAP.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#parameters","content":" binddn (string: &lt;required&gt;) - Distinguished name (DN) of object to bind for managing user entries. For example, cn=openbao,ou=Users,dc=openbao,dc=com.bindpass (string: &lt;required&gt;) - Password to use along with binddn for managing user entries.url (string: &quot;ldap://127.0.0.1&quot;) - The LDAP server to connect to. Examples: ldaps://ldap.myorg.com,ldaps://ldap.myorg.com:636. This can also be a comma-delineated list of URLs, e.g.ldaps://ldap.myorg.com, ldaps://ldap.myorg.com:636, in which case the servers will be tried in-order if there are errors during the connection process.`.password_policy (string: &lt;optional&gt;) - The name of the password policyto use to generate passwords. Note that this accepts the name of the policy, not the policy itself.schema (string: &quot;openldap&quot;) - The LDAP schema to use when storing entry passwords. Valid schemas include openldap, ad, and racf.userdn (string: &lt;optional&gt;) - The base DN under which to perform user search inlibrary management and static roles. For example, ou=Users,dc=openbao,dc=com.userattr (string: &lt;optional&gt;) – The attribute field name used to perform user search in library management and static roles. Defaults to cn for the openldap schema, userPrincipalName for the ad schema, andracfid for the racf schema.upndomain (string: optional) - The domain (userPrincipalDomain) used to construct a UPN string for authentication. The constructed UPN will appear as [binddn]@[upndomain]. For example, if upndomain=example.com and binddn=admin, the UPN string admin@example.comwill be used to log in to Active Directory.connection_timeout (integer: 30 or string: &quot;30s&quot;) - Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL in the configuration.request_timeout (integer: 90, string: &quot;90s&quot; &lt;optional&gt;) - Timeout, in seconds, for the connection when making requests against the server before returning back an error.starttls (bool: &lt;optional&gt;) - If true, issues a StartTLS command after establishing an unencrypted connection.insecure_tls (bool: &lt;optional&gt;) - If true, skips LDAP server SSL certificate verification - insecure, use with caution!certificate (string: &lt;optional&gt;) - CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.client_tls_cert (string: &lt;optional&gt;) - Client certificate to provide to the LDAP server, must be x509 PEM encoded.client_tls_key (string: &lt;optional&gt;) - Client key to provide to the LDAP server, must be x509 PEM encoded.  Deprecated Parameters:  length (int: 64) - The length of generated password strings. Note: some schemas may require shorter password lengths (such as racf). Mutually exclusive with password_policy  Note about password generation:  length and password_policy cannot both be set in the configuration. The POST endpoint will reject the configuration if both are specified.  If neither are set, this will default to a reasonable default password generation algorithm (the same algorithm as prior to the introduction of password policies).If length is set, the same algorithm is used, but with the length specified instead of the default length.If password_policy is set, the password will be generated from the associatedpassword policy. The policy is not exercised prior to saving the configuration. The policy will need to exist prior to passwords needing to be generated by this engine, but does not need to exist prior to saving the configuration.  See LDAP secrets engine docs for additional information.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-payload","content":" { &quot;binddn&quot;: &quot;cn=openbao,ou=Users,dc=openbao,dc=com&quot;, &quot;bindpass&quot;: &quot;pa$$w0rd&quot;, &quot;url&quot;: &quot;ldaps://127.0.0.11&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample POST request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ldap/config   ","version":"Next","tagName":"h3"},{"title":"Sample GET request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-get-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ https://127.0.0.1:8200/v1/ldap/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-response","content":" { &quot;data&quot;: { &quot;binddn&quot;: &quot;cn=admin,dc=openbao,dc=com&quot;, &quot;case_sensitive_names&quot;: false, &quot;certificate&quot;: &quot;&quot;, &quot;insecure_tls&quot;: false, &quot;length&quot;: 64, &quot;schema&quot;: &quot;openldap&quot;, &quot;starttls&quot;: false, &quot;tls_max_version&quot;: &quot;tls12&quot;, &quot;tls_min_version&quot;: &quot;tls12&quot;, &quot;url&quot;: &quot;ldap://127.0.0.1&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Rotate root password​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#rotate-root-password","content":" The rotate-root endpoint offers password rotation for the binddn entry used to manage LDAP. This generated password will only be known to OpenBao and will not be retrievable once rotated.  Method\tPathPOST\t/ldap/rotate-root  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/ldap/rotate-root   ","version":"Next","tagName":"h3"},{"title":"Static roles​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#static-roles","content":" The static-role endpoint configures OpenBao to manage the passwords of existing individual LDAP entries.  Method\tPathGET\t/ldap/static-role GET\t/ldap/static-role/:role_name POST\t/ldap/static-role/:role_name DELETE\t/ldap/static-role/:role_name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#parameters-1","content":" username (string: &lt;required&gt;) - The username of the existing LDAP entry to manage password rotation for. LDAP search for the username will be rooted at the userdnconfiguration value. The attribute to use when searching for the user can be configured with the userattr configuration value. This is useful when dn isn't used for login purposes (such as SSH). Cannot be modified after creation. Example: &quot;bob&quot;dn (string: &lt;optional&gt;) - Distinguished name (DN) of the existing LDAP entry to manage password rotation for. If given, it will take precedence over username for the LDAP search performed during password rotation. Cannot be modified after creation. Example: cn=bob,ou=Users,dc=openbao,dc=comrotation_period (string: &lt;required&gt;) - How often OpenBao should rotate the password of the user entry. Acceptsduration format strings. The minimum rotation period is 5 seconds. Example: &quot;3600&quot;, &quot;5s&quot;, &quot;1h&quot;  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-payload-1","content":" { &quot;dn&quot;: &quot;cn=openbao,ou=Users,dc=openbao,dc=com&quot;, &quot;rotation_period&quot;: &quot;24h&quot;, &quot;username&quot;: &quot;openbao&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample POST request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ldap/static-role/openbao   ","version":"Next","tagName":"h3"},{"title":"Sample GET request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-get-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/ldap/static-role/openbao   ","version":"Next","tagName":"h3"},{"title":"Sample GET response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-get-response","content":" { &quot;data&quot;: { &quot;dn&quot;: &quot;uid=openbao,ou=Users,dc=openbao,dc=com&quot;, &quot;last_vault_rotation&quot;: &quot;2020-02-19T11:31:53.7812-05:00&quot;, &quot;rotation_period&quot;: 86400, &quot;username&quot;: &quot;openbao&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample LIST response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-list-response","content":" [&quot;openbao&quot;, &quot;bob&quot;]   ","version":"Next","tagName":"h3"},{"title":"Static role passwords​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#static-role-passwords","content":" The static-cred endpoint offers the credential information for a given static-role.  Method\tPathGET\t/ldap/static-cred/:role_name  Sample get request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/ldap/static-cred/openbao   Sample get response​  { &quot;dn&quot;: &quot;uid=openbao,ou=Users,dc=openbao,dc=com&quot;, &quot;last_vault_rotation&quot;: &quot;2020-02-19T11:31:53.7812-05:00&quot;, &quot;password&quot;: &quot;LTNfyn7pS7XEZIxEYQ2sEAWic02PEP7zSvIs0xMqIjaU0ORzLhKOKVmYLxL1Xkyv&quot;, &quot;last_password&quot;: &quot;?@09AZSen9TzUwK7ZhafS7B0GuWGraQjfWEna5SwnmF/tVaKFqjXhhGV/Z0v/pBJ&quot;, &quot;rotation_period&quot;: 86400, &quot;ttl&quot;: 86072, &quot;username&quot;: &quot;openbao&quot; }   ","version":"Next","tagName":"h2"},{"title":"Manually rotate static role password​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#manually-rotate-static-role-password","content":" The rotate-role endpoint rotates the password of an existing static role.  Method\tPathPOST\t/ldap/rotate-role/:role_name  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/ldap/rotate-role/:role_name   ","version":"Next","tagName":"h3"},{"title":"Dynamic roles​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#dynamic-roles","content":" Create or update a dynamic role configuration. This provides instructions to OpenBao on how to create an LDAP domain user account.  ","version":"Next","tagName":"h2"},{"title":"Create/Delete dynamic role configuration​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#createdelete-dynamic-role-configuration","content":" Creates, updates, or deletes a dynamic role.  Method\tPathPOST\t/ldap/role/:role_name DELETE\t/ldap/role/:role_name  The POST endpoint allows for partial updates of existing roles. If a role exists and a POST request is made against it, only the keys specified in the request will be updated. To delete a value, specify the key with an empty string as the value. Example: openbao write ldap/role/myrole default_ttl=&quot;&quot;  Parameters​  role_name (string, required) - The name of the dynamic role.creation_ldif (string, required) - A templatized LDIF string used to create a user account. This may contain multiple LDIF entries. The creation_ldif can also be used to add the user account to an existing group. All LDIF entries are performed in order. If OpenBao encounters an error while executing the creation_ldif it will stop at the first error and not execute any remaining LDIF entries. If an error occurs and rollback_ldif is specified, the LDIF entries in rollback_ldif will be executed. See rollback_ldif for more details. This field may optionally be provided as a base64 encoded string.deletion_ldif (string, required) - A templatized LDIF string used to delete the user account once its TTL has expired. This may contain multiple LDIF entries. All LDIF entries are performed in order. If OpenBao encounters an error while executing an entry in the deletion_ldif it will attempt to continue executing any remaining entries. This field may optionally be provided as a base64 encoded string.rollback_ldif (string, not required but recommended) - A templatized LDIF string used to attempt to rollback any changes in the event that execution of the creation_ldif results in an error. This may contain multiple LDIF entries. All LDIF entries are performed in order. If OpenBao encounters an error while executing an entry in therollback_ldif it will attempt to continue executing any remaining entries. This field may optionally be provided as a base64 encoded string.username_template (string) - A template used to generate a dynamic username. This will be used to fill in the.Username field within the creation_ldif string.  Default Username Template v_{{.DisplayName}}_{{.RoleName}}_{{random 10}}_{{unix_time}} Example Usernames: Example\tDisplayName\ttoken RoleName\tmyrolename Username\tv_token_myrolename_uszt1n4cyh_1614294836Example\tDisplayName\tamuchlonger_dispname RoleName\trole-name-with-dashes Username\tv_amuchlonger_dispname_role-name-with-dashes_s0t9xb0jsa_1614294836  default_ttl (string/int) - Specifies the TTL for the leases associated with this role. Acceptsduration format strings. Defaults to system/engine default TTL time.max_ttl (string/int) - Specifies the maximum TTL for the leases associated with this role. Acceptsduration format strings. Defaults to system/mount default TTL time; this value is allowed to be less than the mount max TTL (or, if not set, the system max TTL), but it is not allowed to be longer.  The creation_ldif, deletion_ldif, rollback_ldif, and username_template fields are all templated fields. SeeUsername Templating for details on how to use templating. Also seeTemplates for specifics on what data is available for each template.  Sample payload​  Sample LDIF files:  creation.ldif:  dn: cn={{.Username}},ou=users,dc=learn,dc=example objectClass: person objectClass: top cn: learn sn: {{.Password | utf16le | base64}} memberOf: cn=dev,ou=groups,dc=learn,dc=example userPassword: {{.Password}}   deletion.ldif &amp; rollback.ldif:  dn: cn={{.Username}},ou=users,dc=learn,dc=example changetype: delete   Full Payload:  { &quot;creation_ldif&quot;: &quot;...&quot;, &quot;deletion_ldif&quot;: &quot;...&quot;, &quot;rollback_ldif&quot;: &quot;...&quot;, &quot;username_template&quot;: &quot;...&quot;, &quot;default_ttl&quot;: &quot;1h&quot;, &quot;max_ttl&quot;: &quot;24h&quot; }   info Note: The LDIF statements may optionally be base64 encoded. If they are base64 encoded when creating/updating the role configuration, the decoded version will be returned from the GET endpoint.  Sample POST request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ldap/role/dynamic-role   ","version":"Next","tagName":"h3"},{"title":"Read dynamic role configuration​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#read-dynamic-role-configuration","content":" Retrieves a dynamic role's configuration.  Method\tPathGET\t/ldap/role/:role_name  Response​  200 OK  { &quot;creation_ldif&quot;: &quot;...&quot;, &quot;default_ttl&quot;: 1800, &quot;deletion_ldif&quot;: &quot;...&quot;, &quot;max_ttl&quot;: 0, &quot;rollback_ldif&quot;: &quot;...&quot;, &quot;username_template&quot;: &quot;...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Templates​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#templates","content":" LDIF and username templates use the Go template syntax to construct the LDIF/username that will be executed against the server. This is done because certain values (such as the username and password within an LDIF statement) are not known at configuration time. Additionally, the template gives a lot of flexibility to the operator to construct the LDIF and username.  Templated fields are delimited by {{ and }}. To reference a field (such as the generated Username), a period is placed in front of the field name. Example: {{.Username}}. Spaces can be included between {{ and }}. For instance:{{.Username|lowercase}} is the same as {{ .Username | lowercase }}.  If a field needs to be modified (such as SHA256 hashing, base64 encoding, etc.) the value can be sent to one of thebuilt-in functions. This uses a &quot;pipe&quot; syntax: {{.Username | base64}}. Values may be &quot;piped&quot; to multiple functions: {{.Username | lowercase | base64}}  LDIF template fields​  The following parameters are available within the LDIF templates:  .Username - The name of the generated user (optionally from username_template). Default pattern: v_&lt;display name&gt;_&lt;role name&gt;_&lt;10 random chars&gt;_&lt;unix timestamp&gt;  .Password - The generated password (optionally frompassword policies)  .RoleName - The name of the role that credentials are being generated for.  .DisplayName - The display name associated with the authentication token used to make the credentials request.  .IssueTime - The time that the lease was created. This time may be slightly earlier than the associated lease due to where this value is calculated compared with where OpenBao calculates details of the lease. Format: 2006-01-02T15:04:05Z07:00 (RFC3339)  .IssueTimeSeconds - The unix time the lease was created. This time may be slightly earlier than the associated lease due to where this value is calculated compared with where OpenBao calculates details of the lease. Format: Integer indicating the number of seconds elapsed since January 1, 1970.  .ExpirationTime - The time that the lease is set to expire. This time may be slightly earlier than the associated lease due to where this value is calculated compared with where OpenBao calculates details of the lease. Format: 2006-01-02T15:04:05Z07:00 (RFC3339)  .ExpirationTimeSeconds - The unix time the lease is set to expire. This time may be slightly earlier than the associated lease due to where this value is calculated compared with where OpenBao calculates details of the lease. Format: Integer indicating the number of seconds elapsed since January 1, 1970.  Username template fields​  The following parameters are available within the username template:  Important note: If any of the following fields include dashes or underscores, they will not be removed/changed unless explicitly done so within the username template. For instance:  If RoleName is test-role and the username_template is v_{{.RoleName}}_{{unix_time}}, the result of this template may be: v_test-role_1234567890. Note the - (dash) in the test-role. If the LDAP system OpenBao is managing restricts usernames/DNs to not allow for dashes (or other characters), the template must explicitly modify/remove those characters. In this example, the template can be changed to v_{{.RoleName | replace &quot;-&quot; &quot;_&quot;}} to replace the dashes with underscores. See Template Functions for more functions available.  .RoleName - The name of the role the credentials are being generated from.  .DisplayName - The display name associated with the user making the request against Value.  Template functions​  Both the LDIF templates and the username template use the Go template languageso all functions and capabilities from that language are supported including functions such as printf.  In addition to the functions available through the template language, the following custom functions are also available:  random - Generates a random string from lowercase letters, uppercase letters, and numbers. Must include a number indicating how many characters to generate. Example: {{random 20}} generates 20 random characters  truncate - truncates the previous value to the provided number of characters. Example: {{.FieldName | truncate 10}}  truncate_sha256 - Truncates the previous value to the provided number of characters. The last 8 characters of the truncated value will be the first 8 characters of the SHA256 hash of the truncated characters.  This can aid in identifying values (such as the role &amp; display names) if they need to be truncated to a particular length, particularly if the value has common prefixes. An example of this is having many roles with a common prefix in the name of the role, but the role name is truncated such that only the prefix is shown. This function will keep the non-prefix part of the role name in the username which will aid in identification while also keeping uniqueness.  Example: v_{{.RoleName | truncate_sha256 15}}_{{unix_time}}. If two roles exist for this template, myreallylongprefix-foobar and myreallylongprefix-bazqux, the username for the first role would be v_myrealle6da86ec_1234567890 and the username for the second role would be v_myrealld0420a55_1234567890.  uppercase - Uppercases the provided value. Example: {{.FieldName | uppercase}}  lowercase - Lowercases the provided value. Example: {{.FieldName | lowercase}}  replace - Find/replace on the provided value. Example: {{.FieldName | replace &quot;-&quot; &quot;_&quot;}}  sha256 - SHA256 hashes the provided value. Example: {{.FieldName | sha256}}  base64 - Base64 encodes the provided value. Example: {{.FieldName | base64}}  unix_time - The current unix timestamp (number of seconds since Jan 1 1970). Example: {{unix_time}}  unix_time_millis - The current unix timestamp in milliseconds. Example: {{unix_time_millis}}  timestamp - The current time. Must provide a formatting string based on Go’s time package. Example: {{timestamp &quot;2006-01-02T15:04:05Z&quot;}}  uuid - Generates a random UUID. Example: {{uuid}}  LDIF template functions​  Additionally, the LDIF templates include an additional function to facilitate Active Directory password handling. The username template cannot use this function.  utf16le - Encodes the provided value into UTF16-LE. Example: {{.FieldName | utf16le}}  ","version":"Next","tagName":"h3"},{"title":"Dynamic role passwords​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#dynamic-role-passwords","content":" The creds endpoint offers the credential information for a given dynamic role.  Method\tPathGET\t/ldap/creds/:role_name  Sample get request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/ldap/creds/dynamic-role   Sample get response​  { &quot;distinguished_names&quot;: [ &quot;cn=v_token-dispname_testrole_jmZMnjS42a_1680580467,ou=users,dc=openbao,dc=com&quot; ], &quot;password&quot;: &quot;OWexB3OzYYLFiotWxUS2EheGpriwR20fa2yA7JGTsnBREcxyqpwf73htofMihxcC&quot;, &quot;username&quot;: &quot;v_token-dispname_testrole_jmZMnjS42a_1680580467&quot; }   ","version":"Next","tagName":"h2"},{"title":"Library set management​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#library-set-management","content":" The library endpoint configures the sets of service accounts that OpenBao will offer for check-out.  Method\tPathLIST\t/ldap/library POST\t/ldap/library/:set_name GET\t/ldap/library/:set_name DELETE\t/ldap/library/:set_name  When adding a service account to the library, OpenBao verifies it already exists in the LDAP directory.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#parameters-3","content":" name (string: &quot;&quot;, required) - The name of the set of service accounts.service_account_names (string: &quot;&quot;, or list: [] required) - The names of all the service accounts that can be checked out from this set. These service accounts must only be used by OpenBao, and may only be in one set. These service accounts must already exist in the LDAP directory.ttl (duration: &quot;24h&quot;, optional) - The maximum amount of time a single check-out lasts before OpenBao automatically checks it back in. Defaults to 24 hours. Setting it to zero reflects an unlimited lending period. Uses duration format strings.max_ttl (duration: &quot;24h&quot;, optional) - The maximum amount of time a check-out last with renewal before OpenBao automatically checks it back in. Defaults to 24 hours. Setting it to zero reflects an unlimited lending period. Uses duration format strings.disable_check_in_enforcement (bool: false, optional) - Disable enforcing that service accounts must be checked in by the entity or client token that checked them out. Defaults to false.  ","version":"Next","tagName":"h3"},{"title":"Sample POST request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ldap/library/accounting-team   ","version":"Next","tagName":"h3"},{"title":"Sample POST payload​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-payload","content":" { &quot;service_account_names&quot;: [&quot;fizz@example.com&quot;, &quot;buzz@example.com&quot;], &quot;ttl&quot;: &quot;10h&quot;, &quot;max_ttl&quot;: &quot;20h&quot;, &quot;disable_check_in_enforcement&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Sample GET response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-get-response-3","content":" { &quot;service_account_names&quot;: [&quot;fizz@example.com&quot;, &quot;buzz@example.com&quot;], &quot;ttl&quot;: &quot;10h&quot;, &quot;max_ttl&quot;: &quot;20h&quot;, &quot;disable_check_in_enforcement&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Sample LIST response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-list-response-1","content":" Performing a LIST on the /ldap/library endpoint will list the names of all the sets of service accounts OpenBao contains.  [&quot;accounting-team&quot;]   ","version":"Next","tagName":"h3"},{"title":"Library set status check​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#library-set-status-check","content":" This endpoint provides the check-out status of service accounts in a library set.  Method\tPathGET\t/ldap/library/:set_name/status  ","version":"Next","tagName":"h2"},{"title":"Sample GET request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-get-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/ldap/library/accounting-team/status   ","version":"Next","tagName":"h3"},{"title":"Sample GET response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-get-response-4","content":" { &quot;request_id&quot;: &quot;9e44c8b5-d142-5867-2a11-49f3ba71215a&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;buzz@example.com&quot;: { &quot;available&quot;: true }, &quot;fizz@example.com&quot;: { &quot;available&quot;: false, &quot;borrower_client_token&quot;: &quot;4c653e473bf7e27c6759fccc3def20c44d776279&quot;, &quot;borrower_entity_id&quot;: &quot;631256b1-8523-9838-5501-d0a1e2cdad9c&quot; } }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Check-Out management​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#check-out-management","content":" This endpoint provides service account check out for a library set.  Method\tPathPOST\t/ldap/library/:set_name/check-out  Returns a 200 if a credential is available, and a 400 if no credential is available.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#parameters-4","content":" name (string: &quot;&quot;, required) - The name of the set of service accounts.ttl (duration: &quot;&quot;, optional) - The maximum amount of time a check-out lasts before OpenBao automatically checks it back in. Setting it to zero reflects an unlimited lending period. Defaults to the set's ttl. If the requested ttl is higher than the set's, the set's will be used. Uses duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample POST request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ldap/library/accounting-team/check-out   ","version":"Next","tagName":"h3"},{"title":"Sample POST payload​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-payload-1","content":" { &quot;ttl&quot;: &quot;1h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample POST response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-response","content":" { &quot;request_id&quot;: &quot;364a17d4-e5ab-998b-ceee-b49929229e0c&quot;, &quot;lease_id&quot;: &quot;ad/library/accounting-team/check-out/aoBsaBEI4PK96VnukubvYDlZ&quot;, &quot;renewable&quot;: true, &quot;lease_duration&quot;: 36000, &quot;data&quot;: { &quot;password&quot;: &quot;?@09QW0KZ8DSBu3deIu7XLY1NZqzwhozmMAZ6v0IcZJGOjs5GvpVMvOeW7/duls2&quot;, &quot;service_account_name&quot;: &quot;fizz@example.com&quot; }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Check-In management​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#check-in-management","content":" By default, check-in must be called by the same entity or client token used for check-out. To disable this behavior, use the disable_check_in_enforcement toggle on the library set. Or, use the ad/library/manage/:set_name/check-in behavior to force check-in of the account. Access to the &quot;manage&quot; endpoint should only be granted to highly privileged OpenBao users, like OpenBao operators.  If a caller attempts to check in a service account they're not authorized to check in, they will receive an error response. If they attempt to check in a service account they are authorized to check in, but it's already checked in, they will receive a successful response but the account will not be included in the check_ins listed. check_ins shows which service accounts were checked in by this particular call.  Method\tPathPOST\t/ldap/library/:set_name/check-in POST\t/ldap/library/manage/:set_name/check-in  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#parameters-5","content":" name (string: &quot;&quot;, required) - The name of the set of service accounts.service_account_names (string: &quot;&quot;, or list: [] optional) - The names of all the service accounts to be checked in. May be omitted if only one is checked out.  ","version":"Next","tagName":"h3"},{"title":"Sample POST request​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ldap/library/accounting-team/check-in   ","version":"Next","tagName":"h3"},{"title":"Sample POST payload​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-payload-2","content":" { &quot;service_account_names&quot;: [&quot;fizz@example.com&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample POST response​","type":1,"pageTitle":"LDAP secrets engine (API)","url":"/openbao/api-docs/secret/ldap/#sample-post-response-1","content":" { &quot;request_id&quot;: &quot;db45c714-3f68-b748-95bc-8f7467637a52&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;check_ins&quot;: [&quot;fizz@example.com&quot;] }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"TOTP secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/totp/","content":"","keywords":"","version":"Next"},{"title":"Create key​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#create-key","content":" This endpoint creates or updates a key definition.  Method\tPathPOST\t/totp/keys/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the key to create. This is specified as part of the URL. generate (bool: false) – Specifies if a key should be generated by OpenBao or if a key is being passed from another service. exported (bool: true) – Specifies if a QR code and url are returned upon generating a key. Only used if generate is true. key_size (int: 20) – Specifies the size in bytes of the OpenBao generated key. Only used if generate is true. url (string: &quot;&quot;) – Specifies the TOTP key url string that can be used to configure a key. Only used if generate is false. key (string: &lt;required - if generate is false and url is empty&gt;) – Specifies the root key used to generate a TOTP code. Only used if generate is false. issuer (string: &quot;&quot; &lt;required - if generate is true&gt;) – Specifies the name of the key’s issuing organization. account_name (string: &quot;&quot; &lt;required - if generate is true&gt;) – Specifies the name of the account associated with the key. period (int or duration format string: 30) – Specifies the length of time in seconds used to generate a counter for the TOTP code calculation. algorithm (string: &quot;SHA1&quot;) – Specifies the hashing algorithm used to generate the TOTP code. Options include &quot;SHA1&quot;, &quot;SHA256&quot; and &quot;SHA512&quot;. digits (int: 6) – Specifies the number of digits in the generated TOTP code. This value can be set to 6 or 8. skew (int: 1) – Specifies the number of delay periods that are allowed when validating a TOTP code. This value can be either 0 or 1. Only used if generate is true. qr_size (int: 200) – Specifies the pixel size of the square QR code when generating a new key. Only used if generate is true and exported is true. If this value is 0, a QR code will not be returned.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-payload","content":" { &quot;url&quot;: &quot;otpauth://totp/Google:test@gmail.com?secret=Y64VEVMBTSXCYIWRSHRNDZW62MPGVU2G&amp;issuer=Google&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/totp/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-payload-1","content":" { &quot;generate&quot;: true, &quot;issuer&quot;: &quot;Google&quot;, &quot;account_name&quot;: &quot;test@gmail.com&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/totp/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-response","content":" { &quot;data&quot;: { &quot;barcode&quot;: &quot;iVBORw0KGgoAAAANSUhEUgAAAMgAAADIEAAAAADYoy0BAAAGXklEQVR4nOyd4Y4iOQyEmRPv/8p7upX6BJm4XbbDbK30fT9GAtJJhpLjdhw3z1+/HmDEP396AvDO878/X1+9i1frWvu5Po/6Xz+P2kft1nFVa1f7z+YdjT/5PrEQMxDEDAQx4/n6orsGr6z9ZP1mviMbP/MBav/R6/U61Ud0vk8sxAwEMQNBzHju3lTvv6P2ajwS9Ve9zz+9pkfjRp+r/SjzwULMQBAzEMSMrQ/pUo0bouun7dW9LXVvrBq/TMBCzEAQMxDEjKM+JFqT17W4mu9Y+49eq/OL3r/GVX3CJ7KtWIgZCGIGgpix9SHTtXGa4476qfoa1adVc+HV/6/yfWIhZiCIGQhixpsP6Z4nulD3lqavV7q+Yvo6G7/zfWIhZiCIGQhixteJ/Rh1Da3e71d9RjRul2ocdeK7xELMQBAzEMSM3z6ku6dTrdOo1l9M6y5O7clVx5n4SCzEDAQxA0HMuN3L+qlavqj9itpePY+VtVdrHqfzeQULMQNBzEAQM97ikAv1vr/brltTeCp/svarcjLe2F1PnbohCGIGgphRqjG8mJ6PmtYMVnP363Vqv6d8qZrzf2AhfiCIGQhixm0c8n+jQ8+7+jZ4cY3PrlfHO/1Ml+45st18sRAzEMQMBDHjdxyixgPqs0lWsvvwqH00zrSO41R80p3XXXssxAwEMQNBzJCeuaieo6pedzGtb1/76fqgLH6ofg+dZ65gIWYgiBkIYsbbs9/V+/EVde1V+62eh1I/r/qIrs+Ixo2uYy/LGAQxA0HMeNvLilDX1OraXc2jVNtPzxJXr6v+HzuwEDMQxAwEMWNbp95d21WmzzBR6066e07dPMq0XoW9LEMQxAwEMUOqUz+1p9ONd07Xz586u6yifp/4EEMQxAwEMUPay7rIcthqTrx6v1/NTX+qZrIbF63v34GFmIEgZiCIGdvfU++e1a3GM2oOPjtvpfbfjS+qeZFJXgcLMQNBzEAQM6Tn9p7OLVdrFqP5TFF9ZXTdqfqTV7AQMxDEDAQx482HdPMPGdN8SjeHr6710zzJidrCB/kQTxDEDAQxY7uXdTGNC9S9pK6vqs6nWzdyej53PhELMQNBzEAQM0o59YtTz/xQfVO3jmOdl0rmE6f5ort5YSFmIIgZCGLGbU69eka3ep+v5sCzcbp5jZXMR0zr+aPPqVM3BkHMQBAzRs/tjejmwj9d05ihzq96nQr5EEMQxAwEMWPrQy6q9/fdevFTcVA0v+n5K7U/tf4lGhcfYgiCmIEgZtw+6+RCXUurvkKlepZ2vS5i+oyTaby0GxcLMQNBzEAQM0r5kKnv6K6xK9X4R13zu+eyJnXpazssxAwEMQNBzNj+fkg3nqjGK9laPz1vleXwq2v+p+vciUMMQRAzEMSM298xrOYDVqrtpmtzt59uHqc6v2zcBxbiB4KYgSBmbOvUV7q577VdOIliXqLr87p7Tere2YnrsRAzEMQMBDFj+zuGar3Gp+rNp3kUtR5lmj/Jxo/GvZsvFmIGgpiBIGbcPi/rW+MPPaeqOs407xL1E1E9lzWpg8FCzEAQMxDEDOk3qC66a7f6fsSn1uz18+o8P+GzsBAzEMQMBDFjm1Ov7L3s3p+2/6lcfoa6ZxaNm50DWyEOMQRBzEAQM7Zne6PX3XilW5M3zbd0c/3ZHpvqY6P+7j7HQsxAEDMQxIxRPqRaT6Kuzemkh7WJ3RrJbJxq7eOuPyzEDAQxA0HMKJ3t/XbxobW/Gmdka/PpPMxPgoWYgSBmIIgZ0m9QrXTP1mb9Ru2y+/hsD2xaM9jN5UfjEIf8RSCIGQhiRus3qLp7ONU6jK4vynxMdn10XdY+m4/SHxZiBoKYgSBm3MYhGdl9/qkzvN18ilpDqF6nxiPVGs3Xz7EQMxDEDAQx4/ZcVoR6fqobZ6h7Vtm81TVejZdWuvHNXXssxAwEMQNBzHju3pyujdO68Ky9Wm+h9qPGJVG/6nyU+WIhZiCIGQhixtaHdFF9hlqLeOrcVPcMQDeOmtTNYyFmIIgZCGLGUR/SPQs73QuL5tGtiVznlc1X/T8iXtthIWYgiBkIYsbWh3T3nNS1dXqe6tReW8S0Hr1b5/LAQvxAEDMQxIw3H9I9nzU9R6XGHdn41dx4d4+rGp9En7OX9ReAIGYgiBlff6IWG2KwEDP+DQAA//+TDHXGhqE4+AAAAABJRU5ErkJggg==&quot;, &quot;url&quot;: &quot;otpauth://totp/Google:test@gmail.com?algorithm=SHA1&amp;digits=6&amp;issuer=Google&amp;period=30&amp;secret=HTXT7KJFVNAJUPYWQRWMNVQE5AF5YZI2&quot; } }   If a QR code is returned, it consists of base64-formatted PNG bytes. You can embed it in a web page by including the base64 string in an img tag with the prefix data:image/png;base64  &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUh..&quot; /&gt;   ","version":"Next","tagName":"h3"},{"title":"Read key​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#read-key","content":" This endpoint queries the key definition.  Method\tPathGET\t/totp/keys/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the key to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/totp/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-response-1","content":" { &quot;data&quot;: { &quot;account_name&quot;: &quot;test@gmail.com&quot;, &quot;algorithm&quot;: &quot;SHA1&quot;, &quot;digits&quot;: 6, &quot;issuer&quot;: &quot;Google&quot;, &quot;period&quot;: 30 } }   ","version":"Next","tagName":"h3"},{"title":"List keys​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#list-keys","content":" This endpoint returns a list of available keys. Only the key names are returned, not any values.  Method\tPathLIST\t/totp/keys  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/totp/keys   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-response-2","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;my-key&quot;] }, &quot;lease_duration&quot;: 0, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Delete key​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#delete-key","content":" This endpoint deletes the key definition.  Method\tPathDELETE\t/totp/keys/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the key to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/totp/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Generate code​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#generate-code","content":" This endpoint generates a new time-based one-time use password based on the named key.  Method\tPathGET\t/totp/code/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#parameters-3","content":" name (string: &lt;required&gt;) – Specifies the name of the key to create credentials against. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/totp/code/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-response-3","content":" { &quot;data&quot;: { &quot;code&quot;: &quot;810920&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Validate code​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#validate-code","content":" This endpoint validates a time-based one-time use password generated from the named key.  Method\tPathPOST\t/totp/code/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#parameters-4","content":" name (string: &lt;required&gt;) – Specifies the name of the key used to generate the password. This is specified as part of the URL. code (string: &lt;required&gt;) – Specifies the password you want to validate.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-payload-2","content":" { &quot;code&quot;: &quot;123802&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/totp/code/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"TOTP secrets engine (API)","url":"/openbao/api-docs/secret/totp/#sample-response-4","content":" { &quot;data&quot;: { &quot;valid&quot;: true } }  ","version":"Next","tagName":"h3"},{"title":"SSH secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/ssh/","content":"","keywords":"","version":"Next"},{"title":"Create/Update role​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#createupdate-role","content":" This endpoint creates or updates a named role.  Method\tPathPOST\t/ssh/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create. This is part of the request URL. default_user (string: &quot;&quot;) – Specifies the default username for which a credential will be generated. When the endpoint creds/ is used without a username, this value will be used as default username. Its recommended to create individual roles for each username to ensure absolute isolation between usernames. This is required for OTP type roles. When default_user_template is set to true, this field can contain an identity template with any prefix or suffix, like ssh-{{identity.entity.id}}-user. For the CA type, if you wish this to be a valid principal, it must also be in allowed_users. default_user_template (bool: false) - If set, default_users can be specified using identity template values. A non-templated user is also permitted. cidr_list (string: &quot;&quot;) – Specifies a comma separated list of CIDR blocks for which the role is applicable for. It is possible that a same set of CIDR blocks are part of multiple roles. This is a required parameter, unless the role is registered under the /config/zeroaddress endpoint. Note: [Not applicable for CA type] exclude_cidr_list (string: &quot;&quot;) – Specifies a comma-separated list of CIDR blocks. IP addresses belonging to these blocks are not accepted by the role. This is particularly useful when big CIDR blocks are being used by the role and certain parts need to be kept out. Note: [Not applicable for CA type] port (int: 22) – Specifies the port number for SSH connection. Port number does not play any role in OTP generation. For the otp secrets engine type, this is just a way to inform the client about the port number to use. The port number will be returned to the client by OpenBao along with the OTP. key_type (string: &lt;required&gt;) – Specifies the type of credentials generated by this role. This can be either otp or ca. allowed_users (string: &quot;&quot;) – If this option is not specified, or if it is*, the client can request a credential for any valid user at the remote host, including the admin user. To only allow an explicit list of users, set this parameter using a comma-separated username list to enforce it. When this parameter is set, the credentials are created only for default_user and usernames listed. Setting this option will enable all the users with access this role to fetch credentials for all other usernames in this list. When allowed_users_template is set to true, this field can contain an identity template with any prefix or suffix, like ssh-{{identity.entity.id}}-user. Use with caution. N.B.: if the type is ca, an empty list does not allow any user; instead you must use * to enable this behavior. allowed_users_template (bool: false) - If set, allowed_users can be specified using identity template policies. Non-templated users are also permitted. allowed_domains (string: &quot;&quot;) – A comma-separated list of domains for which a client can request a host certificate. If this option is explicitly set to&quot;*&quot;, then credentials can be created for any domain. See alsoallow_bare_domains and allow_subdomains. allowed_domains_template (bool: false) - If set, allowed_domains can be specified using identity template policies. Non-templated domains are also permitted. ttl (string: &quot;&quot;) – Specifies the Time To Live value provided as a string duration with time suffix. Hour is the largest suffix. If not set, uses the system default value or the value of max_ttl, whichever is shorter. max_ttl (string: &quot;&quot;) – Specifies the maximum Time To Live provided as a string duration with time suffix. Hour is the largest suffix. If not set, defaults to the system maximum lease TTL. allowed_critical_options (string: &quot;&quot;) – Specifies a comma-separated list of critical options that certificates can have when signed. To allow any critical options, set this to an empty string. Will default to allowing any critical options. allowed_extensions (string: &quot;&quot;) – Specifies a comma-separated list of extensions that certificates can have when signed. To allow a user to specify any extension, set this to &quot;*&quot;. If not set, users will not be allowed to specify extensions and will get the extensions specified within default_extensions. For the list of extensions, take a look at the sshd manual'sAUTHORIZED_KEYS FILE FORMAT section. You should add a permit- before the name of extension to allow it. default_critical_options (map&lt;string|string&gt;: &quot;&quot;) – Specifies a map of critical options certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by allowed_critical_options. Defaults to none. default_extensions (map&lt;string|string&gt;: &quot;&quot;) – Specifies a map of extensions certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by allowed_extensions. Defaults to none. allow_user_certificates (bool: false) – Specifies if certificates are allowed to be signed for use as a 'user'. allow_host_certificates (bool: false) – Specifies if certificates are allowed to be signed for use as a 'host'. allow_bare_domains (bool: false) – Specifies if host certificates that are requested are allowed to use the base domains listed in allowed_domains, e.g. &quot;example.com&quot;. This is a separate option as in some cases this can be considered a security threat. allow_subdomains (bool: false) – Specifies if host certificates that are requested are allowed to be subdomains of those listed in allowed_domains, e.g. if &quot;example.com&quot; is part of allowed_domains, this allows &quot;foo.example.com&quot;. allow_user_key_ids (bool: false) – Specifies if users can override the key ID for a signed certificate with the &quot;key_id&quot; field. When false, the key ID will always be the token display name. The key ID is logged by the SSH server and can be useful for auditing. key_id_format (string: &quot;&quot;) – When supplied, this value specifies a custom format for the key id of a signed certificate. The following variables are available for use: '{{token_display_name}}' - The display name of the token used to make the request. '{{role_name}}' - The name of the role signing the request. '{{public_key_hash}}' - A SHA256 checksum of the public key that is being signed. e.g. &quot;custom-keyid-{{token_display_name}}&quot; allowed_user_key_lengths (map&lt;string|(int|[]int|string)&gt;: &quot;&quot;) – Specifies a map of ssh key types and their expected sizes which are allowed to be signed by the CA type. To specify multiple sizes, either use a comma-separated list or an array of allowed key widths. We support both OpenSSH-style key identifiers and short names (rsa, ecdsa, dsa, or ed25519) as keys. For example, a valid policy to allow common RSA and ECDSA key lengths might be: { &quot;rsa&quot;: [2048, 3072, 4096], &quot;ec&quot;: 256, &quot;ecdsa-sha2-nistp521&quot;: 0 } Note that when an algorithm identifier uniquely specifies a key length (such as with ecdsa-sha2-nistp256 or ed25519), the value of the length is ignored (and can be zero).  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: ed25519.  algorithm_signer (string: &quot;default&quot;) - Algorithm to sign keys with. Valid values are ssh-rsa, rsa-sha2-256, rsa-sha2-512, or default. This value may also be left blank to use the signer's default algorithm, and must be left blank or have value default for CA key types other than RSA.  warning Note: The value of default may change over time as vulnerabilities in algorithms are discovered. The present value for RSA keys is equivalent to rsa-sha2-256.  warning Warning: The algorithm_signer value ssh-rsa uses the SHA-1 hash algorithm. This algorithm is now considered insecure and is not supported by current OpenSSH versions. As a result, OpenBao has made the new defaultrsa-sha2-256 for RSA CA keys. It is strongly encouraged for all users to migrate to rsa-sha2-256 or default if the role was created with an explicit algorithm_signer=rsa-sha parameter or has been migrated to such.  not_before_duration (duration: &quot;30s&quot;) – Specifies the duration by which to backdate the ValidAfter property. Uses duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload","content":" { &quot;key_type&quot;: &quot;otp&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#read-role","content":" This endpoint queries a named role.  Method\tPathGET\t/ssh/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the role to read. This is part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/ssh/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response","content":" For an OTP role:  { &quot;cidr_list&quot;: &quot;x.x.x.x/y&quot;, &quot;default_user&quot;: &quot;username&quot;, &quot;key_type&quot;: &quot;otp&quot;, &quot;port&quot;: 22 }   For a CA role:  { &quot;allow_bare_domains&quot;: false, &quot;allow_host_certificates&quot;: true, &quot;allow_subdomains&quot;: false, &quot;allow_user_key_ids&quot;: false, &quot;allow_user_certificates&quot;: true, &quot;allowed_critical_options&quot;: &quot;&quot;, &quot;allowed_extensions&quot;: &quot;&quot;, &quot;default_critical_options&quot;: {}, &quot;default_extensions&quot;: {}, &quot;max_ttl&quot;: &quot;768h&quot;, &quot;ttl&quot;: &quot;4h&quot; }   ","version":"Next","tagName":"h3"},{"title":"List roles​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#list-roles","content":" This endpoint returns a list of available roles. Only the role names are returned, not any values.  Method\tPathLIST\t/ssh/roles  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/ssh/roles   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;dev&quot;, &quot;prod&quot;], &quot;key_info&quot;: { &quot;dev&quot;: { &quot;key_type&quot;: &quot;ca&quot; } } }, &quot;lease_duration&quot;: 2764800, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#delete-role","content":" This endpoint deletes a named role.  Method\tPathDELETE\t/ssh/roles/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the role to delete. This is part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"List Zero-Address roles​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#list-zero-address-roles","content":" This endpoint returns the list of configured zero-address roles.  Method\tPathGET\t/ssh/config/zeroaddress  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/ssh/config/zeroaddress   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-2","content":" { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;roles&quot;: [&quot;otp_key_role&quot;] }, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Configure Zero-Address roles​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#configure-zero-address-roles","content":" This endpoint configures zero-address roles.  Method\tPathPOST\t/ssh/config/zeroaddress  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-3","content":" roles (string: &lt;required&gt;) – Specifies a string containing comma separated list of role names which allows credentials to be requested for any IP address. CIDR blocks previously registered under these roles will be ignored.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-1","content":" { &quot;roles&quot;: [&quot;otp_key_role&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/config/zeroaddress   ","version":"Next","tagName":"h3"},{"title":"Delete Zero-Address role​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#delete-zero-address-role","content":" This endpoint deletes the zero-address roles configuration.  Method\tPathDELETE\t/ssh/config/zeroaddress  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/ssh/config/zeroaddress   ","version":"Next","tagName":"h3"},{"title":"Generate SSH credentials​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#generate-ssh-credentials","content":" This endpoint creates credentials for a specific username and IP with the parameters defined in the given role.  Method\tPathPOST\t/ssh/creds/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-4","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create credentials against. This is part of the request URL. username (string: &quot;&quot;) – Specifies the username on the remote host. ip (string: &lt;required&gt;) – Specifies the IP of the remote host.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-2","content":" { &quot;ip&quot;: &quot;1.2.3.4&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/creds/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-3","content":" For an OTP role:  { &quot;lease_id&quot;: &quot;sshs/creds/c3c2e60c-5a48-415a-9d5a-a41e0e6cdec5/3ee6ad28-383f-d482-2427-70498eba4d96&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 2764800, &quot;data&quot;: { &quot;ip&quot;: &quot;127.0.0.1&quot;, &quot;key&quot;: &quot;6d6411fd-f622-ea0a-7e2c-989a745cbbb2&quot;, &quot;key_type&quot;: &quot;otp&quot;, &quot;port&quot;: 22, &quot;username&quot;: &quot;rajanadar&quot; }, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"List roles by IP​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#list-roles-by-ip","content":" This endpoint lists all of the roles with which the given IP is associated.  Method\tPathPOST\t/ssh/lookup  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-5","content":" ip (string: &lt;required&gt;) – Specifies the IP of the remote host.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-3","content":" { &quot;ip&quot;: &quot;1.2.3.4&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/lookup   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-4","content":" An array of roles as a secret structure.  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;roles&quot;: [ &quot;fe6f61b7-7e4a-46a6-b2c8-0d530b8513df&quot;, &quot;6d6411fd-f622-ea0a-7e2c-989a745cbbb2&quot; ] }, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Verify SSH OTP​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#verify-ssh-otp","content":" This endpoint verifies if the given OTP is valid. This is an unauthenticated endpoint.  Method\tPathPOST\t/ssh/verify  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-6","content":" otp (string: &lt;required&gt;) – Specifies the One-Time-Key that needs to be validated.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-4","content":" { &quot;otp&quot;: &quot;bad2b3-...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-5","content":" { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;ip&quot;: &quot;127.0.0.1&quot;, &quot;username&quot;: &quot;rajanadar&quot; }, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Submit CA information​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#submit-ca-information","content":" This endpoint allows submitting the CA information for the secrets engine via an SSH key pair. If you have already set a certificate and key, they will be overridden.  | Method | Path | | :----- | :--------------- | -------------------------- | | POST | /ssh/config/ca | 200/204 application/json |  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-7","content":" private_key (string: &quot;&quot;) – Specifies the private key part the SSH CA key pair; required if generate_signing_key is false. public_key (string: &quot;&quot;) – Specifies the public key part of the SSH CA key pair; required if generate_signing_key is false. generate_signing_key (bool: true) – Specifies if OpenBao should generate the signing key pair internally. If true, an RSA key pair is generated, and the generated public key is returned so you can add it to your configuration. If false, then you must provide private_key and public_key, but these can be of any valid signing key type. key_type (string: ssh-rsa) - Specifies the desired key type for the generated SSH CA key when generate_signing_key is set to true. Valid values are OpenSSH key type identifiers (ssh-rsa, ecdsa-sha2-nistp256,ecdsa-sha2-nistp384, ecdsa-sha2-nistp521, or ssh-ed25519) or an algorithm (rsa, ec, or ed25519).  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: ed25519.  key_bits (int: 0) - Specifies the desired key bits for the generated SSH CA key when generate_signing_key is set to true. This is only used for variable length keys (such as ssh-rsa, where the value of key_bitsspecifies the size of the RSA key pair to generate; with the default 0value resulting in a 4096-bit key) or when the ec algorithm is specified in key_type (where the value of key_bits identifies which NIST P-curve to use; 256, 384, or 521, with the default 0 value resulting in a NIST P-256 key).  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-5","content":" { &quot;generate_signing_key&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/config/ca   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-6","content":" This will return a 204 response if generate_signing_key was unset or false.  This will return a 200 response if generate_signing_key was true:  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;public_key&quot;: &quot;ssh-rsa AAAAHHNzaC1y...\\n&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Delete CA information​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#delete-ca-information","content":" This endpoint deletes the CA information for the backend via an SSH key pair.  Method\tPathDELETE\t/ssh/config/ca  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/ssh/config/ca   ","version":"Next","tagName":"h3"},{"title":"Read public key (Unauthenticated)​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#read-public-key-unauthenticated","content":" This endpoint returns the configured/generated public key. This is an unauthenticated endpoint.  warning Note: this is a raw response endpoint without JSON encoding; useopenbao read -format=raw or an external tool (e.g., curl) to fetch this value.  Method\tPath\tContent-TypeGET\t/ssh/public_key\t200 text/plain  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-12","content":" $ curl http://127.0.0.1:8200/v1/ssh/public_key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-7","content":"  ssh-rsa AAAAHHNzaC1y...   ","version":"Next","tagName":"h3"},{"title":"Read public key (Authenticated)​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#read-public-key-authenticated","content":" This endpoint reads the configured/generated public key.  Method\tPathGET\t/ssh/config/ca  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-13","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/ssh/config/ca   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-8","content":" { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;public_key&quot;: &quot;ssh-rsa AAAAHHNzaC1y...\\n&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Sign SSH key​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sign-ssh-key","content":" This endpoint signs an SSH public key based on the supplied parameters and subject to the restrictions of the role named in the path. Both create andupdate policy capabilities are needed to sign and update SSH keys. If onlycreate capability is granted, and a SSH key does not exist, it will be created using the default parameters already configured. If only update capability is available and a SSH key does not exist, an error will be returned and SSH keys must exist already before may be updated.  It is similar to the endpoint /ssh/issue/:name. Instead of issuing new SSH credentials, this returns a certificate for the given SSH public key.  The issued certificate uses the defaults specified in the role named in this endpoint. Where not restricted by the parameters of this role, the parameters of the issued certificate can be further customized in this API call.  warning Note: The issued certificate is returned but not stored by OpenBao. If you do not save it from the response, request it again by repeating this request.  Method\tPathPOST\t/ssh/sign/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-8","content":" name (string: &lt;required&gt;) – Specifies the name of the role to sign. This is part of the request URL. public_key (string: &lt;required&gt;) – Specifies the SSH public key that should be signed. ttl (string: &quot;&quot;) – Specifies the Requested Time To Live. Cannot be greater than the role's max_ttl value. If not provided, the role's ttl value will be used. Note that the role values default to system values if not explicitly set. valid_principals (string: &quot;&quot;) – Specifies valid principals, either usernames or hostnames, that the certificate should be signed for. cert_type (string: &quot;user&quot;) – Specifies the type of certificate to be created; either &quot;user&quot; or &quot;host&quot;. key_id (string: &quot;&quot;) – Specifies the key id that the created certificate should have. If not specified, the display name of the token will be used. critical_options (map&lt;string|string&gt;: &quot;&quot;) – Specifies a map of the critical options that the certificate should be signed for. Defaults to none. extensions (map&lt;string|string&gt;: &quot;&quot;) – Specifies a map of the extensions that the certificate should be signed for. Defaults to none.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-6","content":" { &quot;public_key&quot;: &quot;ssh-rsa ...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/sign/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-9","content":" { &quot;lease_id&quot;: &quot;ssh/sign/example/097bf207-96dd-0041-0e83-b23bd1923993&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 21600, &quot;data&quot;: { &quot;serial_number&quot;: &quot;f65ed2fd21443d5c&quot;, &quot;signed_key&quot;: &quot;ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1y...\\n&quot; }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Generate certificate and key​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#generate-certificate-and-key","content":" This endpoint issues a new set of SSH credentials (private key and certificate).  It is similar to the endpoint /ssh/sign/:name: Instead of signing an existing SSH public key, it generates and issues new SSH credentials (key and certificate).  The issued certificate uses the defaults specified in the role named in this endpoint. Where not restricted by the parameters of this role, the parameters of the issued certificate can be further customized in this API call.  warning Note: The issued credentials are returned but not stored by OpenBao. If you do not save them from the response, issue new credentials by using this request again.  Method\tPathPOST\t/ssh/issue/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#parameters-9","content":" name (string: &lt;required&gt;) – Specifies the name of the role to create the certificate against. This is part of the request URL. key_type (string: &quot;rsa&quot;) – Specifies the desired key type; must be rsa, ed25519or ec. key_bits (int: 0) – Specifies the number of bits to use for the generated keys. Allowed values are 0 (universal default); withkey_type=rsa, allowed values are: 2048 (default), 3072, or 4096; with key_type=ec, allowed values are: 256 (default), 384, or 521; ignored with key_type=ed25519. ttl (string: &quot;&quot;) – Specifies the Requested Time To Live. Cannot be greater than the role's max_ttl value. If not provided, the role's ttl value will be used. Note that the role values default to system values if not explicitly set. valid_principals (string: &quot;&quot;) – Specifies valid principals, either usernames or hostnames, that the certificate should be signed for. cert_type (string: &quot;user&quot;) – Specifies the type of certificate to be created; either &quot;user&quot; or &quot;host&quot;. key_id (string: &quot;&quot;) – Specifies the key id that the created certificate should have. If not specified, the display name of the token will be used. critical_options (map&lt;string|string&gt;: &quot;&quot;) – Specifies a map of the critical options that the certificate should be signed for. Defaults to none. extensions (map&lt;string|string&gt;: &quot;&quot;) – Specifies a map of the extensions that the certificate should be signed for. Defaults to none.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-payload-7","content":" { &quot;key_type&quot;: &quot;rsa&quot;, &quot;key_bits&quot;: 2048 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-15","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/ssh/issue/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-10","content":" { &quot;request_id&quot;: &quot;94fd1102-08a1-c207-0e3e-657e8f80c09e&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;serial_number&quot;: &quot;1e965817eb12a511&quot;, &quot;signed_key&quot;: &quot;ssh-rsa-cert-v01@openssh.com AAAAHHN...\\n&quot;, &quot;private_key&quot;: &quot;-----BEGIN RSA PRIVATE KEY-----\\nMIIEpQIBAAKCAQEAwer03vkQrPV+wWpbisJJv2CKqHmMz+Ej0ctLbhpOmR2CY9S9\\n...\\nQN351pgTphi6nlCkGPzkDuwvtxSxiCWXQcaxrHAL7MiJpPzkIBq1\\n-----END RSA PRIVATE KEY-----\\n&quot;, &quot;private_key_type&quot;: &quot;rsa&quot; }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Tidy host keys​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#tidy-host-keys","content":" This endpoint removes all existing host keys from OpenBao, if any are present. These keys were used with the Dynamic Keys functionality, which were removed from this engine.  warning Note: This does not clean up any pending dynamic key leases and will not remove these keys from systems with authorized hosts entries created by OpenBao. That must be done manually by an operator, potentially before the removal of these host keys if they are necessary to access these systems.  Method\tPathDELETE\t/ssh/tidy/dynamic-keys  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-request-16","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/ssh/issue/my-role   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"SSH secrets engine (API)","url":"/openbao/api-docs/secret/ssh/#sample-response-11","content":" { &quot;request_id&quot;: &quot;&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;message&quot;: &quot;Removed 15 of 15 host keys.&quot; }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"System backend","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/","content":"System backend The system backend is a default backend in OpenBao that is mounted at the /sysendpoint. This endpoint cannot be disabled or moved, and is used to configure OpenBao and interact with many of OpenBao's internal features. For more information about a particular path, please click on it in the sidebar.","keywords":"","version":"Next"},{"title":"/sys/audit-hash","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/audit-hash/","content":"","keywords":"","version":"Next"},{"title":"Calculate hash​","type":1,"pageTitle":"/sys/audit-hash","url":"/openbao/api-docs/system/audit-hash/#calculate-hash","content":" This endpoint hashes the given input data with the specified audit device's hash function and salt. This endpoint can be used to discover whether a given plaintext string (the input parameter) appears in the audit log in obfuscated form.  The audit log records requests and responses. Since the OpenBao API is JSON-based, any binary data returned from an API call (such as a DER-format certificate) is base64-encoded by the OpenBao server in the response. As a result such information should also be base64-encoded to supply into the input parameter.  Method\tPathPOST\t/sys/audit-hash/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/audit-hash","url":"/openbao/api-docs/system/audit-hash/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path of the audit device to generate hashes for. This is part of the request URL. input (string: &lt;required&gt;) – Specifies the input string to hash.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/audit-hash","url":"/openbao/api-docs/system/audit-hash/#sample-payload","content":" { &quot;input&quot;: &quot;my-secret-openbao&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/audit-hash","url":"/openbao/api-docs/system/audit-hash/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/audit-hash/example-audit   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/audit-hash","url":"/openbao/api-docs/system/audit-hash/#sample-response","content":" { &quot;hash&quot;: &quot;hmac-sha256:08ba35...&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/audit","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/audit/","content":"","keywords":"","version":"Next"},{"title":"List enabled audit devices​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#list-enabled-audit-devices","content":" This endpoint lists only the enabled audit devices (it does not list all available audit devices).  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathGET\t/sys/audit  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/audit   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#sample-response","content":" { &quot;file&quot;: { &quot;type&quot;: &quot;file&quot;, &quot;description&quot;: &quot;Store logs in a file&quot;, &quot;options&quot;: { &quot;file_path&quot;: &quot;/var/log/openbao.log&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Enable audit device​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#enable-audit-device","content":" This endpoint enables a new audit device at the supplied path. The path can be a single word name or a more complex, nested path.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathPOST\t/sys/audit/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path in which to enable the audit device. This is part of the request URL. description (string: &quot;&quot;) – Specifies a human-friendly description of the audit device. options (map&lt;string|string&gt;: nil) – Specifies configuration options to pass to the audit device itself. For more details, please see the relevant page for an audit device type, under Audit Devices docs. type (string: &lt;required&gt;) – Specifies the type of the audit device. Valid types are file, socket and syslog.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#sample-payload","content":" { &quot;type&quot;: &quot;file&quot;, &quot;options&quot;: { &quot;file_path&quot;: &quot;/var/log/openbao/log&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/audit/example-audit   ","version":"Next","tagName":"h3"},{"title":"Disable audit device​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#disable-audit-device","content":" This endpoint disables the audit device at the given path.  warning Note: Once an audit device is disabled, you will no longer be able to HMAC values for comparison with entries in the audit logs. This is true even if you re-enable the audit device at the same path, as a new salt will be created for hashing.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathDELETE\t/sys/audit/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#parameters-1","content":" path (string: &lt;required&gt;) – Specifies the path of the audit device to delete. This is part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/audit","url":"/openbao/api-docs/system/audit/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/audit/example-audit  ","version":"Next","tagName":"h3"},{"title":"/sys/auth","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/auth/","content":"","keywords":"","version":"Next"},{"title":"List auth methods​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#list-auth-methods","content":" This endpoint lists all enabled auth methods.  Method\tPathGET\t/sys/auth  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/auth   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-response","content":" { &quot;request_id&quot;: &quot;9bc0fab8-d65c-3961-afe6-d05f50c5fd22&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;github/&quot;: { &quot;accessor&quot;: &quot;auth_github_badd7fd0&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0, &quot;token_type&quot;: &quot;default-service&quot; }, &quot;deprecation_status&quot;: &quot;supported&quot;, &quot;description&quot;: &quot;&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: false, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;github&quot;, &quot;uuid&quot;: &quot;4b42d1a4-0a0d-3c88-ae90-997e0c8b41be&quot; }, &quot;token/&quot;: { &quot;accessor&quot;: &quot;auth_token_bd90f507&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0, &quot;token_type&quot;: &quot;default-service&quot; }, &quot;description&quot;: &quot;token based credentials&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: false, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;token&quot;, &quot;uuid&quot;: &quot;e162baec-721b-7657-7913-c960df402f8a&quot; } }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Enable auth method​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#enable-auth-method","content":" This endpoint enables a new auth method. After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the &quot;foo&quot; auth method will make it accessible at/auth/foo.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathPOST\t/sys/auth/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path in which to enable the auth method. This is part of the request URL.  danger NOTE: Use ASCII printable characters to specify the desired path.  description (string: &quot;&quot;) – Specifies a human-friendly description of the auth method. type (string: &lt;required&gt;) – Specifies the name of the authentication method type, such as &quot;github&quot; or &quot;token&quot;. config (map&lt;string|string&gt;: nil) – Specifies configuration options for this auth method. These are the possible values: default_lease_ttl (string: &quot;&quot;) - The default lease duration, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. max_lease_ttl (string: &quot;&quot;) - The maximum lease duration, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. audit_non_hmac_request_keys (array: []) - List of keys that will not be HMAC'd by audit devices in the request data object. audit_non_hmac_response_keys (array: []) - List of keys that will not be HMAC'd by audit devices in the response data object. listing_visibility (string: &quot;&quot;) - Specifies whether to show this mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or &quot;hidden&quot;, with the default &quot;&quot; being equivalent to &quot;hidden&quot;. passthrough_request_headers (array: []) - List of headers to allow and pass from the request to the plugin. allowed_response_headers (array: []) - List of headers to allow, allowing a plugin to include them in the response. plugin_version (string: &quot;&quot;) – Specifies the semantic version of the plugin to use, e.g. &quot;v1.0.0&quot;. If unspecified, the server will select any matching unversioned plugin that may have been registered, the latest versioned plugin registered, or a built-in plugin in that order of precendence.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-payload","content":" { &quot;type&quot;: &quot;github&quot;, &quot;description&quot;: &quot;Login with GitHub&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/auth/my-auth   ","version":"Next","tagName":"h3"},{"title":"Read auth method configuration​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#read-auth-method-configuration","content":" This endpoints returns the configuration of the auth method at the given path.  Method\tPathGET\t/sys/auth/:path  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/auth/my-auth   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-response-1","content":" { &quot;request_id&quot;: &quot;8d2a1e33-4c00-46a5-f50d-4dc5f5d96f12&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;accessor&quot;: &quot;auth_github_badd7fd0&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0, &quot;token_type&quot;: &quot;default-service&quot; }, &quot;deprecation_status&quot;: &quot;supported&quot;, &quot;description&quot;: &quot;&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: false, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;github&quot;, &quot;uuid&quot;: &quot;4b42d1a4-0a0d-3c88-ae90-997e0c8b41be&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Disable auth method​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#disable-auth-method","content":" This endpoint disables the auth method at the given auth path.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathDELETE\t/sys/auth/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#parameters-1","content":" path (string: &lt;required&gt;) – Specifies the path to disable. This is part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/auth/my-auth   ","version":"Next","tagName":"h3"},{"title":"Read auth method tuning​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#read-auth-method-tuning","content":" This endpoint reads the given auth path's configuration. This endpoint requiressudo capability on the final path, but the same functionality can be achieved without sudo via sys/mounts/auth/[auth-path]/tune._ sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathGET\t/sys/auth/:path/tune  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#parameters-2","content":" path (string: &lt;required&gt;) – Specifies the path in which to tune.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/auth/my-auth/tune   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-response-2","content":" { &quot;default_lease_ttl&quot;: 2764800, &quot;description&quot;: &quot;&quot;, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 2764800, &quot;token_type&quot;: &quot;default-service&quot; }   ","version":"Next","tagName":"h3"},{"title":"Tune auth method​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#tune-auth-method","content":" Tune configuration parameters for a given auth path. This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via sys/mounts/auth/[auth-path]/tune.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathPOST\t/sys/auth/:path/tune  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#parameters-3","content":" default_lease_ttl (int: 0) – Specifies the default time-to-live. If set on a specific auth path, this overrides the global default. max_lease_ttl (int: 0) – Specifies the maximum time-to-live. If set on a specific auth path, this overrides the global default. description (string: &quot;&quot;) – Specifies the description of the mount. This overrides the current stored value, if any. audit_non_hmac_request_keys (array: []) - Specifies the list of keys that will not be HMAC'd by audit devices in the request data object. audit_non_hmac_response_keys (array: []) - Specifies the list of keys that will not be HMAC'd by audit devices in the response data object. listing_visibility (string: &quot;&quot;) - Specifies whether to show this mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or &quot;hidden&quot;, with the default &quot;&quot; being equivalent to &quot;hidden&quot;. passthrough_request_headers (array: []) - List of headers to allow and pass from the request to the plugin. allowed_response_headers (array: []) - List of headers to allow, allowing a plugin to include them in the response. token_type (string: &quot;&quot;) – Specifies the type of tokens that should be returned by the mount. The following values are available: default-service: Unless the auth method requests a different type, issue service tokensdefault-batch: Unless the auth method requests a different type, issue batch tokensservice: Override any auth method preference and always issue service tokens from this mountbatch: Override any auth method preference and always issue batch tokens from this mount plugin_version (string: &quot;&quot;) – Specifies the semantic version of the plugin to use, e.g. &quot;v1.0.0&quot;. Changes will not take effect until the mount is reloaded. user_lockout_config (map&lt;string|string&gt;: nil) – Specifies the user lockout configuration for the mount. These are the possible values: lockout_threshold (string: &quot;&quot;) - Specifies the number of failed login attempts after which the user is locked out, specified as a string like &quot;15&quot;. lockout_duration (string: &quot;&quot;) - Specifies the duration for which an user will be locked out, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. lockout_counter_reset (string: &quot;&quot;) - Specifies the duration after which the lockout counter is reset with no failed login attempts, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. lockout_disable (bool: false) - Disables the user lockout feature for this mount if set to true.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-payload-1","content":" { &quot;default_lease_ttl&quot;: 1800, &quot;max_lease_ttl&quot;: 86400, &quot;audit_non_hmac_request_keys&quot;: [&quot;client_nonce&quot;], &quot;user_lockout_config&quot;:{ &quot;lockout_threshold&quot;:&quot;20&quot;, &quot;lockout_duration&quot;:&quot;5m&quot;, &quot;lockout_counter_reset&quot;:&quot;5m&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/auth","url":"/openbao/api-docs/system/auth/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/auth/my-auth/tune  ","version":"Next","tagName":"h3"},{"title":"/sys/capabilities-accessor","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/capabilities-accessor/","content":"","keywords":"","version":"Next"},{"title":"Query token accessor capabilities​","type":1,"pageTitle":"/sys/capabilities-accessor","url":"/openbao/api-docs/system/capabilities-accessor/#query-token-accessor-capabilities","content":" This endpoint returns the capabilities of the token associated with the given accessor, for the given path. Multiple paths are taken in at once and the capabilities of the token associated with the given accessor for each path is returned. For backwards compatibility, if a single path is supplied, acapabilities field will also be returned.  Method\tPathPOST\t/sys/capabilities-accessor  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/capabilities-accessor","url":"/openbao/api-docs/system/capabilities-accessor/#parameters","content":" accessor (string: &lt;required&gt;) – Accessor of the token for which capabilities are being queried. paths (list: &lt;required&gt;) – Paths on which capabilities are being queried.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/capabilities-accessor","url":"/openbao/api-docs/system/capabilities-accessor/#sample-payload","content":" { &quot;accessor&quot;: &quot;abcd1234&quot;, &quot;paths&quot;: [&quot;secret/foo&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/capabilities-accessor","url":"/openbao/api-docs/system/capabilities-accessor/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/capabilities-accessor   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/capabilities-accessor","url":"/openbao/api-docs/system/capabilities-accessor/#sample-response","content":" { &quot;capabilities&quot;: [&quot;delete&quot;, &quot;list&quot;, &quot;read&quot;, &quot;update&quot;], &quot;secret/foo&quot;: [&quot;delete&quot;, &quot;list&quot;, &quot;read&quot;, &quot;update&quot;] }  ","version":"Next","tagName":"h3"},{"title":"Transit secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/transit/","content":"","keywords":"","version":"Next"},{"title":"Create key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#create-key","content":" This endpoint creates a new named encryption key of the specified type. The values set here cannot be changed after key creation.  Method\tPathPOST\t/transit/keys/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to create. This is specified as part of the URL. convergent_encryption (bool: false) – If enabled, the key will support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true. When enabled, each encryption(/decryption/rewrap/datakey) operation will derive a nonce value rather than randomly generate it. derived (bool: false) – Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this named key must provide a context which is used for key derivation. exportable (bool: false) - Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled. allow_plaintext_backup (bool: false) - If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled. type (string: &quot;aes256-gcm96&quot;) – Specifies the type of key to create. The currently-supported types are: aes128-gcm96 – AES-128 wrapped with GCM using a 96-bit nonce size AEAD (symmetric, supports derivation and convergent encryption)aes256-gcm96 – AES-256 wrapped with GCM using a 96-bit nonce size AEAD (symmetric, supports derivation and convergent encryption, default)chacha20-poly1305 – ChaCha20-Poly1305 AEAD (symmetric, supports derivation and convergent encryption)xchacha20-poly1305 – XChaCha20-Poly1305 AEAD (symmetric, supports derivation and convergent encryption)ed25519 – ED25519 (asymmetric, supports derivation). When using derivation, a sign operation with the same context will derive the same key and signature; this is a signing analogue to convergent_encryption.ecdsa-p256 – ECDSA using the P-256 elliptic curve (asymmetric)ecdsa-p384 – ECDSA using the P-384 elliptic curve (asymmetric)ecdsa-p521 – ECDSA using the P-521 elliptic curve (asymmetric)rsa-2048 - RSA with bit size of 2048 (asymmetric)rsa-3072 - RSA with bit size of 3072 (asymmetric)rsa-4096 - RSA with bit size of 4096 (asymmetric)hmac - HMAC (HMAC generation, verification) key_size (int: &quot;0&quot;, optional) - The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes. auto_rotate_period (duration: &quot;0&quot;, optional) – The period at which this key should be rotated automatically. Setting this to &quot;0&quot; (the default) will disable automatic key rotation. This value cannot be shorter than one hour. Uses duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload","content":" { &quot;type&quot;: &quot;ecdsa-p256&quot;, &quot;derived&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Import key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#import-key","content":" This endpoint imports existing key material into a new transit-managed encryption key. To import key material into an existing key, see the import_version/ endpoint.  This supports one of two forms:  Private/Symmetric Key import, requiring the ciphertext, hash_functionparameters be set (and automatically deriving the public key), orPublic Key-only import, restricting the operations that can be done with this key, and requiring only the public_key parameter.  The remaining parameters (including name, type, allow_rotation,derived, context, exportable, allow_plaintext_backup, andauto_rotate_period) remain the same across both versions of this call.  Method\tPathPOST\t/transit/keys/:name/import  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to create. This is specified as part of the URL. ciphertext (string: &lt;required&gt;) - A base64-encoded string that contains two values: an ephemeral 256-bit AES key wrapped using the wrapping key returned by OpenBao and the encryption of the import key material under the provided AES key. The wrapped AES key should be the first 512 bytes of the ciphertext, and the encrypted key material should be the remaining bytes. See the BYOK section of the Transit secrets engine documentationfor more information on constructing the ciphertext. If public_key is set, this field is not required. hash_function (string: &quot;SHA256&quot;) - The hash function used for the RSA-OAEP step of creating the ciphertext. Supported hash functions are:SHA1, SHA224, SHA256, SHA384, and SHA512. If not specified, the hash function defaults to SHA256. type (string: &lt;required&gt;) – Specifies the type of key to create. The currently-supported types are: aes128-gcm96 – AES-128 wrapped with GCM using a 96-bit nonce size AEAD (symmetric, supports derivation and convergent encryption)aes256-gcm96 – AES-256 wrapped with GCM using a 96-bit nonce size AEAD (symmetric, supports derivation and convergent encryption, default)chacha20-poly1305 – ChaCha20-Poly1305 AEAD (symmetric, supports derivation and convergent encryption)xchacha20-poly1305 – XChaCha20-Poly1305 AEAD (symmetric, supports derivation and convergent encryption)ed25519 – ED25519 (asymmetric, supports derivation). When using derivation, a sign operation with the same context will derive the same key and signature; this is a signing analogue to convergent_encryption.ecdsa-p256 – ECDSA using the P-256 elliptic curve (asymmetric)ecdsa-p384 – ECDSA using the P-384 elliptic curve (asymmetric)ecdsa-p521 – ECDSA using the P-521 elliptic curve (asymmetric)rsa-2048 - RSA with bit size of 2048 (asymmetric)rsa-3072 - RSA with bit size of 3072 (asymmetric)rsa-4096 - RSA with bit size of 4096 (asymmetric) public_key (string: &quot;&quot;, optional) - A plaintext PEM public key to be imported. This limits the operations available under this key to verification and encryption, depending on the key type and algorithm, as no private key is available. allow_rotation (bool: false) - If set, the imported key can be rotated within OpenBao by using the rotate endpoint.  warning NOTE: Once an imported key is rotated within OpenBao, it will no longer support importing key material with the import_version endpoint.  derived (bool: false) – Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this named key must provide a context which is used for key derivation. context (string: &quot;&quot;) - A base64-encoded string providing a context for key derivation. Required if derived is set to true. exportable (bool: false) - Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled. allow_plaintext_backup (bool: false) - If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled. auto_rotate_period (duration: &quot;0&quot;, optional) – The period at which this key should be rotated automatically. Setting this to &quot;0&quot; (the default) will disable automatic key rotation. This value cannot be shorter than one hour.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-1","content":" { &quot;type&quot;: &quot;ed25519&quot;, &quot;ciphertext&quot;: &quot;...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/keys/my-key/import   ","version":"Next","tagName":"h3"},{"title":"Import key version​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#import-key-version","content":" This endpoint imports new key material into an existing imported key.  See description and note in Import Key above about importing public and private keys.  Notably, using this method, a private key matching a public key can be imported at a later date.  Method\tPathPOST\t/transit/keys/:name/import_version  warning Note: Keys whose material was generated by OpenBao do not support importing key material. Only keys that were previously imported into OpenBao can import new key material from an external source.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to create. This is specified as part of the URL. ciphertext (string: &lt;required&gt;) - A base64-encoded string that contains two values: an ephemeral 256-bit AES key wrapped using the wrapping key returned by OpenBao and the encryption of the import key material under the provided AES key. The wrapped AES key should be the first 512 bytes of the ciphertext, and the encrypted key material should be the remaining bytes. See the BYOK section of the Transit secrets engine documentationfor more information on constructing the ciphertext. hash_function (string: &quot;SHA256&quot;) - The hash function used for the RSA-OAEP step of creating the ciphertext. Supported hash functions are:SHA1, SHA224, SHA256, SHA384, and SHA512. If not specified, the hash function defaults to SHA256. public_key (string: &quot;&quot;, optional) - A plaintext PEM public key to be imported. This limits the operations available under this key to verification and encryption, depending on the key type and algorithm, as no private key is available. version (int, optional) - Key version to be updated, if left empty, a new version will be created unless a private key is specified and the 'Latest' key is missing a private key.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-2","content":" { &quot;ciphertext&quot;: &quot;...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/keys/my-key/import_version   ","version":"Next","tagName":"h3"},{"title":"Get wrapping key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#get-wrapping-key","content":" This endpoint is used to retrieve the wrapping key to use for importing keys. The returned key will be a 4096-bit RSA public key.  Method\tPathGET\t/transit/wrapping_key  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/transit/wrapping_key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response","content":" { &quot;data&quot;: { &quot;public_key&quot;: &quot;...&quot; }, }   ","version":"Next","tagName":"h3"},{"title":"Read key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#read-key","content":" This endpoint returns information about a named encryption key. The keysobject shows the creation time of each key version; the values are not the keys themselves. Depending on the type of key, different information may be returned, e.g. an asymmetric key will return its public key in a standard format for the type.  Method\tPathGET\t/transit/keys/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-3","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to read. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/transit/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-1","content":" { &quot;data&quot;: { &quot;type&quot;: &quot;aes256-gcm96&quot;, &quot;deletion_allowed&quot;: false, &quot;derived&quot;: false, &quot;exportable&quot;: false, &quot;allow_plaintext_backup&quot;: false, &quot;keys&quot;: { &quot;1&quot;: 1442851412 }, &quot;min_decryption_version&quot;: 1, &quot;min_encryption_version&quot;: 0, &quot;name&quot;: &quot;foo&quot;, &quot;supports_encryption&quot;: true, &quot;supports_decryption&quot;: true, &quot;supports_derivation&quot;: true, &quot;supports_signing&quot;: false, &quot;imported&quot;: false } }   The keys attribute lists each version of the key, and the time that key was created as seconds since the Unix epoch. The sample response shows a key that was created on September 22, 2015 7:50:12 PM GMT, and has not been rotated.  The fields supports_encryption, supports_decryption, supports_derivation and supports_signing are derived from the type of the key, and indicate which operations may be performed with it.  ","version":"Next","tagName":"h3"},{"title":"List keys​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#list-keys","content":" This endpoint returns a list of keys. Only the key names are returned (not the actual keys themselves).  Method\tPathLIST\t/transit/keys  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/transit/keys   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-2","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;foo&quot;, &quot;bar&quot;] }, &quot;lease_duration&quot;: 0, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Delete key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#delete-key","content":" This endpoint deletes a named encryption key. It will no longer be possible to decrypt any data encrypted with the named key. Because this is a potentially catastrophic operation, the deletion_allowed tunable must be set in the key's/config endpoint.  Method\tPathDELETE\t/transit/keys/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-4","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to delete. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/transit/keys/my-key   ","version":"Next","tagName":"h3"},{"title":"Update key configuration​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#update-key-configuration","content":" This endpoint allows tuning configuration values for a given key. (These values are returned during a read operation on the named key.)  Method\tPathPOST\t/transit/keys/:name/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-5","content":" min_decryption_version (int: 0) – Specifies the minimum version of ciphertext allowed to be decrypted. Adjusting this as part of a key rotation policy can prevent old copies of ciphertext from being decrypted, should they fall into the wrong hands. For signatures, this value controls the minimum version of signature that can be verified against. For HMACs, this controls the minimum version of a key allowed to be used as the key for verification. min_encryption_version (int: 0) – Specifies the minimum version of the key that can be used to encrypt plaintext, sign payloads, or generate HMACs. Must be 0 (which will use the latest version) or a value greater or equal to min_decryption_version. deletion_allowed (bool: false) - Specifies if the key is allowed to be deleted. exportable (bool: false) - Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled. allow_plaintext_backup (bool: false) - If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled. auto_rotate_period (duration: &quot;&quot;, optional) – The period at which this key should be rotated automatically. Setting this to &quot;0&quot; will disable automatic key rotation. This value cannot be shorter than one hour. When no value is provided, the period remains unchanged. Uses duration format strings.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-3","content":" { &quot;deletion_allowed&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/keys/my-key/config   ","version":"Next","tagName":"h3"},{"title":"Rotate key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#rotate-key","content":" This endpoint rotates the version of the named key. After rotation, new plaintext requests will be encrypted with the new version of the key. To upgrade ciphertext to be encrypted with the latest version of the key, use the rewrapendpoint. This is only supported with keys that support encryption and decryption operations.  For algorithms with a configurable key size, the rotated key will use the same key size as the previous version.  warning Note: For imported keys, rotation is only supported if theallow_rotation field was set to true on import. Once an imported key is rotated within OpenBao, it will not support further import operations.  Method\tPathPOST\t/transit/keys/:name/rotate  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-6","content":" managed_key_name (string: &quot;&quot;) - The name of the managed key to use for this transit key.managed_key_id (string: &quot;&quot;) - The UUID of the managed key to use for this transit key.  warning Note: If the key to be rotated is of type managed_key, either the managed_key_name or the managed_key_id for the new key must be provided.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/transit/keys/my-key/rotate   ","version":"Next","tagName":"h3"},{"title":"Securely export key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#securely-export-key","content":" This endpoint returns a wrapped copy of the source key, protected by thedestination key using BYOK method accepted by the/transit/keys/:name/import API. This allows an operator using two separate OpenBao instances to secure established shared key material, withing exposing either key in plaintext and needing to run a manual BYOK import using the CLI helper utility.  Method\tPathGET\t/transit/byok-export/:destination/:source(/:version)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-7","content":" destination (string: &lt;required&gt;) - Specifies the name of the key to encrypt the source key to: this is usually another mount or cluster's wrapping key (from /transit/wrapping_key). This is specified as part of the URL.  warning Note: This destination key type must be an RSA key type.  source (string: &lt;required&gt;) - Specifies the source key to encrypt, to copy (encrypted) to another cluster. This is specified as part of the URL. version (string: &quot;&quot;) - Specifies the version of the source key to wrap. If omitted, all versions of the key will be returned. This is specified as part of the URL. If the version is set to latest, the current key will be returned.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/transit/byok-export/wrapping-key/to-be-shared-key/1   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-3","content":" { &quot;data&quot;: { &quot;name&quot;: &quot;foo&quot;, &quot;keys&quot;: { &quot;1&quot;: &quot;H/0T+CKQ8I82KJWpPk ... additional response elided ...&quot;, } } }   ","version":"Next","tagName":"h3"},{"title":"Export key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#export-key","content":" This endpoint returns the named key. The keys object shows the value of the key for each version. If version is specified, the specific version will be returned. If latest is provided as the version, the current key will be provided. Depending on the type of key, different information may be returned. The key must be exportable to support this operation and the version must still be valid.  Method\tPathGET\t/transit/export/:key_type/:name(/:version)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-8","content":" key_type (string: &lt;required&gt;) – Specifies the type of the key to export. This is specified as part of the URL. Valid values are: encryption-keysigning-keyhmac-keypublic-key, to return the corresponding public keys of private key asymmetric keys (EC with NIST P-curves or Ed25519 and RSA). name (string: &lt;required&gt;) – Specifies the name of the key to read information about. This is specified as part of the URL. version (string: &quot;&quot;) – Specifies the version of the key to read. If omitted, all versions of the key will be returned. This is specified as part of the URL. If the version is set to latest, the current key will be returned.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/transit/export/encryption-key/my-key/1   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-4","content":" { &quot;data&quot;: { &quot;name&quot;: &quot;foo&quot;, &quot;keys&quot;: { &quot;1&quot;: &quot;eyXYGHbTmugUJn6EtYD/yVEoF6pCxm4R/cMEutUm3MY=&quot;, &quot;2&quot;: &quot;Euzymqx6iXjS3/NuGKDCiM2Ev6wdhnU+rBiKnJ7YpHE=&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Write keys configuration​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#write-keys-configuration","content":" This endpoint maintains global configuration across all keys. This allows removing the upsert capability of the /encrypt/:key endpoint, preventing new keys from being created if none exists.  Method\tPathPOST\t/transit/config/keys  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-9","content":" disable_upsert (bool: false) - Specifies whether to disable upserting on encryption (automatic creation of unknown keys).  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-4","content":" { &quot;disable_upsert&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-11","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/config/keys   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-5","content":" { &quot;data&quot;: { &quot;disable_upsert&quot;: true, } }   ","version":"Next","tagName":"h3"},{"title":"Read keys configuration​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#read-keys-configuration","content":" This endpoint maintains global configuration across all keys. This allows removing the upsert capability of the /encrypt/:key endpoint, preventing new keys from being created if none exists.  Method\tPathGET\t/transit/config/keys  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-12","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/transit/config/keys   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-6","content":" { &quot;data&quot;: { &quot;disable_upsert&quot;: false, } }   ","version":"Next","tagName":"h3"},{"title":"Encrypt data​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#encrypt-data","content":" This endpoint encrypts the provided plaintext using the named key. This path supports the create and update policy capabilities as follows: if the user has the create capability for this endpoint in their policies, and the key does not exist, it will be upserted with default values (whether the key requires derivation depends on whether the context parameter is empty or not). If the user only has update capability and the key does not exist, an error will be returned.  warning Note: If upsert is disallowed by global keys configuration, createrequests will behave like update requests.  Method\tPathPOST\t/transit/encrypt/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-10","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to encrypt against. This is specified as part of the URL. plaintext (string: &lt;required&gt;) – Specifies base64 encoded plaintext to be encoded. associated_data (string: &quot;&quot;) - Specifies base64 encoded associated data (also known as additional data or AAD) to also be authenticated with AEAD ciphers (aes128-gcm96, aes256-gcm, chacha20-poly1305, andxchacha20-poly1305). context (string: &quot;&quot;) – Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled for this key. key_version (int: 0) – Specifies the version of the key to use for encryption. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set. nonce (string: &quot;&quot;) – Specifies the base64 encoded nonce value. The value must be exactly 96 bits (12 bytes) long and the user must ensure that for any given context (and thus, any given encryption key) this nonce value isnever reused. reference (string: &quot;&quot;) - A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input. Only valid on batch requests when using ‘batch_input’ below. batch_input (array&lt;object&gt;: nil) – Specifies a list of items to be encrypted in a single batch. When this parameter is set, if the parameters 'plaintext' and 'context' are also set, they will be ignored. Any batch output will preserve the order of the batch input. The format for the input is: [ { &quot;context&quot;: &quot;c2FtcGxlY29udGV4dA==&quot;, &quot;plaintext&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveA==&quot; }, { &quot;context&quot;: &quot;YW5vdGhlcnNhbXBsZWNvbnRleHQ=&quot;, &quot;plaintext&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveA==&quot; } ] type (string: &quot;aes256-gcm96&quot;) –This parameter is required when encryption key is expected to be created. When performing an upsert operation, the type of key to create. convergent_encryption (string: &quot;&quot;) – This parameter will only be used when a key is expected to be created. Whether to support convergent encryption. This is only supported when using a key with key derivation enabled and will require all requests to carry both a context and 96-bit (12-byte) for AES and ChaCha20 or 192-bit (24-byte) for XChaCha20 nonce. The given nonce will be used in place of a randomly generated nonce. As a result, when the same context and nonce are supplied, the same ciphertext is generated. It is very important when using this mode that you ensure that all nonces are unique for a given context. Failing to do so will severely impact the ciphertext's security. partial_failure_response_code (int: 400) Ordinarily, if a batch item fails to encrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a failed status code in this case. If all values fail an error code is still returned. Be warned that some failures (such as failure to decrypt) could be indicative of a security breach and should not be ignored.  warning NOTE: All plaintext data must be base64-encoded. The reason for this requirement is that OpenBao does not require that the plaintext is &quot;text&quot;. It could be a binary file such as a PDF or image. The easiest safe transport mechanism for this data as part of a JSON payload is to base64-encode it.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-5","content":" Fist, encode the plaintext with base64:  $ echo &quot;the quick brown fox&quot; | base64 dGhlIHF1aWNrIGJyb3duIGZveAo=   Use the base64-encoded plaintext in the payload:  { &quot;plaintext&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; }   danger OpenBao HTTP API imposes a maximum request size of 32MB to prevent a denial of service attack. This can be tuned per listener block in the OpenBao server configuration.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-13","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/encrypt/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-7","content":" { &quot;data&quot;: { &quot;ciphertext&quot;: &quot;vault:v1:XjsPWPjqPrBi1N2Ms2s1QM798YyFWnO4TR4lsFA=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Decrypt data​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#decrypt-data","content":" This endpoint decrypts the provided ciphertext using the named key.  Method\tPathPOST\t/transit/decrypt/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-11","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to decrypt against. This is specified as part of the URL. ciphertext (string: &lt;required&gt;) – Specifies the ciphertext to decrypt. associated_data (string: &quot;&quot;) - Specifies base64 encoded associated data (also known as additional data or AAD) to also be authenticated with AEAD ciphers (aes128-gcm96, aes256-gcm, chacha20-poly1305, andxchacha20-poly1305). context (string: &quot;&quot;) – Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled. nonce (string: &quot;&quot;) – Specifies a base64 encoded nonce value used during encryption. reference (string: &quot;&quot;) - A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input. Only valid on batch requests when using ‘batch_input’ below. batch_input (array&lt;object&gt;: nil) – Specifies a list of items to be decrypted in a single batch. When this parameter is set, if the parameters 'ciphertext' and 'context' are also set, they will be ignored. Any batch output will preserve the order of the batch input. Format for the input goes like this: [ { &quot;context&quot;: &quot;c2FtcGxlY29udGV4dA==&quot;, &quot;ciphertext&quot;: &quot;vault:v1:/DupSiSbX/ATkGmKAmhqD0tvukByrx6gmps7dVI=&quot; }, { &quot;context&quot;: &quot;YW5vdGhlcnNhbXBsZWNvbnRleHQ=&quot;, &quot;ciphertext&quot;: &quot;vault:v1:XjsPWPjqPrBi1N2Ms2s1QM798YyFWnO4TR4lsFA=&quot; } ] partial_failure_response_code (int: 400) Ordinarily, if a batch item fails to encrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a failed status code in this case. If all values fail an error code is still returned. Be warned that some failures (such as failure to decrypt) could be indicative of a security breach and should not be ignored.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-6","content":" { &quot;ciphertext&quot;: &quot;vault:v1:XjsPWPjqPrBi1N2Ms2s1QM798YyFWnO4TR4lsFA=&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-14","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/decrypt/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-8","content":" { &quot;data&quot;: { &quot;plaintext&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Rewrap data​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#rewrap-data","content":" This endpoint rewraps the provided ciphertext using the latest version of the named key. Because this never returns plaintext, it is possible to delegate this functionality to untrusted users or scripts.  Method\tPathPOST\t/transit/rewrap/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-12","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to re-encrypt against. This is specified as part of the URL. ciphertext (string: &lt;required&gt;) – Specifies the ciphertext to re-encrypt. context (string: &quot;&quot;) – Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled. key_version (int: 0) – Specifies the version of the key to use for the operation. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set. nonce (string: &quot;&quot;) – Specifies a base64 encoded nonce value used during encryption. reference (string: &quot;&quot;) - A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input. Only valid on batch requests when using ‘batch_input’ below. batch_input (array&lt;object&gt;: nil) – Specifies a list of items to be re-encrypted in a single batch. When this parameter is set, if the parameters 'ciphertext' and 'context' are also set, they will be ignored. Any batch output will preserve the order of the batch input. Format for the input goes like this: [ { &quot;context&quot;: &quot;c2FtcGxlY29udGV4dA==&quot;, &quot;ciphertext&quot;: &quot;vault:v1:/DupSiSbX/ATkGmKAmhqD0tvukByrx6gmps7dVI=&quot; }, { &quot;context&quot;: &quot;YW5vdGhlcnNhbXBsZWNvbnRleHQ=&quot;, &quot;ciphertext&quot;: &quot;vault:v1:XjsPWPjqPrBi1N2Ms2s1QM798YyFWnO4TR4lsFA=&quot; } ]   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-7","content":" { &quot;ciphertext&quot;: &quot;vault:v1:XjsPWPjqPrBi1N2Ms2s1QM798YyFWnO4TR4lsFA=&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-15","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/rewrap/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-9","content":" { &quot;data&quot;: { &quot;ciphertext&quot;: &quot;vault:v2:abcdefgh&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Generate data key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#generate-data-key","content":" This endpoint generates a new high-entropy key and the value encrypted with the named key. Optionally return the plaintext of the key as well. Whether plaintext is returned depends on the path; as a result, you can use OpenBao ACL policies to control whether a user is allowed to retrieve the plaintext value of a key. This is useful if you want an untrusted user or operation to generate keys that are then made available to trusted users.  Method\tPathPOST\t/transit/datakey/:type/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-13","content":" type (string: &lt;required&gt;) – Specifies the type of key to generate. Ifplaintext, the plaintext key will be returned along with the ciphertext. Ifwrapped, only the ciphertext value will be returned. This is specified as part of the URL. name (string: &lt;required&gt;) – Specifies the name of the encryption key to use to encrypt the datakey. This is specified as part of the URL. context (string: &quot;&quot;) – Specifies the key derivation context, provided as a base64-encoded string. This must be provided if derivation is enabled. nonce (string: &quot;&quot;) – Specifies a nonce value, provided as base64 encoded. The value must be exactly 96 bits (12 bytes) long and the user must ensure that for any given context (and thus, any given encryption key) this nonce value is never reused. bits (int: 256) – Specifies the number of bits in the desired key. Can be 128, 256, or 512.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-8","content":" { &quot;context&quot;: &quot;Ab3==&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-16","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/datakey/plaintext/my-key   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-10","content":" { &quot;data&quot;: { &quot;plaintext&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot;, &quot;ciphertext&quot;: &quot;vault:v1:abcdefgh&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Generate random bytes​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#generate-random-bytes","content":" This endpoint returns high-quality random bytes of the specified length.  Method\tPathPOST\t/transit/random(/:source)(/:bytes)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-14","content":" bytes (int: 32) – Specifies the number of bytes to return. This value can be specified either in the request body, or as a part of the URL. format (string: &quot;base64&quot;) – Specifies the output encoding. Valid options are hex or base64. source (string: &quot;platform&quot;) - Specifies the source of the requested bytes.platform, the default, sources bytes from the platform's entropy source.all mixes bytes from all available sources.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-9","content":" { &quot;format&quot;: &quot;hex&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-17","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/random/164   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-11","content":" { &quot;data&quot;: { &quot;random_bytes&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Hash data​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#hash-data","content":" This endpoint returns the cryptographic hash of given data using the specified algorithm.  Method\tPathPOST\t/transit/hash(/:algorithm)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-15","content":" algorithm (string: &quot;sha2-256&quot;) – Specifies the hash algorithm to use. This can also be specified as part of the URL. Currently-supported algorithms are: sha2-224sha2-256sha2-384sha2-512sha3-224sha3-256sha3-384sha3-512  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: sha3-224, sha3-256, sha3-384, andsha3-512.  input (string: &lt;required&gt;) – Specifies the base64 encoded input data. format (string: &quot;hex&quot;) – Specifies the output encoding. This can be eitherhex or base64.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-10","content":" { &quot;input&quot;: &quot;adba32==&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-18","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/hash/sha2-512   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-12","content":" { &quot;data&quot;: { &quot;sum&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Generate HMAC​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#generate-hmac","content":" This endpoint returns the digest of given data using the specified hash algorithm and the named key. The key can be of any type supported by transit, as each transit key version has an independent, random 256-bit HMAC secret key. If the key is of a type that supports rotation, the latest (current) version will be used.  Method\tPathPOST\t/transit/hmac/:name(/:algorithm)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-16","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to generate hmac against. This is specified as part of the URL. key_version (int: 0) – Specifies the version of the key to use for the operation. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set. algorithm (string: &quot;sha2-256&quot;) – Specifies the hash algorithm to use. This can also be specified as part of the URL. Currently-supported algorithms are: sha2-224sha2-256sha2-384sha2-512sha3-224sha3-256sha3-384sha3-512  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: sha3-224, sha3-256, sha3-384, andsha3-512.  input (string: &quot;&quot;) – Specifies the base64 encoded input data. One ofinput or batch_input must be supplied. reference (string: &quot;&quot;) - A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input. Only valid on batch requests when using ‘batch_input’ below. batch_input (array&lt;object&gt;: nil) – Specifies a list of items for processing. When this parameter is set, if the parameter 'input' is also set, it will be ignored. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input. If the input data value of an item is invalid, the corresponding item in the 'batch_results' will have the key 'error' with a value describing the error. The format for batch_input is: { &quot;batch_input&quot;: [ { &quot;input&quot;: &quot;adba32==&quot; }, { &quot;input&quot;: &quot;aGVsbG8gd29ybGQuCg==&quot; } ] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-19","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/hmac/my-key/sha2-512   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-11","content":" { &quot;input&quot;: &quot;adba32==&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-13","content":" { &quot;data&quot;: { &quot;hmac&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample payload with batch_input​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-with-batch_input","content":" { &quot;batch_input&quot;: [ { &quot;input&quot;: &quot;adba32==&quot; }, { &quot;input&quot;: &quot;adba32==&quot; }, {}, { &quot;input&quot;: &quot;&quot; } ] }   ","version":"Next","tagName":"h3"},{"title":"Sample response for batch_input​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-for-batch_input","content":" { &quot;data&quot;: { &quot;batch_results&quot;: [ { &quot;hmac&quot;: &quot;vault:v1:1jFhRYWHiddSKgEFyVRpX8ieX7UU+748NBwHKecXE3hnGBoAxrfgoD5U0yAvji7b5X6V1fP&quot; }, { &quot;hmac&quot;: &quot;vault:v1:1jFhRYWHiddSKgEFyVRpX8ieX7UU+748NBwHKecXE3hnGBoAxrfgoD5U0yAvji7b5X6V1fP&quot; }, { &quot;error&quot;: &quot;missing input for HMAC&quot; }, { &quot;hmac&quot;: &quot;vault:v1:/wsSP6iQ9ECO9RRkefKLXey9sDntzSjoiW0vBrWfUsYB0ISroyC6plUt/jN7gcOv9O+Ecow&quot; } ] } }   ","version":"Next","tagName":"h3"},{"title":"Sign data​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sign-data","content":" This endpoint returns the cryptographic signature of the given data using the named key and the specified hash algorithm. The key must be of a type that supports signing.  Method\tPathPOST\t/transit/sign/:name(/:hash_algorithm)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-17","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key to use for signing. This is specified as part of the URL. key_version (int: 0) – Specifies the version of the key to use for signing. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set. hash_algorithm (string: &quot;sha2-256&quot;) – Specifies the hash algorithm to use for supporting key types (notably, not including ed25519 which specifies its own hash algorithm). This can also be specified as part of the URL. Currently-supported algorithms are: sha1sha2-224sha2-256sha2-384sha2-512sha3-224sha3-256sha3-384sha3-512none  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: sha3-224, sha3-256, sha3-384, andsha3-512.  warning ** Warning:** sha1 should be considered a compromised algorithm and used only for legacy applications. Signing using SHA-1 can be blocked by operators by assigning the following policy corresponding to a named key:  path &quot;/transit/sign/:name/sha1&quot; { capabilities = [&quot;deny&quot;] }   warning Note: using hash_algorithm=none requires setting prehashed=trueand signature_algorithm=pkcs1v15. This generates a PKCSv1_5_NoOIDsignature rather than the PKCSv1_5_DERnull signature type usually created. See RFC 3447 Section 9.2.  input (string: &quot;&quot;) – Specifies the base64 encoded input data. One ofinput or batch_input must be supplied. reference (string: &quot;&quot;) - A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input. Only valid on batch requests when using ‘batch_input’ below. batch_input (array&lt;object&gt;: nil) – Specifies a list of items for processing. When this parameter is set, any supplied 'input' or 'context' parameters will be ignored. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input. If the input data value of an item is invalid, the corresponding item in the 'batch_results' will have the key 'error' with a value describing the error. The format for batch_input is: { &quot;batch_input&quot;: [ { &quot;input&quot;: &quot;adba32==&quot;, &quot;context&quot;: &quot;abcd&quot; }, { &quot;input&quot;: &quot;aGVsbG8gd29ybGQuCg==&quot;, &quot;context&quot;: &quot;efgh&quot; } ] } context (string: &quot;&quot;) - Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys. prehashed (bool: false) - Set to true when the input is already hashed. If the key type is rsa-2048, rsa-3072 or rsa-4096, then the algorithm used to hash the input should be indicated by the hash_algorithm parameter. Just as the value to sign should be the base64-encoded representation of the exact binary data you want signed, when set, input is expected to be base64-encoded binary hashed data, not hex-formatted. (As an example, on the command line, you could generate a suitable input via openssl dgst -sha256 -binary | base64.) signature_algorithm (string: &quot;pss&quot;) – When using a RSA key, specifies the RSA signature algorithm to use for signing. Supported signature types are: psspkcs1v15 marshaling_algorithm (string: &quot;asn1&quot;) – Specifies the way in which the signature should be marshaled. This currently only applies to ECDSA keys. Supported types are: asn1: The default, used by OpenSSL and X.509jws: The version used by JWS (and thus for JWTs). Selecting this will also change the output encoding to URL-safe Base64 encoding instead of standard Base64-encoding. salt_length (string: &quot;auto&quot;) – The salt length used to sign. This currently only applies to the RSA PSS signature scheme. Options are: auto: The default used by Golang (causing the salt to be as large as possible when signing)hash: Causes the salt length to equal the length of the hash used in the signatureAn integer between the minimum and the maximum permissible salt lengths for the given RSA key size.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-20","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/sign/my-key/sha2-512   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-12","content":" { &quot;input&quot;: &quot;adba32==&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-14","content":" { &quot;data&quot;: { &quot;signature&quot;: &quot;vault:v1:MEUCIQCyb869d7KWuA0hBM9b5NJrmWzMW3/pT+0XYCM9VmGR+QIgWWF6ufi4OS2xo1eS2V5IeJQfsi59qeMWtgX0LipxEHI=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample payload with batch_input​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-with-batch_input-1","content":" Given an ed25519 key with derived keys set, the context parameter is expected for each batch_input item, and the response will include the derived public key for each item.  { &quot;batch_input&quot;: [ { &quot;input&quot;: &quot;adba32==&quot;, &quot;context&quot;: &quot;efgh&quot; }, { &quot;input&quot;: &quot;adba32==&quot;, &quot;context&quot;: &quot;abcd&quot; }, {} ] }   ","version":"Next","tagName":"h3"},{"title":"Sample response for batch_input​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-for-batch_input-1","content":" { &quot;data&quot;: { &quot;batch_results&quot;: [ { &quot;signature&quot;: &quot;vault:v1:+R3cxAy6j4KriYzAyExU6p1glnyT/eLDSaUZO7gr8a8kgi/zSynNbOBSDJcGaAfLD1OF2hGupYBYTjmZMNoVAA==&quot;, &quot;publickey&quot;: &quot;2fQIaaem7+EhSGs3jUebAS/8qP2+sUrmxOmgqZIZc0c=&quot; }, { &quot;signature&quot;: &quot;vault:v1:3hBwA88lnuAVJqb5rCCEstzKYaBTeSdejk356BTCE/nKwySOhzQH3mWCvJZwbRptNGa7ia5ykosYYdJz+aIKDA==&quot;, &quot;publickey&quot;: &quot;goDXuePo7L9z6HOw+a54O4HeV189BLECK9nAUudwp4Y=&quot; }, { &quot;error&quot;: &quot;missing input&quot; } ] }, }   ","version":"Next","tagName":"h3"},{"title":"Verify signed data​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#verify-signed-data","content":" This endpoint returns whether the provided signature is valid for the given data.  Method\tPathPOST\t/transit/verify/:name(/:hash_algorithm)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-18","content":" name (string: &lt;required&gt;) – Specifies the name of the encryption key that was used to generate the signature or HMAC. hash_algorithm (string: &quot;sha2-256&quot;) – Specifies the hash algorithm to use. This can also be specified as part of the URL. Currently-supported algorithms are: sha1sha2-224sha2-256sha2-384sha2-512sha3-224sha3-256sha3-384sha3-512none  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: sha3-224, sha3-256, sha3-384, andsha3-512.  warning ** Warning:** sha1 should be considered a compromised algorithm. Signatures verified using the algorithm could be forgeries. Verification using SHA-1 can be blocked by operators by assigning the following policy corresponding to a named key:  path &quot;/transit/verify/:name/sha1&quot; { capabilities = [&quot;deny&quot;] }   warning Note: using hash_algorithm=none requires setting prehashed=trueand signature_algorithm=pkcs1v15. This verifies a PKCSv1_5_NoOIDsignature rather than the PKCSv1_5_DERnull signature type usually verified. See RFC 3447 Section 9.2.  input (string: &quot;&quot;) – Specifies the base64 encoded input data. One ofinput or batch_input must be supplied. signature (string: &quot;&quot;) – Specifies the signature output from the/transit/sign function. Either this must be supplied or hmac must be supplied. hmac (string: &quot;&quot;) – Specifies the signature output from the/transit/hmac function. Either this must be supplied or signature must be supplied. reference (string: &quot;&quot;) - A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input. Only valid on batch requests when using ‘batch_input’ below. batch_input (array&lt;object&gt;: nil) – Specifies a list of items for processing. When this parameter is set, any supplied 'input', 'hmac' or 'signature' parameters will be ignored. 'batch_input' items should contain an 'input' parameter and either an 'hmac' or 'signature' parameter. All items in the batch must consistently supply either 'hmac' or 'signature' parameters. It is an error for some items to supply 'hmac' while others supply 'signature'. Responses are returned in the 'batch_results' array component of the 'data' element of the response. Any batch output will preserve the order of the batch input. If the input data value of an item is invalid, the corresponding item in the 'batch_results' will have the key 'error' with a value describing the error. The format for batch_input is: { &quot;batch_input&quot;: [ { &quot;input&quot;: &quot;adba32==&quot;, &quot;hmac&quot;: &quot;vault:v1:1jFhRYWHiddSKgEFyVRpX8ieX7UU+748NBwHKecXE3hnGBoAxrfgoD5U0yAvji7b5X6V1fP&quot; }, { &quot;input&quot;: &quot;aGVsbG8gd29ybGQuCg==&quot;, &quot;hmac&quot;: &quot;vault:v1:/wsSP6iQ9ECO9RRkefKLXey9sDntzSjoiW0vBrWfUsYB0ISroyC6plUt/jN7gcOv9O+Ecow&quot; } ] } context (string: &quot;&quot;) - Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys. prehashed (bool: false) - Set to true when the input is already hashed. If the key type is rsa-2048, rsa-3072 or rsa-4096, then the algorithm used to hash the input should be indicated by the hash_algorithm parameter. signature_algorithm (string: &quot;pss&quot;) – When using a RSA key, specifies the RSA signature algorithm to use for signature verification. Supported signature types are: psspkcs1v15 marshaling_algorithm (string: &quot;asn1&quot;) – Specifies the way in which the signature was originally marshaled. This currently only applies to ECDSA keys. Supported types are: asn1: The default, used by OpenSSL and X.509jws: The version used by JWS (and thus for JWTs). Selecting this will also expect the input encoding to URL-safe Base64 encoding instead of standard Base64-encoding. salt_length (string: &quot;auto&quot;) – The salt length used to sign. This currently only applies to the RSA PSS signature scheme. Options are: auto: The default used by Golang (causing the salt to be as large as possible when signing)hash: Causes the salt length to equal the length of the hash used in the signatureAn integer between the minimum and the maximum permissible salt lengths for the given RSA key size.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-21","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/verify/my-key/sha2-512   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-13","content":" { &quot;input&quot;: &quot;abcd13==&quot;, &quot;signature&quot;: &quot;vault:v1:MEUCIQCyb869d7KWuA...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-15","content":" { &quot;data&quot;: { &quot;valid&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Sample payload with batch_input​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-with-batch_input-2","content":" { &quot;batch_input&quot;: [ { &quot;input&quot;: &quot;adba32==&quot;, &quot;context&quot;: &quot;abcd&quot;, &quot;signature&quot;: &quot;vault:v1:3hBwA88lnuAVJqb5rCCEstzKYaBTeSdejk356BTCE/nKwySOhzQH3mWCvJZwbRptNGa7ia5ykosYYdJz+aIKDA==&quot; }, { &quot;input&quot;: &quot;adba32==&quot;, &quot;context&quot;: &quot;efgh&quot;, &quot;signature&quot;: &quot;vault:v1:3hBwA88lnuAVJqb5rCCEstzKYaBTeSdejk356BTCE/nKwySOhzQH3mWCvJZwbRptNGa7ia5ykosYYdJz+aIKDA==&quot; }, { &quot;input&quot;: &quot;&quot;, &quot;context&quot;: &quot;abcd&quot;, &quot;signature&quot;: &quot;vault:v1:C/pxm5V1RI6kqudLdbLdj5Bpm2P38FKgvxoV69oNXphvJukRcQIqjZO793jCa2JPYPG21Y7vquDWy/Ff4Ma4AQ==&quot; } ] }   ","version":"Next","tagName":"h3"},{"title":"Sample response for batch_input​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-for-batch_input-2","content":" { &quot;data&quot;: { &quot;batch_results&quot;: [ { &quot;valid&quot;: true }, { &quot;valid&quot;: false }, { &quot;valid&quot;: true } ] }, }   ","version":"Next","tagName":"h3"},{"title":"Backup key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#backup-key","content":" This endpoint returns a plaintext backup of a named key. The backup contains all the configuration data and keys of all the versions along with the HMAC key. The response from this endpoint can be used with the /restore endpoint to restore the key.  Method\tPathGET\t/transit/backup/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-19","content":" name (string: &lt;required&gt;) - Name of the key.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-22","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/transit/backup/aes   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-16","content":" { &quot;data&quot;: { &quot;backup&quot;: &quot;eyJwb2xpY3kiOnsibmFtZSI6ImFlcyIsImtleXMiOnsiMSI6eyJrZXkiOiJXK3k4Z0dOMHdiTDJLOU95NXFPN1laMGtjdzMvR0ZiNWM4STBzdlNMMnFNPSIsImhtYWNfa2V5IjoiUDBTcjh1YTJaZERNUTdPd2h4RGp1Z0U5d0JSR3Q2QXl6K0t4TzN5Z2M5ST0iLCJ0aW1lIjoiMjAxNy0xMi0wOFQxMTo1MDowOC42MTM4MzctMDU6MDAiLCJlY194IjpudWxsLCJlY195IjpudWxsLCJlY19kIjpudWxsLCJyc2Ffa2V5IjpudWxsLCJwdWJsaWNfa2V5IjoiIiwiY3JlYXRpb25fdGltZSI6MTUxMjc1MTgwOH19LCJkZXJpdmVkIjpmYWxzZSwia2RmIjowLCJjb252ZXJnZW50X2VuY3J5cHRpb24iOmZhbHNlLCJleHBvcnRhYmxlIjpmYWxzZSwibWluX2RlY3J5cHRpb25fdmVyc2lvbiI6MSwibWluX2VuY3J5cHRpb25fdmVyc2lvbiI6MCwibGF0ZXN0X3ZlcnNpb24iOjEsImFyY2hpdmVfdmVyc2lvbiI6MSwiZGVsZXRpb25fYWxsb3dlZCI6ZmFsc2UsImNvbnZlcmdlbnRfdmVyc2lvbiI6MCwidHlwZSI6MCwiYmFja3VwX2luZm8iOnsidGltZSI6IjIwMTctMTItMDhUMTE6NTA6MjkuMjI4MTU3LTA1OjAwIiwidmVyc2lvbiI6MX0sInJlc3RvcmVfaW5mbyI6bnVsbH0sImFyY2hpdmVkX2tleXMiOnsia2V5cyI6W3sia2V5IjpudWxsLCJobWFjX2tleSI6bnVsbCwidGltZSI6IjAwMDEtMDEtMDFUMDA6MDA6MDBaIiwiZWNfeCI6bnVsbCwiZWNfeSI6bnVsbCwiZWNfZCI6bnVsbCwicnNhX2tleSI6bnVsbCwicHVibGljX2tleSI6IiIsImNyZWF0aW9uX3RpbWUiOjB9LHsia2V5IjoiVyt5OGdHTjB3YkwySzlPeTVxTzdZWjBrY3czL0dGYjVjOEkwc3ZTTDJxTT0iLCJobWFjX2tleSI6IlAwU3I4dWEyWmRETVE3T3doeERqdWdFOXdCUkd0NkF5eitLeE8zeWdjOUk9IiwidGltZSI6IjIwMTctMTItMDhUMTE6NTA6MDguNjEzODM3LTA1OjAwIiwiZWNfeCI6bnVsbCwiZWNfeSI6bnVsbCwiZWNfZCI6bnVsbCwicnNhX2tleSI6bnVsbCwicHVibGljX2tleSI6IiIsImNyZWF0aW9uX3RpbWUiOjE1MTI3NTE4MDh9XX19Cg==&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Restore key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#restore-key","content":" This endpoint restores the backup as a named key. This will restore the key configurations and all the versions of the named key along with HMAC keys. The input to this endpoint should be the output of /backup endpoint.  warning For safety, by default the backend will refuse to restore to an existing key. If you want to reuse a key name, it is recommended you delete the key before restoring. It is a good idea to attempt restoring to a different key name first to verify that the operation successfully completes.  Method\tPathPOST\t/transit/restore(/:name)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-20","content":" backup (string: &lt;required&gt;) - Backed up key data to be restored. This should be the output from the /backup endpoint. name (string: &lt;optional&gt;) - If set, this will be the name of the restored key. force (bool: false) - If set, force the restore to proceed even if a key by this name already exists.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-14","content":" { &quot;backup&quot;: &quot;eyJwb2xpY3kiOnsibmFtZSI6ImFlcyIsImtleXMiOnsiMSI6eyJrZXkiOiJXK3k4Z0dOMHdiTDJLOU95NXFPN1laMGtjdzMvR0ZiNWM4STBzdlNMMnFNPSIsImhtYWNfa2V5IjoiUDBTcjh1YTJaZERNUTdPd2h4RGp1Z0U5d0JSR3Q2QXl6K0t4TzN5Z2M5ST0iLCJ0aW1lIjoiMjAxNy0xMi0wOFQxMTo1MDowOC42MTM4MzctMDU6MDAiLCJlY194IjpudWxsLCJlY195IjpudWxsLCJlY19kIjpudWxsLCJyc2Ffa2V5IjpudWxsLCJwdWJsaWNfa2V5IjoiIiwiY3JlYXRpb25fdGltZSI6MTUxMjc1MTgwOH19LCJkZXJpdmVkIjpmYWxzZSwia2RmIjowLCJjb252ZXJnZW50X2VuY3J5cHRpb24iOmZhbHNlLCJleHBvcnRhYmxlIjpmYWxzZSwibWluX2RlY3J5cHRpb25fdmVyc2lvbiI6MSwibWluX2VuY3J5cHRpb25fdmVyc2lvbiI6MCwibGF0ZXN0X3ZlcnNpb24iOjEsImFyY2hpdmVfdmVyc2lvbiI6MSwiZGVsZXRpb25fYWxsb3dlZCI6ZmFsc2UsImNvbnZlcmdlbnRfdmVyc2lvbiI6MCwidHlwZSI6MCwiYmFja3VwX2luZm8iOnsidGltZSI6IjIwMTctMTItMDhUMTE6NTA6MjkuMjI4MTU3LTA1OjAwIiwidmVyc2lvbiI6MX0sInJlc3RvcmVfaW5mbyI6bnVsbH0sImFyY2hpdmVkX2tleXMiOnsia2V5cyI6W3sia2V5IjpudWxsLCJobWFjX2tleSI6bnVsbCwidGltZSI6IjAwMDEtMDEtMDFUMDA6MDA6MDBaIiwiZWNfeCI6bnVsbCwiZWNfeSI6bnVsbCwiZWNfZCI6bnVsbCwicnNhX2tleSI6bnVsbCwicHVibGljX2tleSI6IiIsImNyZWF0aW9uX3RpbWUiOjB9LHsia2V5IjoiVyt5OGdHTjB3YkwySzlPeTVxTzdZWjBrY3czL0dGYjVjOEkwc3ZTTDJxTT0iLCJobWFjX2tleSI6IlAwU3I4dWEyWmRETVE3T3doeERqdWdFOXdCUkd0NkF5eitLeE8zeWdjOUk9IiwidGltZSI6IjIwMTctMTItMDhUMTE6NTA6MDguNjEzODM3LTA1OjAwIiwiZWNfeCI6bnVsbCwiZWNfeSI6bnVsbCwiZWNfZCI6bnVsbCwicnNhX2tleSI6bnVsbCwicHVibGljX2tleSI6IiIsImNyZWF0aW9uX3RpbWUiOjE1MTI3NTE4MDh9XX19Cg==&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-23","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/restore   ","version":"Next","tagName":"h3"},{"title":"Trim key​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#trim-key","content":" This endpoint trims older key versions setting a minimum version for the keyring. Once trimmed, previous versions of the key cannot be recovered.  Method\tPathPOST\t/transit/keys/:name/trim  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-21","content":" min_available_version (int: &lt;required&gt;) - The minimum available version for the key ring. All versions before this version will be permanently deleted. This value can at most be equal to the lesser ofmin_decryption_version and min_encryption_version. This is not allowed to be set when either min_encryption_version or min_decryption_version is set to zero.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-15","content":" { &quot;min_available_version&quot;: 2 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-24","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/keys/my-key/trim   ","version":"Next","tagName":"h3"},{"title":"Configure cache​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#configure-cache","content":" This endpoint is used to configure the transit engine's cache. Note that configuration changes will not be applied until the transit plugin is reloaded which can be achieved using the [/sys/plugins/reload/backend][sys-plugin-reload-backend] endpoint.  Method\tPathPOST\t/transit/cache-config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#parameters-22","content":" size (int: 0) - Specifies the size in terms of number of entries. A size of0 means unlimited. A Least Recently Used (LRU) caching strategy is used for a non-zero cache size. Must be 0 (default) or a value greater or equal to 10 (minimum cache size).  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-payload-16","content":" { &quot;size&quot;: 456 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-25","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/transit/cache-config   ","version":"Next","tagName":"h3"},{"title":"Read transit cache configuration​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#read-transit-cache-configuration","content":" This endpoint retrieves configurations for the transit engine's cache.  Method\tPathGET\t/transit/cache-config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-request-26","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; --request GET \\ http://127.0.0.1:8200/v1/transit/cache-config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Transit secrets engine (API)","url":"/openbao/api-docs/secret/transit/#sample-response-17","content":"  &quot;data&quot;: { &quot;size&quot;: 0 },  ","version":"Next","tagName":"h3"},{"title":"/sys/capabilities-self","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/capabilities-self/","content":"","keywords":"","version":"Next"},{"title":"Query self capabilities​","type":1,"pageTitle":"/sys/capabilities-self","url":"/openbao/api-docs/system/capabilities-self/#query-self-capabilities","content":" This endpoint returns the capabilities of client token on the given paths. The client token is the OpenBao token with which this API call is made. Multiple paths are taken in at once and the capabilities of the token for each path is returned. For backwards compatibility, if a single path is supplied, acapabilities field will also be returned.  Method\tPathPOST\t/sys/capabilities-self  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/capabilities-self","url":"/openbao/api-docs/system/capabilities-self/#parameters","content":" paths (list: &lt;required&gt;) – Paths on which capabilities are being queried.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/capabilities-self","url":"/openbao/api-docs/system/capabilities-self/#sample-payload","content":" { &quot;paths&quot;: [&quot;secret/foo&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/capabilities-self","url":"/openbao/api-docs/system/capabilities-self/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/capabilities-self   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/capabilities-self","url":"/openbao/api-docs/system/capabilities-self/#sample-response","content":" { &quot;capabilities&quot;: [&quot;delete&quot;, &quot;list&quot;, &quot;read&quot;, &quot;update&quot;], &quot;secret/foo&quot;: [&quot;delete&quot;, &quot;list&quot;, &quot;read&quot;, &quot;update&quot;] }  ","version":"Next","tagName":"h3"},{"title":"/sys/capabilities","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/capabilities/","content":"","keywords":"","version":"Next"},{"title":"Query token capabilities​","type":1,"pageTitle":"/sys/capabilities","url":"/openbao/api-docs/system/capabilities/#query-token-capabilities","content":" This endpoint returns the list of capabilities of a given token on the given paths. Multiple paths are taken in at once and the capabilities of the token for each path is returned. For backwards compatibility, if a single path is supplied, a capabilities field will also be returned.  Method\tPathPOST\t/sys/capabilities  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/capabilities","url":"/openbao/api-docs/system/capabilities/#parameters","content":" paths (list: &lt;required&gt;) – Paths on which capabilities are being queried. token (string: &lt;required&gt;) – Token for which capabilities are being queried.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/capabilities","url":"/openbao/api-docs/system/capabilities/#sample-payload","content":" { &quot;token&quot;: &quot;abcd1234&quot;, &quot;paths&quot;: [&quot;secret/foo&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/capabilities","url":"/openbao/api-docs/system/capabilities/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/capabilities   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/capabilities","url":"/openbao/api-docs/system/capabilities/#sample-response","content":" { &quot;capabilities&quot;: [&quot;delete&quot;, &quot;list&quot;, &quot;read&quot;, &quot;update&quot;], &quot;secret/foo&quot;: [&quot;delete&quot;, &quot;list&quot;, &quot;read&quot;, &quot;update&quot;] }  ","version":"Next","tagName":"h3"},{"title":"/sys/config/cors","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/config-cors/","content":"","keywords":"","version":"Next"},{"title":"Read CORS settings​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#read-cors-settings","content":" This endpoint returns the current CORS configuration.  Method\tPathGET\t/sys/config/cors  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/config/cors   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#sample-response","content":" { &quot;enabled&quot;: true, &quot;allowed_origins&quot;: [&quot;http://www.example.com&quot;], &quot;allowed_headers&quot;: [ &quot;Content-Type&quot;, &quot;X-Requested-With&quot;, &quot;X-Vault-No-Request-Forwarding&quot;, &quot;X-Vault-Token&quot;, &quot;Authorization&quot;, &quot;X-Vault-Wrap-Format&quot;, &quot;X-Vault-Wrap-TTL&quot; ] }   ","version":"Next","tagName":"h3"},{"title":"Configure CORS settings​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#configure-cors-settings","content":" This endpoint allows configuring the origins that are permitted to make cross-origin requests, as well as headers that are allowed on cross-origin requests.  Method\tPathPOST\t/sys/config/cors  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#parameters","content":" allowed_origins (string or string array: &lt;required&gt;) – A wildcard (*), comma-delimited string, or array of strings specifying the origins that are permitted to make cross-origin requests. allowed_headers (string or string array: &quot;&quot; or []) – A comma-delimited string or array of strings specifying headers that are permitted to be on cross-origin requests. Headers set via this parameter will be appended to the list of headers that OpenBao allows by default.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#sample-payload","content":" { &quot;allowed_origins&quot;: &quot;*&quot;, &quot;allowed_headers&quot;: &quot;X-Custom-Header&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/config/cors   ","version":"Next","tagName":"h3"},{"title":"Delete CORS settings​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#delete-cors-settings","content":" This endpoint removes any CORS configuration.  Method\tPathDELETE\t/sys/config/cors  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/cors","url":"/openbao/api-docs/system/config-cors/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/config/cors  ","version":"Next","tagName":"h3"},{"title":"/sys/config/state","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/config-state/","content":"","keywords":"","version":"Next"},{"title":"Get sanitized configuration state​","type":1,"pageTitle":"/sys/config/state","url":"/openbao/api-docs/system/config-state/#get-sanitized-configuration-state","content":" This endpoint returns a sanitized version of the configuration state. The configuration excludes certain fields and mappings in the configuration file that can potentially contain sensitive information, which includes values fromStorage.Config, HAStorage.Config, Seals.Config and theTelemetry.CirconusAPIToken value.  Method\tPathGET\t/sys/config/state/sanitized  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/state","url":"/openbao/api-docs/system/config-state/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ 'http://127.0.0.1:8200/v1/sys/config/state/sanitized'   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/state","url":"/openbao/api-docs/system/config-state/#sample-response","content":" { &quot;api_addr&quot;: &quot;http://127.0.0.1:8200&quot;, &quot;cache_size&quot;: 0, &quot;cluster_addr&quot;: &quot;&quot;, &quot;cluster_cipher_suites&quot;: &quot;&quot;, &quot;cluster_name&quot;: &quot;&quot;, &quot;default_lease_ttl&quot;: 0, &quot;default_max_request_duration&quot;: 0, &quot;disable_cache&quot;: false, &quot;disable_clustering&quot;: false, &quot;disable_indexing&quot;: false, &quot;disable_mlock&quot;: false, &quot;disable_performance_standby&quot;: false, &quot;disable_printable_check&quot;: false, &quot;disable_sealwrap&quot;: false, &quot;enable_ui&quot;: true, &quot;listeners&quot;: [ { &quot;config&quot;: { &quot;address&quot;: &quot;127.0.0.1:8200&quot;, &quot;tls_disable&quot;: 1 }, &quot;type&quot;: &quot;tcp&quot; } ], &quot;log_format&quot;: &quot;&quot;, &quot;log_level&quot;: &quot;&quot;, &quot;max_lease_ttl&quot;: 0, &quot;pid_file&quot;: &quot;&quot;, &quot;plugin_directory&quot;: &quot;/opt/openbao/plugins&quot;, &quot;raw_storage_endpoint&quot;: false, &quot;seals&quot;: [ { &quot;disabled&quot;: false, &quot;type&quot;: &quot;shamir&quot; } ], &quot;storage&quot;: { &quot;cluster_addr&quot;: &quot;&quot;, &quot;disable_clustering&quot;: false, &quot;redirect_addr&quot;: &quot;http://127.0.0.1:8200&quot;, &quot;type&quot;: &quot;inmem&quot; } }  ","version":"Next","tagName":"h3"},{"title":"/sys/config/auditing","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/config-auditing/","content":"","keywords":"","version":"Next"},{"title":"Read all audited request headers​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#read-all-audited-request-headers","content":" This endpoint lists the request headers that are configured to be audited.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathGET\t/sys/config/auditing/request-headers  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/config/auditing/request-headers   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-response","content":" { &quot;headers&quot;: { &quot;X-Forwarded-For&quot;: { &quot;hmac&quot;: true } } }   ","version":"Next","tagName":"h3"},{"title":"Read single audit request header​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#read-single-audit-request-header","content":" This endpoint lists the information for the given request header.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathGET\t/sys/config/auditing/request-headers/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the request header to query. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/config/auditing/request-headers/my-header   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-response-1","content":" { &quot;X-Forwarded-For&quot;: { &quot;hmac&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Create/Update audit request header​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#createupdate-audit-request-header","content":" This endpoint enables auditing of a header.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathPOST\t/sys/config/auditing/request-headers/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#parameters-1","content":" hmac (bool: false) – Specifies if this header's value should be HMAC'ed in the audit logs.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-payload","content":" { &quot;hmac&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/config/auditing/request-headers/my-header   ","version":"Next","tagName":"h3"},{"title":"Delete audit request header​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#delete-audit-request-header","content":" This endpoint disables auditing of the given request header.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathDELETE\t/sys/config/auditing/request-headers/:name  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/auditing","url":"/openbao/api-docs/system/config-auditing/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/config/auditing/request-headers/my-header  ","version":"Next","tagName":"h3"},{"title":"/sys/decode-token","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/decode-token/","content":"","keywords":"","version":"Next"},{"title":"Parameters​","type":1,"pageTitle":"/sys/decode-token","url":"/openbao/api-docs/system/decode-token/#parameters","content":" encoded_token (string: &lt;required&gt;) – Specifies the encoded token (result from /sys/generate-root). otp (string: &lt;required&gt;) - Specifies the otp code for decode.  ","version":"Next","tagName":"h2"},{"title":"Sample response​","type":1,"pageTitle":"/sys/decode-token","url":"/openbao/api-docs/system/decode-token/#sample-response","content":" { &quot;request_id&quot;: &quot;9bc0fab8-d65c-3961-afe6-d05f50c5fd22&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;token&quot;: &quot;4RUmoevJ3lsLni9sTXcNnRE1&quot; }, &quot;warnings&quot;: null }  ","version":"Next","tagName":"h2"},{"title":"/sys/config/ui","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/config-ui/","content":"","keywords":"","version":"Next"},{"title":"Read UI settings​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#read-ui-settings","content":" This endpoint returns the given UI header configuration.  Method\tPathGET\t/sys/config/ui/headers/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#parameters","content":" name (string: &lt;required&gt;) – The name of the custom header. multivalue (bool: &lt;optional&gt;) - Returns multiple values if true.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/config/ui/headers/X-Custom-Header   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-response","content":" { &quot;value&quot;: &quot;custom-value&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request (Multi value)​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-request-multi-value","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/config/ui/headers/X-Custom-Header?multivalue=true   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-response-1","content":" { &quot;values&quot;: [&quot;custom-value-1&quot;, &quot;custom-value-2&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Configure UI headers​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#configure-ui-headers","content":" This endpoint allows configuring the values to be returned for the UI header.  Method\tPathPOST\t/sys/config/ui/headers/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#parameters-1","content":" name (string: &lt;required&gt;) – The name of the custom header. values (list: &lt;required&gt;) - The values to be returned from the header.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-payload","content":" { &quot;values&quot;: [&quot;custom value 1&quot;, &quot;custom value 2&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/config/ui/headers/X-Custom-Header   ","version":"Next","tagName":"h3"},{"title":"Delete a UI header​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#delete-a-ui-header","content":" This endpoint removes a UI header.  Method\tPathDELETE\t/sys/config/ui/headers/:name  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/config/ui/headers/X-Custom-Header   ","version":"Next","tagName":"h3"},{"title":"List UI headers​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#list-ui-headers","content":" This endpoint returns a list of configured UI headers.  Method\tPathLIST\t/sys/config/ui/headers  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/sys/config/ui/headers   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/config/ui","url":"/openbao/api-docs/system/config-ui/#sample-response-2","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;X-Custom...&quot;, &quot;X-Header...&quot;] } }  ","version":"Next","tagName":"h3"},{"title":"/sys/generate-root","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/generate-root/","content":"","keywords":"","version":"Next"},{"title":"Read root generation progress​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#read-root-generation-progress","content":" This endpoint reads the configuration and process of the current root generation attempt.  Method\tPathGET\t/sys/generate-root/attempt  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/generate-root/attempt   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-response","content":" { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;progress&quot;: 1, &quot;required&quot;: 3, &quot;encoded_token&quot;: &quot;&quot;, &quot;pgp_fingerprint&quot;: &quot;&quot;, &quot;otp_length&quot;: 24, &quot;complete&quot;: false }   If a root generation is started, progress is how many unseal keys have been provided for this generation attempt, where required must be reached to complete. The nonce for the current attempt and whether the attempt is complete is also displayed.  If a PGP key is being used to encrypt the final root token, its fingerprint will be returned.  If an OTP is being used to encode the final root token it will be returned only once, on the response to the start request.  The OTP is a base62 string, with length of otp_length. The raw bytes (char codes) of the token will be XOR'd with this value before being returned as a response to the final unseal key, encoded as base64.  ","version":"Next","tagName":"h3"},{"title":"Start root token generation​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#start-root-token-generation","content":" This endpoint initializes a new root generation attempt. Only a single root generation attempt can take place at a time.  Method\tPathPOST\t/sys/generate-root/attempt  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#parameters","content":" pgp_key (string: &lt;optional&gt;) – Specifies a base64-encoded PGP public key. The raw bytes of the token will be encrypted with this value before being returned to the final unseal key provider.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-request-1","content":" $ curl \\ --request POST \\ http://127.0.0.1:8200/v1/sys/generate-root/attempt   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-response-1","content":" { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;progress&quot;: 1, &quot;required&quot;: 3, &quot;encoded_token&quot;: &quot;&quot;, &quot;otp&quot;: &quot;2vPFYG8gUSW9npwzyvxXMug0&quot;, &quot;otp_length&quot;: 24, &quot;complete&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Cancel root generation​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#cancel-root-generation","content":" This endpoint cancels any in-progress root generation attempt. This clears any progress made. This must be called to change the OTP or PGP key being used.  Method\tPathDELETE\t/sys/generate-root/attempt  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-request-2","content":" $ curl \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/generate-root/attempt   ","version":"Next","tagName":"h3"},{"title":"Provide key share to generate root​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#provide-key-share-to-generate-root","content":" This endpoint is used to enter a single root key share to progress the root generation attempt. If the threshold number of root key shares is reached, OpenBao will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.  Method\tPathPOST\t/sys/generate-root/update  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#parameters-1","content":" key (string: &lt;required&gt;) – Specifies a single root key share. nonce (string: &lt;required&gt;) – Specifies the nonce of the attempt.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-payload","content":" { &quot;key&quot;: &quot;acbd1234&quot;, &quot;nonce&quot;: &quot;ad235&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-request-3","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/generate-root/update   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/generate-root","url":"/openbao/api-docs/system/generate-root/#sample-response-2","content":" This returns a JSON-encoded object indicating the attempt nonce, and completion status, and the encoded root token, if the attempt is complete.  { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;progress&quot;: 3, &quot;required&quot;: 3, &quot;pgp_fingerprint&quot;: &quot;&quot;, &quot;complete&quot;: true, &quot;encoded_token&quot;: &quot;FPzkNBvwNDeFh4SmGA8c+w==&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/generate-recovery-token","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/generate-recovery-token/","content":"","keywords":"","version":"Next"},{"title":"Read recovery token generation progress​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#read-recovery-token-generation-progress","content":" This endpoint reads the configuration and process of the current root generation attempt.  Method\tPathGET\t/sys/generate-recovery-token/attempt  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/generate-recovery-token/attempt   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-response","content":" { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;progress&quot;: 1, &quot;required&quot;: 3, &quot;encoded_token&quot;: &quot;&quot;, &quot;pgp_fingerprint&quot;: &quot;&quot;, &quot;otp_length&quot;: 24, &quot;complete&quot;: false }   If a recovery token generation is started, progress is how many unseal keys have been provided for this generation attempt, where required must be reached to complete. The nonce for the current attempt and whether the attempt is complete is also displayed.  If a PGP key is being used to encrypt the final root token, its fingerprint will be returned.  If an OTP is being used to encode the final root token it will be returned only once, on the response to the start request.  The OTP is a base62 string, with length of otp_length. The raw bytes (char codes) of the token will be XOR'd with this value before being returned as a response to the final unseal key, encoded as base64.  ","version":"Next","tagName":"h3"},{"title":"Start recovery token generation​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#start-recovery-token-generation","content":" This endpoint initializes a new recovery token generation attempt. Only a single recovery token generation attempt can take place at a time.  Method\tPathPOST\t/sys/generate-recovery-token/attempt  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#parameters","content":" pgp_key (string: &lt;optional&gt;) – Specifies a base64-encoded PGP public key. The raw bytes of the token will be encrypted with this value before being returned to the final unseal key provider.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-request-1","content":" $ curl \\ --request POST \\ http://127.0.0.1:8200/v1/sys/generate-recovery-token/attempt   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-response-1","content":" { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;progress&quot;: 1, &quot;required&quot;: 3, &quot;encoded_token&quot;: &quot;&quot;, &quot;otp&quot;: &quot;2vPFYG8gUSW9npwzyvxXMug0&quot;, &quot;otp_length&quot;: 24, &quot;complete&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Cancel recovery token generation​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#cancel-recovery-token-generation","content":" This endpoint cancels any in-progress recovery token generation attempt. This clears any progress made. This must be called to change the OTP or PGP key being used.  Method\tPathDELETE\t/sys/generate-recovery-token/attempt  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-request-2","content":" $ curl \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/generate-recovery-token/attempt   ","version":"Next","tagName":"h3"},{"title":"Provide key share to generate recovery token​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#provide-key-share-to-generate-recovery-token","content":" This endpoint is used to enter a single root key share to progress the recovery token generation attempt. If the threshold number of root key shares is reached, OpenBao will complete the recovery token generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.  Note that once a token has been issued, OpenBao is unsealed. The token lives only in memory and thus will only be valid until the next restart.  Method\tPathPOST\t/sys/generate-recovery-token/update  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#parameters-1","content":" key (string: &lt;required&gt;) – Specifies a single root key share. nonce (string: &lt;required&gt;) – Specifies the nonce of the attempt.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-payload","content":" { &quot;key&quot;: &quot;acbd1234&quot;, &quot;nonce&quot;: &quot;ad235&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-request-3","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/generate-recovery-token/update   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/generate-recovery-token","url":"/openbao/api-docs/system/generate-recovery-token/#sample-response-2","content":" This returns a JSON-encoded object indicating the attempt nonce, and completion status, and the encoded recovery token, if the attempt is complete.  { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;progress&quot;: 3, &quot;required&quot;: 3, &quot;pgp_fingerprint&quot;: &quot;&quot;, &quot;complete&quot;: true, &quot;encoded_token&quot;: &quot;FPzkNBvwNDeFh4SmGA8c+w==&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/experiments","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/experiments/","content":"","keywords":"","version":"Next"},{"title":"Read experiments​","type":1,"pageTitle":"/sys/experiments","url":"/openbao/api-docs/system/experiments/#read-experiments","content":" This endpoint returns the experiments available and enabled on the OpenBao node. Experiments are per-node and cannot be changed while the node is running. See the -experiment flag and theexperiments config key documentation for details on enabling experiments.  Method\tPathGET\t/sys/experiments  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/experiments","url":"/openbao/api-docs/system/experiments/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/experiments   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/experiments","url":"/openbao/api-docs/system/experiments/#sample-response","content":" { &quot;request_id&quot;: &quot;cb48b1e2-635c-52e9-db79-ad9a54ed3e88&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;available&quot;: [ &quot;events.alpha1&quot; ], &quot;enabled&quot;: [] }, &quot;warnings&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"/sys/ha-status","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/ha-status/","content":"","keywords":"","version":"Next"},{"title":"HA status​","type":1,"pageTitle":"/sys/ha-status","url":"/openbao/api-docs/system/ha-status/#ha-status","content":" This endpoint returns the HA status of the OpenBao cluster.  Method\tPathGET\t/sys/ha-status  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/ha-status","url":"/openbao/api-docs/system/ha-status/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/ha-status   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/ha-status","url":"/openbao/api-docs/system/ha-status/#sample-response","content":" { &quot;Nodes&quot;: [ { &quot;hostname&quot;: &quot;node1&quot;, &quot;api_address&quot;: &quot;http://10.0.0.2:8200&quot;, &quot;cluster_address&quot;: &quot;https://10.0.0.2:8201&quot;, &quot;active_node&quot;: true, &quot;last_echo&quot;: null, &quot;version&quot;: &quot;1.11.0&quot; }, { &quot;hostname&quot;: &quot;node2&quot;, &quot;api_address&quot;: &quot;http://10.0.0.3:8200&quot;, &quot;cluster_address&quot;: &quot;https://10.0.0.3:8201&quot;, &quot;active_node&quot;: false, &quot;last_echo&quot;: &quot;2021-11-29T10:29:09.202235-05:00&quot;, &quot;version&quot;: &quot;1.11.0&quot; }, { &quot;hostname&quot;: &quot;node3&quot;, &quot;api_address&quot;: &quot;http://10.0.0.4:8200&quot;, &quot;cluster_address&quot;: &quot;https://10.0.0.4:8201&quot;, &quot;active_node&quot;: false, &quot;last_echo&quot;: &quot;2021-11-29T10:29:07.402548-05:00&quot;, &quot;version&quot;: &quot;1.11.0&quot; } ] }  ","version":"Next","tagName":"h3"},{"title":"/sys/in-flight-req","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/in-flight-req/","content":"","keywords":"","version":"Next"},{"title":"Collect In-Flight request information​","type":1,"pageTitle":"/sys/in-flight-req","url":"/openbao/api-docs/system/in-flight-req/#collect-in-flight-request-information","content":" This endpoint returns the information about the in-flight requests.  Method\tPathGET\t/sys/in-flight-req  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/in-flight-req","url":"/openbao/api-docs/system/in-flight-req/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/in-flight-req   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/in-flight-req","url":"/openbao/api-docs/system/in-flight-req/#sample-response","content":" { &quot;9049326b-ceed-1033-c099-96c5cc97db1f&quot;: { &quot;start_time&quot;: &quot;2021-11-19T09:13:01.34157-08:00&quot;, &quot;client_remote_address&quot;: &quot;127.0.0.3:49816&quot;, &quot;request_path&quot;: &quot;/v1/sys/in-flight-req&quot;, &quot;request_method&quot;: &quot;GET&quot;, &quot;client_id&quot;: &quot;&quot;, } }  ","version":"Next","tagName":"h3"},{"title":"/sys/health","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/health/","content":"","keywords":"","version":"Next"},{"title":"Read health information​","type":1,"pageTitle":"/sys/health","url":"/openbao/api-docs/system/health/#read-health-information","content":" This endpoint returns the health status of OpenBao. This matches the semantics of a Consul HTTP health check and provides a simple way to monitor the health of a OpenBao instance.  Method\tPathHEAD\t/sys/health GET\t/sys/health  The default status codes are:  200 if initialized, unsealed, and active429 if unsealed and standby501 if not initialized503 if sealed  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/health","url":"/openbao/api-docs/system/health/#parameters","content":" standbyok (bool: false) – Specifies if being a standby should still return the active status code instead of the standby status code. This is useful when OpenBao is behind a non-configurable load balancer that just wants a 200-level response. activecode (int: 200) – Specifies the status code that should be returned for an active node. standbycode (int: 429) – Specifies the status code that should be returned for a standby node. sealedcode (int: 503) – Specifies the status code that should be returned for a sealed node. uninitcode (int: 501) – Specifies the status code that should be returned for a uninitialized node.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/health","url":"/openbao/api-docs/system/health/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/health   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/health","url":"/openbao/api-docs/system/health/#sample-response","content":" This response is only returned for a GET request.  { &quot;initialized&quot;: true, &quot;sealed&quot;: false, &quot;standby&quot;: false, &quot;performance_standby&quot;: false, &quot;replication_performance_mode&quot;: &quot;disabled&quot;, &quot;replication_dr_mode&quot;: &quot;disabled&quot;, &quot;server_time_utc&quot;: 1516639589, &quot;version&quot;: &quot;0.9.2&quot;, &quot;cluster_name&quot;: &quot;openbao-cluster-3bd69ca2&quot;, &quot;cluster_id&quot;: &quot;00af5aa8-c87d-b5fc-e82e-97cd8dfaf731&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request to customize the status code being returned​","type":1,"pageTitle":"/sys/health","url":"/openbao/api-docs/system/health/#sample-request-to-customize-the-status-code-being-returned","content":" $ curl -i https://127.0.0.1:8200/v1/sys/health\\?standbycode\\=200 HTTP/2 200 cache-control: no-store content-type: application/json strict-transport-security: max-age=31536000; includeSubDomains content-length: 364 date: Wed, 26 Jan 2022 09:21:13 GMT   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/health","url":"/openbao/api-docs/system/health/#sample-response-1","content":" This response is only returned for a GET request.  { &quot;initialized&quot;: true, &quot;sealed&quot;: false, &quot;standby&quot;: false, &quot;performance_standby&quot;: false, &quot;replication_performance_mode&quot;: &quot;disabled&quot;, &quot;replication_dr_mode&quot;: &quot;disabled&quot;, &quot;server_time_utc&quot;: 1706217694, &quot;version&quot;: &quot;1.14.8&quot;, &quot;cluster_name&quot;: &quot;openbao-cluster-6fc973c2&quot;, &quot;cluster_id&quot;: &quot;8190fce1-679e-3a57-7d1f-f63d4851633b&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/init","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/init/","content":"","keywords":"","version":"Next"},{"title":"Read initialization status​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#read-initialization-status","content":" This endpoint returns the initialization status of OpenBao.  Method\tPathGET\t/sys/init  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/init   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#sample-response","content":" { &quot;initialized&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Start initialization​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#start-initialization","content":" This endpoint initializes a new OpenBao. The OpenBao must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Auto Unseal.  Method\tPathPOST\t/sys/init  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#parameters","content":" pgp_keys (array&lt;string&gt;: nil) – Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares. root_token_pgp_key (string: &quot;&quot;) – Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation. secret_shares (int: &lt;required&gt;) – Specifies the number of shares to split the root key into. secret_threshold (int: &lt;required&gt;) – Specifies the number of shares required to reconstruct the root key. This must be less than or equalsecret_shares.  Additionally, the following options are only supported using Auto Unseal:  stored_shares (int: &lt;required&gt;) – Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as secret_shares. recovery_shares (int: 0) – Specifies the number of shares to split the recovery key into. This is only available when using Auto Unseal. recovery_threshold (int: 0) – Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal torecovery_shares. This is only available when using Auto Unseal. recovery_pgp_keys (array&lt;string&gt;: nil) – Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as recovery_shares. This is only available when using Auto Unseal.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#sample-payload","content":" { &quot;secret_shares&quot;: 10, &quot;secret_threshold&quot;: 5 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#sample-request-1","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/init   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/init","url":"/openbao/api-docs/system/init/#sample-response-1","content":" A JSON-encoded object including the (possibly encrypted, if pgp_keys was provided) root keys, base 64 encoded root keys and initial root token:  { &quot;keys&quot;: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], &quot;keys_base64&quot;: [&quot;cR9No5cBC&quot;, &quot;F3VLrkOo&quot;, &quot;zIDSZNGv&quot;], &quot;root_token&quot;: &quot;foo&quot; }   Warning: Please be reminded that recovery keys are used as an authentication flow for rekeying and regeneration of root credentials and cannot be used to unseal OpenBao in the case of the unavailability of the seal mechanism. Refer to the full warning in the documentation forAuto Unseal. ","version":"Next","tagName":"h3"},{"title":"/sys/host-info","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/host-info/","content":"","keywords":"","version":"Next"},{"title":"Collect host information​","type":1,"pageTitle":"/sys/host-info","url":"/openbao/api-docs/system/host-info/#collect-host-information","content":" This endpoint returns information about the host instance that the OpenBao server is running on. The data returned includes CPU information, CPU times, disk usage, host info, and memory statistics.  Method\tPathGET\t/sys/host-info  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/host-info","url":"/openbao/api-docs/system/host-info/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/host-info   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/host-info","url":"/openbao/api-docs/system/host-info/#sample-response","content":" { &quot;data&quot;: { &quot;cpu&quot;: [ { &quot;cpu&quot;: 0, &quot;vendorId&quot;: &quot;GenuineIntel&quot;, &quot;family&quot;: &quot;6&quot;, &quot;model&quot;: &quot;78&quot;, ... }, ... ], &quot;cpu_times&quot;: [ { &quot;cpu&quot;: &quot;cpu&quot;, &quot;user&quot;: 7491, &quot;system&quot;: 16833, &quot;idle&quot;: 5726276, ... }, ... ], &quot;disk&quot;: [ { &quot;path&quot;: &quot;/&quot;, &quot;fstype&quot;: &quot;ext4&quot;, &quot;total&quot;: 410352476160, &quot;free&quot;: 102141169664, &quot;used&quot;: 306428051456, ... }, ... ], &quot;host&quot;: { &quot;hostname&quot;: &quot;openbao-server-1&quot;, &quot;uptime&quot;: 28618, &quot;bootTime&quot;: 1570114491, &quot;procs&quot;: 439, ... }, &quot;memory&quot;: { &quot;total&quot;: 17179869184, &quot;available&quot;: 6203424768, &quot;used&quot;: 10976444416, ... }, &quot;timestamp&quot;: &quot;2019-10-03T22:51:49.715927Z&quot; } }  ","version":"Next","tagName":"h3"},{"title":"/sys/internal/inspect","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/inspect/","content":"","keywords":"","version":"Next"},{"title":"Supported inspection paths​","type":1,"pageTitle":"/sys/internal/inspect","url":"/openbao/api-docs/system/inspect/#supported-inspection-paths","content":" Router ","version":"Next","tagName":"h2"},{"title":"/sys/internal/specs/openapi","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/internal-specs-openapi/","content":"","keywords":"","version":"Next"},{"title":"Get OpenAPI document​","type":1,"pageTitle":"/sys/internal/specs/openapi","url":"/openbao/api-docs/system/internal-specs-openapi/#get-openapi-document","content":" This endpoint returns a single OpenAPI document describing all paths visible to the requester.  Method\tPathGET\t/sys/internal/specs/openapi  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/internal/specs/openapi","url":"/openbao/api-docs/system/internal-specs-openapi/#parameters","content":" generic_mount_paths (bool: false) – Used to specify whether to use generic mount paths. If set, the mount paths will be replaced with a dynamic parameter: {mountPath}  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/specs/openapi","url":"/openbao/api-docs/system/internal-specs-openapi/#sample-request","content":" $ curl http://127.0.0.1:8200/v1/sys/internal/specs/openapi?generic_mount_paths=false   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/specs/openapi","url":"/openbao/api-docs/system/internal-specs-openapi/#sample-response","content":" { &quot;openapi&quot;: &quot;3.0.2&quot;, &quot;info&quot;: { &quot;title&quot;: &quot;OpenBao API&quot;, &quot;description&quot;: &quot;HTTP API that gives you full access to OpenBao. All API routes are prefixed with `/v1/`.&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;license&quot;: { &quot;name&quot;: &quot;Mozilla Public License 2.0&quot;, &quot;url&quot;: &quot;https://www.mozilla.org/en-US/MPL/2.0&quot; } }, &quot;paths&quot;: { &quot;/auth/token/create&quot;: { &quot;description&quot;: &quot;The token create path is used to create new tokens.&quot;, &quot;post&quot;: { &quot;summary&quot;: &quot;The token create path is used to create new tokens.&quot;, &quot;tags&quot;: [ &quot;auth&quot; ], &quot;responses&quot;: { &quot;200&quot;: { &quot;description&quot;: &quot;OK&quot; } } } }, ...  ","version":"Next","tagName":"h3"},{"title":"/sys/internal/ui/feature-flags","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/internal-ui-feature/","content":"","keywords":"","version":"Next"},{"title":"Get enabled feature flags​","type":1,"pageTitle":"/sys/internal/ui/feature-flags","url":"/openbao/api-docs/system/internal-ui-feature/#get-enabled-feature-flags","content":" This endpoint lists the enabled feature flags relevant to the UI.  Method\tPathGET\t/sys/internal/ui/feature-flags  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/ui/feature-flags","url":"/openbao/api-docs/system/internal-ui-feature/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/internal/ui/feature-flags   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/ui/feature-flags","url":"/openbao/api-docs/system/internal-ui-feature/#sample-response","content":" { &quot;feature-flags&quot;: [] }  ","version":"Next","tagName":"h3"},{"title":"/sys/internal/inspect/router","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/inspect/router/","content":"","keywords":"","version":"Next"},{"title":"Root​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#root","content":" This endpoint returns a list of router entries in the router's root tree.  Method\tPathGET\t/sys/internal/inspect/router/root  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/internal/inspect/router/root   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-response","content":" { &quot;request_id&quot;: &quot;819de627-d3bc-27f4-0e3c-5c5fb0b204ee&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;root&quot;: [ { &quot;accessor&quot;: &quot;auth_token_d5fcf970&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;token/&quot;, &quot;mount_type&quot;: &quot;token&quot;, &quot;storage_prefix&quot;: &quot;sys/token/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;de61dd8c-a181-ccc2-457d-908e417d10b0&quot; }, { &quot;accessor&quot;: &quot;cubbyhole_58b6727b&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;cubbyhole/&quot;, &quot;mount_type&quot;: &quot;cubbyhole&quot;, &quot;storage_prefix&quot;: &quot;logical/496bc2e4-b641-2561-1829-f6557bf1fedc/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;496bc2e4-b641-2561-1829-f6557bf1fedc&quot; }, { &quot;accessor&quot;: &quot;identity_2ccfb6ab&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;identity/&quot;, &quot;mount_type&quot;: &quot;identity&quot;, &quot;storage_prefix&quot;: &quot;logical/b15e93e0-5bf1-07b0-86d3-563f9c77eef1/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;b15e93e0-5bf1-07b0-86d3-563f9c77eef1&quot; }, { &quot;accessor&quot;: &quot;system_0157e00a&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;sys/&quot;, &quot;mount_type&quot;: &quot;system&quot;, &quot;storage_prefix&quot;: &quot;sys/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;8ac2615e-8a73-fe66-52a6-a422f7e3273f&quot; } ] }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Mount UUID cache​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#mount-uuid-cache","content":" This endpoint returns a list of mount entries in the router's mount UUID cache.  Method\tPathGET\t/sys/internal/inspect/router/uuid  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/internal/inspect/router/uuid   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-response-1","content":" { &quot;request_id&quot;: &quot;71512d6c-bb77-2e05-c24e-07c964139fdb&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;uuid&quot;: [ { &quot;accessor&quot;: &quot;auth_token_d5fcf970&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;token/&quot;, &quot;mount_type&quot;: &quot;token&quot;, &quot;uuid&quot;: &quot;de61dd8c-a181-ccc2-457d-908e417d10b0&quot; }, { &quot;accessor&quot;: &quot;cubbyhole_58b6727b&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;cubbyhole/&quot;, &quot;mount_type&quot;: &quot;cubbyhole&quot;, &quot;uuid&quot;: &quot;496bc2e4-b641-2561-1829-f6557bf1fedc&quot; }, { &quot;accessor&quot;: &quot;system_0157e00a&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;sys/&quot;, &quot;mount_type&quot;: &quot;system&quot;, &quot;uuid&quot;: &quot;8ac2615e-8a73-fe66-52a6-a422f7e3273f&quot; }, { &quot;accessor&quot;: &quot;identity_2ccfb6ab&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;identity/&quot;, &quot;mount_type&quot;: &quot;identity&quot;, &quot;uuid&quot;: &quot;b15e93e0-5bf1-07b0-86d3-563f9c77eef1&quot; } ] }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Mount accessor cache​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#mount-accessor-cache","content":" This endpoint returns a list of mount entries in the router's mount accessor cache.  Method\tPathGET\t/sys/internal/inspect/router/accessor  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/internal/inspect/router/accessor   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-request-3","content":" { &quot;request_id&quot;: &quot;4b7de90d-75e0-978f-bc23-23c23b19a604&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;accessor&quot;: [ { &quot;accessor&quot;: &quot;auth_token_d5fcf970&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;token/&quot;, &quot;mount_type&quot;: &quot;token&quot;, &quot;uuid&quot;: &quot;de61dd8c-a181-ccc2-457d-908e417d10b0&quot; }, { &quot;accessor&quot;: &quot;cubbyhole_58b6727b&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;cubbyhole/&quot;, &quot;mount_type&quot;: &quot;cubbyhole&quot;, &quot;uuid&quot;: &quot;496bc2e4-b641-2561-1829-f6557bf1fedc&quot; }, { &quot;accessor&quot;: &quot;identity_2ccfb6ab&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;identity/&quot;, &quot;mount_type&quot;: &quot;identity&quot;, &quot;uuid&quot;: &quot;b15e93e0-5bf1-07b0-86d3-563f9c77eef1&quot; }, { &quot;accessor&quot;: &quot;system_0157e00a&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;sys/&quot;, &quot;mount_type&quot;: &quot;system&quot;, &quot;uuid&quot;: &quot;8ac2615e-8a73-fe66-52a6-a422f7e3273f&quot; } ] }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Storage prefix tree​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#storage-prefix-tree","content":" This endpoint returns a list of mount entries in the router's storage prefix tree.  Method\tPathGET\t/sys/internal/inspect/router/storage  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/internal/inspect/router/storage   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/inspect/router","url":"/openbao/api-docs/system/inspect/router/#sample-response-2","content":" { &quot;request_id&quot;: &quot;ff94bb22-3d4d-8199-6882-f0e4188e10bd&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;storage&quot;: [ { &quot;accessor&quot;: &quot;identity_2ccfb6ab&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;identity/&quot;, &quot;mount_type&quot;: &quot;identity&quot;, &quot;storage_prefix&quot;: &quot;logical/b15e93e0-5bf1-07b0-86d3-563f9c77eef1/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;b15e93e0-5bf1-07b0-86d3-563f9c77eef1&quot; }, { &quot;accessor&quot;: &quot;system_0157e00a&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;sys/&quot;, &quot;mount_type&quot;: &quot;system&quot;, &quot;storage_prefix&quot;: &quot;sys/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;8ac2615e-8a73-fe66-52a6-a422f7e3273f&quot; }, { &quot;accessor&quot;: &quot;auth_token_d5fcf970&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;token/&quot;, &quot;mount_type&quot;: &quot;token&quot;, &quot;storage_prefix&quot;: &quot;sys/token/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;de61dd8c-a181-ccc2-457d-908e417d10b0&quot; }, { &quot;accessor&quot;: &quot;cubbyhole_58b6727b&quot;, &quot;mount_namespace&quot;: &quot;&quot;, &quot;mount_path&quot;: &quot;cubbyhole/&quot;, &quot;mount_type&quot;: &quot;cubbyhole&quot;, &quot;storage_prefix&quot;: &quot;logical/496bc2e4-b641-2561-1829-f6557bf1fedc/&quot;, &quot;tainted&quot;: false, &quot;uuid&quot;: &quot;496bc2e4-b641-2561-1829-f6557bf1fedc&quot; } ] }, &quot;warnings&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"/sys/internal/ui/mounts","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/internal-ui-mounts/","content":"","keywords":"","version":"Next"},{"title":"Get available visible mounts​","type":1,"pageTitle":"/sys/internal/ui/mounts","url":"/openbao/api-docs/system/internal-ui-mounts/#get-available-visible-mounts","content":" This endpoint lists all enabled auth methods.  Method\tPathGET\t/sys/internal/ui/mounts  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/ui/mounts","url":"/openbao/api-docs/system/internal-ui-mounts/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/internal/ui/mounts   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/ui/mounts","url":"/openbao/api-docs/system/internal-ui-mounts/#sample-response","content":" { &quot;auth&quot;: { &quot;github/&quot;: { &quot;description&quot;: &quot;GitHub auth&quot;, &quot;type&quot;: &quot;github&quot; } }, &quot;secret&quot;: { &quot;custom-secrets/&quot;: { &quot;description&quot;: &quot;Custom secrets&quot;, &quot;options&quot;: { &quot;version&quot;: &quot;2&quot; }, &quot;type&quot;: &quot;kv&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Get single mount details​","type":1,"pageTitle":"/sys/internal/ui/mounts","url":"/openbao/api-docs/system/internal-ui-mounts/#get-single-mount-details","content":" This endpoint lists details for a specific mount path. This is an authenticated endpoint, and is currently only being used internally.  The calling token should not be granted permissions to these API endpoints directly, but instead rely on permissions granted to the individual mount path. This means that if you give a token a policy with capabilities on a :path(e.g. /secret/*), the token will be able to callsys/internal/ui/mounts/:path (e.g. sys/internal/ui/mounts/secret) without having to add that literal path to the policy document.  On certain mounts, it is possible to call an arbitrary path within the engine (for example, /sys/internal/ui/mounts/secret/path/to/secret when the mount path is /secret). If called in this manner, then this endpoint will return the data for the mount that hosts that path. Therefore, a call to/sys/internal/ui/mounts/secret/path/to/secret and a call to/sys/internal/ui/mounts/secret will yield an identical response.  Due to the nature of its intended usage, there is no guarantee on backwards compatibility for this endpoint.  Method\tPathGET\t/sys/internal/ui/mounts/:path  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/ui/mounts","url":"/openbao/api-docs/system/internal-ui-mounts/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/internal/ui/mounts/cubbyhole   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/ui/mounts","url":"/openbao/api-docs/system/internal-ui-mounts/#sample-response-1","content":" { &quot;accessor&quot;: &quot;cubbyhole_50fbe8d2&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0 }, &quot;description&quot;: &quot;per-token private secret storage&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: true, &quot;options&quot;: null, &quot;path&quot;: &quot;cubbyhole/&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;cubbyhole&quot;, &quot;uuid&quot;: &quot;4bb40403-d9ba-d2ee-087a-4c6d371db5f2&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/internal/ui/namespaces","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/internal-ui-namespaces/","content":"","keywords":"","version":"Next"},{"title":"Get namespaces​","type":1,"pageTitle":"/sys/internal/ui/namespaces","url":"/openbao/api-docs/system/internal-ui-namespaces/#get-namespaces","content":" This endpoint lists the namespaces relevant to the UI.  Method\tPathGET\t/sys/internal/ui/namespaces  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/ui/namespaces","url":"/openbao/api-docs/system/internal-ui-namespaces/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/internal/ui/namespaces   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/ui/namespaces","url":"/openbao/api-docs/system/internal-ui-namespaces/#sample-response","content":" { &quot;namespaces&quot;: [] }  ","version":"Next","tagName":"h3"},{"title":"PKI secrets engine (API)","type":0,"sectionRef":"#","url":"/openbao/api-docs/secret/pki/","content":"","keywords":"","version":"Next"},{"title":"Table of contents​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#table-of-contents","content":" Notice About New Multi-Issuer FunctionalityACME Certificate Issuance ACME DirectoriesGet ACME EAB Binding TokenList Unused ACME EAB Binding TokensDelete Unused ACME EAB Binding TokensGet ACME ConfigurationSet ACME Configuration Issuing Certificates List RolesRead RoleGenerate Certificate and KeySign CertificateSign IntermediateSign Self-IssuedSign VerbatimRevoke CertificateRevoke Certificate with Private KeyList Revoked CertificatesList Revocation RequestsList Cross-Cluster Revocations Accessing Authority Information List IssuersRead Issuer CertificateRead Default Issuer Certificate ChainRead Issuer CRLOCSP RequestList CertificatesRead Certificate Managing Keys and Issuers List IssuersList KeysGenerate KeyGenerate RootGenerate Intermediate CSRImport CA Certificates and KeysRead IssuerUpdate IssuerRevoke IssuerDelete IssuerImport KeyRead KeyUpdate KeyDelete KeyDelete All Issuers and Keys Managing Authority Information List RolesCreate/Update RoleRead RoleDelete RoleRead URLsSet URLsRead Issuers ConfigurationSet Issuers ConfigurationRead Keys ConfigurationSet Keys ConfigurationRead Cluster ConfigurationSet Cluster ConfigurationRead CRL ConfigurationSet CRL ConfigurationRotate CRLsRotate Delta CRLsCombining CRLs from the Same IssuerSign Revocation ListTidyRead Automatic Tidy ConfigurationSet Automatic Tidy ConfigurationTidy StatusCancel Tidy Cluster ScalabilityOpenBao CLI with DER/PEM responses  ","version":"Next","tagName":"h2"},{"title":"Notice about new Multi-Issuer functionality​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#notice-about-new-multi-issuer-functionality","content":" OpenBao allows a single PKI mount to have multiple Certificate Authority (CA) certificates (&quot;issuers&quot;) in a single mount, for the purpose of facilitating rotation. All issuers within a single mount are treated as a single Authority, meaning that:  Certificate Revocation List (CRL) configuration is common to all issuers,All authority access URLs are common to all issuers,Issued certificates' serial numbers will be unique across all issuers.  However, since each issuer may have a distinct subject and keys, different issuers may have different CRLs.  It is strongly encouraged to limit the scope of CAs within a mount and not to mix different types of CAs (roots and intermediates).  warning Note: Some functionality will not work if a default issuer is not configured. OpenBao automatically selects the default issuer from the current issuing certificate on migration from an older OpenBao version.  ","version":"Next","tagName":"h2"},{"title":"ACME certificate issuance​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#acme-certificate-issuance","content":" OpenBao supports the ACME certificate lifecycle management protocol for issuing and renewing leaf server certificates.  In order to use ACME, a cluster path must be set and ACME must be enabled in its configurationwith the required headers enabled on the mount tuning.  Using ACME with a role requires no_store=false to be set on the role; this allows the certificate to be stored and later fetched through the ACME protocol.  ","version":"Next","tagName":"h2"},{"title":"ACME directories​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#acme-directories","content":" OpenBao PKI supports the following ACME directories, providing different restrictions around usage (defaults, a specific issuer and/or a specific role). To interact with these directories, specify the directory URL in an ACME client. For example, with the EFF's CertBot:  $ certbot certonly --server https://localhost:8200/v1/pki/acme/directory ...   These endpoints are unauthenticated from an OpenBao authentication model, but internally authenticated via the ACME protocol.  Method\tPath\tDefault Directory Policy\tIssuer\tRoleACME\t/pki/acme/directory\tsign-verbatim\tdefault\tSign-Verbatim ACME\t/pki/acme/directory\trole:role_ref\tSpecified by the role\t:role_ref ACME\t/pki/issuer/:issuer_ref/acme/directory\tsign-verbatim\t:issuer_ref\tSign-Verbatim ACME\t/pki/issuer/:issuer_ref/acme/directory\trole:role_ref\t:issuer_ref\t:role_ref ACME\t/pki/roles/:role/acme/directory\t(any)\tSpecified by the role\t:role ACME\t/pki/issuer/:issuer_ref/roles/:role/acme/directory\t(any)\t:issuer_ref\t:role  When a role is not specified (for the first two directory URLs, or four lines in the table), behavior is specified by the default_directory_policy in theACME configuration. These directories can also be forbidden by setting that policy as forbid. If the policy is sign-verbatimthen any identifier for which the client can prove ownership of will be issued for. This is similar to using the Sign Verbatimendpoint, but with additional verification that the client has proven ownership (within the ACME protocol) of the requested certificate identifiers.  ACME challenge types​  OpenBao supports the following ACME challenge types presently:  http-01, supporting both dns and ip identifiers.dns-01, supporting dns identifiers including wildcards.tls-alpn-01, supporting only non-wildcard dns identifiers.  A custom DNS resolver used by the server for looking up DNS names for use with both mechanisms can be added via the ACME configuration.  ACME external account bindings​  ACME External Account Binding (EAB) Policy can enforce that clients need to have a valid external account binding to OpenBao. Before registering a new account, an authenticated OpenBao client will need to fetch a new EAB token. This returns two values: a key identifier and an HMAC key used by the ACME client to authenticate with EAB. For example:  $ openbao write -f /pki/acme/new-eab $ certbot certonly --server https://localhost:8200/v1/pki/acme/directory \\ --eab-kid &lt;id&gt; --eab-hmac-key &lt;hmac-key&gt;   With or without EAB, requests from the ACME client are not authenticated using traditional OpenBao authentication, but are instead authenticated through the ACME protocol. With EAB however, an OpenBao authenticated client will have to fetch an EAB token and pass it to the ACME client for use on the initial registration: this binds the ACME client's registration to an authenticated OpenBao endpoint, but not further to the client's entity or other information.  warning Note: Enabling EAB is strongly recommended for public-facing OpenBao deployments. Use of the VAULT_DISABLE_PUBLIC_ACME environment variable can be used to enforce all ACME instances have EAB enabled.  ACME required headers​  ACME requires the following response headers (allowed_response_headers) to be specified by mount tuning:  Replay-NonceLinkLocation  On an existing mount, these can be specified by running the following command:  $ openbao secrets tune -allowed-response-headers=Location -allowed-response-headers=Replay-Nonce \\ -allowed-response-headers=Link \\ pki/   ","version":"Next","tagName":"h3"},{"title":"Get ACME EAB binding token​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#get-acme-eab-binding-token","content":" This endpoint returns a new ACME binding token. The id response field can be used as the key identifier and the key response field be used as the EAB HMAC key in the ACME Client.  Each call to this endpoint will generate and return a new EAB binding token that is linked to the specific ACME directory it resides under. EAB tokens are not usable across different ACME directories.  Method\tPathPOST\t/pki/acme/new-eab POST\t/pki/issuer/:issuer_ref/acme/new-eab POST\t/pki/roles/:role/acme/new-eab POST\t/pki/issuer/:issuer_ref/roles/:role/acme/new-eab  Parameters​  No parameters.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/pki/acme/new-eab   Sample response​  { &quot;data&quot;: { &quot;created_on&quot;: &quot;2023-05-24T14:33:00-04:00&quot;, &quot;id&quot;: &quot;bc8088d9-3816-5177-ae8e-d8393265f7dd&quot;, &quot;key_type&quot;: &quot;hs&quot;, &quot;acme_directory&quot;: &quot;acme/directory&quot;, &quot;key&quot;: &quot;MHcCAQE... additional data elided ...&quot;, } }   ","version":"Next","tagName":"h3"},{"title":"List unused ACME EAB binding tokens​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-unused-acme-eab-binding-tokens","content":" This endpoint returns a list of all unused ACME binding tokens; once used, they will be removed from this list.  Method\tPathLIST\t/pki/eab  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/eab   Sample response​  { &quot;data&quot;: { &quot;key_info&quot;: { &quot;bc8088d9-3816-5177-ae8e-d8393265f7dd&quot;: { &quot;created_on&quot;: &quot;2023-05-24T14:33:00-04:00&quot;, &quot;key_type&quot;: &quot;hs&quot;, &quot;acme_directory&quot;: &quot;acme/directory&quot; } }, &quot;keys&quot;: [ &quot;bc8088d9-3816-5177-ae8e-d8393265f7dd&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Delete unused ACME EAB binding tokens​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#delete-unused-acme-eab-binding-tokens","content":" This endpoint allows the deletion of an unused ACME binding token.  Method\tPathDELETE\t/pki/eab/:key_id  Parameters​  key_id (string: &lt;required&gt;) - The id of the EAB binding token to delete. This is part of the request URL.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/pki/eab/bc8088d9-3816-5177-ae8e-d8393265f7dd   ","version":"Next","tagName":"h3"},{"title":"Get ACME configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#get-acme-configuration","content":" This endpoint allows reading of the current ACME server configuration used by this mount.  Method\tPathGET\t/pki/config/acme  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/acme   Sample response​  { &quot;data&quot;: { &quot;allowed_issuers&quot;: [ &quot;*&quot; ], &quot;allowed_roles&quot;: [ &quot;*&quot; ], &quot;default_directory_policy&quot;: &quot;sign-verbatim&quot;, &quot;dns_resolver&quot;: &quot;&quot;, &quot;eab_policy&quot;: &quot;not-required&quot;, &quot;enabled&quot;: true }, }   ","version":"Next","tagName":"h3"},{"title":"Set ACME configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-acme-configuration","content":" This endpoint allows setting the ACME server configuration used by this mount.  Method\tPathPOST\t/pki/config/acme  Parameters​  allowed_issuers (list: [&quot;*&quot;]) - Specifies a list issuers allowed to issue certificates via explicit ACME paths. If an allowed role specifies an issuer outside this list, it will be allowed. The default value *allows every issuer within the mount. allow_role_ext_key_usage (bool: false) - whether the ExtKeyUsage field from a role is used, defaults to false meaning that certificate will be signed with ServerAuth. allowed_roles (list: [&quot;*&quot;]) - Specifies a list of roles allowed to issue certificates via explicit ACME paths. The default value * allows every role within the mount to be used. If the default_directory_policyspecifies a role, it must be allowed under this configuration. default_directory_policy (string: &quot;sign-verbatim&quot;) - Specifies the behavior of the default ACME directory. Can be forbid, sign-verbatimor a role given by role:&lt;role_name&gt;. If a role is used, it must be present in allowed_roles. dns_resolver (string: &quot;&quot;) - An optional overriding DNS resolver to use for challenge verification lookups. When not specified, the default system resolver will be used. This allows domains on peered networks with an accessible DNS resolver to be validated. eab_policy (string: &quot;not-required&quot;) - Specified policy to enforce around External Account Bindings (EABs). The allowed values are: not-required, where EABs are not enforced but are validated if specified. new-account-required, where new accounts are required to have EAB but existing accounts can still be used. always-required, where all accounts regardless of age are required to have EABs set. enabled (bool: false) - Whether ACME is enabled on this mount. When ACME is disabled, all requests to ACME directory URLs will return 404.  Sample payload​  { &quot;enabled&quot;: true }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/acme   Sample response​  { &quot;data&quot;: { &quot;allowed_issuers&quot;: [ &quot;*&quot; ], &quot;allowed_roles&quot;: [ &quot;*&quot; ], &quot;default_directory_policy&quot;: &quot;sign-verbatim&quot;, &quot;dns_resolver&quot;: &quot;&quot;, &quot;eab_policy&quot;: &quot;not-required&quot;, &quot;enabled&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Issuing certificates​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#issuing-certificates","content":" The following API endpoints allow users or operators to request certificates and are all authenticated.  In general, for self-serve use, the /pki/sign/:name and /pki/issue/:nameare sufficient to allow most users to access for ACL purposes. The per-issuer variants (/pki/issuer/:issuer_ref/sign/:name and/pki/issuer/:issuer_ref/issue/:name) allow the requester to override the role's chosen issuer, potentially allowing users to request certificates issued by the wrong parent authority.  Some API endpoints included here are privileged and should only be accessed by trusted users or operators; these include the various sign-verbatim,sign-self-signed and sign-intermediate endpoints.  If an issued certificate has been compromised, it should be revoked. The OpenBao PKI secrets engine presently only allows revocation by serial number; because this could allow users to deny access to other users, it should be restricted to operators.  ","version":"Next","tagName":"h2"},{"title":"List roles​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-roles","content":" This endpoint returns a list of available roles. Only the role names are returned, not any values. It is useful to both operators and users.  Method\tPathLIST\t/pki/roles  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/roles   Sample response​  { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;dev&quot;, &quot;prod&quot;] }, &quot;lease_duration&quot;: 0, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-role","content":" This endpoint queries the role definition. It is useful to both operators and users.  Method\tPathGET\t/pki/roles/:name  Parameters​  name (string: &lt;required&gt;) - Specifies the name of the role to read. This is part of the request URL.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/roles/my-role   Sample response​  { &quot;data&quot;: { &quot;allow_any_name&quot;: false, &quot;allow_ip_sans&quot;: true, &quot;allow_localhost&quot;: true, &quot;allow_subdomains&quot;: false, &quot;allowed_domains&quot;: [&quot;example.com&quot;, &quot;foobar.com&quot;], &quot;allowed_uri_sans&quot;: [&quot;example.com&quot;, &quot;spiffe://*&quot;], &quot;allowed_other_sans&quot;: [ &quot;1.3.6.1.4.1.311.20.2.3;utf8:devops@example.com&quot;, &quot;1.3.6.1.4.1.311.20.2.4;UTF-8:*&quot; ], &quot;client_flag&quot;: true, &quot;code_signing_flag&quot;: false, &quot;key_bits&quot;: 2048, &quot;key_type&quot;: &quot;rsa&quot;, &quot;ttl&quot;: &quot;6h&quot;, &quot;max_ttl&quot;: &quot;12h&quot;, &quot;server_flag&quot;: true, ... additional fields elided ... } }     ","version":"Next","tagName":"h3"},{"title":"Generate certificate and key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#generate-certificate-and-key","content":" This endpoint generates a new set of credentials (private key and certificate) based on the role named in the endpoint. The issuing CA certificate and full CA chain is returned as well, so that only the root CA need be in a client's trust store. Choice of issuing CA is determined first by the role (when using the/pki/issue/:name path) and then by the path (when using the/pki/issuer/:issuer_ref/issue/name path).  It is suggested to limit access to the path-overridden issue endpoint (on/pki/issuer/:issuer_ref/issue/:name).  warning Note: The private key is not stored. If you do not save the private key from the response, you will need to request a new certificate.  Method\tPath\tIssuerPOST\t/pki/issue/:name\tRole selected POST\t/pki/issuer/:issuer_ref/issue/:name\tPath selected  Parameters​  name (string: &lt;required&gt;) - Specifies the name of the role to create the certificate against. This is part of the request URL. issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/issue/:name path and takes its value from the role's issuer_ref field.  common_name (string: &quot;&quot;) - Specifies the requested CN for the certificate. If the CN is allowed by role policy, it will be issued. If more than one common_name is desired, specify the alternative names in thealt_names list.  warning Note: A value for common_name is required when require_cn is set to true  alt_names (string: &quot;&quot;) - Specifies requested Subject Alternative Names, in a comma-delimited list. These can be host names or email addresses; they will be parsed into their respective fields. If any requested names do not match role policy, the entire request will be denied. ip_sans (string: &quot;&quot;) - Specifies requested IP Subject Alternative Names, in a comma-delimited list. Only valid if the role allows IP SANs (which is the default). uri_sans (string: &quot;&quot;) - Specifies the requested URI Subject Alternative Names, in a comma-delimited list. If any requested URIs do not match role policy, the entire request will be denied. other_sans (string: &quot;&quot;) - Specifies custom OID/UTF8-string SANs. These must match values specified on the role in allowed_other_sans (see role creation for allowed_other_sans globbing rules). The format is the same as OpenSSL: &lt;oid&gt;;&lt;type&gt;:&lt;value&gt; where the only current valid type is UTF8. This can be a comma-delimited list or a JSON string slice. ttl (string: &quot;&quot;) - Specifies requested Time To Live. Cannot be greater than the role's max_ttl value. If not provided, the role's ttl value will be used. Note that the role values default to system values if not explicitly set. See not_after as an alternative for setting an absolute end date (rather than a relative one). format (string: &quot;pem&quot;) - Specifies the format for returned data. Can bepem, der, or pem_bundle; defaults to pem. If der, the output is base64 encoded. If pem_bundle, the certificate field will contain the private key and certificate, concatenated; if the issuing CA is not a OpenBao-derived self-signed root, this will be included as well. private_key_format (string: &quot;der&quot;) - Specifies the format for marshaling the private key within the private_key response field. Defaults to der which will return either base64-encoded DER or PEM-encoded DER, depending on the value offormat. The other option is pkcs8 which will return the key marshalled as PEM-encoded PKCS8.  warning Note that this does not apply to the private key within the certificate field if format=pem_bundle parameter is specified.  exclude_cn_from_sans (bool: false) - If true, the given common_name will not be included in DNS or Email Subject Alternate Names (as appropriate). Useful if the CN is not a hostname or email address, but is instead some human-readable identifier. not_after (string) - Set the Not After field of the certificate with specified date value. The value format should be given in UTC formatYYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z. remove_roots_from_chain (bool: false) - If true, the returned ca_chainfield will not include any self-signed CA certificates. Useful if end-users already have the root CA in their trust store. user_ids (string: &quot;&quot;) - Specifies the comma-separated list of requested User ID (OID 0.9.2342.19200300.100.1.1) Subject values to be placed on the signed certificate. This field is validated against allowed_user_ids on the role.  Sample payload​  { &quot;common_name&quot;: &quot;www.example.com&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/issue/my-role   Sample response​  { &quot;lease_id&quot;: &quot;pki/issue/test/7ad6cfa5-f04f-c62a-d477-f33210475d05&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 21600, &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;issuing_ca&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot;, &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot; ], &quot;private_key&quot;: &quot;-----BEGIN RSA PRIVATE KEY-----\\nMIIEowIBAAKCAQEAnVHfwoKsUG1GDVyWB1AFroaKl2ImMBO8EnvGLRrmobIkQvh+\\n...\\nQN351pgTphi6nlCkGPzkDuwvtxSxiCWXQcaxrHAL7MiJpPzkIBq1\\n-----END RSA PRIVATE KEY-----\\n&quot;, &quot;private_key_type&quot;: &quot;rsa&quot;, &quot;serial_number&quot;: &quot;39:dd:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot; }, &quot;warnings&quot;: &quot;&quot;, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Sign certificate​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#sign-certificate","content":" This endpoint signs a new certificate based upon the provided CSR and the supplied parameters, subject to the restrictions contained in the role named in the endpoint. The issuing CA certificate and the full CA chain is returned as well, so that only the root CA need be in a client's trust store.  It is suggested to limit access to the path-overridden sign endpoint (on/pki/issuer/:issuer_ref/sign/:name).  Method\tPath\tIssuerPOST\t/pki/sign/:name\tRole selected POST\t/pki/issuer/:issuer_ref/sign/:name\tPath selected  Parameters​  name (string: &lt;required&gt;) - Specifies the name of the role to create the certificate against. This is part of the request URL. issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/sign/:name path and takes its value from the role's issuer_ref field.  csr (string: &lt;required&gt;) - Specifies the PEM-encoded CSR. common_name (string: &lt;required&gt;) - Specifies the requested CN for the certificate. If the CN is allowed by role policy, it will be issued. If more than one common_name is desired, specify the alternative names in the alt_names list. alt_names (string: &quot;&quot;) - Specifies the requested Subject Alternative Names, in a comma-delimited list. These can be host names or email addresses; they will be parsed into their respective fields. If any requested names do not match role policy, the entire request will be denied. other_sans (string: &quot;&quot;) - Specifies custom OID/UTF8-string SANs. These must match values specified on the role in allowed_other_sans (see role creation for allowed_other_sans globbing rules). The format is the same as OpenSSL: &lt;oid&gt;;&lt;type&gt;:&lt;value&gt; where the only current valid type is UTF8. This can be a comma-delimited list or a JSON string slice. ip_sans (string: &quot;&quot;) - Specifies the requested IP Subject Alternative Names, in a comma-delimited list. Only valid if the role allows IP SANs (which is the default). uri_sans (string: &quot;&quot;) - Specifies the requested URI Subject Alternative Names, in a comma-delimited list. If any requested URIs do not match role policy, the entire request will be denied. ttl (string: &quot;&quot;) - Specifies the requested Time To Live. Cannot be greater than the role's max_ttl value. If not provided, the role's ttl value will be used. Note that the role values default to system values if not explicitly set. See not_after as an alternative for setting an absolute end date (rather than a relative one). format (string: &quot;pem&quot;) - Specifies the format for returned data. Can bepem, der, or pem_bundle. If der, the output is base64 encoded. Ifpem_bundle, the certificate field will contain the certificate and, if the issuing CA is not an OpenBao-derived self-signed root, it will be concatenated with the certificate. exclude_cn_from_sans (bool: false) - If true, the given common_name will not be included in DNS or Email Subject Alternate Names (as appropriate). Useful if the CN is not a hostname or email address, but is instead some human-readable identifier. not_after (string) - Set the Not After field of the certificate with specified date value. The value format should be given in UTC formatYYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z. remove_roots_from_chain (bool: false) - If true, the returned ca_chainfield will not include any self-signed CA certificates. Useful if end-users already have the root CA in their trust store. user_ids (string: &quot;&quot;) - Specifies the comma-separated list of requested User ID (OID 0.9.2342.19200300.100.1.1) Subject values to be placed on the signed certificate. This field is validated against allowed_user_ids on the role.  Sample payload​  { &quot;csr&quot;: &quot;...&quot;, &quot;common_name&quot;: &quot;example.com&quot; }   Sample response​  { &quot;lease_id&quot;: &quot;pki/sign/test/7ad6cfa5-f04f-c62a-d477-f33210475d05&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 21600, &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;issuing_ca&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot;, &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot; ], &quot;serial_number&quot;: &quot;39:dd:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot; }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Sign intermediate​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#sign-intermediate","content":" This endpoint uses the configured CA certificate to issue a certificate with appropriate values for acting as an intermediate CA. Distribution points use the values set via config/urls. Values set in the CSR are ignored unlessuse_csr_values is set to true, in which case the values from the CSR are used verbatim.  This endpoint can be used both when signing an OpenBao-backed intermediate or when signing an externally-owned intermediate.  warning Note: This is a privileged endpoint, as callers are granted a new intermediate certificate, with which they can issue for arbitrary names. Access to this endpoint should be restricted by policy to only trusted operators.  Method\tPath\tIssuerPOST\t/pki/root/sign-intermediate\tdefault POST\t/pki/issuer/:issuer_ref/sign-intermediate\tSelected  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/root/sign-intermediatepath and takes the value default.  csr (string: &lt;required&gt;) - Specifies the PEM-encoded CSR to be signed. common_name (string: &lt;required&gt;) - Specifies the requested CN for the certificate. If more than one common_name is desired, specify the alternative names in the alt_names list. alt_names (string: &quot;&quot;) - Specifies the requested Subject Alternative Names, in a comma-delimited list. These can be host names or email addresses; they will be parsed into their respective fields. ip_sans (string: &quot;&quot;) - Specifies the requested IP Subject Alternative Names, in a comma-delimited list. uri_sans (string: &quot;&quot;) - Specifies the requested URI Subject Alternative Names, in a comma-delimited list. other_sans (string: &quot;&quot;) - Specifies custom OID/UTF8-string SANs. These must match values specified on the role in allowed_other_sans (see role creation for allowed_other_sans globbing rules). The format is the same as OpenSSL: &lt;oid&gt;;&lt;type&gt;:&lt;value&gt; where the only current valid type is UTF8. This can be a comma-delimited list or a JSON string slice. ttl (string: &quot;&quot;) - Specifies the requested Time To Live (after which the certificate will be expired). This cannot be larger than the engine's max (or, if not set, the system max). However, this can be after the expiration of the signing CA. See not_after as an alternative for setting an absolute end date (rather than a relative one). format (string: &quot;pem&quot;) - Specifies the format for returned data. Can bepem, der, or pem_bundle. If der, the output is base64 encoded. Ifpem_bundle, the certificate field will contain the certificate and, if the issuing CA is not an OpenBao-derived self-signed root, it will be concatenated with the certificate. max_path_length (int: -1) - Specifies the maximum path length to encode in the generated certificate. -1, means no limit, unless the signing certificate has a maximum path length set, in which case the path length is set to one less than that of the signing certificate. A limit of 0 means a literal path length of zero. exclude_cn_from_sans (bool: false) - If true, the given common_name will not be included in DNS or Email Subject Alternate Names (as appropriate). Useful if the CN is not a hostname or email address, but is instead some human-readable identifier. use_csr_values (bool: false) - If set to true, then: 1) Subject information, including names and alternate names, will be preserved from the CSR rather than using the values provided in the other parameters to this path; 2) Any key usages (for instance, non-repudiation) requested in the CSR will be added to the basic set of key usages used for CA certs signed by this path; 3) Extensions requested in the CSR will be copied into the issued certificate. permitted_dns_domains (string: &quot;&quot;) - A comma separated string (or, string array) containing DNS domains for which certificates are allowed to be issued or signed by this CA certificate. Supports subdomains via a . in front of the domain, as per RFC 5280 Section 4.2.1.10 - Name Constraints ou (string: &quot;&quot;) - Specifies the OU (OrganizationalUnit) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. organization (string: &quot;&quot;) - Specifies the O (Organization) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. country (string: &quot;&quot;) - Specifies the C (Country) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. locality (string: &quot;&quot;) - Specifies the L (Locality) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. province (string: &quot;&quot;) - Specifies the ST (Province) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. street_address (string: &quot;&quot;) - Specifies the Street Address values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. postal_code (string: &quot;&quot;) - Specifies the Postal Code values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. serial_number (string: &quot;&quot;) - - Specifies the requested Subject's namedSerial Numbervalue, if any. If you want more than one, specify alternative names in thealt_names map using OID 2.5.4.5. Note that this has no impact on the Certificate's serial number field, which OpenBao randomly generates. not_before_duration (duration: &quot;30s&quot;) - Specifies the duration by which to backdate the NotBefore property. This value has no impact in the validity period of the requested certificate, specified in the ttl field. Uses duration format strings. not_after (string) - Set the Not After field of the certificate with specified date value. The value format should be given in UTC formatYYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z. signature_bits (int: 0) - Specifies the number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on issuer's key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).  warning Note: ECDSA and Ed25519 issuers do not follow configuration of thesignature_bits value; only RSA issuers will change signature types based on this parameter.  skid (string: &quot;&quot;) - Value for the Subject Key Identifier field (RFC 5280 Section 4.2.1.2). Specified as a string in hex format. Default is empty, allowing OpenBao to automatically calculate the SKID according to method one in the above RFC section.  warning Note: This value should ONLY be used when cross-signing to mimic the existing certificate's SKID value; this is necessary to allow certain TLS implementations (such as OpenSSL) which use SKID/AKID matches in chain building to restrict possible valid chains.  use_pss (bool: false) - Specifies whether or not to use PSS signatures over PKCS#1v1.5 signatures when a RSA-type issuer is used. Ignored for ECDSA/Ed25519 issuers. key_usage (list: [&quot;KeyAgreement&quot;, &quot;KeyEncipherment&quot;]) - Specifies the default key usage constraint on the issued certificate. Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage - simply drop the KeyUsage part of the value. Values are not case-sensitive.  ~&gt; Note: previous versions of this document incorrectly called this a constraint; this value is only used as a default when the KeyUsage extension is missing from the CSR.  ext_key_usage (list: []) - Specifies the default extended key usage constraint on the issued certificate. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage - simply drop the ExtKeyUsage part of the value. Values are not case-sensitive. To specify no key default usage constraints, set this to an empty list.  ~&gt; Note: previous versions of this document incorrectly called this a constraint; this value is only used as a default when the ExtendedKeyUsage extension is missing from the CSR.  ext_key_usage_oids (string: &quot;&quot;) - A comma-separated string or list of extended key usage oids.  ~&gt; Note: This value is only used as a default when the ExtendedKeyUsageextension is missing from the CSR.  Sample payload​  { &quot;csr&quot;: &quot;...&quot;, &quot;common_name&quot;: &quot;example.com&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/root/sign-intermediate   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;issuing_ca&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot;, &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot; ], &quot;serial_number&quot;: &quot;39:dd:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot; }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Sign Self-Issued​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#sign-self-issued","content":" This endpoint uses the configured CA certificate to sign a self-issued certificate (which will usually be a self-signed certificate as well).  warning This is an extremely privileged endpoint. The given certificate will be signed as-is with only minimal validation performed (is it a CA cert, and is it actually self-issued). The only values that will be changed will be the authority key ID, the issuer DN, and, if set, any distribution points. It is recommended to limit this endpoint to only trusted operators.  This is generally only needed for root certificate rolling in cases where you don't want/can't get access to a CSR (such as if it's a root stored in OpenBao where the key is not exposed). If you don't know whether you need this endpoint, you most likely should be using a different endpoint (such assign-intermediate).  Method\tPath\tIssuer\tRequires sudo capabilityPOST\t/pki/root/sign-self-issued\tdefault\tyes POST\t/pki/issuer/:issuer_ref/sign-self-issued\tSelected\tno  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/root/sign-self-issuedpath and takes the value default.  certificate (string: &lt;required&gt;) - Specifies the PEM-encoded self-issued certificate. require_matching_certificate_algorithms (bool: false) - If true, requires that the public key algorithm of the CA match that of the submitted certificate.  Sample payload​  { &quot;certificate&quot;: &quot;...&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/root/sign-self-issued   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;issuing_ca&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot; }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Sign verbatim​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#sign-verbatim","content":" This endpoint signs a new certificate based upon the provided CSR. Values are taken verbatim from the CSR; the only restriction is that this endpoint will refuse to issue an intermediate CA certificate (see the/pki/root/sign-intermediate endpoint for that functionality.)  This is a potentially dangerous endpoint and only highly trusted users should have access.  Method\tPath\tIssuerPOST\t/pki/sign-verbatim(/:name)\tdefault POST\t/pki/issuer/:issuer_ref/sign-verbatim(/:name)\tSelected  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/root/sign-self-issuedpath and takes the value default.  name (string: &quot;&quot;) - Specifies a role. If set, the following parameters from the role will have effect: ttl, max_ttl, generate_lease, no_store and not_before_duration. csr (string: &lt;required&gt;) - Specifies the PEM-encoded CSR. key_usage (list: [&quot;DigitalSignature&quot;, &quot;KeyAgreement&quot;, &quot;KeyEncipherment&quot;]) - Specifies the default key usage constraint on the issued certificate. Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage - simply drop the KeyUsage part of the value. Values are not case-sensitive. To specify no default key usage constraints, set this to an empty list.  warning Note: previous versions of this document incorrectly called this a constraint; this value is only used as a default when the KeyUsage extension is missing from the CSR.  ext_key_usage (list: []) - Specifies the default extended key usage constraint on the issued certificate. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage - simply drop the ExtKeyUsage part of the value. Values are not case-sensitive. To specify no key default usage constraints, set this to an empty list.  warning Note: previous versions of this document incorrectly called this a constraint; this value is only used as a default when the ExtendedKeyUsage extension is missing from the CSR.  ext_key_usage_oids (string: &quot;&quot;) - A comma-separated string or list of extended key usage oids.  warning Note: This value is only used as a default when the ExtendedKeyUsageextension is missing from the CSR.  ttl (string: &quot;&quot;) - Specifies the requested Time To Live. Cannot be greater than the engine's max_ttl value. If not provided, the engine's ttl value will be used, which defaults to system values if not explicitly set. Seenot_after as an alternative for setting an absolute end date (rather than a relative one). format (string: &quot;pem&quot;) - Specifies the format for returned data. Can bepem, der, or pem_bundle. If der, the output is base64 encoded. Ifpem_bundle, the certificate field will contain the certificate and, if the issuing CA is not an OpenBao-derived self-signed root, it will be concatenated with the certificate. not_after (string) - Set the Not After field of the certificate with specified date value. The value format should be given in UTC formatYYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z. signature_bits (int: 0) - Specifies the number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on issuer's key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).  warning Note: ECDSA and Ed25519 issuers do not follow configuration of thesignature_bits value; only RSA issuers will change signature types based on this parameter.  use_pss (bool: false) - Specifies whether or not to use PSS signatures over PKCS#1v1.5 signatures when a RSA-type issuer is used. Ignored for ECDSA/Ed25519 issuers. remove_roots_from_chain (bool: false) - If true, the returned ca_chainfield will not include any self-signed CA certificates. Useful if end-users already have the root CA in their trust store. user_ids (string: &quot;&quot;) - Specifies the comma-separated list of requested User ID (OID 0.9.2342.19200300.100.1.1) Subject values to be placed on the signed certificate. No validation on names is performed using this endpoint.  Sample payload​  { &quot;csr&quot;: &quot;...&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/sign-verbatim   Sample response​  { &quot;lease_id&quot;: &quot;pki/sign-verbatim/7ad6cfa5-f04f-c62a-d477-f33210475d05&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 21600, &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;issuing_ca&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot;, &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDUTCCAjmgAwIBAgIJAKM+z4MSfw2mMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\\n...\\nG/7g4koczXLoUM3OQXd5Aq2cs4SS1vODrYmgbioFsQ3eDHd1fg==\\n-----END CERTIFICATE-----\\n&quot; ], &quot;serial_number&quot;: &quot;39:dd:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot; }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Revoke certificate​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#revoke-certificate","content":" This endpoint revokes a certificate using its serial number. This is an alternative option to the standard method of revoking using OpenBao lease IDs. A successful revocation will rotate the CRL.  warning Note: This operation is privileged as it allows revocation of arbitrary certificates based purely on their serial number. It does not validate that the requesting user issued the certificate or has possession of the private key. It is not possible to revoke issuers using this path.  Method\tPathPOST\t/pki/revoke  Parameters​  warning Note: either serial_number or certificate (but not both) must be specified on requests to this endpoint.  serial_number (string: &lt;optional&gt;) - Specifies the serial number of the certificate to revoke, in hyphen-separated or colon-separated hexadecimal. certificate (string: &lt;optional&gt;) - Specifies the certificate to revoke, in PEM format. This certificate must have been signed by one of the issuers in this mount in order to be accepted for revocation.  Sample payload​  { &quot;serial_number&quot;: &quot;39:dd:2e...&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/revoke   Sample response​  { &quot;data&quot;: { &quot;revocation_time&quot;: 1433269787 } }   ","version":"Next","tagName":"h3"},{"title":"Revoke certificate with private key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#revoke-certificate-with-private-key","content":" This endpoint revokes a certificate using its private key as proof that the request is authorized by an appropriate individual (Proof of Possession).  This is an alternative option to the standard method of revoking using OpenBao lease IDs or revocation via serial number. A successful revocation will rotate the CRL.  It is not possible to revoke issuers using this path.  warning Note: This operation is NOT privileged, as it validates revocation has a private key corresponding to a certificate signed by OpenBao. However, to avoid third parties performing a denial-of-service (DOS) against OpenBao, we've made this endpoint authenticated. Thus it is strongly encouraged to generally allow all access to this path via ACLs.  Method\tPathPOST\t/pki/revoke-with-key  Parameters​  warning Note: either serial_number or certificate (but not both) must be specified on requests to this endpoint.  serial_number (string: &lt;optional&gt;) - Specifies the serial number of the certificate to revoke, in hyphen-separated or colon-separated hexadecimal. certificate (string: &lt;optional&gt;) - Specifies the certificate to revoke, in PEM format. This certificate must have been signed by one of the issuers in this mount in order to be accepted for revocation. private_key (string: &lt;required&gt;) - Specifies the private key (in PEM format) corresponding to the certificate issued by OpenBao that is attempted to be revoked. This endpoint must be called several times (with each unique certificate/serial number) if this private key is used in multiple certificates as OpenBao does not maintain such a mapping.  Sample payload​  { &quot;serial_number&quot;: &quot;39:dd:2e...&quot;, &quot;private_key&quot;: &quot;-----BEGIN PRIVATE KEY-----\\n...&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/revoke-with-key   Sample response​  { &quot;data&quot;: { &quot;revocation_time&quot;: 1433269787 } }   ","version":"Next","tagName":"h3"},{"title":"List revoked certificates​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-revoked-certificates","content":" This endpoint returns a list of serial numbers that have been revoked on the local cluster.  Method\tPathLIST\t/certs/revoked  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/certs/revoked   Sample response​  { &quot;data&quot;: { &quot;keys&quot;: [ &quot;3d:80:91:c3:c2:34:3b:81:69:3d:92:a3:80:69:db:53:04:26:ab:b4&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"List revocation requests​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-revocation-requests","content":" This endpoint returns a list of serial numbers that have been requested to be revoked on any cluster, along with information about the request's state and which cluster it originated on.  Method\tPathLIST\t/certs/revocation-queue  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/certs/revocation-queue   Sample response​  { &quot;data&quot;: { &quot;key_info&quot;: { &quot;3d:80:91:c3:c2:34:3b:81:69:3d:92:a3:80:69:db:53:04:26:ab:b4&quot;: { &quot;requesting_cluster&quot;: &quot;48327b28-8325-6d79-6a0b-4cbaa6f27b4a&quot; } }, &quot;keys&quot;: [ &quot;3d:80:91:c3:c2:34:3b:81:69:3d:92:a3:80:69:db:53:04:26:ab:b4&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Accessing authority information​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#accessing-authority-information","content":" All consumers of the PKI Secrets Engine mount point will have access to the following unauthenticated APIs, useful for reading information about the certificate authority in this mount point.  This includes information about CA certificates,their chains, and their signed CRLs, containing an encoded list of revoked certificates previously issued by this authority. Individual issued certificates can also be read, assuming their serial number is known. Finally, the list of issuing certificates is public information in this mount.  ","version":"Next","tagName":"h2"},{"title":"List issuers​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-issuers","content":" This endpoint returns a list of issuers currently provisioned in this mount. The response includes both the issuer's identifier as well as the name chosen by the operators; either can be used to refer to the issuer later.  This endpoint is unauthenticated.  Method\tPathLIST\t/pki/issuers  Sample request​  $ curl \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/issuers   Sample response​  { &quot;data&quot;: { &quot;key_info&quot;: { &quot;1ae8ce9d-2f70-0761-a465-8c9840a247a2&quot;: { &quot;issuer_name&quot;: &quot;imported-root&quot; }, &quot;3dc79a5a-7a6c-70e2-1123-94b88557ba12&quot;: { &quot;issuer_name&quot;: &quot;root-x1&quot; } }, &quot;keys&quot;: [ &quot;1ae8ce9d-2f70-0761-a465-8c9840a247a2&quot;, &quot;3dc79a5a-7a6c-70e2-1123-94b88557ba12&quot; ] } }     ","version":"Next","tagName":"h3"},{"title":"Read issuer certificate​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-issuer-certificate","content":" This endpoint retrieves the specified issuer's certificate.  Note that the response differs between the older /pki/cert/capath and the newer /pki/issuer/:issuer_ref/json path; the latter includes the full ca_chain of the issuer, removing the need for a separate endpoint.  These are unauthenticated endpoints.  warning Note: this endpoint accepts the If-Modified-Since header, to respond with 304 Not Modified when the requested resource has not changed. This header needs to be allowed on the PKI mount by tuning the passthrough_request_headersoption. In order for clients to know the last modified time, the response header Last-Modified needs to be added to the mount tunableallowed_response_headers.  Method\tPath\tIssuer\tFormatGET\t/pki/cert/ca\tdefault\tJSON GET\t/pki/ca\tdefault\tDER [1] GET\t/pki/ca/pem\tdefault\tPEM [1] GET\t/pki/issuer/:issuer_ref/json\tSelected\tJSON GET\t/pki/issuer/:issuer_ref/der\tSelected\tDER [1] GET\t/pki/issuer/:issuer_ref/pem\tSelected\tPEM [1]  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/cert/ca and/pki/ca(/pem)? paths and takes the implicit value default.  Sample request​  $ curl \\ http://127.0.0.1:8200/v1/pki/issuer/root-x1/json   Sample response​  { &quot;data&quot;: { &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;-----BEGIN CERTIFICATE-----\\nMIIDFTCCAf2gAwIBAgIUUo/qwLm5AyqUWqFHw1MlgwUtS/kwDQYJKoZIhvcNAQEL\\n...&quot; ], &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nnMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL...&quot;, &quot;revocation_time&quot;: 0 } }     ","version":"Next","tagName":"h3"},{"title":"Read default issuer certificate chain​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-default-issuer-certificate-chain","content":" This endpoint retrieves the default issuer's CA certificate chain, including the default issuer.  To read other issuers' chains, use the/pki/issuer/:issuer_ref/json endpoint instead.  These are unauthenticated endpoints.  Method\tPath\tIssuer\tFormatGET\t/pki/ca_chain\tdefault\tPEM [1] GET\t/pki/cert/ca_chain\tdefault\tJSON  warning Note: These endpoints return the full chain (including the default issuer's certificate and all parent issuers known to OpenBao) in these responses.  Sample request​  $ curl \\ http://127.0.0.1:8200/v1/pki/ca_chain   Sample response​  &lt;PEM-encoded certificate chain&gt;     ","version":"Next","tagName":"h3"},{"title":"Read issuer CRL​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-issuer-crl","content":" This endpoint retrieves the specified issuer's CRL.  Note that the response differs between the older /pki/cert/crl path and the newer /pki/issuer/:issuer_ref/crl path; the latter correctly places the PEM-encoded CRL in the crl field whereas the former incorrectly places it in the certificate field.  Endpoints with type complete are full CRLs containing all revoked certificates (as of the time of generation. Endpoints with type deltacontain incremental CRLs on top of the last complete CRL, with any new certificates that have been revoked. See the revocation configuration section for more information about these options. The delta CRL clears when the next complete CRL is rebuilt. Consumers of delta CRLs will need to update their client to support fetching the corresponding full CRL when it has been regenerated; otherwise, some serial numbers may not appear in the local copy of the full CRL if the remote complete and delta CRLs has been regenerated.  Endpoints with source local only include cluster-local revocations.  These are unauthenticated endpoints.  warning Note: These endpoints now serve a version 2 CRL response.  warning Note: this endpoint accepts the If-Modified-Since header, to respond with 304 Not Modified when the requested resource has not changed. This header needs to be allowed on the PKI mount by tuning the passthrough_request_headersoption. In order for clients to know the last modified time, the response header Last-Modified needs to be added to the mount tunableallowed_response_headers.  Method\tPath\tIssuer\tFormat\tType\tSourceGET\t/pki/cert/crl\tdefault\tJSON\tComplete\tLocal GET\t/pki/crl\tdefault\tDER [1]\tComplete\tLocal GET\t/pki/crl/pem\tdefault\tPEM [1]\tComplete\tLocal GET\t/pki/cert/delta-crl\tdefault\tJSON\tDelta\tLocal GET\t/pki/crl/delta\tdefault\tDER [1]\tDelta\tLocal GET\t/pki/crl/delta/pem\tdefault\tPEM [1]\tDelta\tLocal GET\t/pki/issuer/:issuer_ref/crl\tSelected\tJSON\tComplete\tLocal GET\t/pki/issuer/:issuer_ref/crl/der\tSelected\tDER [1]\tComplete\tLocal GET\t/pki/issuer/:issuer_ref/crl/pem\tSelected\tPEM [1]\tComplete\tLocal GET\t/pki/issuer/:issuer_ref/crl/delta\tSelected\tJSON\tDelta\tLocal GET\t/pki/issuer/:issuer_ref/crl/delta/der\tSelected\tDER [1]\tDelta\tLocal GET\t/pki/issuer/:issuer_ref/crl/delta/pem\tSelected\tPEM [1]\tDelta\tLocal  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  warning Note: This parameter is not present on the /pki/cert/crl and/pki/crl(/pem)? paths and takes the implicit value default.  Sample request​  $ curl \\ http://127.0.0.1:8200/v1/pki/issuer/root-x1/crl   Sample response​  { &quot;data&quot;: { &quot;crl&quot;: &quot;-----BEGIN X509 CRL-----\\nMIIBizB1AgEBMA0GCSqGSIb3DQEBCwUAMBIxEDAOBgNVBAMTB3Jvb3QgeDEXDTIy\\n...&quot; } }   ","version":"Next","tagName":"h3"},{"title":"OCSP request​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#ocsp-request","content":" This endpoint retrieves an OCSP response (revocation status) for a given serial number. The request/response formats are based on RFC 6960  Endpoints with source local only include cluster-local revocations.  At this time there are certain limitations of the OCSP implementation at this path:  Only a single serial number within the request will appear in the response,None of the extensions defined in the RFC are supported for requests or responses,Ed25519 backed CA's are not supported for OCSP requests,Note that this API will not work with the OpenBao client as both request and responses are DER encoded, andNote that KMS based issuers which require PSS support are not supported either (such as PKCS#11 HSMs or GCP in certain scenarios).  These are unauthenticated endpoints.  Method\tPath\tResponse Format\tSourceGET\t/pki/ocsp/&lt;base 64+URL encoded ocsp DER request&gt;\tDER [1]\tLocal POST\t/pki/ocsp\tDER [1]\tLocal  Parameters​  None  Sample request​  openssl ocsp -no_nonce -issuer issuer.pem -CAfile ca_chain.pem -cert cert-to-revoke.pem -text -url $OPENBAO_ADDR/v1/pki/ocsp   ","version":"Next","tagName":"h3"},{"title":"List certificates​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-certificates","content":" This endpoint returns a list of the current certificates by serial number only. The response does not include the special serial numbers(ca, ca_chain, and crl) that can be used with /pki/cert/:serial.  This includes only certificates issued by this mount with no_store=false. While root generation does create entries here, importing certificates (including both roots and intermediates) will not cause the imported certificate's serial number to appear in this list.  warning Note: The endpoint to list all certificates is authenticated. This is to prevent automated enumeration of issued certificates for internal services; however, this information should generally be considered non-sensitive and the certificates themselves are exposed without authentication (provided their serial number is known). Many Public CAs participate in the Certificate Transparency initiative, where all issued certificates are publicly disclosed in the interest of third-party verification of CA integrity.  Method\tPathLIST\t/pki/certs  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/certs   Sample response​  { &quot;data&quot;: { &quot;keys&quot;: [ &quot;17:67:16:b0:b9:45:58:c0:3a:29:e3:cb:d6:98:33:7a:a6:3b:66:c1&quot;, &quot;26:0f:76:93:73:cb:3f:a0:7a:ff:97:85:42:48:3a:aa:e5:96:03:21&quot; ] } }     ","version":"Next","tagName":"h3"},{"title":"Read certificate​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-certificate","content":" This endpoint retrieves the certificate specified by its serial number, including issued certificates.  These are unauthenticated endpoints.  Method\tPath\tFormatGET\t/pki/cert/:serial\tJSON GET\t/pki/cert/:serial/raw\tDER [1] GET\t/pki/cert/:serial/raw/pem\tPEM [1]  Parameters​  serial (string: &lt;required&gt;) - Specifies the serial of the key to read. This is part of the request URL. Valid values for serial are:    &lt;serial&gt; for the certificate with the given serial number, in hyphen-separated or colon-separated hexadecimal.ca for the default issuer's CA certificatecrl for the default issuer's CRLca_chain for the default issuer's CA trust chain.  warning Note: These endpoints return the full chain (including this certificate and all parent issuers known to OpenBao) in the ca_chain response, for both the certificate and newer ca_chainfields.  Sample request​  $ curl \\ http://127.0.0.1:8200/v1/pki/cert/67:b4:f7:2c:aa:ef:b9:30:f6:ae:f5:12:21:79:ac:08:8a:86:89:72   Sample response​  { &quot;data&quot;: { &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIGmDCCBYCgAwIBAgIHBzEB3fTzhTANBgkqhkiG9w0BAQsFADCBjDELMAkGA1UE\\n...&quot;, &quot;revocation_time&quot;: 1667400107, &quot;revocation_time_rfc3339&quot;: &quot;2022-11-02T14:41:47.327515Z&quot;, &quot;issuer_id&quot;: &quot;e27bf456-51e1-d937-0001-4a609184fd9b&quot; } }     ","version":"Next","tagName":"h3"},{"title":"Managing keys and issuers​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#managing-keys-and-issuers","content":" The following endpoints are highly privileged and allow operators to generate or import new issuer certificates and keys, remove existing keys and issuers, or read internal information about keys and issuers.  ","version":"Next","tagName":"h2"},{"title":"List issuers​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-issuers-1","content":" Refer to the earlier section for more information about listing issuers.  ","version":"Next","tagName":"h3"},{"title":"List keys​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-keys","content":" This endpoint returns a list of keys currently provisioned in this mount. The response includes both the key's identifier as well as the name chosen by the operators; either can be used to refer to the key later.  This endpoint is authenticated.  Method\tPathLIST\t/pki/keys  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/pki/keys   Sample response​  { &quot;data&quot;: { &quot;key_info&quot;: { &quot;f9244f54-adc7-4a5c-6b08-6ca3a3325620&quot;: { &quot;key_name&quot;: &quot;imported-root-key&quot; }, }, &quot;keys&quot;: [ &quot;f9244f54-adc7-4a5c-6b08-6ca3a3325620&quot;, ] } }   ","version":"Next","tagName":"h3"},{"title":"Generate key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#generate-key","content":" This endpoint generates a new private key for use in the PKI mount. This key can be used with either the root or intermediateendpoints, using the type=existing variant.  If the path ends with exported, the private key will be returned in the response; if it is internal the private key will not be returned and cannot be retrieved later.  Method\tPathPOST\t/pki/keys/generate/:type  Parameters​  type (string: &lt;required&gt;) - Specifies the type of the key to create. If exported, the private key will be returned in the response; ifinternal the private key will not be returned and cannot be retrieved later. key_name (string: &quot;&quot;) - When a new key is created with this request, optionally specifies the name for this. The global ref default may not be used as a name. key_type (string: &quot;rsa&quot;) - Specifies the desired key type; must be rsa, ed25519or ec.  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: ed25519.  key_bits (int: 0) - Specifies the number of bits to use for the generated keys. Allowed values are 0 (universal default); withkey_type=rsa, allowed values are: 2048 (default), 3072, or 4096; with key_type=ec, allowed values are: 224, 256 (default), 384, or 521; ignored with key_type=ed25519.  Sample payload​  { &quot;key_type&quot;: &quot;ec&quot;, &quot;key_bits&quot;: &quot;256&quot;, &quot;key_name&quot;: &quot;root-key-2022&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/keys/generate/internal   Sample response​  { &quot;request_id&quot;: &quot;8ad22b2f-7d14-f2cd-a10a-d1abc33676ab&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;key_id&quot;: &quot;adda2443-a8aa-d181-9d07-07c7be6a76ab&quot;, &quot;key_name&quot;: &quot;root-key-2022&quot;, &quot;key_type&quot;: &quot;ec&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Generate root​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#generate-root","content":" This endpoint generates a new self-signed CA certificate and private key. If the path ends with exported, the private key will be returned in the response; if it is internal the private key will not be returned and cannot be retrieved later; if it is existing, the key specified by key_ref will be reused for this root.  This generated root will sign its own CRL. Authority Access distribution points use the values set via config/urls.  warning Note: The PKI Secrets Engine supports multiple issuers under a single mount. Use the management operations in this section to listand modify issuers within this mount. No issuers will be overridden by calling this operation. Deleting individual keys and issuers should be preferred to calling DELETE /pki/root, which deletes everything.  Method\tPathPOST\t/pki/root/generate/:type POST\t/pki/issuers/generate/root/:type POST\t/pki/root/rotate/:type  Parameters​  type (string: &lt;required&gt;) - Specifies the type of the root to create. If exported, the private key will be returned in the response; ifinternal the private key will not be returned and cannot be retrieved later; if existing, we use the value of the key_ref parameter to find existing key material to create the CSR. This parameter is part of the request URL. issuer_name (string: &quot;&quot;) - Provides a name to the specified issuer. The name must be unique across all issuers and not be the reserved valuedefault. When no value is supplied and the path is /pki/root/rotate/:type, the default value of &quot;next&quot; will be used. key_name (string: &quot;&quot;) - When a new key is created with this request, optionally specifies the name for this. The global ref default may not be used as a name. key_ref (string: &quot;default&quot;) - Specifies the key (either default, by name, or by identifier) to use for generating this request. Only suitable for type=existing requests. common_name (string: &lt;required&gt;) - Specifies the requested CN for the certificate. If more than one common_name is desired, specify the alternative names in the alt_names list. alt_names (string: &quot;&quot;) - Specifies the requested Subject Alternative Names, in a comma-delimited list. These can be host names or email addresses; they will be parsed into their respective fields. ip_sans (string: &quot;&quot;) - Specifies the requested IP Subject Alternative Names, in a comma-delimited list. uri_sans (string: &quot;&quot;) - Specifies the requested URI Subject Alternative Names, in a comma-delimited list. other_sans (string: &quot;&quot;) - Specifies custom OID/UTF8-string SANs. These must match values specified on the role in allowed_other_sans (see role creation for allowed_other_sans globbing rules). The format is the same as OpenSSL: &lt;oid&gt;;&lt;type&gt;:&lt;value&gt; where the only current valid type is UTF8. This can be a comma-delimited list or a JSON string slice. ttl (string: &quot;&quot;) - Specifies the requested Time To Live (after which the certificate will be expired). This cannot be larger than the engine's max (or, if not set, the system max). See not_after as an alternative for setting an absolute end date (rather than a relative one). format (string: &quot;pem&quot;) - Specifies the format for returned data. Can bepem, der, or pem_bundle. If der, the output is base64 encoded. Ifpem_bundle, the certificate field will contain the private key (if exported) and certificate, concatenated; if the issuing CA is not a OpenBao-derived self-signed root, this will be included as well. private_key_format (string: &quot;der&quot;) - Specifies the format for marshaling the private key within the private_key response field. Defaults to der which will return either base64-encoded DER or PEM-encoded DER, depending on the value offormat. The other option is pkcs8 which will return the key marshalled as PEM-encoded PKCS8.  warning Note that this does not apply to the private key within the certificate field if format=pem_bundle parameter is specified.  key_type (string: &quot;rsa&quot;) - Specifies the desired key type; must be rsa, ed25519or ec.  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: ed25519.  key_bits (int: 0) - Specifies the number of bits to use for the generated keys. Allowed values are 0 (universal default); withkey_type=rsa, allowed values are: 2048 (default), 3072, or 4096; with key_type=ec, allowed values are: 224, 256 (default), 384, or 521; ignored with key_type=ed25519. max_path_length (int: -1) - Specifies the maximum path length to encode in the generated certificate. -1 means no limit. Unless the signing certificate has a maximum path length set, in which case the path length is set to one less than that of the signing certificate. A limit of 0 means a literal path length of zero. exclude_cn_from_sans (bool: false) - If true, the given common_name will not be included in DNS or Email Subject Alternate Names (as appropriate). Useful if the CN is not a hostname or email address, but is instead some human-readable identifier. permitted_dns_domains (string: &quot;&quot;) - A comma separated string (or, string array) containing DNS domains for which certificates are allowed to be issued or signed by this CA certificate. Note that subdomains are allowed, as perRFC 5280 Section 4.2.1.10 - Name Constraints. ou (string: &quot;&quot;) - Specifies the OU (OrganizationalUnit) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. organization (string: &quot;&quot;) - Specifies the O (Organization) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. country (string: &quot;&quot;) - Specifies the C (Country) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. locality (string: &quot;&quot;) - Specifies the L (Locality) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. province (string: &quot;&quot;) - Specifies the ST (Province) values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. street_address (string: &quot;&quot;) - Specifies the Street Address values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. postal_code (string: &quot;&quot;) - Specifies the Postal Code values in the subject field of the resulting certificate. This is a comma-separated string or JSON array. serial_number (string: &quot;&quot;) - - Specifies the default Subject's namedSerial Numbervalue, if any. If you want more than one, specify alternative names in thealt_names map using OID 2.5.4.5. Note that this has no impact on the Certificate's serial number field, which OpenBao randomly generates. not_before_duration (duration: &quot;30s&quot;) - Specifies the duration by which to backdate the NotBefore property. This value has no impact in the validity period of the requested certificate, specified in the ttl field. Uses duration format strings. not_after (string) - Set the Not After field of the certificate with specified date value. The value format should be given in UTC formatYYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z. key_usage (list: [&quot;KeyAgreement&quot;, &quot;KeyEncipherment&quot;]) - Specifies the default key usage constraint on the issued certificate. Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage - simply drop the KeyUsage part of the value. Values are not case-sensitive.  warning Note: previous versions of this document incorrectly called this a constraint; this value is only used as a default when the KeyUsage extension is missing from the CSR.  ext_key_usage (list: []) - Specifies the default extended key usage constraint on the issued certificate. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage - simply drop the ExtKeyUsage part of the value. Values are not case-sensitive. To specify no key default usage constraints, set this to an empty list.  warning Note: previous versions of this document incorrectly called this a constraint; this value is only used as a default when the ExtendedKeyUsage extension is missing from the CSR.  ext_key_usage_oids (string: &quot;&quot;) - A comma-separated string or list of extended key usage oids.  warning Note: This value is only used as a default when the ExtendedKeyUsageextension is missing from the CSR.  warning Note: Keys of type rsa currently only support PKCS#1 v1.5 signatures.  Sample payload​  { &quot;common_name&quot;: &quot;example.com&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/root/generate/internal   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;expiration&quot;: &quot;1654105687&quot;, &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;issuing_ca&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE-----\\n&quot;, &quot;serial_number&quot;: &quot;39:dd:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot;, &quot;issuer_id&quot;: &quot;7b493f17-6c08-ff73-cf1a-99bfcc448a73&quot;, &quot;issuer_name&quot;: &quot;&quot;, &quot;key_id&quot;: &quot;22b82e37-529d-7251-7d78-3862bfd069ac&quot;, &quot;key_name&quot;: &quot;&quot; }, &quot;auth&quot;: null }     ","version":"Next","tagName":"h3"},{"title":"Generate intermediate CSR​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#generate-intermediate-csr","content":" This endpoint returns a new CSR for signing, optionally generating a new private key. If using OpenBao as a root (and, like many other CAs), the various parameters on the final signed certificate are set at signing time and may or may not honor the parameters set here (and transmitted in the returned CSR).  The parameters below are mostly meant as a helper function; not all possible parameters that can be set in a CSR are supported in this request.  No new issuer is yet created by this call; note that a new key may be generated depending on the type request parameter.  warning Note: In order to complete the intermediate generation, the CSR must be signed and the resulting certificate imported. This may involve working with external systems (such as an external or offline root CA) to transmit the CSR and complete the signing before the signed intermediate certificate isimported into this mount.  Method\tPath\tPrivate key source (type)POST\t/pki/intermediate/generate/:type\tspecified per request POST\t/pki/issuers/generate/intermediate/:type\tspecified per request POST\t/pki/intermediate/cross-sign\texisting  Parameters​  type (string: &lt;required&gt;) - Specifies the type of the intermediate to create. If exported, the private key will be returned in the response; ifinternal the private key will not be returned and cannot be retrieved later; if existing, we expect the key_ref parameter to use existing key material to create the CSR. This parameter is part of the request URL. common_name (string: &lt;required&gt;) - Specifies the requested CN for the certificate. If more than one common_name is desired, specify the alternative names in the alt_names list. alt_names (string: &quot;&quot;) - Specifies the requested Subject Alternative Names, in a comma-delimited list. These can be host names or email addresses; they will be parsed into their respective fields. ip_sans (string: &quot;&quot;) - Specifies the requested IP Subject Alternative Names, in a comma-delimited list. uri_sans (string: &quot;&quot;) - Specifies the requested URI Subject Alternative Names, in a comma-delimited list. other_sans (string: &quot;&quot;) - Specifies custom OID/UTF8-string SANs. These must match values specified on the role in allowed_other_sans (see role creation for allowed_other_sans globbing rules). The format is the same as OpenSSL: &lt;oid&gt;;&lt;type&gt;:&lt;value&gt; where the only current valid type is UTF8. This can be a comma-delimited list or a JSON string slice. format (string: &quot;pem&quot;) - Specifies the format for returned data. This can bepem, der, or pem_bundle; defaults to pem. If der, the output is base64 encoded. If pem_bundle, the csr field will contain the private key (if exported) and CSR, concatenated. private_key_format (string: &quot;der&quot;) - Specifies the format for marshaling the private key within the private_key response field. Defaults to der which will return either base64-encoded DER or PEM-encoded DER, depending on the value offormat. The other option is pkcs8 which will return the key marshalled as PEM-encoded PKCS8.  warning Note that this does not apply to the private key within the certificate field if format=pem_bundle parameter is specified.  key_type (string: &quot;rsa&quot;) - Specifies the desired key type; must be rsa, ed25519or ec. Not suitable for type=existing requests.  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: ed25519.  warning Note: Keys of type rsa currently only support PKCS#1 v1.5 signatures.  key_bits (int: 0) - Specifies the number of bits to use for the generated keys. Allowed values are 0 (universal default); withkey_type=rsa, allowed values are: 2048 (default), 3072, or 4096; with key_type=ec, allowed values are: 224, 256 (default), 384, or 521; ignored with key_type=ed25519. Not suitable fortype=existing requests. key_name (string: &quot;&quot;) - When a new key is created with this request, optionally specifies the name for this. The global ref default may not be used as a name. key_ref (string: &quot;default&quot;) - Specifies the key (either default, by name, or by identifier) to use for generating this request. Only suitable for type=existing requests. signature_bits (int: 0) - Specifies the number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on issuer's key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).  warning Note: ECDSA and Ed25519 issuers do not follow configuration of thesignature_bits value; only RSA issuers will change signature types based on this parameter.  exclude_cn_from_sans (bool: false) - If true, the given common_name will not be included in DNS or Email Subject Alternate Names (as appropriate). Useful if the CN is not a hostname or email address, but is instead some human-readable identifier. ou (string: &quot;&quot;) - Specifies the OU (OrganizationalUnit) values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. organization (string: &quot;&quot;) - Specifies the O (Organization) values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. country (string: &quot;&quot;) - Specifies the C (Country) values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. locality (string: &quot;&quot;) - Specifies the L (Locality) values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. province (string: &quot;&quot;) - Specifies the ST (Province) values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. street_address (string: &quot;&quot;) - Specifies the Street Address values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. postal_code (string: &quot;&quot;) - Specifies the Postal Code values in the subject field of the resulting CSR. This is a comma-separated string or JSON array. serial_number (string: &quot;&quot;) - Specifies the requested Subject's namedSerial Numbervalue, if any. If you want more than one, specify alternative names in thealt_names map using OID 2.5.4.5. Note that this has no impact on the Certificate's serial number field, which OpenBao randomly generates. add_basic_constraints (bool: false) - Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services.  Sample payload​  { &quot;common_name&quot;: &quot;www.example.com&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/intermediate/generate/exported   { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;csr&quot;: &quot;-----BEGIN CERTIFICATE REQUEST-----\\nMIIDzDCCAragAwIBAgIUOd0ukLcjH43TfTHFG9qE0FtlMVgwCwYJKoZIhvcNAQEL\\n...\\numkqeYeO30g1uYvDuWLXVA==\\n-----END CERTIFICATE REQUEST-----\\n&quot;, &quot;private_key&quot;: &quot;-----BEGIN RSA PRIVATE KEY-----\\\\nMIIEpAIBAAKCAQEAwsANtGz9gS3o5SwTSlOG1l-----END RSA PRIVATE KEY-----&quot;, &quot;private_key_type&quot;: &quot;rsa&quot; }, &quot;warnings&quot;: null, &quot;auth&quot;: null }       ","version":"Next","tagName":"h3"},{"title":"Import CA certificates and keys​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#import-ca-certificates-and-keys","content":" This endpoint allows submitting (importing) the CA information for the backend via a PEM file containing the CA certificate and any private keys, concatenated together, in any order.  Each certificate will be validated to ensure it is a valid CA (has an asserted isCA basic constraint); non-CA certs will err. Any provided CRLs will be ignored. Each unique certificate and private key will be imported as its own issuer or key entry; duplicates (including with existing keys) will be ignored.  The response will indicate what issuers and keys were created as part of this request (in the imported_issuers and imported_keys), along with a mappingfield, indicating which keys belong to which issuers (including from already imported entries present in the same bundle). The response also contains anexisting_issuers and existing_keys fields, which specifies the issuer and key IDs of any entries in the bundle that already existed within this mount.  Method\tPath\tAllows private keys\tRequest ParameterPOST\t/pki/config/ca\tyes\tpem_bundle POST\t/pki/issuers/import/bundle\tyes\tpem_bundle POST\t/pki/issuers/import/cert\tno\tpem_bundle POST\t/pki/intermediate/set-signed\tno\tcertificate  warning Note: endpoints which allow importing private keys should be considered highly privileged and restricted appropriately. Endpoints which allow importing issuers should also be restricted, but note that issuers without keys are unable to issue certificates or CRLs.  warning Note: OpenBao will deduplicate differently-encoded but same-valued keys and issuers. This means the returned certificate may differ in encoding from the one provided on subsequent re-imports of the same issuer or key.  warning Note: This import may fail due to CRL rebuilding issues or other potential issues; this may impact long-term use of these issuers, but some issuers or keys may still be imported as a result of this process.  warning Warning: See the noteregarding Subject naming on externally created CA certificates and shortcomings with CRL building.  Parameters​  pem_bundle (string: &lt;required&gt;) - Specifies the unencrypted private key and certificate, concatenated in PEM format.  warning Note: this parameter is on the /pki/config/ca and /pki/issuers/import/*paths; it is not on the /pki/intermediate/set-signed path.  certificate (string: &lt;required&gt;) - Specifies the certificates to import, concatenated in PEM format.  warning Note: this parameter is only on the /pki/intermediate/set-signed path.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data &quot;@payload.json&quot; \\ http://127.0.0.1:8200/v1/pki/config/ca   Note that if you provide the data through the HTTP API, it must be JSON-formatted, with newlines replaced with \\n, like so:  { &quot;pem_bundle&quot;: &quot;-----BEGIN RSA PRIVATE KEY-----\\n...\\n-----END CERTIFICATE-----&quot; }   Sample response​  { &quot;data&quot;: { &quot;imported_issuers&quot;: [&quot;1ae8ce9d-2f70-0761-a465-8c9840a247a2&quot;], &quot;imported_keys&quot;: [&quot;97be2525-717a-e2f7-88da-0a20e11aad88&quot;], &quot;mapping&quot;: { &quot;1ae8ce9d-2f70-0761-a465-8c9840a247a2&quot;: &quot;97be2525-717a-e2f7-88da-0a20e11aad88&quot; }, &quot;existing_issuers&quot;: [], &quot;existing_keys&quot;: [] } }   ","version":"Next","tagName":"h3"},{"title":"Read issuer​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-issuer","content":" This endpoint allows an operator to fetch a single issuer certificate and its chain, including internal information not exposed on the unauthenticated/pki/issuer/:issuer_ref/json endpoint. This includes information about the name, the key material, if an explicitly constructed chain has been set, what the behavior is for signing longer TTL'd certificates, and what usage modes are set on this issuer.  Method\tPathGET\t/pki/issuer/:issuer_ref  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/issuer/default   Sample response​  { &quot;data&quot;: { &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;-----BEGIN CERTIFICATE-----\\nMIIDFTCCAf2gAwIBAgIUUo/qwLm5AyqUWqFHw1MlgwUtS/kwDQYJKoZIhvcNAQEL\\n...&quot; ], &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;issuer_id&quot;: &quot;7545992c-1910-0898-9e64-d575549fbe9c&quot;, &quot;issuer_name&quot;: &quot;root-x1&quot;, &quot;key_id&quot;: &quot;baadd98d-ec5a-66ac-06b7-dfc91c02c9cf&quot;, &quot;leaf_not_after_behavior&quot;: &quot;truncate&quot;, &quot;manual_chain&quot;: null, &quot;usage&quot;: &quot;read-only,issuing-certificates,crl-signing,ocsp-signing&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Update issuer​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#update-issuer","content":" This endpoint allows an operator to manage a single issuer, updating various properties about it, including its name, an explicitly constructed chain, what the behavior is for signing longer TTL'd certificates, and what usage modes are set on this issuer.  Note that it is not possible to change the certificate of this issuer; to do so, import a new issuer and a new issuer_id will be assigned.  Method\tPathPOST\t/pki/issuer/:issuer_ref PATCH\t/pki/issuer/:issuer_ref  warning Note POSTing to this endpoint causes OpenBao to overwrite the previous contents of the issuer, using the provided request data (and any defaults for elided parameters). It does not update only the provided fields. OpenBao supports the PATCH operation to this endpoint, using the JSON patch format supported by KVv2, allowing update of specific fields. Note that bao write uses POST.  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL. issuer_name (string: &quot;&quot;) - Provides a name to the specified issuer. The name must be unique across all issuers and not be the reserved valuedefault. leaf_not_after_behavior (string: &quot;err&quot;) - Behavior of a leaf'sNotAfter field during issuance. Valid options are: err, to error if the computed NotAfter exceeds that of this issuer;truncate to silently truncate the requested NotAfter value to that of this issuer; orpermit to allow this issuance to succeed with a NotAfter value exceeding that of this issuer.  warning Note: Not all values result in leaf certificates that can be validated through the entire validity period. It is suggested to use truncate for intermediate CAs and permit only for root CAs. This is because (root) certificates in browsers' trust stores typically aren't checked for validity, whereas intermediate CA certificates sent in TLS connections are checked for validity at the time of use. This means that a leaf certificate permitted to be issued for longer than the intermediate likely won't continue to validate after the intermediate has expired.  manual_chain ([]string: nil) - Chain of issuer references to build this issuer's computed CAChain field from, when non-empty.  warning Note: the manual_chain field is an advanced field useful when automatic chain building isn't desired. The first element must be the present issuer's reference. Subsequent references should validate previous entries, terminating with a root certificate. Ideally a single linear chain would come first (from this issuer to a single root certificate) before any parallel, alternate chains appear. This field is especially useful for cross-signed intermediates within OpenBao. Because each cross-signed intermediate will only know of the one root, but issuance should serve both, update the issuers' entries with the desired manual_chain value. The CA Chain returned by a GET to the issuer configuration is the same chain presented during signing and (if this issuer is the default) on the /ca_chain path. Setting manual_chain thus allows controlling the presented chain as desired.  usage ([]string: read-only,issuing-certificates,crl-signing,ocsp-signing) - Allowed usages for this issuer. Valid options are: read-only, to allow this issuer to be read; implict; always allowed;issuing-certificates, to allow this issuer to be used for issuing other certificates; orcrl-signing, to allow this issuer to be used for signing CRLs. This is separate from the CRLSign KeyUsage on the x509 certificate, but this usage cannot be set unless that KeyUsage is allowed on the x509 certificate.ocsp-signing, to allow this issuer to be used for signing OCSP responses  warning Note: The usage field allows for a soft-delete capability on the issuer, or to prevent use of the issuer prior to it being enabled. For example, as issuance is rotated to a new issuer, the old issuer could be markedusage=read-only,crl-signing,ocsp-signing, allowing existing certificates to be revoked (and the CRL updated), but preventing new certificate issuance. After all certificates issued under this certificate have expired, this certificate could be marked usage=read-only, freezing the CRL. Finally, after a grace period, the issuer could be deleted.  revocation_signature_algorithm (string: &quot;&quot;) - Which signature algorithm to use when building CRLs. See Go's x509.SignatureAlgorithmconstant for possible values. This flag allows control over hash function and signature scheme (PKCS#1v1.5 vs PSS). The default (empty string) value is for Go to select the signature algorithm automatically, which may not always work.  warning Note: This can fail if the underlying key does not support the requested signature algorithm; this may not always be known at modification time.  issuing_certificates (array&lt;string&gt;: nil) - Specifies the URL values for the Issuing Certificate field. This can be an array or a comma-separated string list. See also RFC 5280 Section 4.2.2.1for information about the Authority Information Access field. crl_distribution_points (array&lt;string&gt;: nil) - Specifies the URL values for the CRL Distribution Points field. This can be an array or a comma-separated string list. See also RFC 5280 Section 4.2.1.13for information about the CRL Distribution Points field.  warning Note: When multiple issuers are in use under a single mount, each issuer will have its own CRL distribution point. These separate CRLs should either be aggregated into a single CRL (externally; as OpenBao does not support this functionality) or multiple crl_distribution_points should be specified here, pointing to each cluster and issuer.  ocsp_servers (array&lt;string&gt;: nil) - Specifies the URL values for the OCSP Servers field. This can be an array or a comma-separated string list. See alsoRFC 5280 Section 4.2.2.1for information about the Authority Information Access field. enable_aia_url_templating (bool: false) - Specifies that the above AIA URL values (issuing_certificates, crl_distribution_points, andocsp_servers) should be templated. This replaces the literal value{{issuer_id}} with the ID of the issuer doing the issuance, the literal value {{cluster_path}} with the value of path from the cluster-local configuration endpoint /config/cluster, and the literal value {{cluster_aia_path}} with the value of aia_path from the cluster-local configuration endpoint /config/cluster.  warning Note: If no cluster-local address is present and templating is used, issuance will fail.  Sample payload​  { &quot;issuer_name&quot;: &quot;root-x1&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/issuer/default   Sample response​  { &quot;data&quot;: { &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;-----BEGIN CERTIFICATE-----\\nMIIDFTCCAf2gAwIBAgIUUo/qwLm5AyqUWqFHw1MlgwUtS/kwDQYJKoZIhvcNAQEL\\n...&quot; ], &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;issuer_id&quot;: &quot;7545992c-1910-0898-9e64-d575549fbe9c&quot;, &quot;issuer_name&quot;: &quot;root-x1&quot;, &quot;key_id&quot;: &quot;baadd98d-ec5a-66ac-06b7-dfc91c02c9cf&quot;, &quot;leaf_not_after_behavior&quot;: &quot;truncate&quot;, &quot;manual_chain&quot;: null, &quot;usage&quot;: &quot;read-only,issuing-certificates,crl-signing,ocsp-signing&quot;, &quot;revocation_signature_algorithm&quot;: &quot;&quot;, &quot;issuing_certificates&quot;: [&quot;&lt;url1&gt;&quot;, &quot;&lt;url2&gt;&quot;], &quot;crl_distribution_points&quot;: [&quot;&lt;url1&gt;&quot;, &quot;&lt;url2&gt;&quot;], &quot;ocsp_servers&quot;: [&quot;&lt;url1&gt;&quot;, &quot;&lt;url2&gt;&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Revoke issuer​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#revoke-issuer","content":" This endpoint allows an operator to revoke an issuer certificate, marking it unable to issue new certificates and adding it to other issuers' CRLs, if they have signed this issuer's certificate. This will cause all CRLs to be rebuilt.  This is mostly provided for book-keeping and as a soft-delete feature, to ensure this issuer is not accidentally reused in the future.  warning Warning: This operation cannot be undone!  warning Note: This operation does not have any impact on other clusters or mounts and may not have any impact on whether clients consider these issuers revoked. Revoked issuers will not appear on their own CRLs. Revoked issuers may not appear on other CRLs if a suitable parent is not present in the same mount point. Revoked issuers will still need to be revoked in any other mounts they appear in, both as issuers, in the event of issuer reuse, and as issued certificates, in the event of an external parent mount.  Method\tPathPOST\t/pki/issuer/:issuer_ref/revoke  Parameters​  No parameters.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/pki/issuer/old-intermediate/revoke   Sample response​  { &quot;data&quot;: { &quot;ca_chain&quot;: [ &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;-----BEGIN CERTIFICATE-----\\nMIIDFTCCAf2gAwIBAgIUUo/qwLm5AyqUWqFHw1MlgwUtS/kwDQYJKoZIhvcNAQEL\\n...&quot; ], &quot;certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDFDCCAfygAwIBAgIUXgxy54mKooz5soqQoRINazH/3pQwDQYJKoZIhvcNAQEL\\n...&quot;, &quot;issuer_id&quot;: &quot;7545992c-1910-0898-9e64-d575549fbe9c&quot;, &quot;issuer_name&quot;: &quot;old-intermediate&quot;, &quot;key_id&quot;: &quot;baadd98d-ec5a-66ac-06b7-dfc91c02c9cf&quot;, &quot;leaf_not_after_behavior&quot;: &quot;truncate&quot;, &quot;manual_chain&quot;: null, &quot;usage&quot;: &quot;read-only,issuing-certificates,crl-signing&quot; &quot;revocation_time&quot;: 1433269787, } }   ","version":"Next","tagName":"h3"},{"title":"Delete issuer​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#delete-issuer","content":" This endpoint deletes the specified issuer. A warning is emitted and the default is cleared if this issuer is the default issuer.  warning Note: If an issuer is incorrectly deleted, but its key material remains, it is possible to re-import just the issuer certificate. Theissuer_id will change, but the name can be re-assigned to the new issuer.  Method\tPathDELETE\t/pki/issuer/:issuer_ref  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/pki/issuer/root-x1   ","version":"Next","tagName":"h3"},{"title":"Import key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#import-key","content":" This endpoint allows an operator to import a single pem encoded rsa, ec, or ed25519key.  warning Note: This API does not protect against importing keys using insecure combinations of algorithm and key length.  Method\tPathPOST\t/pki/keys/import  Parameters​  pem_bundle (string: &lt;required&gt;) - Specifies the unencrypted private key in PEM format. key_name (string: &quot;&quot;) - Provides a name to the specified key. The name must be unique across all keys and not be the reserved valuedefault.  Sample payload​  { &quot;key_name&quot;: &quot;my-imported-key&quot;, &quot;pem_bundle&quot;: &quot;-----BEGIN RSA PRIVATE KEY-----\\n...\\n-----END CERTIFICATE-----&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/keys/import   Sample response​  { &quot;data&quot;: { &quot;key_id&quot;: &quot;2cf03991-b052-1dc3-393e-374b41f8dcd8&quot;, &quot;key_name&quot;: &quot;my-imported-key&quot;, &quot;key_type&quot;: &quot;rsa&quot; }, }   ","version":"Next","tagName":"h3"},{"title":"Read key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-key","content":" This endpoint allows an operator to fetch information about an existing key.  warning Note: OpenBao does not allow reading the value of the private key after it has been created.  Method\tPathGET\t/pki/key/:key_ref  Parameters​  key_ref (string: &lt;required&gt;) - Reference to an existing key, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default key, or the name assigned to a key. This parameter is part of the request URL.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/key/default   Sample response​  { &quot;data&quot;: { &quot;key_id&quot;: &quot;8c4046f8-52a8-0974-29d2-745d8a0dd848&quot;, &quot;key_name&quot;: &quot;key-root-x1&quot;, &quot;key_type&quot;: &quot;rsa&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Update key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#update-key","content":" This endpoint allows an operator to manage a single key. Currently, the only parameter that is configurable is the key's name.  Note that it is not possible to change the private key of this key; to do so, import a new key and a new key_id will be assigned.  Method\tPathPOST\t/pki/key/:key_ref  warning Note POSTing to this endpoint causes OpenBao to overwrite the previous contents of the key, using the provided request data (and any defaults for elided parameters). It does not update only the provided fields.  Parameters​  key_ref (string: &lt;required&gt;) - Reference to an existing key, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default key, or the name assigned to a key. This parameter is part of the request URL. key_name (string: &quot;&quot;) - Provides a name to the specified key. The name must be unique across all keys and not be the reserved valuedefault.  Sample payload​  { &quot;key_name&quot;: &quot;key-root-x1&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/key/default   Sample response​  { &quot;data&quot;: { &quot;key_id&quot;: &quot;8c4046f8-52a8-0974-29d2-745d8a0dd848&quot;, &quot;key_name&quot;: &quot;key-root-x1&quot;, &quot;key_type&quot;: &quot;rsa&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete key​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#delete-key","content":" This endpoint deletes the specified key. A warning is emitted and the default is cleared if this key is the default key.  warning Note: Because OpenBao does not allow exporting the private key after it is initially generated, deletion of keys is a sensitive operation. Additionally, one key may be used by more than one issuer. As a result, OpenBao prohibits deletion of keys until all issuers using this key have also been deleted. If these issuers are still necessary for chain building, re-import them without the corresponding keys after the key has been deleted or use the soft-delete feature of issuers.  Method\tPathDELETE\t/pki/key/:key_ref  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/pki/key/key-root-x1   ","version":"Next","tagName":"h3"},{"title":"Delete all issuers and keys​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#delete-all-issuers-and-keys","content":" This endpoint deletes all issuers and keys within the mount. It is highly recommended to use the individual delete operations instead. This mount will be unusable until new issuers and keys are provisioned.  This endpoint requires sudo/root privileges.  Method\tPathDELETE\t/pki/root  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/pki/root     ","version":"Next","tagName":"h3"},{"title":"Managing authority information​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#managing-authority-information","content":" The following privileged endpoints allow the operator to control information about the core contents of certificates and to perform privileged operations like rotating the CRLs or performing tidy operations.  ","version":"Next","tagName":"h2"},{"title":"List roles​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#list-roles-1","content":" Refer to the earlier section for more information about listing roles.  ","version":"Next","tagName":"h3"},{"title":"Create/Update role​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#createupdate-role","content":" This endpoint creates or updates the role definition. Note that theallowed_domains, allow_subdomains, allow_glob_domains, andallow_any_name attributes are additive; between them nearly and across multiple roles nearly any issuing policy can be accommodated. server_flag,client_flag, and code_signing_flag are additive as well. If a client requests a certificate that is not allowed by the CN policy in the role, the request is denied.  Method\tPathPOST\t/pki/roles/:name PATCH\t/pki/roles/:name  warning Note POSTing to this endpoint when the role already exists causes OpenBao to overwrite the contents of the role, using the provided request data (and any defaults for elided parameters). It does not update only the provided fields. OpenBao supports the PATCH operation to this endpoint, using the JSON patch format supported by KVv2, allowing update of specific fields. Note that bao write uses POST.  Parameters​  name (string: &lt;required&gt;) - Specifies the name of the role to create. This is part of the request URL. issuer_ref: (string: &quot;default&quot;) - Specifies the default issuer of this request. May be the value default, a name, or an issuer ID. Use ACLs to prevent access to the /pki/issuer/:issuer_ref/{issue,sign}/:name paths to prevent users overriding the role's issuer_ref value.  warning Note: This parameter is stored as-is; if the reference is to a name, it is not resolve to an identifier. Deletion of issuers (or updating their names) may result in issuance failing or using an unexpected issuer.  warning Note: existing roles from previous OpenBao versions are migrated to use the issuer_ref=default.  ttl (string: &quot;&quot;) - Specifies the Time To Live value to be used for the validity period of the requested certificate, provided as a string duration with time suffix. Hour is the largest suffix. The value specified is strictly used for future validity. If not set, uses the system default value or the value of max_ttl, whichever is shorter. See not_after as an alternative for setting an absolute end date (rather than a relative one). max_ttl (string: &quot;&quot;) - Specifies the maximum Time To Live provided as a string duration with time suffix. Hour is the largest suffix. If not set, defaults to the system maximum lease TTL. allow_localhost (bool: true) - Specifies if clients can request certificates for localhost as one of the requested common names. This is useful for testing and to allow clients on a single host to talk securely.  warning Note: This strictly applies to localhost and localdomain when this option is enabled. Additionally, even if this option is disabled, if either name is included in allowed_domains, the match rules for that option could permit issuance of a certificate for localhost.  allowed_domains (list: []) - Specifies the domains this role is allowed to issue certificates for. This is used with the allow_bare_domains,allow_subdomains, and allow_glob_domains options to determine the type of matching between these domains and the values of common name, DNS-typed SAN entries, and Email-typed SAN entries. When allow_any_name is used, this attribute has no effect.  warning Note: The three options allow_bare_domains, allow_subdomains, andallow_glob_domains are each independent of each other. That is, at least one type of allowed matching must describe the relationship between theallowed_domains list and the names on the issued certificate. For example, given allowed_domain=foo.*.example.com and allow_subdomains=true andallow_glob_domains=true, a request for bar.foo.baz.example.com won't be permitted, even though it foo.baz.example.com matches the globfoo.*.example.com and bar is a subdomain of that.  allowed_domains_template (bool: false) - When set, allowed_domainsmay contain templates, as with ACL Path Templating. Non-templated domains are also still permitted. allow_bare_domains (bool: false) - Specifies if clients can request certificates matching the value of the actual domains themselves; e.g. if a configured domain set with allowed_domains is example.com, this allows clients to actually request a certificate containing the name example.com as one of the DNS values on the final certificate. In some scenarios, this can be considered a security risk. Note that when an allowed_domain field contains a potential wildcard character (for example, allowed_domains=*.example.com) and allow_bare_domains and allow_wildcard_certificates are both enabled, issuance of a wildcard certificate for *.example.com will be permitted. allow_subdomains (bool: false) - Specifies if clients can request certificates with CNs that are subdomains of the CNs allowed by the other role options. This includes wildcard subdomains. For example, anallowed_domains value of example.com with this option set to true will allow foo.example.com and bar.example.com as well as *.example.com. To restrict issuance of wildcards by this option, see allow_wildcard_certificatesbelow. This option is redundant when using the allow_any_name option. allow_glob_domains (bool: false) - Allows names specified inallowed_domains to contain glob patterns (e.g. ftp*.example.com). Clients will be allowed to request certificates with names matching the glob patterns.  warning Note: These globs behave like shell-style globs and can match across multiple domain parts. For example, allowed_domains=*.example.comwith allow_glob_domains enabled will match not only foo.example.com but also baz.bar.foo.example.com.  warning Warning: Glob patterns will match wildcard domains and permit their issuance unless otherwise restricted by allow_wildcard_certificates. For instance, with allowed_domains=*.*.example.com and both allow_glob_domainsand allow_wildcard_certificates enabled, we will permit the issuance of a wildcard certificate for *.foo.example.com.  allow_wildcard_certificates (bool: true) - Allows the issuance of certificates with RFC 6125 wildcards in the CN field. When set to false, this prevents wildcards from being issued even if they would've been allowed by an option above. We support the following four wildcard types: *.example.com, a single wildcard as the entire left-most label,foo*.example.com, a single suffixed wildcard in the left-most label,*foo.example.com, a single prefixed wildcard in the left-most label, andf*o.example.com, a single interior wildcard in the left-most label. allow_any_name (bool: false) - Specifies if clients can request any CN. Useful in some circumstances, but make sure you understand whether it is appropriate for your installation before enabling it. Note that bothenforce_hostnames and allow_wildcard_certificates are still checked, which may introduce limitations on issuance with this option. enforce_hostnames (bool: true) - Specifies if only valid host names are allowed for CNs, DNS SANs, and the host part of email addresses. allow_ip_sans (bool: true) - Specifies if clients can request IP Subject Alternative Names. No authorization checking is performed except to verify that the given values are valid IP addresses. allowed_uri_sans (string: &quot;&quot;) - Defines allowed URI Subject Alternative Names. No authorization checking is performed except to verify that the given values are valid URIs. This can be a comma-delimited list or a JSON string slice. Values can contain glob patterns (e.g.spiffe://hostname/*). allowed_uri_sans_template (bool: false) - When set, allowed_uri_sansmay contain templates, as with ACL Path Templating. Non-templated domains are also still permitted. allowed_other_sans (string: &quot;&quot;) - Defines allowed custom OID/UTF8-string SANs. This can be a comma-delimited list or a JSON string slice, where each element has the same format as OpenSSL: &lt;oid&gt;;&lt;type&gt;:&lt;value&gt;, but the only valid type is UTF8 or UTF-8. The value part of an element may be a * to allow any value with that OID. Alternatively, specifying a single * will allow any other_sans input. allowed_serial_numbers (string: &quot;&quot;) - If set, an array of allowed serial numbers to be requested during certificate issuance. These values support shell-style globbing. When empty, custom-specified serial numbers will be forbidden. It is strongly recommended to allow OpenBao to generate random serial numbers instead. server_flag (bool: true) - Specifies if certificates are flagged for server authentication use. See RFC 5280 Section 4.2.1.12for information about the Extended Key Usage field. client_flag (bool: true) - Specifies if certificates are flagged for client authentication use. See RFC 5280 Section 4.2.1.12for information about the Extended Key Usage field. code_signing_flag (bool: false) - Specifies if certificates are flagged for code signing use. See RFC 5280 Section 4.2.1.12for information about the Extended Key Usage field. email_protection_flag (bool: false) - Specifies if certificates are flagged for email protection use. See RFC 5280 Section 4.2.1.12for information about the Extended Key Usage field. key_type (string: &quot;rsa&quot;) - Specifies the type of key to generate for generated private keys and the type of key expected for submitted CSRs. Currently, rsa, ec, and ed25519 are supported, or when signing existing CSRs, any can be specified to allow keys of either type and with any bit size (subject to &gt;=2048 bits for RSA keys or &gt;= 224 for EC keys). When any is used, this role cannot generate certificates and can only be used to sign CSRs.  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: ed25519.  key_bits (int: 0) - Specifies the number of bits to use for the generated keys. Allowed values are 0 (universal default); withkey_type=rsa, allowed values are: 2048 (default), 3072, or 4096; with key_type=ec, allowed values are: 224, 256 (default), 384, or 521; ignored with key_type=ed25519 or in signing operations when key_type=any. signature_bits (int: 0) - Specifies the number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on issuer's key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).  warning Note: ECDSA and Ed25519 issuers do not follow configuration of thesignature_bits value; only RSA issuers will change signature types based on this parameter.  use_pss (bool: false) - Specifies whether or not to use PSS signatures over PKCS#1v1.5 signatures when a RSA-type issuer is used. Ignored for ECDSA/Ed25519 issuers. key_usage (list: [&quot;DigitalSignature&quot;, &quot;KeyAgreement&quot;, &quot;KeyEncipherment&quot;]) - Specifies the allowed key usage constraint on issued certificates. Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage - simply drop the KeyUsage part of the value. Values are not case-sensitive. To specify no key usage constraints, set this to an empty list. SeeRFC 5280 Section 4.2.1.3for more information about the Key Usage field. ext_key_usage (list: []) - Specifies the allowed extended key usage constraint on issued certificates. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage - simply drop the ExtKeyUsage part of the value. Values are not case-sensitive. To specify no key usage constraints, set this to an empty list. SeeRFC 5280 Section 4.2.1.12for information about the Extended Key Usage field. ext_key_usage_oids (string: &quot;&quot;) - A comma-separated string or list of extended key usage oids. Useful for adding EKUs not supported by the Go standard library. use_csr_common_name (bool: true) - When used with the CSR signing endpoint, the common name in the CSR will be used instead of taken from the JSON data. This does not include any requested SANs in the CSR; useuse_csr_sans for that. use_csr_sans (bool: true) - When used with the CSR signing endpoint, the subject alternate names in the CSR will be used instead of taken from the JSON data. This does not include the common name in the CSR; useuse_csr_common_name for that. ou (string: &quot;&quot;) - Specifies the OU (OrganizationalUnit) values in the subject field of issued certificates. This is a comma-separated string or JSON array. organization (string: &quot;&quot;) - Specifies the O (Organization) values in the subject field of issued certificates. This is a comma-separated string or JSON array. country (string: &quot;&quot;) - Specifies the C (Country) values in the subject field of issued certificates. This is a comma-separated string or JSON array. locality (string: &quot;&quot;) - Specifies the L (Locality) values in the subject field of issued certificates. This is a comma-separated string or JSON array. province (string: &quot;&quot;) - Specifies the ST (Province) values in the subject field of issued certificates. This is a comma-separated string or JSON array. street_address (string: &quot;&quot;) - Specifies the Street Address values in the subject field of issued certificates. This is a comma-separated string or JSON array. postal_code (string: &quot;&quot;) - Specifies the Postal Code values in the subject field of issued certificates. This is a comma-separated string or JSON array. generate_lease (bool: false) - Specifies if certificates issued/signed against this role will have OpenBao leases attached to them. Certificates can be added to the CRL by openbao revoke &lt;lease_id&gt; when certificates are associated with leases. It can also be done using the pki/revoke endpoint. However, when lease generation is disabled, invoking pki/revoke would be the only way to add the certificates to the CRL. When large number of certificates are generated with long lifetimes, it is recommended that lease generation be disabled, as large amount of leases adversely affect the startup time of OpenBao. no_store (bool: false) - If set, certificates issued/signed against this role will not be stored in the storage backend. This can improve performance when issuing large numbers of certificates. However, certificates issued in this way cannot be enumerated or revoked via serial number. Certificates may still be revoked via BYOC revocation. This option is recommend only for certificates that are non-sensitive, extremely short-lived, or have high volume/turn-over that would prohibit storage. This option implies a value of false for generate_lease. require_cn (bool: true) - If set to false, makes the common_name field optional while generating a certificate. policy_identifiers (list: []) - A comma-separated string or list of policy OIDs. basic_constraints_valid_for_non_ca (bool: false) - Mark Basic Constraints valid when issuing non-CA certificates. not_before_duration (duration: &quot;30s&quot;) - Specifies the duration by which to backdate the NotBefore property. This value has no impact in the validity period of the requested certificate, specified in the ttl field. not_after (string) - Set the Not After field of the certificate with specified date value. The value format should be given in UTC formatYYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z. cn_validations (list: [&quot;email&quot;, &quot;hostname&quot;]) - Validations to run on the Common Name field of the certificate. Valid values include: email, to ensure the Common Name is an email address (contains an @ sign),hostname, to ensure the Common Name is a hostname (otherwise). Multiple values can be separated with a comma or specified as a list and use OR semantics (either email or hostname in the CN are allowed). When the special value &quot;disabled&quot; is used (must be specified alone), none of the usual validation is run (including but not limited to allowed_domains and basic correctness validation around email addresses and domain names). This allows non-standard CNs to be used verbatim from the request. allowed_user_ids (string: &quot;&quot;) - Comma separated, globbing list of User ID Subject components to allow on requests. By default, no user IDs are allowed. Use the bare wildcard * value to allow any value. See also the user_idsrequest parameter.  Sample payload​  { &quot;allowed_domains&quot;: [&quot;example.com&quot;], &quot;allow_subdomains&quot;: true }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Read role​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-role-1","content":" Refer to the earlier section for more information about reading roles.  ","version":"Next","tagName":"h3"},{"title":"Delete role​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#delete-role","content":" This endpoint deletes the role definition. Deleting a role does notrevoke certificates previously issued under this role.  Method\tPathDELETE\t/pki/roles/:name  Parameters​  name (string: &lt;required&gt;) - Specifies the name of the role to delete. This is part of the request URL.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/pki/roles/my-role   ","version":"Next","tagName":"h3"},{"title":"Read URLs​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-urls","content":" This endpoint fetches the URLs to be encoded in generated certificates. No URL configuration will be returned until the configuration is set.  Method\tPathGET\t/pki/config/urls  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/urls   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;issuing_certificates&quot;: [&quot;&lt;url1&gt;&quot;, &quot;&lt;url2&gt;&quot;], &quot;crl_distribution_points&quot;: [&quot;&lt;url1&gt;&quot;, &quot;&lt;url2&gt;&quot;], &quot;ocsp_servers&quot;: [&quot;&lt;url1&gt;&quot;, &quot;&lt;url2&gt;&quot;] }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Set URLs​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-urls","content":" This endpoint allows setting the issuing certificate endpoints, CRL distribution points, and OCSP server endpoints that will be encoded into issued certificates. You can update any of the values at any time without affecting the other existing values. To remove the values, simply use a blank string as the parameter.  Method\tPathPOST\t/pki/config/urls  warning Note: When using multiple issuers within the same mount, it is strongly suggested to use the per-issuer AIA information instead of the global AIA information. If any of the per-issuer AIA fields are set, the entire issuer's preferences will be used instead. Otherwise, these fields are used as a fallback. This can be achieved by using templated global AIA values, but setting the cluster-local address in configuration.  Parameters​  issuing_certificates (array&lt;string&gt;: nil) - Specifies the URL values for the Issuing Certificate field. This can be an array or a comma-separated string list. See also RFC 5280 Section 4.2.2.1for information about the Authority Information Access field. crl_distribution_points (array&lt;string&gt;: nil) - Specifies the URL values for the CRL Distribution Points field. This can be an array or a comma-separated string list. See also RFC 5280 Section 4.2.1.13for information about the CRL Distribution Points field.  warning Note: When multiple issuers are in use under a single mount, each issuer will have its own CRL distribution point. These separate CRLs should either be aggregated into a single CRL (externally; as OpenBao does not support this functionality) or multiple crl_distribution_points should be specified here, pointing to each cluster and issuer.  ocsp_servers (array&lt;string&gt;: nil) - Specifies the URL values for the OCSP Servers field. This can be an array or a comma-separated string list. See alsoRFC 5280 Section 4.2.2.1for information about the Authority Information Access field. enable_templating (bool: false) - Specifies that the above AIA URL values (issuing_certificates, crl_distribution_points, andocsp_servers) should be templated. This replaces the literal value{{issuer_id}} with the ID of the issuer doing the issuance, the literal value {{cluster_path}} with the value of path from the cluster-local configuration endpoint /config/cluster, and the literal value {{cluster_aia_path}} with the value of aia_path from the cluster-local configuration endpoint /config/cluster. For example, the following values can be used globally to ensure all AIA URIs use the cluster-local, per-issuer canonical reference, but with the issuing CA certificate and CRL distribution points to potentially use an external, non-OpenBao CDN. issuing_certificates={{cluster_aia_path}}/issuer/{{issuer_id}}/dercrl_distribution_points={{cluster_aia_path}}/issuer/{{issuer_id}}/crl/derocsp_servers={{cluster_aia_path}}/ocsp  warning Note: If no cluster-local address is present and templating is used, issuance will fail.  Sample payload​  { &quot;issuing_certificates&quot;: [&quot;{{cluster_aia_path}}/issuer/{{issuer_id}}/der&quot;], &quot;crl_distribution_points&quot;: [&quot;{{cluster_aia_path}}/issuer/{{issuer_id}}/crl/der&quot;], &quot;ocsp_servers&quot;: [&quot;{{cluster_aia_path}}/ocsp&quot;] }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/urls   ","version":"Next","tagName":"h3"},{"title":"Read issuers configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-issuers-configuration","content":" This endpoint allows getting the value of the default issuer.  Method\tPathGET\t/pki/config/issuers  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/issuers   Sample response​  { &quot;data&quot;: { &quot;default&quot;: &quot;3dc79a5a-7a6c-70e2-1123-94b88557ba12&quot;, &quot;default_follows_latest_issuer&quot;: &quot;false&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Set issuers configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-issuers-configuration","content":" This endpoint allows setting the value of the default issuer.  Method\tPathPOST\t/pki/config/issuers POST\t/pki/root/replace  Parameters​  default (string: &quot;&quot;) - Specifies the default issuer (by reference; either a name or an ID). When no value is specified and the path is/pki/root/replace, the default value of &quot;next&quot; will be used. default_follows_latest_issuer (bool: false) - Specifies whether a root creation or an issuer import operation updates the default issuer to the newly added issuer. While the new multi-issuer functionality of 1.11 was backwards compatible on a per-API basis, some applications relied explicitly on unsafe behavior across multiple APIs that we addressed. For instance, calling/intermediate/generate/:type would silently remove any (potentially in-use!) key material and generate new private keys. While our response to this endpoint is backwards compatible (returning a new key and safely preserving old keys), some applications implicitly relied on this behavior. This new option is meant to provide compatibility across API calls to these callers: the newly created issuer (once imported -- not on intermediate generation) will become the default and it will look (to anyone strictly using old APIs) that it is the only issuer in the mount. However, it is encouraged for applications to update to the newer, safer semantics associated with multi-issuer rotation.  warning Note: When an import creates more than one new issuer with key material known to this mount, no default update will occur.  Sample payload​  { &quot;default&quot;: &quot;root-x1&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/issuers   Sample response​  { &quot;data&quot;: { &quot;default&quot;: &quot;3dc79a5a-7a6c-70e2-1123-94b88557ba12&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Read keys configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-keys-configuration","content":" This endpoint allows getting the value of the default key.  Method\tPathGET\t/pki/config/keys  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/keys   Sample response​  { &quot;data&quot;: { &quot;default&quot;: &quot;baadd98d-ec5a-66ac-06b7-dfc91c02c9cf&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Set keys configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-keys-configuration","content":" This endpoint allows setting the value of the default key.  Method\tPathPOST\t/pki/config/keys  Parameters​  default (string: &quot;&quot;) - Specifies the default key (by reference; either a name or an ID).  Sample payload​  { &quot;default&quot;: &quot;baadd98d-ec5a-66ac-06b7-dfc91c02c9cf&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/keys   Sample response​  { &quot;data&quot;: { &quot;default&quot;: &quot;baadd98d-ec5a-66ac-06b7-dfc91c02c9cf&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Read cluster configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-cluster-configuration","content":" This endpoint fetches the cluster-local configuration.  The cluster-local config has path, which sets the URL to this mount on a particular cluster. This is useful for populating {{cluster_path}} during AIA URL templating, but may be used for other values in the future.  It also has aia_path, which allows using a non-OpenBao, external responder, setting the {{cluster_aia_path}} value for AIA URL templating. This is useful for distributing CA and CRL information over an unsecured, non-TLS channel.  Method\tPathGET\t/pki/config/cluster  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/cluster   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;path&quot;: &quot;&lt;url&gt;&quot;, &quot;aia_path&quot;: &quot;&lt;url&gt;&quot; }, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Set cluster configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-cluster-configuration","content":" This endpoint sets cluster-local configuration.  The cluster-local config has path, which sets the URL to this mount on a particular cluster. This is useful for populating {{cluster_path}} during AIA URL templating, but may be used for other values in the future.  It also has aia_path, which allows using a non-OpenBao, external responder, setting the {{cluster_aia_path}} value for AIA URL templating. This is useful for distributing CA and CRL information over an unsecured, non-TLS channel.  Method\tPathPOST\t/pki/config/cluster  Parameters​  path (string: &quot;&quot;) - Specifies the path to this cluster's API mount path, including any namespaces as path components. For example,https://a.openbao.example.com/v1/ns1/pki-root. aia_path (string: &quot;&quot;) - Specifies the path to this cluster's AIA distribution point; may refer to an external, non-OpenBao responder. This is for resolving AIA URLs and providing the {{cluster_aia_path}} template parameter and will not be used for other purposes. As such, unlike pathabove, this could safely be an insecure transit mechanism (like HTTP without TLS).  Sample payload​  { &quot;path&quot;: &quot;https://...&quot;, &quot;aia_path&quot;: &quot;http://...&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/cluster   ","version":"Next","tagName":"h3"},{"title":"Read CRL configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-crl-configuration","content":" This endpoint allows getting the duration for which the generated CRL should be marked valid. No CRL configuration will be returned until the configuration is set, but the CRL will still default to enabled with 72h expiration.  Method\tPathGET\t/pki/config/crl  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/crl   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;disable&quot;: false, &quot;expiry&quot;: &quot;72h&quot;, &quot;ocsp_disable&quot;: false, &quot;ocsp_expiry&quot;: &quot;12h&quot;, &quot;auto_rebuild&quot;: false, &quot;auto_rebuild_grace_period&quot;: &quot;12h&quot;, &quot;enable_delta&quot;: false, &quot;delta_rebuild_interval&quot;: &quot;15m&quot;, &quot;cross_cluster_revocation&quot;: true, &quot;unified_crl&quot;: true, &quot;unified_crl_on_existing_paths&quot;: true }, &quot;auth&quot;: null }     ","version":"Next","tagName":"h3"},{"title":"Set revocation configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-revocation-configuration","content":" This endpoint allows setting the duration for which the generated CRL should be marked valid. If the CRL is disabled, it will return a signed but zero-length CRL for any request. If enabled, it will re-build the CRL.  If the ocsp_disable key is set to true, the OCSP responder will always respond with an Unauthorized OCSP response to any request.  warning Note: This parameter is global, across all clusters and issuers. Use the per-issuer usage field to disable CRL building for a specific issuer, while leaving the global CRL building enabled.  warning Note: Disabling the CRL does not affect whether revoked certificates are stored internally. Certificates that have been revoked when a role's certificate storage is enabled will continue to be marked and stored as revoked until tidy has been run with the desired safety buffer. Re-enabling CRL generation will then result in all such certificates becoming a part of the CRL.  warning Note: Enabling automatic rebuilding of CRLs disables immediate regeneration on revocation. This is in line with the behavior of other CAs which only rebuild CRLs periodically. We suggest manually hitting the rotate if a fresh CRL is necessary after a revocation. For the most part though, CRLs should not be relied upon for the latest certificate status information, and OCSP should be used instead.  warning Note: The periodic function which controls automatic rebuilding of CRLs and delta CRLs only executes once a minute; this prevents high system load but limits the granularity of the temporal options below.  Method\tPathPOST\t/pki/config/crl  Parameters​  expiry (string: &quot;72h&quot;) - The amount of time the generated CRL should be valid. disable (bool: false) - Disables or enables CRL building. ocsp_disable (bool: false) - Disables or enables the OCSP responder in OpenBao. ocsp_expiry (string: &quot;12h&quot;) - The amount of time an OCSP response can be cached for, (controls the NextUpdate field), useful for OCSP stapling refresh durations. If set to 0 the NextUpdate field is not set, indicating newer revocation information is available all the time. auto_rebuild (bool: false) - Enables or disables periodic rebuilding of the CRL upon expiry. auto_rebuild_grace_period (string: &quot;12h&quot;) - Grace period before CRL expiry to attempt rebuild of CRL. Must be shorter than the CRL expiry period. enable_delta (bool: false) - Enables or disables building of delta CRLs with up-to-date revocation information, augmenting the last complete CRL. This option requires auto_rebuild to also be enabled. delta_rebuild_interval (string: &quot;15m&quot;) - Interval to check for new revocations on, to regenerate the delta CRL. Must be shorter than CRL expiry.  Sample payload​  { &quot;expiry&quot;: &quot;48h&quot;, &quot;disable&quot;: &quot;false&quot;, &quot;ocsp_disable&quot;: &quot;false&quot;, &quot;ocsp_expiry&quot;: &quot;12h&quot;, &quot;auto_rebuild&quot;: &quot;true&quot;, &quot;auto_rebuild_grace_period&quot;: &quot;8h&quot;, &quot;enable_delta&quot;: &quot;true&quot;, &quot;delta_rebuild_interval&quot;: &quot;10m&quot;, &quot;cross_cluster_revocation&quot;: true, &quot;unified_crl&quot;: true, &quot;unified_crl_on_existing_paths&quot;: true, }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/crl   ","version":"Next","tagName":"h3"},{"title":"Rotate CRLs​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#rotate-crls","content":" This endpoint forces a rotation of all issuers' CRLs. This can be used by administrators to cut the size of the CRL if it contains a number of certificates that have now expired, but has not been rotated due to no further certificates being revoked. If no certificates have been revoked, but the CRL has expired or is close to expiring, administrators must hit this endpoint to manually rotate the CRL. This rotates all CRLs on the present cluster, and must be called on every cluster.  warning Note: Mirroring the behavior of earlier OpenBao versions, we add certificates revoked by an unknown issuer to the default issuer's CRL. To fully purge old revoked, unexpired certificates, it is not sufficient to delete their issuer and is instead necessary to remove the mount completely.  warning Note: It is suggested to switch to enabling the CRL's auto_rebuildfunctionality to avoid having to manually hit the Rotate endpoint when the CRL expires. This ensures a valid CRL is always maintained, at the expense of potentially not being up-to-date. If a revocation occurs that must be immediately propagated, this endpoint can be used to regenerate the CRL, though distribution must still occur outside of OpenBao (either manually or via AIA where supported).  Method\tPathGET\t/pki/crl/rotate  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/crl/rotate   Sample response​  { &quot;data&quot;: { &quot;success&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Rotate delta CRLs​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#rotate-delta-crls","content":" This endpoint forces a rotation of all issuers' delta CRLs, when enabled. This can be used by administrators to force a rebuild of a delta CRL if high-profile revocations have occurred and there's a long high interval between delta rebuilds (delta_rebuild_interval).  See notes about rotating regular CRLs above as they apply here as well.  Method\tPathGET\t/pki/crl/rotate-delta  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/crl/rotate   Sample response​  { &quot;data&quot;: { &quot;success&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Combine CRLs from the same issuer​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#combine-crls-from-the-same-issuer","content":" This endpoint allows combining multiple different CRLs that have been signed by the same issuer into a single signed CRL. This is useful to generate a single authoritative CRL of revocations across distinct OpenBao clusters.  Method\tPathPOST\t/pki/issuer/:issuer_ref/resign-crls  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.crls (list of strings: &lt;required&gt;) - A list of PEM encoded CRLs that have been signed by the issuercrl_number (int: &lt;required&gt;) - The sequence number to be written within the CRL Number extension.delta_crl_base_number (int: -1) - Using a value of 0 or greater specifies the base CRL revision number to encode within a Delta CRL indicator extension, otherwise the extension will not be added; defaults to -1.format (string: pem) - The format of the combined CRL, can be &quot;pem&quot; or &quot;der&quot;. If &quot;der&quot;, the value will be base64 encoded; Defaults to &quot;pem&quot;.next_update (string: 72h) - The amount of time the generated CRL should be valid; defaults to 72 hours.  Sample payload​  { &quot;crl_number&quot;: &quot;10&quot;, &quot;next_update&quot;: &quot;24h&quot;, &quot;crls&quot;: [&quot;&lt;PEM crl 1&gt;&quot;, &quot;&lt;PEM crl 2&gt;&quot;], &quot;format&quot;: &quot;pem&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ -request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/issuer/default/resign-crls   Sample response​  { &quot;data&quot;: { &quot;crl&quot;: &quot;&lt;PEM encoded crl&gt;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sign revocation list​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#sign-revocation-list","content":" This endpoint allows generating a CRL based on the provided parameter data from any external source and signed by the specified issuer. Values are taken verbatim from the parameters provided.  This is a potentially dangerous endpoint and only highly trusted users should have access.  Method\tPathPOST\t/pki/issuer/:issuer_ref/sign-revocation-list  Parameters​  issuer_ref (string: &lt;required&gt;) - Reference to an existing issuer, either by OpenBao-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.crl_number (int: &lt;required&gt;) - The sequence number to be written within the CRL Number extension.delta_crl_base_number (int: -1) - Using a value of 0 or greater specifies the base CRL revision number to encode within a Delta CRL indicator extension, otherwise the extension will not be added; defaults to -1.format (string: pem) - The format of the combined CRL, can be &quot;pem&quot; or &quot;der&quot;. If &quot;der&quot;, the value will be base64 encoded; Defaults to &quot;pem&quot;.next_update (string: 72h) - The amount of time the generated CRL should be valid; defaults to 72 hours.revoked_certs (type: slice of maps) - Each element contains revocation information for a single serial number along with the revocation time and the serial's extensions if any. Each element can have the following key/values serial_number (type: string) - the serial number of the revoked certrevocation_time (type: string) - the revocation time, unix int format or RFC3339 encoding supportedextensions (type: slice of maps) - A slice of all extensions that should be added to the revoked certificate entry. Each ele,ent contains a map with the following entries id (type: string) - an ASN1 object identifier in dot notationcritical (type: bool) - should the extension be marked criticalvalue (type: string) - base64 encoded bytes for extension value extensions (type: slice of maps) - A slice of all extensions that should be added to the generated CRL each element containing a map with the following entries. id (type: string) - an ASN1 object identifier in dot notationcritical (type: bool) - should the extension be marked criticalvalue (type: string) - base64 encoded bytes for extension value  warning Note: The following extension ids are not allowed to be provided and can be influenced by other parameters 2.5.29.20: CRL Number2.5.29.27: Delta CRL2.5.29.35: Authority Key Identifier  Sample payload​  { &quot;crl_number&quot;: &quot;10&quot;, &quot;next_update&quot;: &quot;24h&quot;, &quot;format&quot;: &quot;pem&quot;, &quot;revoked_certs&quot;: [ { &quot;serial_number&quot;: &quot;39:dd:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot;, &quot;revocation_time&quot;: &quot;2009-11-10T23:00:00Z&quot; }, { &quot;serial_number&quot;: &quot;40:33:2e:90:b7:23:1f:8d:d3:7d:31:c5:1b:da:84:d0:5b:65:31:58&quot;, &quot;revocation_time&quot;: &quot;1257894000&quot; } ] }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ -request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/issuer/default/sign-revocation-list   Sample response​  { &quot;data&quot;: { &quot;crl&quot;: &quot;&lt;PEM encoded crl&gt;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Tidy​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#tidy","content":" This endpoint allows tidying up the storage backend and/or CRL by removing certificates that have expired and are past a certain buffer period beyond their expiration time.  Method\tPathPOST\t/pki/tidy  warning Note: it is encouraged to use the automatic tidy capabilitiesto ensure this gets run periodically.  Parameters​  tidy_cert_store (bool: false) - Specifies whether to tidy up the certificate store. tidy_revoked_certs (bool: false) - Set to true to remove all invalid and expired certificates from storage. A revoked storage entry is considered invalid if the entry is empty, or the value within the entry is empty. If a certificate is removed due to expiry, the entry will also be removed from the CRL, and the CRL will be rotated. tidy_revoked_cert_issuer_associations (bool: false) - Set to true to associate revoked certificates with their corresponding issuers; this improves the performance of OCSP and CRL building, by shifting work to a tidy operation instead.  warning Note: With multiple issuers, a CA which issued a particular revoked certificate may be removed and re-added, resulting in a different issuer ID value. When building CRLs, these links are automatically updated for any missing or added issuers, but during OCSP this value is computed and then discarded, potentially causing a performance penalty on each request. During regular CA operations, it is not necessary to run this operation. It is suggested to run this tidy when removing or importing new issuers but otherwise not to run it during automatic tidy operations.  tidy_expired_issuers (bool: false) - Set to true to automatically remove expired issuers after the issuer_safety_buffer duration has elapsed. We log the issuer certificate on removal to allow recovery; no keys are removed during this process.  warning Note: The default issuer will not be removed even if it has expired and is past the issuer_safety_buffer specified.  tidy_move_legacy_ca_bundle (bool: false) - Set to true to backup any legacy CA/issuers bundle to config/ca_bundle.bak. This can be restored withsys/raw back to config/ca_bundle if necessary, but won't impact mount startup (as mounts will attempt to read the latter and do a migration of CA issuers if present). Migration will only occur after issuer_safety_bufferhas passed since the last successful migration. safety_buffer (string: &quot;&quot;) - Specifies a duration using duration format stringsused as a safety buffer to ensure certificates are not expunged prematurely; as an example, this can keep certificates from being removed from the CRL that, due to clock skew, might still be considered valid on other hosts. For a certificate to be expunged, the time must be after the expiration time of the certificate (according to the local clock) plus the duration of safety_buffer. Defaults to 72h. issuer_safety_buffer (string: &quot;&quot;) - Specifies a duration that issuers should be kept for, past their NotAfter validity period. Defaults to 365 days as hours (8760h). pause_duration (string: &quot;0s&quot;) - Specifies the duration to pause between tidying individual certificates. This releases the revocation lock and allows other operations to continue while tidy is paused. This allows an operator to control tidy's resource utilization within a timespan: the LIST operation will remain in memory, but the space between reading, parsing, and updates on-disk cert entries will be increased, decreasing resource utilization. Does not affect tidy_expired_issuers.  warning Note: Using too long of a pause_duration can result in tidy operations not concluding during this lifetime! Using too short of a pause duration (but non-zero) can lead to lock contention. Use tidy's cancellationto stop a running operation after the sleep period is over.  revocation_queue_safety_buffer (string: &quot;&quot;) - Specifies a duration after which cross-cluster revocation requests will be removed as expired. This should be set high enough that, if a cluster disappears for a while but later comes back, any revocation requests which it should process will still be there, but not too long as to fill up storage with too many invalid requests. Defaults to 48h. tidy_acme (bool: false) - Set to true to tidy stale ACME accounts, orders, authorizations, EABs, and challenges. ACME orders are tidied (deleted)safety_buffer after the certificate associated with them expires, or after the order and relevant authorizations have expired if no certificate was produced. Authorizations are tidied with the corresponding order. When a valid ACME Account is at least acme_account_safety_bufferold, and has no remaining orders associated with it, the account is marked as revoked. After another acme_account_safety_buffer has passed from the revocation or deactivation date, a revoked or deactivated ACME account is deleted. acme_account_safety_buffer (string: &quot;720h&quot;) - The amount of time that must pass after creation that an account with no orders is marked revoked, and the amount of time after being marked revoked or deactivated. The default is 30 days as hours.  Sample payload​  { &quot;safety_buffer&quot;: &quot;24h&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/tidy   ","version":"Next","tagName":"h3"},{"title":"Read automatic tidy configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#read-automatic-tidy-configuration","content":" This endpoint fetches the current automatic tidy configuration.  This is the combination of the periodic invocation parameters describedin the below write handler and the tidy parameters described above in the tidy endpoint.  Method\tPathGET\t/pki/config/auto-tidy  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/pki/config/auto-tidy   Sample response​  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;enabled&quot;: false, &quot;interval_duration&quot;: 43200, &quot;issuer_safety_buffer&quot;: 31536000, &quot;maintain_stored_certificate_counts&quot;: false, &quot;pause_duration&quot;: &quot;0s&quot;, &quot;publish_stored_certificate_count_metrics&quot;: false, &quot;revocation_queue_safety_buffer&quot;: 172800, &quot;safety_buffer&quot;: 259200, &quot;tidy_cert_store&quot;: false, &quot;tidy_cross_cluster_revoked_certs&quot;: false, &quot;tidy_expired_issuers&quot;: false, &quot;tidy_move_legacy_ca_bundle&quot;: false, &quot;tidy_revocation_queue&quot;: false, &quot;tidy_revoked_cert_issuer_associations&quot;: false, &quot;tidy_revoked_certs&quot;: false }, &quot;auth&quot;: null }     ","version":"Next","tagName":"h3"},{"title":"Set automatic tidy configuration​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#set-automatic-tidy-configuration","content":" This endpoint allows configuring periodic tidy operations, using the tidy mechanism described above. Status is from automatically run tidies are still reported at the status endpoint described below.  Method\tPathPOST\t/pki/config/auto-tidy  Parameters​  The below parameters are in addition to the regular parameters accepted by the/pki/tidy endpoint documented above.  enabled (bool: false) - Specifies whether automatic tidy is enabled or not. interval_duration (string: &quot;&quot;) - Specifies the duration between automatic tidy operations; note that this is from the end of one operation to the start of the next so the time of the operation itself does not need to be considered. Defaults to 12h maintain_stored_certificate_counts (bool: false) - When enabled, maintains expensive counts of certificates. During initialization of the mount, a LIST of all certificates is performed to get a baseline figure and throughout operations like issuance, revocation, and subsequent tidies, the figure is updated.  warning Note: It is strongly recommend to not enable this value if 50k or more certificates are stored in the mount or if many PKI mounts are in use in this cluster. Instead, use audit logs and aggregate this data externally to OpenBao so as not to impact OpenBao performance.  publish_stored_certificate_count_metrics (bool: false) - When enabled, publishes the value computed by maintain_stored_certificate_counts to the mount's metrics. This requires the former to be enabled.  Sample payload​  { &quot;enabled&quot;: true, &quot;tidy_revoked_cert_issuer_associations&quot;: true, &quot;safety_buffer&quot;: &quot;24h&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/pki/config/auto-tidy   ","version":"Next","tagName":"h3"},{"title":"Tidy status​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#tidy-status","content":" This is a read only endpoint that returns information about the current tidy operation, or the most recent if none are currently running.  The result includes the following fields:  safety_buffer: the value of this parameter when initiating the tidy operationtidy_cert_store: the value of this parameter when initiating the tidy operationtidy_revoked_certs: the value of this parameter when initiating the tidy operationstate: one of Inactive, Running, Finished, Error, Cancelling, or Cancellederror: the error message, if the operation ran into an errortime_started: the time the operation startedtime_finished: the time the operation finishedmessage: One of Tidying certificate store: checking entry N of TOTAL orTidying revoked certificates: checking certificate N of TOTALcert_store_deleted_count: The number of certificate storage entries deletedrevoked_cert_deleted_count: The number of revoked certificate entries deletedmissing_issuer_cert_count: The number of revoked certificates which were missing a valid issuer referencetidy_expired_issuers: the value of this parameter when initiating the tidy operationissuer_safety_buffer: the value of this parameter when initiating the tidy operationtidy_move_legacy_ca_bundle: the value of this parameter when initiating the tidy operationtidy_revocation_queue: the value of this parameter when initiating the tidy operationrevocation_queue_deleted_count: the number of revocation queue entries deletedtidy_cross_cluster_revoked_certs: the value of this parameter when initiating the tidy operationcross_revoked_cert_deleted_count: the number of cross-cluster revoked certificate entries deletedrevocation_queue_safety_buffer: the value of this parameter when initiating the tidy operationpause_duration: the value of this parameter when initiating the tidy operationlast_auto_tidy_finished: the time when the last auto-tidy operation finished; may be different than time_finished especially if the last operation was a manually executed tidy operation. Set to current time at mount time to delay the initial auto-tidy operation; not persisted.  Method\tPathGET\t/pki/tidy-status  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/pki/tidy-status   Sample response​   &quot;data&quot;: { &quot;safety_buffer&quot;: 60, &quot;tidy_cert_store&quot;: true, &quot;tidy_revoked_certs&quot;: true, &quot;error&quot;: null, &quot;message&quot;: &quot;Tidying certificate store: checking entry 234 of 488&quot;, &quot;revoked_cert_deleted_count&quot;: 0, &quot;cert_store_deleted_count&quot;: 2, &quot;state&quot;: &quot;Running&quot;, &quot;time_started&quot;: &quot;2021-10-20T14:52:13.510161-04:00&quot;, &quot;time_finished&quot;: null },   ","version":"Next","tagName":"h3"},{"title":"Cancel tidy​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#cancel-tidy","content":" This endpoint allows cancelling a running tidy operation. It takes no parameter and cancels the tidy at the next available checkpoint, which may process additional certificates between when the operation was marked as cancelled and when the operation stopped.  The response to this endpoint is the same as the status.  Method\tPathPOST\t/pki/tidy-cancel  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/pki/tidy-cancel   Sample response​   &quot;data&quot;: { &quot;safety_buffer&quot;: 60, &quot;tidy_cert_store&quot;: true, &quot;tidy_revoked_certs&quot;: true, &quot;error&quot;: null, &quot;message&quot;: &quot;Tidying certificate store: checking entry 234 of 488&quot;, &quot;revoked_cert_deleted_count&quot;: 0, &quot;cert_store_deleted_count&quot;: 2, &quot;state&quot;: &quot;Cancelling&quot;, &quot;time_started&quot;: &quot;2021-10-20T14:52:13.510161-04:00&quot;, &quot;time_finished&quot;: null },     ","version":"Next","tagName":"h3"},{"title":"Cluster scalability​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#cluster-scalability","content":" See PKI Cluster Scalability in the considerations page.  ","version":"Next","tagName":"h2"},{"title":"OpenBao CLI with DER/PEM responses​","type":1,"pageTitle":"PKI secrets engine (API)","url":"/openbao/api-docs/secret/pki/#openbao-cli-with-derpem-responses","content":" The OpenBao CLI can only display JSON responses. For APIs that return non-JSON formatted data such as DER and PEM formats, bao read will fail without the -format=rawoption or another client such as curl must be used. ","version":"Next","tagName":"h2"},{"title":"/sys/key-status","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/key-status/","content":"","keywords":"","version":"Next"},{"title":"Get encryption key status​","type":1,"pageTitle":"/sys/key-status","url":"/openbao/api-docs/system/key-status/#get-encryption-key-status","content":" This endpoint returns information about the current encryption key used by OpenBao.  Method\tPathGET\t/sys/key-status  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/key-status","url":"/openbao/api-docs/system/key-status/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/key-status   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/key-status","url":"/openbao/api-docs/system/key-status/#sample-response","content":" { &quot;term&quot;: 3, &quot;install_time&quot;: &quot;2015-05-29T14:50:46.223692553-07:00&quot;, &quot;encryptions&quot;: 74718331 }   The term parameter is the sequential key number. install_time is the time that encryption key was installed. encryptions is the estimated number of encryptions made by the key including those on other cluster nodes.  Note that the estimated encryption count is aggregated from secondary OpenBao nodes to the primary but not in the other direction. Thus the count only accurately reflects the cluster-wide estimate when queried on the primary. ","version":"Next","tagName":"h3"},{"title":"/sys/internal/ui/resultant-acl","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/internal-ui-resultant-acl/","content":"","keywords":"","version":"Next"},{"title":"Get resultant-acl​","type":1,"pageTitle":"/sys/internal/ui/resultant-acl","url":"/openbao/api-docs/system/internal-ui-resultant-acl/#get-resultant-acl","content":" This endpoint lists the resultant-acl relevant to the UI.  Method\tPathGET\t/sys/internal/ui/resultant-acl  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/ui/resultant-acl","url":"/openbao/api-docs/system/internal-ui-resultant-acl/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/internal/ui/resultant-acl   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/ui/resultant-acl","url":"/openbao/api-docs/system/internal-ui-resultant-acl/#sample-response","content":" { &quot;resultant-acl&quot;: [] }  ","version":"Next","tagName":"h3"},{"title":"/sys/internal/counters","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/internal-counters/","content":"","keywords":"","version":"Next"},{"title":"Entities​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#entities","content":" This endpoint returns the total number of Entities.  Method\tPathGET\t/sys/internal/counters/entities  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/entities   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-response","content":" { &quot;request_id&quot;: &quot;75cbaa46-e741-3eba-2be2-325b1ba8f03f&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;counters&quot;: { &quot;entities&quot;: { &quot;total&quot;: 1 } } }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Tokens​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#tokens","content":" This endpoint returns the total number of Tokens.  Method\tPathGET\t/sys/internal/counters/tokens  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/tokens   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-response-1","content":" { &quot;request_id&quot;: &quot;75cbaa46-e741-3eba-2be2-325b1ba8f03f&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;counters&quot;: { &quot;service_tokens&quot;: { &quot;total&quot;: 1 } } }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Client count​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#client-count","content":" This endpoint returns client activity information for a given billing period, which is represented by the start_time and end_time parameters.  There are a few things to keep in mind while using this API.  The response contains the total activity for the billing period and the attributions of the total activity against specific components in OpenBao. This helps in understanding the total activity better by knowing which components in OpenBao lead to that top-level activity count. First-level of attribution breakdowns are by namespaces and months, under the by_namespaces and monthsJSON block, respectively.  { &quot;by_namespace&quot;:[], &quot;months&quot;:[], }   by_namespaces breakdowns provide attributions of each namespace to the total activity count. Mount level attributions further break down these namespaces attributions, wherein information can be found on the attributions of each mount path within a given namespace to the overall activity of the namespace.  { &quot;by_namespace&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{}, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{} }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{} } ] } ] }   months breakdowns provide attributions of each month to the total activity count. These month-level attributions are further broken down into namespace and mount level attributions for each month.  { &quot;months&quot;:[ { &quot;timestamp&quot;:&quot;2021-05-01T00:00:00Z&quot;, &quot;counts&quot;:{}, &quot;namespaces&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{}, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{} }, { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{} } ] }, { &quot;namespace_id&quot;:&quot;s07UR&quot;, &quot;namespace_path&quot;:&quot;ns1/&quot;, &quot;counts&quot;:{}, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{} }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{} } ] } ], &quot;new_clients&quot;:{} } ], }   Each entry in the months breakdown contains a new_clients block. When a token is first used within a billing period, it is considered a new client for that billing period. This means that all the active clients in the first month of the billing period will be considered new clients for that billing period. While these tokens could be generated and counted in the previous billing period, they are still considered new clients in the context of the given billing period. For each subsequent month in the same billing period, the tokens used in those months that were unused in previous months of the same billing period are considered new clients for that month. Hence, the computation of new clients differs for each combination of start_time and end_time. The new_clients block within the months breakdown will also be further broken down by namespaces and mounts for visibility into which components in OpenBao lead to the new clients for each month.  { &quot;months&quot;:[ { &quot;new_clients&quot;:{ &quot;counts&quot;:{}, &quot;namespaces&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{}, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{} }, { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{} } ] } ] } } ], }   The distinct_entities field name has been deprecated. Refer toentity_clients field instead. The distinct_entities field is currently returned by the API for backward compatibility and it may be removed in the future. The non_entity_tokens field name has been deprecated. Refer tonon_entity_clients field instead. The non_entity_tokens field is currently returned by the API for backward compatibility, and it may be removed in the future. If the end_date supplied to the API is for the current month, the activity information returned by this API will only be till the previous month. The activity system is designed to process the accumulated activity only at the end of the month. Since the system does not fully process the current month's information, it will not be added to the API response. The response includes the actual time period covered, which may not exactly match the query parameters due to the month granularity of data or missing months in the requested time range. Note that if the end_date specified is the current month, the last element in the months response stanza, signifying the current month, will not have namespace attribution for the new_clients stanza. Furthermore, thenew_clients counts returned for the current month will be an approximation. That is to say, the response will appear as follows.  { &quot;months&quot;:[ { &quot;timestamp&quot;:&quot;current_month_timestamp&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:&quot;exact int value&quot;, &quot;entity_clients&quot;:&quot;exact int value&quot;, &quot;non_entity_tokens&quot;:&quot;exact int value&quot;, &quot;non_entity_clients&quot;:&quot;exact int value&quot;, &quot;clients&quot;:&quot;exact int value&quot; }, &quot;namespaces&quot;: [ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;path&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:&quot;exact int value&quot;, &quot;entity_clients&quot;:&quot;exact int value&quot;, &quot;non_entity_tokens&quot;:&quot;exact int value&quot;, &quot;non_entity_clients&quot;:&quot;exact int value&quot;, &quot;clients&quot;:&quot;exact int value&quot; }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:&quot;exact int value&quot;, &quot;entity_clients&quot;:&quot;exact int value&quot;, &quot;non_entity_tokens&quot;:&quot;exact int value&quot;, &quot;non_entity_clients&quot;:&quot;exact int value&quot;, &quot;clients&quot;:&quot;exact int value&quot; }, }, ] }, ], &quot;new_clients&quot;:{ &quot;counts&quot;:{ &quot;distinct_entities&quot;:&quot;approx int value&quot;, &quot;entity_clients&quot;:&quot;approx int value&quot;, &quot;non_entity_tokens&quot;:&quot;approx int value&quot;, &quot;non_entity_clients&quot;:&quot;approx int value&quot;, &quot;clients&quot;:&quot;approx int value&quot; }, &quot;namespaces&quot;:[] } } ], }   Please visit the client count concepts page for more information on how clients map to these client IDs and how they are counted, or for more information about how the new clients for the current month are estimated in a billing period.  The response will include all child namespaces of the namespace in which the request was made. If some namespace has subsequently been deleted, its path will be listed as &quot;deleted namespace :ID:.&quot; Deleted namespaces are reported only for queries in the root namespace because the information about the namespace path is unknown.  Method\tPathGET\t/sys/internal/counters/activity  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#parameters","content":" start_time (string, optional) - An RFC3339 timestamp or Unix epoch time. Specifies the start of the period for which client counts will be reported. If no start time is specified, the default_report_monthsprior to the end_time will be used.end_time (string, optional) - An RFC3339 timestamp or Unix epoch time. Specifies the end of the period for which client counts will be reported. If no end time is specified, the end of the previous calendar month will be used.limit_namespaces (int, optional) - Controls the total number of by_namespace data returned. This can be used to return the client counts for the specified number of namespaces having highest activity. If no limit_namespaces parameter is specified, client counts for all namespaces in specified usage period is returned.current_billing_period (bool, optional) - Uses the builtin billing start timestamp as start_time and the current time as the end_time, returning a response with the current billing period information without having to explicitly provide a start and end time.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/activity   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-response-2","content":" { &quot;request_id&quot;:&quot;26be5ab9-dcac-9237-ec12-269a8ca647d5&quot;, &quot;lease_id&quot;:&quot;&quot;, &quot;renewable&quot;:false, &quot;lease_duration&quot;:0, &quot;data&quot;:{ &quot;by_namespace&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:20, &quot;entity_clients&quot;:20, &quot;non_entity_tokens&quot;:10, &quot;non_entity_clients&quot;:10, &quot;clients&quot;:30 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:10, &quot;entity_clients&quot;:10, &quot;non_entity_tokens&quot;:10, &quot;non_entity_clients&quot;:10, &quot;clients&quot;:20 } }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 } } ] }, { &quot;namespace_id&quot;:&quot;s07UR&quot;, &quot;namespace_path&quot;:&quot;ns1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:0, &quot;entity_clients&quot;:0, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:5 } }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:0, &quot;non_entity_clients&quot;:0, &quot;clients&quot;:5 } } ] } ], &quot;end_time&quot;:&quot;2021-05-31T23:59:59Z&quot;, &quot;months&quot;:[ { &quot;timestamp&quot;:&quot;2021-05-01T00:00:00Z&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:20, &quot;entity_clients&quot;:20, &quot;non_entity_tokens&quot;:10, &quot;non_entity_clients&quot;:10, &quot;clients&quot;:30 }, &quot;namespaces&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:15, &quot;entity_clients&quot;:15, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:20 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:10, &quot;entity_clients&quot;:10, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:15 } }, { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:3, &quot;entity_clients&quot;:3, &quot;non_entity_tokens&quot;:2, &quot;non_entity_clients&quot;:2, &quot;clients&quot;:5 } } ] }, { &quot;namespace_id&quot;:&quot;s07UR&quot;, &quot;namespace_path&quot;:&quot;ns1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:0, &quot;entity_clients&quot;:0, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:5 } }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:0, &quot;non_entity_clients&quot;:0, &quot;clients&quot;:5 } } ] } ], &quot;new_clients&quot;:{ &quot;counts&quot;:{ &quot;distinct_entities&quot;:10, &quot;entity_clients&quot;:10, &quot;non_entity_tokens&quot;:10, &quot;non_entity_clients&quot;:10, &quot;clients&quot;:20 }, &quot;namespaces&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:0, &quot;entity_clients&quot;:0, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:5 } }, { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:0, &quot;non_entity_clients&quot;:0, &quot;clients&quot;:5 } } ] }, { &quot;namespace_id&quot;:&quot;s07UR&quot;, &quot;namespace_path&quot;:&quot;ns1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:0, &quot;entity_clients&quot;:0, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:5 } }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:0, &quot;non_entity_clients&quot;:0, &quot;clients&quot;:5 } } ] } ] } }, { &quot;timestamp&quot;:&quot;2021-04-01T00:00:00Z&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;namespaces&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:0, &quot;entity_clients&quot;:0, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:5 } }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:0, &quot;non_entity_clients&quot;:0, &quot;clients&quot;:5 } } ] } ], &quot;new_clients&quot;:{ &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;namespaces&quot;:[ { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:10 }, &quot;mounts&quot;:[ { &quot;path&quot;:&quot;auth/up1/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:0, &quot;entity_clients&quot;:0, &quot;non_entity_tokens&quot;:5, &quot;non_entity_clients&quot;:5, &quot;clients&quot;:5 } }, { &quot;path&quot;:&quot;auth/up2/&quot;, &quot;counts&quot;:{ &quot;distinct_entities&quot;:5, &quot;entity_clients&quot;:5, &quot;non_entity_tokens&quot;:0, &quot;non_entity_clients&quot;:0, &quot;clients&quot;:5 } } ] } ] } } ], &quot;start_time&quot;:&quot;2021-01-01T00:00:00Z&quot;, &quot;total&quot;:{ &quot;distinct_entities&quot;:20, &quot;entity_clients&quot;:20, &quot;non_entity_tokens&quot;:20, &quot;non_entity_clients&quot;:20, &quot;clients&quot;:40 } }, &quot;wrap_info&quot;:null, &quot;warnings&quot;:null, &quot;auth&quot;:null }   ","version":"Next","tagName":"h3"},{"title":"Sample request for a single month​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-for-a-single-month","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/activity?end_time=2020-06-30T00%3A00%3A00Z&amp;start_time=2020-06-01T00%3A00%3A00Z   ","version":"Next","tagName":"h3"},{"title":"Sample request to get client counts for top 2 namespaces with highest activity for a usage period​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-to-get-client-counts-for-top-2-namespaces-with-highest-activity-for-a-usage-period","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/activity?end_time=2020-06-30T00%3A00%3A00Z&amp;start_time=2020-06-01T00%3A00%3A00Z&amp;limit_namespaces=2   ","version":"Next","tagName":"h3"},{"title":"Partial month client count​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#partial-month-client-count","content":" This endpoint returns the client activity in the current month. The response will have activity attributions per namespace, per mount within each namespaces, and new clients information.  The time period is from the start of the current month, up until the time that this request was made.  Note: the client count may be inaccurate in the moments following an OpenBao reboot, or leadership change. The estimate will stabilize when background loading of client data has completed.  Method\tPathGET\t/sys/internal/counters/activity/monthly  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/activity/monthly   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-response-3","content":" { &quot;request_id&quot;: &quot;d0d37f90-96ec-28c7-b59c-b53612cbbcad&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;by_namespace&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 1 }, &quot;mounts&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;mount_path&quot;: &quot;auth_token_0747d59c&quot; } ], &quot;namespace_id&quot;: &quot;root&quot;, &quot;namespace_path&quot;: &quot;&quot; } ], &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;months&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;namespaces&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;mounts&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;mount_path&quot;: &quot;auth_token_0747d59c&quot; } ], &quot;namespace_id&quot;: &quot;root&quot;, &quot;namespace_path&quot;: &quot;&quot; } ], &quot;new_clients&quot;: { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;namespaces&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;mounts&quot;: [ { &quot;counts&quot;: { &quot;clients&quot;: 1, &quot;distinct_entities&quot;: 0, &quot;entity_clients&quot;: 0, &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 0 }, &quot;mount_path&quot;: &quot;auth_token_0747d59c&quot; } ], &quot;namespace_id&quot;: &quot;root&quot;, &quot;namespace_path&quot;: &quot;&quot; } ] }, &quot;timestamp&quot;: &quot;2022-04-01T04:00:00Z&quot; } ], &quot;non_entity_clients&quot;: 1, &quot;non_entity_tokens&quot;: 1 }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Update the client count configuration​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#update-the-client-count-configuration","content":" The /sys/internal/counters/config endpoint is used to configure logging of active clients.  Method\tPathPOST\t/sys/internal/counters/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#parameters-1","content":" default_report_months (integer: 12) - The number of months to report if no start_time is specified in a query.enabled (string: enable, disable, default) - Enable or disable counting of client activity. When set to default, the client counts are disabled. Disabling the feature during the middle of a month will discard any data recorded for that month, but does not delete previous months.retention_months (integer: 24) - The number of months of history to retain.  Any missing parameters are left at their existing value.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-payload","content":" { &quot;enabled&quot;: &quot;enable&quot;, &quot;default_report_months&quot;: 3, &quot;retention_months&quot;: 12 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-4","content":" $ curl \\ --request POST --header &quot;X-Vault-Token: ...&quot; \\ --data @payload.json http://127.0.0.1:8200/v1/sys/internal/counters/config   ","version":"Next","tagName":"h3"},{"title":"Read the client count configuration​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#read-the-client-count-configuration","content":" Reading the configuration shows the current settings, as well as a flag as to whether any data can be queried.  Method\tPathGET\t/sys/internal/counters/config  enabled (string) - returns default-enabled or default-disabled if the configuration is default.queries_available (bool) - indicates whether any usage report is available. This will initially be false until the end of the first calendar month after the feature is enabled.  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-5","content":" $ curl \\ --request GET --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/internal/counters/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-response-4","content":" { &quot;request_id&quot;: &quot;25a94b99-b49a-c4ac-cb7b-5ba0eb390a25&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;default_report_months&quot;: 12, &quot;enabled&quot;: &quot;default-enabled&quot;, &quot;queries_available&quot;: true, &quot;retention_months&quot;: 24, &quot;reporting_enabled&quot;: false, &quot;billing_start_timestamp&quot;: &quot;2022-03-01T00:00:00Z&quot;, }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Activity export​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#activity-export","content":" This endpoint returns an export of the clients that had activity within the provided start and end times. The returned set of client information will be deduplicated over the time window and will show the earliest activity logged for each client. The output will be ordered chronologically by month of activity.  warning NOTE: This endpoint is currently in tech preview status.  There are a few things to keep in mind while using this API.  The response includes the actual time period covered, which may not exactly match the query parameters due to the month granularity of data or missing months in the requested time range. If the end_date supplied to the API is for the current month, the activity information returned by this API will include activity for this month, however it may be up to 20 minutes delayed.  Method\tPathGET\t/sys/internal/counters/activity/export  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#parameters-2","content":" start_time (string, optional) - An RFC3339 timestamp or Unix epoch time. Specifies the start of the period for which client counts will be reported. If no start time is specified, the default_report_monthsprior to the end_time will be used.end_time (string, optional) - An RFC3339 timestamp or Unix epoch time. Specifies the end of the period for which client counts will be reported. If no end time is specified, the end of the previous calendar month will be used.format (string, optional) - The desired format of the output file. Allowed values are csv and json. If no format is provided a default of jsonwill be used.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/internal/counters/activity/export   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/internal/counters","url":"/openbao/api-docs/system/internal-counters/#sample-response-5","content":" {&quot;client_id&quot;:&quot;3f210722-7210-98e8-1f0d-e6a39ffb29c6&quot;,&quot;namespace_id&quot;:&quot;root&quot;,&quot;timestamp&quot;:1653350457,&quot;mount_accessor&quot;:&quot;auth_userpass_bb52979d&quot;} {&quot;client_id&quot;:&quot;X/Yed4Oj4cqODj9tSHjKwnRy5QVSBRlX3COxjjWSXyI=&quot;,&quot;namespace_id&quot;:&quot;root&quot;,&quot;timestamp&quot;:1653350491,&quot;non_entity&quot;:true,&quot;mount_accessor&quot;:&quot;auth_token_f6f2c11c&quot;} {&quot;client_id&quot;:&quot;d93405dc-b592-b1c3-a520-14e618d359c1&quot;,&quot;namespace_id&quot;:&quot;root&quot;,&quot;timestamp&quot;:1653350501,&quot;mount_accessor&quot;:&quot;auth_userpass_bb52979d&quot;}  ","version":"Next","tagName":"h3"},{"title":"/sys/leader","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/leader/","content":"","keywords":"","version":"Next"},{"title":"Read leader status​","type":1,"pageTitle":"/sys/leader","url":"/openbao/api-docs/system/leader/#read-leader-status","content":" This endpoint returns the high availability status and current leader instance of OpenBao.  Method\tPathGET\t/sys/leader  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leader","url":"/openbao/api-docs/system/leader/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/leader   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/leader","url":"/openbao/api-docs/system/leader/#sample-response","content":" { &quot;ha_enabled&quot;: true, &quot;is_self&quot;: false, &quot;leader_address&quot;: &quot;https://127.0.0.1:8200/&quot;, &quot;leader_cluster_address&quot;: &quot;https://127.0.0.1:8201/&quot;, &quot;performance_standby&quot;: false, &quot;performance_standby_last_remote_wal&quot;: 0 }  ","version":"Next","tagName":"h3"},{"title":"/sys/leases","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/leases/","content":"","keywords":"","version":"Next"},{"title":"Read lease​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#read-lease","content":" This endpoint retrieve lease metadata.  Method\tPathPOST\t/sys/leases/lookup  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters","content":" lease_id (string: &lt;required&gt;) – Specifies the ID of the lease to lookup.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-payload","content":" { &quot;lease_id&quot;: &quot;auth/userpass/login/user/h5a2...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/leases/lookup   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-response","content":" { &quot;data&quot;: { &quot;expire_time&quot;: &quot;2024-03-07T20:34:02.005655614+01:00&quot;, &quot;id&quot;: &quot;auth/userpass/login/user/h5a2d7506918f459d022267a3351666b35bd8b5d6d39b0bcfe14927c0e4464225&quot;, &quot;issue_time&quot;: &quot;2024-02-04T20:34:02.005663311+01:00&quot;, &quot;last_renewal&quot;: null, &quot;renewable&quot;: true, &quot;ttl&quot;: 2764397 } }   ","version":"Next","tagName":"h3"},{"title":"List leases​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#list-leases","content":" This endpoint returns a list of lease ids.  This endpoint requires 'sudo' capability.  Method\tPathLIST\t/sys/leases/lookup/:prefix  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/sys/leases/lookup/auth/userpass/login/user/   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;h5a2d7506918f459d022267a3351666b35bd8b5d6d39b0bcfe14927c0e4464225&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Renew lease​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#renew-lease","content":" This endpoint renews a lease, requesting to extend the lease. Token leases cannot be renewed using this endpoint, use instead the auth/token/renew endpoint.  Method\tPathPOST\t/sys/leases/renew  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters-1","content":" lease_id (string: &lt;required&gt;) – Specifies the ID of the lease to extend. This parameter can either be specified in a json request, as shown below, or provided as a path parameter to the endpoint, like /sys/leases/revoke/:lease_id. If both are provided, the leaseID in the request json takes precedence. increment (int: 0) – Specifies the requested amount of time (in seconds) to extend the lease.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-payload-1","content":" { &quot;lease_id&quot;: &quot;auth/userpass/login/user/h5a2...&quot;, &quot;increment&quot;: 1800 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/leases/renew   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-response-2","content":" { &quot;lease_id&quot;: &quot;auth/userpass/login/user/h5a2...&quot;, &quot;renewable&quot;: true, &quot;lease_duration&quot;: 2764790 }   ","version":"Next","tagName":"h3"},{"title":"Revoke lease​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#revoke-lease","content":" This endpoint revokes a lease immediately.  Method\tPathPOST\t/sys/leases/revoke  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters-2","content":" lease_id (string: &lt;required&gt;) – Specifies the ID of the lease to revoke. This parameter can either be specified in a json request, as shown below, or provided as a path parameter to the endpoint, like /sys/leases/revoke/:lease_id. If both are provided, the leaseID in the request json takes precedence.sync (bool: false) - Instead of the default behaviour of queueing the lease revocation, sync=true will revoke the lease immediately and only return once complete.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-payload-2","content":" { &quot;lease_id&quot;: &quot;postgresql/creds/readonly/abcd-1234...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/leases/revoke   ","version":"Next","tagName":"h3"},{"title":"Revoke force​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#revoke-force","content":" This endpoint revokes all secrets or tokens generated under a given prefix immediately. Unlike /sys/leases/revoke-prefix, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, OpenBao abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.  This endpoint requires 'sudo' capability.  Method\tPathPOST\t/sys/leases/revoke-force/:prefix  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters-3","content":" prefix (string: &lt;required&gt;) – Specifies the prefix to revoke. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/leases/revoke-force/auth/userpass   ","version":"Next","tagName":"h3"},{"title":"Revoke prefix​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#revoke-prefix","content":" This endpoint revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately. This requiressudo capability and access to it should be tightly controlled as it can be used to revoke very large numbers of secrets/tokens at once.  This endpoint requires 'sudo' capability.  Method\tPathPOST\t/sys/leases/revoke-prefix/:prefix  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters-4","content":" prefix (string: &lt;required&gt;) – Specifies the prefix to revoke. This is specified as part of the URL.sync (bool: false) - Instead of the default behaviour of queueing the lease revocations, sync=true will revoke ths leases immediately and only return once complete.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/leases/revoke-prefix/auth/userpass   ","version":"Next","tagName":"h3"},{"title":"Tidy leases​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#tidy-leases","content":" This endpoint cleans up the dangling storage entries for leases: for each lease entry in storage, OpenBao will verify that it has an associated valid non-expired token in storage, and if not, the lease will be revoked.  Generally, running this is not needed unless upgrade notes or support personnel suggest it. This may perform a lot of I/O to the storage method so should be used sparingly.  Method\tPathPOST\t/sys/leases/tidy  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/leases/tidy   ","version":"Next","tagName":"h3"},{"title":"Lease counts​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#lease-counts","content":" This endpoint returns the total count of a type of lease, as well as a count per mount point. Note that it currently only supports type &quot;irrevocable&quot;.  This can help determine if particular endpoints are disproportionately resulting in irrevocable leases.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters-5","content":" type (string: &lt;required&gt;) - Specifies the type of lease.include_child_namespaces (bool: false) - Specifies if leases in child namespaces should be included in the result.  Method\tPathGET\t/sys/leases/count  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/leases/count \\ -d type=irrevocable   ","version":"Next","tagName":"h3"},{"title":"Leases list​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#leases-list","content":" This endpoint returns the total count of a type of lease, as well as a list of leases per mount point. Note that it currently only supports type &quot;irrevocable&quot;.  This can help determine if particular endpoints or causes are disproportionately resulting in irrevocable leases.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#parameters-6","content":" type (string: &lt;required&gt;) - Specifies the type of lease.include_child_namespaces (bool: false) - Specifies if leases in child namespaces should be included in the resultlimit (string: &quot;&quot;) - Specifies the maximum number of leases to return in a request. To return all results, set to none. If not set, this API will return a maximum of 10,000 leases. If not set to none and there exist more leases than limit, the response will include a warning.  Method\tPathGET\t/sys/leases  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/leases","url":"/openbao/api-docs/system/leases/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/leases \\ -d type=irrevocable  ","version":"Next","tagName":"h3"},{"title":"/sys/loggers","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/loggers/","content":"","keywords":"","version":"Next"},{"title":"Modify verbosity level of all loggers​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#modify-verbosity-level-of-all-loggers","content":" Method\tPathPOST\t/sys/loggers  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#parameters","content":" level (string: &lt;required&gt;) – Specifies the log verbosity level to be set for all loggers. Supported values (in order of detail) are &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, and &quot;error&quot;.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-payload","content":" { &quot;level&quot;: &quot;debug&quot;, }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/loggers   ","version":"Next","tagName":"h3"},{"title":"Modify verbosity level of a single logger​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#modify-verbosity-level-of-a-single-logger","content":" Method\tPathPOST\t/sys/loggers/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the logger to be modified (e.g. audit, core, expiration).level (string: &lt;required&gt;) – Specifies the log verbosity level to be set for the provided logger. Supported values (in order of detail) are &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, and &quot;error&quot;.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-payload-1","content":" { &quot;level&quot;: &quot;debug&quot;, }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/loggers/core   ","version":"Next","tagName":"h3"},{"title":"Read verbosity level of all loggers​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#read-verbosity-level-of-all-loggers","content":" Method\tPathGET\t/sys/loggers  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/sys/loggers   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-response","content":" { &quot;audit&quot;: &quot;trace&quot;, &quot;core&quot;: &quot;info&quot;, &quot;policy&quot;: &quot;debug&quot; }   ","version":"Next","tagName":"h3"},{"title":"Read verbosity level of a single logger​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#read-verbosity-level-of-a-single-logger","content":" Method\tPathGET\t/sys/loggers/:name  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://127.0.0.1:8200/v1/sys/loggers/core   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-response-1","content":" { &quot;core&quot;: &quot;info&quot; }   ","version":"Next","tagName":"h3"},{"title":"Revert verbosity of all loggers to configured level​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#revert-verbosity-of-all-loggers-to-configured-level","content":" Method\tPathDELETE\t/sys/loggers  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/loggers   ","version":"Next","tagName":"h3"},{"title":"Revert verbosity of a single logger to configured level​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#revert-verbosity-of-a-single-logger-to-configured-level","content":" Method\tPathDELETE\t/sys/loggers/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the logger to be modified (e.g. audit, core, expiration).  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/loggers","url":"/openbao/api-docs/system/loggers/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/loggers/core  ","version":"Next","tagName":"h3"},{"title":"/sys/metrics","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/metrics/","content":"","keywords":"","version":"Next"},{"title":"Read telemetry metrics​","type":1,"pageTitle":"/sys/metrics","url":"/openbao/api-docs/system/metrics/#read-telemetry-metrics","content":" This endpoint returns the telemetry metrics for OpenBao. It can be used by metrics collections systems like Prometheus that use a pull model for metrics collection.  Method\tPathGET\t/sys/metrics  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/metrics","url":"/openbao/api-docs/system/metrics/#parameters","content":" format (string: &quot;&quot;) – Specifies the format used for the returned metrics. The default metrics format is JSON. Setting format to prometheus will return the metrics in Prometheus format.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/metrics","url":"/openbao/api-docs/system/metrics/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ 'http://127.0.0.1:8200/v1/sys/metrics?format=prometheus'   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/metrics","url":"/openbao/api-docs/system/metrics/#sample-response","content":" This response is only returned for a GET request.  # HELP vault_audit_log_request vault_audit_log_request # TYPE vault_audit_log_request summary vault_audit_log_request{quantile=&quot;0.5&quot;} 0.005927000194787979 vault_audit_log_request{quantile=&quot;0.9&quot;} 0.005927000194787979 vault_audit_log_request{quantile=&quot;0.99&quot;} 0.005927000194787979 vault_audit_log_request_sum 0.014550999738276005 vault_audit_log_request_count 2 # HELP vault_audit_log_request_failure vault_audit_log_request_failure # TYPE vault_audit_log_request_failure counter vault_audit_log_request_failure 0 # HELP vault_audit_log_response vault_audit_log_response # TYPE vault_audit_log_response summary vault_audit_log_response{quantile=&quot;0.5&quot;} NaN vault_audit_log_response{quantile=&quot;0.9&quot;} NaN vault_audit_log_response{quantile=&quot;0.99&quot;} NaN vault_audit_log_response_sum 0.0057669999077916145 vault_audit_log_response_count 1 # HELP vault_audit_log_response_failure vault_audit_log_response_failure # TYPE vault_audit_log_response_failure counter vault_audit_log_response_failure 0 # HELP vault_barrier_get vault_barrier_get # TYPE vault_barrier_get summary vault_barrier_get{quantile=&quot;0.5&quot;} 0.011938000097870827 vault_barrier_get{quantile=&quot;0.9&quot;} 0.011938000097870827 vault_barrier_get{quantile=&quot;0.99&quot;} 0.011938000097870827 vault_barrier_get_sum 0.1814980012131855 vault_barrier_get_count 36 ...  ","version":"Next","tagName":"h3"},{"title":"mfa-validate","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/mfa-validate/","content":"","keywords":"","version":"Next"},{"title":"Validate login MFA request​","type":1,"pageTitle":"mfa-validate","url":"/openbao/api-docs/system/mfa-validate/#validate-login-mfa-request","content":" This endpoint validates a login request which is subject to MFA validation.  Method\tPathPOST\t/sys/mfa/validate  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"mfa-validate","url":"/openbao/api-docs/system/mfa-validate/#parameters","content":" mfa_request_id (string: &lt;required&gt;) – A unique identification of an MFA restricted login request. This can be found in the MFA requirement included in the auth response of the login request. mfa_payload (map&lt;string|[]string&gt;: &lt;required&gt;) - A map of login MFA methodIDs to passcode credentials. MFA methodIDs are UUID strings which are used as keys of the map. The values of the map are string slices. In cases where an MFA method is configured not to use passcodes, the passcode remains an empty string.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"mfa-validate","url":"/openbao/api-docs/system/mfa-validate/#sample-payload","content":" { &quot;mfa_request_id&quot;: &quot;5879c74a-1418-1948-7be9-97b209d693a7&quot;, &quot;mfa_payload&quot;: { &quot;d16fd3c2-50de-0b9b-eed3-0301dadeca10&quot;: [&quot;910201&quot;] } }   It is also possible to use an MFA method name as the key to the mfa_payload.  { &quot;mfa_request_id&quot;: &quot;5879c74a-1418-1948-7be9-97b209d693a7&quot;, &quot;mfa_payload&quot;: { &quot;sample_mfa_method_name&quot;: [&quot;passcode=910201&quot;] } } ### Sample request ```shell-session $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/mfa/validate   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"mfa-validate","url":"/openbao/api-docs/system/mfa-validate/#sample-response","content":" In cases where MFA validation fails, a 403 status code is returned with the details about the error. If MFA validation succeeds, the response is identical to a successful login request which contains a client token and its accessor.  { &quot;request_id&quot;: &quot;7e7dec1d-311a-ecbd-4dd0-ff12a5e38959&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: { &quot;client_token&quot;: &quot;hvs.CAESIKZJNqQbG9E9cQGPXh68NWxi3xp7yPa1Z1RWv1P9UyHVGh4KHGh2cy5GUmYzTzdJOWhIZGFNSm5jdTBsSVNFSTk&quot;, &quot;accessor&quot;: &quot;3fBgbEmHyA5IWABmVEjqManI&quot;, &quot;policies&quot;: [ &quot;default&quot; ], &quot;token_policies&quot;: [ &quot;default&quot; ], &quot;identity_policies&quot;: null, &quot;metadata&quot;: { &quot;username&quot;: &quot;alice&quot; }, &quot;orphan&quot;: true, &quot;entity_id&quot;: &quot;caeac75b-dbfe-58be-e3fc-957549b7292e&quot;, &quot;lease_duration&quot;: 2764800, &quot;renewable&quot;: true, &quot;mfa_requirement&quot;: null } }  ","version":"Next","tagName":"h3"},{"title":"/sys/monitor","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/monitor/","content":"","keywords":"","version":"Next"},{"title":"Monitor system logs​","type":1,"pageTitle":"/sys/monitor","url":"/openbao/api-docs/system/monitor/#monitor-system-logs","content":" This endpoint streams logs back to the client from OpenBao. Note that unlike most API endpoints in OpenBao, this one does not return JSON by default. This will send back data in whatever log format OpenBao has been configured with. By default, this is text.  Method\tPathGET\t/sys/monitor  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/monitor","url":"/openbao/api-docs/system/monitor/#parameters","content":" log_level (string: &quot;info&quot;) – Specifies the log level to use when streaming logs. This defaults to infoif not specified. log_format (string: &quot;standard&quot;) – Specifies the log format to emit when streaming logs. Supported values are &quot;standard&quot; and &quot;json&quot;. The default is standard, if not specified.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/monitor","url":"/openbao/api-docs/system/monitor/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ 'http://127.0.0.1:8200/v1/sys/monitor?log_level=debug'   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/monitor","url":"/openbao/api-docs/system/monitor/#sample-response","content":" 2020-09-15T11:28:09.188-0700 [INFO] core: successful mount: namespace= path=foo/ type=kv 2020-09-15T11:28:18.265-0700 [DEBUG] core.secrets.deletion: clearing view: namespace=root path=foo/ total_keys=0 2020-09-15T11:28:18.265-0700 [DEBUG] core.secrets.deletion: view cleared: namespace=root path=foo/ 2020-09-15T11:28:18.265-0700 [INFO] core: successfully unmounted: path=foo/ namespace=  ","version":"Next","tagName":"h3"},{"title":"/sys/plugins/reload/backend","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/plugins-reload-backend/","content":"","keywords":"","version":"Next"},{"title":"Reload plugins​","type":1,"pageTitle":"/sys/plugins/reload/backend","url":"/openbao/api-docs/system/plugins-reload-backend/#reload-plugins","content":" This endpoint reloads mounted plugin backends.  Method\tPath -POST\t/sys/plugins/reload/backend  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/plugins/reload/backend","url":"/openbao/api-docs/system/plugins-reload-backend/#parameters","content":" plugin (string: &quot;&quot;) – The name of the plugin to reload, as registered in the plugin catalog. mounts (array: []) – Array or comma-separated string mount paths of the plugin backends to reload. scope (string: &quot;&quot;) - The scope of the reload. If omitted, reloads the plugin or mounts on this OpenBao instance. If 'global', will begin reloading the plugin on all instances of a cluster.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/plugins/reload/backend","url":"/openbao/api-docs/system/plugins-reload-backend/#sample-payload","content":" { &quot;plugin&quot;: &quot;mock-plugin&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/plugins/reload/backend","url":"/openbao/api-docs/system/plugins-reload-backend/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/plugins/reload/backend  ","version":"Next","tagName":"h3"},{"title":"/sys/namespaces","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/namespaces/","content":"","keywords":"","version":"Next"},{"title":"List namespaces​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#list-namespaces","content":" This endpoints lists all the namespaces.  Method\tPathLIST\t/sys/namespaces  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ -X LIST \\ http://127.0.0.1:8200/v1/sys/namespaces   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-response","content":" { &quot;data&quot;: { &quot;key_info&quot;: { &quot;bar/&quot;: { &quot;custom_metadata&quot;: {}, &quot;id&quot;: &quot;HWmNL&quot;, &quot;path&quot;: &quot;bar/&quot; }, &quot;foo/&quot;: { &quot;custom_metadata&quot;: {}, &quot;id&quot;: &quot;5q39x&quot;, &quot;path&quot;: &quot;foo/&quot; } }, &quot;keys&quot;: [ &quot;bar/&quot;, &quot;foo/&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Create namespace​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#create-namespace","content":" This endpoint creates a namespace at the given path.  Method\tPathPOST\t/sys/namespaces/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path where the namespace will be created.custom_metadata (map&lt;string|string&gt;: nil) - A map of arbitrary string to string valued user-provided metadata meant to describe the namespace.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-payload","content":" { &quot;custom_metadata&quot;: { &quot;foo&quot;: &quot;abc&quot;, &quot;bar&quot;: &quot;123&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/namespaces/ns1   ","version":"Next","tagName":"h3"},{"title":"Patch namespace​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#patch-namespace","content":" This endpoint patches an existing namespace at the specified path.  Method\tPathPATCH\t/sys/namespaces/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#parameters-1","content":" path (string: &lt;required&gt;) – Specifies the path of the existing namespace.custom_metadata (map&lt;string|string&gt;: nil) - A map of arbitrary string to string valued user-provided metadata meant to describe the namespace.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-payload-1","content":" { &quot;custom_metadata&quot;: { &quot;foo&quot;: &quot;abc&quot;, &quot;bar&quot;: &quot;123&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;Content-Type: application/merge-patch+json&quot; --request PATCH \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/namespaces/ns1   ","version":"Next","tagName":"h3"},{"title":"Delete namespace​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#delete-namespace","content":" This endpoint deletes a namespace at the specified path.  Method\tPathDELETE\t/sys/namespaces/:path  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/namespaces/ns1   ","version":"Next","tagName":"h3"},{"title":"Read namespace information​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#read-namespace-information","content":" This endpoint gets the metadata for the given namespace path.  Method\tPathGET\t/sys/namespaces/:path  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/namespaces/ns1   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/namespaces","url":"/openbao/api-docs/system/namespaces/#sample-response-1","content":" { &quot;id&quot;: &quot;gsudj&quot;, &quot;path&quot;: &quot;ns1/&quot;, &quot;custom_metadata&quot;: { &quot;foo&quot;: &quot;abc&quot;, &quot;bar&quot;: &quot;123&quot; } }  ","version":"Next","tagName":"h3"},{"title":"/sys/plugins/catalog","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/plugins-catalog/","content":"","keywords":"","version":"Next"},{"title":"LIST plugins​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#list-plugins","content":" This endpoint lists the plugins in the catalog by type.  Method\tPathGET\t/sys/plugins/catalog  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/plugins/catalog   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-response","content":" { &quot;data&quot;: { &quot;auth&quot;: [ &quot;custom-auth-plugin&quot;, &quot;ldap&quot; ], &quot;database&quot;: [ &quot;cassandra-database-plugin&quot;, &quot;mysql-database-plugin&quot;, &quot;postgresql-database-plugin&quot; ], &quot;detailed&quot;: [ { &quot;builtin&quot;: true, &quot;deprecation_status&quot;: &quot;supported&quot;, &quot;name&quot;: &quot;ldap&quot;, &quot;type&quot;: &quot;auth&quot;, &quot;version&quot;: &quot;v1.14.8+builtin.openbao&quot; }, ... { &quot;builtin&quot;: true, &quot;deprecation_status&quot;: &quot;supported&quot;, &quot;name&quot;: &quot;cassandra-database-plugin&quot;, &quot;type&quot;: &quot;database&quot;, &quot;version&quot;: &quot;v1.14.8+builtin.openbao&quot; }, ... ], &quot;secret&quot;: [ &quot;transit&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"LIST plugins​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#list-plugins-1","content":" This endpoint lists the plugins in the catalog by type.  Method\tPathLIST\t/sys/plugins/catalog/auth LIST\t/sys/plugins/catalog/database LIST\t/sys/plugins/catalog/secret  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST http://127.0.0.1:8200/v1/sys/plugins/catalog/auth   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [ &quot;custom-auth-plugin&quot;, &quot;ldap&quot; ] } }   ","version":"Next","tagName":"h3"},{"title":"Register plugin​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#register-plugin","content":" This endpoint registers a new plugin, or updates an existing one with the supplied name.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathPOST\t/sys/plugins/catalog/:type/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name for this plugin. The name is what is used to look up plugins in the catalog. This is part of the request URL. type (string: &lt;required&gt;) – Specifies the type of this plugin. May be &quot;auth&quot;, &quot;database&quot;, or &quot;secret&quot;. version (string: &quot;&quot;) - Specifies the semantic version of this plugin. sha256 (string: &lt;required&gt;) – This is the SHA256 sum of the plugin's binary. Before a plugin is run it's SHA will be checked against this value, if they do not match the plugin can not be run. command (string: &lt;required&gt;) – Specifies the command used to execute the plugin. This is relative to the plugin directory. e.g. &quot;myplugin&quot;. args (array: []) – Specifies the arguments used to execute the plugin. If the arguments are provided here, the command parameter should only contain the named program. e.g. &quot;--my_flag=1&quot;. env (array: []) – Specifies the environment variables used during the execution of the plugin. Each entry is of the form &quot;key=value&quot;. e.g&quot;FOO=BAR&quot;.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-payload","content":" { &quot;sha256&quot;: &quot;d130b9a0fbfddef9709d8ff92e5e6053ccd246b78632fc03b8548457026961e9&quot;, &quot;command&quot;: &quot;mysql-database-plugin&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/plugins/catalog/secret/example-plugin   ","version":"Next","tagName":"h3"},{"title":"Read plugin​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#read-plugin","content":" This endpoint returns the configuration data for the plugin with the given name.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathGET\t/sys/plugins/catalog/:type/:name?version=:version  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the plugin to retrieve. This is part of the request URL. type (string: &lt;required&gt;) – Specifies the type of this plugin. May be &quot;auth&quot;, &quot;database&quot;, or &quot;secret&quot;. version (string: &quot;&quot;) – The semantic version of the plugin to read. Required if the plugin was registered with a version.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/plugins/catalog/secret/example-plugin?version=v1.0.0   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-response-2","content":" { &quot;data&quot;: { &quot;args&quot;: [], &quot;builtin&quot;: false, &quot;command&quot;: &quot;/tmp/openbao-plugins/mysql-database-plugin&quot;, &quot;name&quot;: &quot;example-plugin&quot;, &quot;sha256&quot;: &quot;0TC5oPv93vlwnY/5Ll5gU8zSRreGMvwDuFSEVwJpYek=&quot;, &quot;version&quot;: &quot;v1.0.0&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Remove plugin from catalog​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#remove-plugin-from-catalog","content":" This endpoint removes the plugin with the given name.  sudo required – This endpoint requires sudo capability in addition to any path-specific capabilities.  Method\tPathDELETE\t/sys/plugins/catalog/:type/:name?version=:version  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the plugin to delete. This is part of the request URL. type (string: &lt;required&gt;) – Specifies the type of this plugin. May be &quot;auth&quot;, &quot;database&quot;, or &quot;secret&quot;. version (string: &quot;&quot;) – Specifies the semantic version of the plugin to delete.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/plugins/catalog","url":"/openbao/api-docs/system/plugins-catalog/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/plugins/catalog/secret/example-plugin?version=v1.0.0  ","version":"Next","tagName":"h3"},{"title":"/sys/policies/password/","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/policies-password/","content":"","keywords":"","version":"Next"},{"title":"Create/Update password policy​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#createupdate-password-policy","content":" This endpoint adds a new or updates an existing password policy. Once a policy is updated, it takes effect immediately to all associated secret engines.  Prior to OpenBao saving the password policy, it will attempt to generate a number of passwords from the policy. This helps prevent creating password policies that are impossible to satisfy as well as prevent password policies that are overly restrictive which prevents both a poor security posture for the policy as well as preventing performance problems due to slow generation times.  Method\tPathPOST\t/sys/policies/password/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the password policy to create. This is specified as part of the request URL. policy (string: &lt;required&gt;) - Specifies the password policy document. This can be base64-encoded to avoid string escaping. See Password Policy Syntaxfor details on password policy definitions.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-payload","content":" { &quot;policy&quot;: &quot;length = 20\\nrule \\&quot;charset\\&quot; { ...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-request","content":" cURL:  $ cat payload.json { &quot;policy&quot;: &quot;length = 20\\nrule \\&quot;charset\\&quot; {\\n charset = \\&quot;abcde\\&quot;\\n}\\n&quot; } $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/policies/password/my-policy   OpenBao CLI:  $ cat my-policy.hcl length = 20 rule &quot;charset&quot; { charset = &quot;abcde&quot; } $ openbao write sys/policies/password/my-policy policy=@my-policy.hcl   ","version":"Next","tagName":"h3"},{"title":"List password policies​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#list-password-policies","content":" This endpoints list the password policies.  Method\tPathLIST\t/sys/policies/password GET\t/sys/policies/password?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/sys/policies/password   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-response","content":" { &quot;request_id&quot;: &quot;58e2540f-8c51-6390-46de-38e279e75468&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;keys&quot;: [ &quot;my-policy&quot; ] }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Read password policy​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#read-password-policy","content":" This endpoint retrieves information about the named password policy.  Method\tPathGET\t/sys/policies/password/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the password policy to retrieve. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/policies/password/my-policy   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-response-1","content":" { &quot;policy&quot;: &quot;length = 20\\nrule \\&quot;charset\\&quot; { ...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Delete password policy​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#delete-password-policy","content":" This endpoint deletes the password policy with the given name. This does not check if any secret engines are using it prior to deletion, so you should ensure that any engines that are utilizing this password policy are changed to a different policy (or to that engines' default behavior).  Method\tPathDELETE\t/sys/policies/password/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the password policy to delete. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE http://127.0.0.1:8200/v1/sys/policies/password/my-policy   ","version":"Next","tagName":"h3"},{"title":"Generate password from password policy​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#generate-password-from-password-policy","content":" This endpoint generates a password from the specified existing password policy.  Method\tPathGET\t/sys/policies/password/:name/generate  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#parameters-3","content":" name (string: &lt;required&gt;) – Specifies the name of the password policy to generate a password from. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/policies/password/my-policy/generate   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policies/password/","url":"/openbao/api-docs/system/policies-password/#sample-response-2","content":" { &quot;password&quot;: &quot;...&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/mounts","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/mounts/","content":"","keywords":"","version":"Next"},{"title":"List mounted secrets engines​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#list-mounted-secrets-engines","content":" This endpoints lists all the mounted secrets engines.  Method\tPathGET\t/sys/mounts  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/mounts   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-response","content":" { &quot;request_id&quot;: &quot;48d2c601-97a0-3904-f549-4fcbc740d718&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;cubbyhole/&quot;: { &quot;accessor&quot;: &quot;cubbyhole_eb4503de&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0 }, &quot;description&quot;: &quot;per-token private secret storage&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: true, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;cubbyhole&quot;, &quot;uuid&quot;: &quot;79ddaa52-fa07-6f19-653a-f0777f6439fd&quot; }, &quot;identity/&quot;: { &quot;accessor&quot;: &quot;identity_68a03448&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0 }, &quot;description&quot;: &quot;identity store&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: false, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;identity&quot;, &quot;uuid&quot;: &quot;45f79a67-58f7-3f87-892c-9032084e7801&quot; }, &quot;secret/&quot;: { &quot;accessor&quot;: &quot;kv_aedd93c1&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0 }, &quot;deprecation_status&quot;: &quot;supported&quot;, &quot;description&quot;: &quot;key/value secret storage&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: false, &quot;options&quot;: { &quot;version&quot;: &quot;2&quot; }, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v0.13.0+builtin&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;kv&quot;, &quot;uuid&quot;: &quot;8074a73f-6921-c0cd-589a-016405dc46ec&quot; }, &quot;sys/&quot;: { &quot;accessor&quot;: &quot;system_f8df2902&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0, &quot;passthrough_request_headers&quot;: [&quot;Accept&quot;] }, &quot;description&quot;: &quot;system endpoints used for control, policy and debugging&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: false, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;system&quot;, &quot;uuid&quot;: &quot;c79f4f66-4cfa-4521-9d31-b1238b0a6800&quot; } }, &quot;warnings&quot;: null }   default_lease_ttl or max_lease_ttl values of 0 mean that the system defaults are used by this backend.  ","version":"Next","tagName":"h3"},{"title":"Enable secrets engine​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#enable-secrets-engine","content":" This endpoint enables a new secrets engine at the given path.  Method\tPathPOST\t/sys/mounts/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#parameters","content":" path (string: &lt;required&gt;) – Specifies the path where the secrets engine will be mounted. This is specified as part of the URL.  danger NOTE: Use ASCII printable characters to specify the desired path.  type (string: &lt;required&gt;) – Specifies the type of the backend, such as &quot;kv&quot;. description (string: &quot;&quot;) – Specifies the human-friendly description of the mount. config (map&lt;string|string&gt;: nil) – Specifies configuration options for this mount; if set on a specific mount, values will override any global defaults (e.g. the system TTL/Max TTL) default_lease_ttl (string: &quot;&quot;) - The default lease duration, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. max_lease_ttl (string: &quot;&quot;) - The maximum lease duration, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. force_no_cache (bool: false) - Disable caching. audit_non_hmac_request_keys (array: []) - List of keys that will not be HMAC'd by audit devices in the request data object. audit_non_hmac_response_keys (array: []) - List of keys that will not be HMAC'd by audit devices in the response data object. listing_visibility (string: &quot;&quot;) - Specifies whether to show this mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or&quot;hidden&quot;. If not set, behaves like &quot;hidden&quot;. passthrough_request_headers (array: []) - List of headers to allow and pass from the request to the plugin. allowed_response_headers (array: []) - List of headers to allow, allowing a plugin to include them in the response. plugin_version (string: &quot;&quot;) – Specifies the semantic version of the plugin to use, e.g. &quot;v1.0.0&quot;. If unspecified, the server will select any matching unversioned plugin that may have been registered, the latest versioned plugin registered, or a built-in plugin in that order of precendence. options (map&lt;string|string&gt;: nil) - Specifies mount type specific options that are passed to the backend. Key/Value (KV) version (string: &quot;1&quot;) - The version of the KV to mount. Set to &quot;2&quot; for mount KV v2.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-payload","content":" { &quot;type&quot;: &quot;kv&quot;, &quot;config&quot;: { &quot;force_no_cache&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/mounts/my-mount   ","version":"Next","tagName":"h3"},{"title":"Disable secrets engine​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#disable-secrets-engine","content":" This endpoint disables the mount point specified in the URL.  Method\tPath\tDELETE\t/sys/mounts/:path\t204 (empty body)  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/mounts/my-mount   ","version":"Next","tagName":"h3"},{"title":"Force disable​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#force-disable","content":" Because disabling a secrets engine revokes secrets associated with this mount, possible errors can prevent the secrets engine from being disabled if the revocation fails.  The best way to resolve this is to figure out the underlying issue and then disable the secrets engine once the underlying issue is resolved. Often, this can be as simple as increasing the timeout (in the event of timeout errors).  For recovery situations where the secret was manually removed from the secrets backing service, one can force a secrets engine disable in OpenBao by performing a force revokeon the mount prefix, followed by a secrets disable when that completes. If the underlying secrets were not manually cleaned up, this method might result in dangling credentials. This is meant for extreme circumstances.  ","version":"Next","tagName":"h3"},{"title":"Get the configuration of a secret engine​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#get-the-configuration-of-a-secret-engine","content":" This endpoint returns the configuration of a specific secret engine.  Method\tPathGET\t/sys/mounts/:path  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/mounts/cubbyhole   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-response-1","content":" { &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0 }, &quot;description&quot;: &quot;per-token private secret storage&quot;, &quot;accessor&quot;: &quot;cubbyhole_db85f061&quot;, &quot;external_entropy_access&quot;: false, &quot;options&quot;: null, &quot;uuid&quot;: &quot;9c0e211a-904d-e41d-e1a2-7f1ff2bb8461&quot;, &quot;type&quot;: &quot;cubbyhole&quot;, &quot;local&quot;: true, &quot;seal_wrap&quot;: false, &quot;request_id&quot;: &quot;efdab917-ade2-1802-b8fa-fe2e6486d4e5&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: { &quot;accessor&quot;: &quot;cubbyhole_db85f061&quot;, &quot;config&quot;: { &quot;default_lease_ttl&quot;: 0, &quot;force_no_cache&quot;: false, &quot;max_lease_ttl&quot;: 0 }, &quot;description&quot;: &quot;per-token private secret storage&quot;, &quot;external_entropy_access&quot;: false, &quot;local&quot;: true, &quot;options&quot;: null, &quot;plugin_version&quot;: &quot;&quot;, &quot;running_plugin_version&quot;: &quot;v1.12.0+builtin.openbao&quot;, &quot;running_sha256&quot;: &quot;&quot;, &quot;seal_wrap&quot;: false, &quot;type&quot;: &quot;cubbyhole&quot;, &quot;uuid&quot;: &quot;9c0e211a-904d-e41d-e1a2-7f1ff2bb8461&quot; }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Read mount configuration​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#read-mount-configuration","content":" This endpoint reads the given mount's configuration. Unlike the mountsendpoint, this will return the current time in seconds for each TTL, which may be the system default or a mount-specific value.  Method\tPathGET\t/sys/mounts/:path/tune  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/mounts/my-mount/tune   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-response-2","content":" { &quot;default_lease_ttl&quot;: 3600, &quot;max_lease_ttl&quot;: 7200, &quot;force_no_cache&quot;: false }   ","version":"Next","tagName":"h3"},{"title":"Tune mount configuration​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#tune-mount-configuration","content":" This endpoint tunes configuration parameters for a given mount point.  Method\tPathPOST\t/sys/mounts/:path/tune  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#parameters-1","content":" default_lease_ttl (int: 0) – Specifies the default time-to-live. This overrides the global default. A value of 0 is equivalent to the system default TTL. max_lease_ttl (int: 0) – Specifies the maximum time-to-live. This overrides the global default. A value of 0 are equivalent and set to the system max TTL. description (string: &quot;&quot;) – Specifies the description of the mount. This overrides the current stored value, if any. audit_non_hmac_request_keys (array: []) - Specifies the list of keys that will not be HMAC'd by audit devices in the request data object. audit_non_hmac_response_keys (array: []) - Specifies the list of keys that will not be HMAC'd by audit devices in the response data object. listing_visibility (string: &quot;&quot;) - Specifies whether to show this mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or &quot;hidden&quot;. If not set, behaves like &quot;hidden&quot;. passthrough_request_headers (array: []) - List of headers to allow and pass from the request to the plugin. allowed_response_headers (array: []) - List of headers to allow, allowing a plugin to include them in the response. plugin_version (string: &quot;&quot;) – Specifies the semantic version of the plugin to use, e.g. &quot;v1.0.0&quot;. Changes will not take effect until the mount is reloaded.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-payload-1","content":" { &quot;default_lease_ttl&quot;: 1800, &quot;max_lease_ttl&quot;: 3600 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/mounts","url":"/openbao/api-docs/system/mounts/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/mounts/my-mount/tune  ","version":"Next","tagName":"h3"},{"title":"/sys/policies/","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/policies/","content":"","keywords":"","version":"Next"},{"title":"List ACL policies​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#list-acl-policies","content":" This endpoint lists all configured ACL policies.  Method\tPathLIST\t/sys/policies/acl  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-request","content":" $ curl \\ -X LIST --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/policies/acl   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-response","content":" { &quot;keys&quot;: [&quot;root&quot;, &quot;my-policy&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Read ACL policy​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#read-acl-policy","content":" This endpoint retrieves information about the named ACL policy.  Method\tPathGET\t/sys/policies/acl/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the policy to retrieve. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/policies/acl/my-policy   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-response-1","content":" { &quot;name&quot;: &quot;deploy&quot;, &quot;policy&quot;: &quot;path \\&quot;secret/foo\\&quot; {...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Create/Update ACL policy​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#createupdate-acl-policy","content":" This endpoint adds a new or updates an existing ACL policy. Once a policy is updated, it takes effect immediately to all associated users.  Method\tPathPOST\t/sys/policies/acl/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the policy to create. This is specified as part of the request URL. policy (string: &lt;required&gt;) - Specifies the policy document. This can be base64-encoded to avoid string escaping.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-payload","content":" { &quot;policy&quot;: &quot;path \\&quot;secret/foo\\&quot; {...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/policies/acl/my-policy   ","version":"Next","tagName":"h3"},{"title":"Delete ACL policy​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#delete-acl-policy","content":" This endpoint deletes the ACL policy with the given name. This will immediately affect all users associated with this policy. (A deleted policy set on a token acts as an empty policy.)  Method\tPathDELETE\t/sys/policies/acl/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the policy to delete. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policies/","url":"/openbao/api-docs/system/policies/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/policies/acl/my-policy  ","version":"Next","tagName":"h3"},{"title":"/sys/policy","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/policy/","content":"","keywords":"","version":"Next"},{"title":"List policies​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#list-policies","content":" This endpoint lists all configured policies.  Method\tPathGET\t/sys/policy  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/policy   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-response","content":" { &quot;policies&quot;: [&quot;root&quot;, &quot;deploy&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Read policy​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#read-policy","content":" This endpoint retrieve the policy body for the named policy.  Method\tPathGET\t/sys/policy/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#parameters","content":" name (string: &lt;required&gt;) – Specifies the name of the policy to retrieve. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/policy/my-policy   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-response-1","content":" { &quot;name&quot;: &quot;my-policy&quot;, &quot;rules&quot;: &quot;path \\&quot;secret/*\\&quot;... }   ","version":"Next","tagName":"h3"},{"title":"Create/Update policy​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#createupdate-policy","content":" This endpoint adds a new or updates an existing policy. Once a policy is updated, it takes effect immediately to all associated users.  Method\tPathPOST\t/sys/policy/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#parameters-1","content":" name (string: &lt;required&gt;) – Specifies the name of the policy to create. This is specified as part of the request URL. policy (string: &lt;required&gt;) - Specifies the policy document.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-payload","content":" { &quot;policy&quot;: &quot;path \\&quot;secret/foo\\&quot; {...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/policy/my-policy   ","version":"Next","tagName":"h3"},{"title":"Delete policy​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#delete-policy","content":" This endpoint deletes the policy with the given name. This will immediately affect all users associated with this policy.  Method\tPathDELETE\t/sys/policy/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#parameters-2","content":" name (string: &lt;required&gt;) – Specifies the name of the policy to delete. This is specified as part of the request URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/policy","url":"/openbao/api-docs/system/policy/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/policy/my-policy  ","version":"Next","tagName":"h3"},{"title":"/sys/quotas/config","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/quotas-config/","content":"","keywords":"","version":"Next"},{"title":"Create or update the rate limit configuration​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#create-or-update-the-rate-limit-configuration","content":" Method\tPathPOST\t/sys/quotas/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#parameters","content":" rate_limit_exempt_paths ([]string: []) - Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt.enable_rate_limit_audit_logging (bool: false) - If set, starts audit logging of requests that get rejected due to rate limit quota rule violations.enable_rate_limit_response_headers (bool: false) - If set, additional rate limit quota HTTP headers will be added to responses.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#sample-payload","content":" { &quot;rate_limit_exempt_paths&quot;: [ &quot;sys/internal/ui/mounts&quot;, &quot;sys/generate-recovery-token/attempt&quot;, &quot;sys/generate-recovery-token/update&quot;, &quot;sys/generate-root/attempt&quot;, &quot;sys/generate-root/update&quot;, &quot;sys/health&quot;, &quot;sys/seal-status&quot;, &quot;sys/unseal&quot; ], &quot;enable_rate_limit_audit_logging&quot;: true, &quot;enable_rate_limit_response_headers&quot;: true }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#sample-request","content":" $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/quotas/config   ","version":"Next","tagName":"h3"},{"title":"Get the rate limit configuration​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#get-the-rate-limit-configuration","content":" Method\tPathGET\t/sys/quotas/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#sample-request-1","content":" $ curl \\ --request GET \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/quotas/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/quotas/config","url":"/openbao/api-docs/system/quotas-config/#sample-response","content":" { &quot;request_id&quot;: &quot;259801bd-a0c9-9350-8eb9-26c91afd19c6&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;enable_rate_limit_audit_logging&quot;: false, &quot;enable_rate_limit_response_headers&quot;: false, &quot;rate_limit_exempt_paths&quot;: [ &quot;sys/internal/ui/mounts&quot;, &quot;sys/generate-recovery-token/attempt&quot;, &quot;sys/generate-recovery-token/update&quot;, &quot;sys/generate-root/attempt&quot;, &quot;sys/generate-root/update&quot;, &quot;sys/health&quot;, &quot;sys/seal-status&quot;, &quot;sys/unseal&quot; ] }, &quot;warnings&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"/sys/pprof","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/pprof/","content":"","keywords":"","version":"Next"},{"title":"Index​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#index","content":" This endpoint returns an HTML page listing the available profiles.  Method\tPathGET\t/sys/pprof/  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/   ","version":"Next","tagName":"h3"},{"title":"Allocs​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#allocs","content":" This endpoint returns a sampling of historical memory allocations over the life of the program.  Method\tPathGET\t/sys/pprof/allocs  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/allocs   ","version":"Next","tagName":"h3"},{"title":"Block​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#block","content":" This endpoint returns a sampling of goroutines involved in blocking on synchronization primitives.  It is included for completeness, but since OpenBao doesn't normally enable collection of this data, it won't return anything useful with the standard OpenBao binary.  Method\tPathGET\t/sys/pprof/block  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/block   ","version":"Next","tagName":"h3"},{"title":"Cmdline​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#cmdline","content":" This endpoint returns the running program's command line, with arguments separated by NUL bytes.  Method\tPathGET\t/sys/pprof/cmdline  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/cmdline   ","version":"Next","tagName":"h3"},{"title":"Goroutine​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#goroutine","content":" This endpoint returns stack traces of all current goroutines.  Method\tPathGET\t/sys/pprof/goroutine  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#parameters","content":" debug (int: 0) - Specifies special arguments for the collection. A value of 2 results in the stack traces being returned as text instead of the default pprof format.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/goroutine   ","version":"Next","tagName":"h3"},{"title":"Heap​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#heap","content":" This endpoint returns a sampling of memory allocations of live object.  Method\tPathGET\t/sys/pprof/heap  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/heap   ","version":"Next","tagName":"h3"},{"title":"Mutex​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#mutex","content":" This endpoint returns a sampling of goroutines holding contended mutexes.  It is included for completeness, but since OpenBao doesn't normally enable collection of this data, it won't return anything useful with the standard OpenBao binary.  Method\tPathGET\t/sys/pprof/mutex  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/mutex   ","version":"Next","tagName":"h3"},{"title":"Profile​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#profile","content":" This endpoint returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.  Method\tPathGET\t/sys/pprof/profile  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#parameters-1","content":" seconds (int: 30) - Specifies the duration to run the profiling command. This value is specified as a query parameter.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/profile   ","version":"Next","tagName":"h3"},{"title":"Symbol​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#symbol","content":" This endpoint returns the program counters listed in the request.  Method\tPathGET\t/sys/pprof/symbol  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/symbol   ","version":"Next","tagName":"h3"},{"title":"Threadcreate​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#threadcreate","content":" This endpoint returns stack traces of goroutines that led to the creation of new OS threads.  Method\tPathGET\t/sys/pprof/threadcreate  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-9","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/threadcreate   ","version":"Next","tagName":"h3"},{"title":"Trace​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#trace","content":" This endpoint returns the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.  Method\tPathGET\t/sys/pprof/trace  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#parameters-2","content":" seconds (int: 1) - Specifies the duration to run the tracing command. This value is specified as a query parameter.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/pprof","url":"/openbao/api-docs/system/pprof/#sample-request-10","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/pprof/trace  ","version":"Next","tagName":"h3"},{"title":"/sys/quotas/rate-limit","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/rate-limit-quotas/","content":"","keywords":"","version":"Next"},{"title":"Create or update a rate limit quota​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#create-or-update-a-rate-limit-quota","content":" This endpoint is used to create a rate limit quota with an identifier, name. A rate limit quota must include a rate value with an optional path that can either be a namespace or mount, and can optionally include a path suffix following the mount to restrict more specific API paths.  Method\tPathPOST\t/sys/quotas/rate-limit/:name  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#parameters","content":" name (string: &quot;&quot;) - The name of the quota.path (string: &quot;&quot;) - Path of the mount to apply the quota.rate (float: 0.0) - The maximum number of requests in a given interval to be allowed by the quota rule. The rate must be positive.interval (string: &quot;&quot;) - The duration to enforce rate limiting for (default &quot;1s&quot;).block_interval (string: &quot;&quot;) - If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.role (string: &quot;&quot;) - If set on a quota where path is set to an auth mount with a concept of roles (such as /auth/approle/), this will make the quota restrict login requests to that mount that are made with the specified role. The request will fail if the auth mount does not have a concept of roles, or path is not an auth mount.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-payload","content":" { &quot;path&quot;: &quot;&quot;, &quot;rate&quot;: 897.3, &quot;interval&quot;: &quot;2m&quot;, &quot;block_interval&quot;: &quot;5m&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-request","content":" $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/quotas/rate-limit/global-rate-limiter   ","version":"Next","tagName":"h3"},{"title":"Delete a rate limit quota​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#delete-a-rate-limit-quota","content":" A rate limit quota can be deleted by name.  Method\tPathDELETE\t/sys/quotas/rate-limit/:name  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-request-1","content":" $ curl \\ --request DELETE \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/quotas/rate-limit/global-rate-limiter   ","version":"Next","tagName":"h3"},{"title":"Get a rate limit quota​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#get-a-rate-limit-quota","content":" A rate limit quota can be retrieved by name.  Method\tPathGET\t/sys/quotas/rate-limit/:name  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-request-2","content":" $ curl \\ --request GET \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/quotas/rate-limit/global-rate-limiter   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-response","content":" { &quot;request_id&quot;: &quot;d0870811-455d-3dfd-459f-aee016e6fb68&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;block_interval&quot;: 300, &quot;interval&quot;: 2, &quot;name&quot;: &quot;global-rate-limiter&quot;, &quot;path&quot;: &quot;&quot;, &quot;rate&quot;: 897.3, &quot;role&quot;: &quot;&quot;, &quot;type&quot;: &quot;rate-limit&quot; }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"List rate limit quotas​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#list-rate-limit-quotas","content":" This endpoint returns a list of all the rate limit quotas.  Method\tPathLIST\t/sys/quotas/rate-limit  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-request-3","content":" $ curl \\ --request LIST \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/quotas/rate-limit   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/quotas/rate-limit","url":"/openbao/api-docs/system/rate-limit-quotas/#sample-response-1","content":" { &quot;auth&quot;: null, &quot;data&quot;: { &quot;keys&quot;: [&quot;global-rate-limiter&quot;, &quot;kv-rate-limiter&quot;] }, &quot;lease_duration&quot;: 0, &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;request_id&quot;: &quot;ab633ee1-a692-ba03-083b-f1bd91c51c28&quot;, &quot;warnings&quot;: null, &quot;wrap_info&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"/sys/raw","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/raw/","content":"","keywords":"","version":"Next"},{"title":"Read raw​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#read-raw","content":" This endpoint reads the value of the key at the given path. This is the raw path in the storage backend and not the logical path that is exposed via the mount system.  Method\tPathGET\t/sys/raw/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#parameters","content":" path (string: &lt;required&gt;) – Specifies the raw path in the storage backend. This is specified as part of the URL. compressed (bool: true) - Attempt to decompress the value. encoding (string: &quot;&quot;) - Specifies the encoding of the returned data. Defaults to no encoding. &quot;base64&quot; returns the value encoded in base64.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/raw/secret/foo   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-response","content":" { &quot;value&quot;: &quot;{'foo':'bar'}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Create/Update raw​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#createupdate-raw","content":" This endpoint updates the value of the key at the given path. This is the raw path in the storage backend and not the logical path that is exposed via the mount system.  Method\tPathPOST\t/sys/raw/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#parameters-1","content":" path (string: &lt;required&gt;) – Specifies the raw path in the storage backend. This is specified as part of the URL. value (string: &lt;required&gt;) – Specifies the value of the key. compression_type (string: &quot;&quot;) - Create/update using the compressed form of value. Supported compression_typevalues are gzip, lzw, lz4, snappy, or &quot;&quot;. &quot;&quot; means no compression is used. If omitted and key already exists, update uses the same compression (or no compression) as the existing value. encoding (string: &quot;&quot;) - Specifies the encoding of value. Defaults to no encoding. Use &quot;base64&quot; if value is encoded in base64.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-payload","content":" { &quot;value&quot;: &quot;{\\&quot;foo\\&quot;: \\&quot;bar\\&quot;}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/raw/secret/foo   ","version":"Next","tagName":"h3"},{"title":"List raw​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#list-raw","content":" This endpoint returns a list keys for a given path prefix.  This endpoint requires 'sudo' capability.  Method\tPathLIST\t/sys/raw/:prefix GET\t/sys/raw/:prefix?list=true  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request LIST \\ http://127.0.0.1:8200/v1/sys/raw/logical   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-response-1","content":" { &quot;data&quot;: { &quot;keys&quot;: [&quot;abcd-1234...&quot;, &quot;efgh-1234...&quot;, &quot;ijkl-1234...&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Delete raw​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#delete-raw","content":" This endpoint deletes the key with given path. This is the raw path in the storage backend and not the logical path that is exposed via the mount system.  Method\tPathDELETE\t/sys/raw/:path  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#parameters-2","content":" path (string: &lt;required&gt;) – Specifies the raw path in the storage backend. This is specified as part of the URL.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/raw","url":"/openbao/api-docs/system/raw/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/raw/secret/foo  ","version":"Next","tagName":"h3"},{"title":"/sys/rekey-recovery-key","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/rekey-recovery-key/","content":"","keywords":"","version":"Next"},{"title":"Read rekey progress​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#read-rekey-progress","content":" This endpoint reads the configuration and progress of the current rekey attempt.  Method\tPathGET\t/sys/rekey-recovery-key/init  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/init   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-response","content":" { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 1, &quot;required&quot;: 3, &quot;pgp_fingerprints&quot;: [&quot;abcd1234&quot;], &quot;backup&quot;: true, &quot;verification_required&quot;: false }   If a rekey is started, then n is the new shares to generate and t is the threshold required for the new shares. progress is how many recovery keys have been provided for this rekey, where required must be reached to complete. Thenonce for the current rekey operation is also displayed. If PGP keys are being used to encrypt the final shares, the key fingerprints and whether the final keys will be backed up to physical storage will also be displayed.verification_required indicates whether verification was enabled for this operation.  ","version":"Next","tagName":"h3"},{"title":"Start rekey​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#start-rekey","content":" This endpoint initializes a new rekey attempt. Only a single recovery key rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.  Method\tPathPOST\t/sys/rekey-recovery-key/init  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#parameters","content":" secret_shares (int: &lt;required&gt;) – Specifies the number of shares to split the recovery key into. secret_threshold (int: &lt;required&gt;) – Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal tosecret_shares. pgp_keys (array&lt;string&gt;: nil) – Specifies an array of PGP public keys used to encrypt the output recovery key shares. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares. backup (bool: false) – Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the PGP-encrypted keys atcore/recovery-keys-backup in the physical storage backend. These can then be retrieved and removed via the sys/rekey-recovery-key/backup endpoint. require_verification (bool: false) – This turns on verification functionality. When verification is turned on, after successful authorization with the current unseal keys, the new unseal keys are returned but the recovery key is not actually rotated. The new keys must be provided to authorize the actual rotation of the key. This ensures that the new keys have been successfully saved and protects against a risk of the keys being lost after rotation but before they can be persisted. This can be used with without pgp_keys, and when used with it, it allows ensuring that the returned keys can be successfully decrypted before committing to the new shares, which the backup functionality does not provide.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-payload","content":" { &quot;secret_shares&quot;: 10, &quot;secret_threshold&quot;: 5 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/init   ","version":"Next","tagName":"h3"},{"title":"Cancel rekey​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#cancel-rekey","content":" This endpoint cancels any in-progress rekey. This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.  Method\tPathDELETE\t/sys/rekey-recovery-key/init  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/init   ","version":"Next","tagName":"h3"},{"title":"Read backup key​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#read-backup-key","content":" This endpoint returns the backup copy of PGP-encrypted recovery key shares. The returned value is the nonce of the rekey operation and a map of PGP key fingerprint to hex-encoded PGP-encrypted key.  Method\tPathGET\t/sys/rekey/recovery-key-backup  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rekey/recovery-key-backup   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-response-1","content":" { &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;keys&quot;: { &quot;abcd1234&quot;: &quot;...&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete backup key​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#delete-backup-key","content":" This endpoint deletes the backup copy of PGP-encrypted recovery key shares.  Method\tPathDELETE\t/sys/rekey/recovery-key-backup  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/rekey/recovery-key-backup   ","version":"Next","tagName":"h3"},{"title":"Submit key​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#submit-key","content":" This endpoint is used to enter a single recovery key share to progress the rekey of the OpenBao. If the threshold number of recovery key shares is reached, OpenBao will complete the rekey. Otherwise, this API must be called multiple times until that threshold is met. The rekey nonce operation must be provided with each call.  When the operation is complete, this will return a response like the example below; otherwise the response will be the same as the GET method againstsys/rekey/init, providing status on the operation itself.  If verification was requested, successfully completing this flow will immediately put the operation into a verification state, and provide the nonce for the verification operation.  Method\tPathPOST\t/sys/rekey-recovery-key/update  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#parameters-1","content":" key (string: &lt;required&gt;) – Specifies a single recovery share key. nonce (string: &lt;required&gt;) – Specifies the nonce of the rekey operation.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-payload-1","content":" { &quot;key&quot;: &quot;AB32...&quot;, &quot;nonce&quot;: &quot;abcd1234...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/update   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-response-2","content":" { &quot;complete&quot;: true, &quot;keys&quot;: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;pgp_fingerprints&quot;: [&quot;abcd1234&quot;], &quot;keys_base64&quot;: [&quot;base64keyvalue&quot;], &quot;backup&quot;: true, &quot;verification_required&quot;: true, &quot;verification_nonce&quot;: &quot;8b112c9e-2738-929d-bcc2-19aff249ff10&quot; }   If the keys are PGP-encrypted, an array of key fingerprints will also be provided (with the order in which the keys were used for encryption) along with whether or not the keys were backed up to physical storage.  ","version":"Next","tagName":"h3"},{"title":"Read rekey recovery key verification progress​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#read-rekey-recovery-key-verification-progress","content":" This endpoint reads the configuration and progress of the current rekey verification attempt.  Method\tPathGET\t/sys/rekey-recovery-key/verify  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-response-3","content":" { &quot;nonce&quot;: &quot;8b112c9e-2738-929d-bcc2-19aff249ff10&quot;, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 1 }   n is the total number of new shares that were generated and t is the threshold required for the new shares to pass verification. progress is how many of the new unseal keys have been provided for this verification operation. The nonce for the current rekey operation is also displayed.  ","version":"Next","tagName":"h3"},{"title":"Cancel rekey verification​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#cancel-rekey-verification","content":" This endpoint cancels any in-progress rekey verification operation. This clears any progress made and resets the nonce. Unlike a DELETE againstsys/rekey-recovery-key/init, this only resets the current verification operation, not the entire rekey atttempt. The return value is the same as GETalong with the new nonce.  Method\tPathDELETE\t/sys/rekey-recovery-key/verify  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-response-4","content":" { &quot;nonce&quot;: &quot;5827bbc1-0110-5725-cc21-beddc129d942&quot;, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 0 }   ","version":"Next","tagName":"h3"},{"title":"Submit verification key​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#submit-verification-key","content":" This endpoint is used to enter a single new key share to progress the rekey verification operation. If the threshold number of new key shares is reached, OpenBao will complete the rekey by performing the actual rotation of the recovery key. Otherwise, this API must be called multiple times until that threshold is met. The nonce must be provided with each call.  When the operation is complete, this will return a response like the example below; otherwise the response will be the same as the GET method againstsys/rekey-recovery-key/verify, providing status on the operation itself.  Method\tPathPOST\t/sys/rekey-recovery-key/verify  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#parameters-2","content":" key (string: &lt;required&gt;) – Specifies a single recovery share key from the new set of shares. nonce (string: &lt;required&gt;) – Specifies the nonce of the rekey verification operation.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-payload-2","content":" { &quot;key&quot;: &quot;A58d...&quot;, &quot;nonce&quot;: &quot;5a27bbc1...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rekey-recovery-key/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey-recovery-key","url":"/openbao/api-docs/system/rekey-recovery-key/#sample-response-5","content":" { &quot;nonce&quot;: &quot;5827bbc1-0110-5725-cc21-beddc129d942&quot;, &quot;complete&quot;: true }  ","version":"Next","tagName":"h3"},{"title":"Remount ( API )","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/remount/","content":"","keywords":"","version":"Next"},{"title":"Move backend​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#move-backend","content":" The /sys/remount endpoint moves an already-mounted backend to a new mount point. Remounting works for both secret engines and auth methods.  OpenBao returns a migration ID when the remount operation completes. You can use the migration ID to look up the status of the mount migration. More details about the remount operation are described inMount Migration.  warning Note: This endpoint requires a policy with both sudo and update capabilities to sys/remount  warning Note: A mount migration will revoke all leases for the secrets of a secrets backend or tokens of an auth backend, depending on which type of backend is being moved.  Method\tPathPOST\t/sys/remount  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#parameters","content":" from (string: &lt;required&gt;) – Specifies the previous mount point. to (string: &lt;required&gt;) – Specifies the new destination mount point.  ","version":"Next","tagName":"h3"},{"title":"Sample payload ( cross namespace )​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-payload--cross-namespace-","content":" { &quot;from&quot;: &quot;ns1/ns2/secret&quot;, &quot;to&quot;: &quot;ns1/ns3/new-secret&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample payload ( cross namespace, auth mount )​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-payload--cross-namespace-auth-mount-","content":" { &quot;from&quot;: &quot;ns1/ns2/auth/approle&quot;, &quot;to&quot;: &quot;ns1/ns3/auth/new-approle&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample payload ( within namespace )​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-payload--within-namespace-","content":" { &quot;from&quot;: &quot;secret&quot;, &quot;to&quot;: &quot;new-secret&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/remount   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-response","content":" { &quot;migration_id&quot;: &quot;ef3ba21c-8be8-4e5f-8d00-cb46a532c665&quot; }   ","version":"Next","tagName":"h3"},{"title":"Monitor migration status​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#monitor-migration-status","content":" This endpoint is used to monitor the status of a mount migration operation, using the ID returned in the response of the sys/remount call. The response contains the passed-in ID, the source and target mounts, and a status field that displays in-progress, success or failure.  Method\tPathGET\t/sys/remount/status/:migration_id  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#parameters-1","content":" migration_id (string: &lt;required&gt;) – Specifies the id of the mount migration  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/remount/status/ef3ba21c-8be8-4e5f-8d00-cb46a532c665   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"Remount ( API )","url":"/openbao/api-docs/system/remount/#sample-response-1","content":" { &quot;migration_id&quot;: &quot;ef3ba21c-8be8-4e5f-8d00-cb46a532c665&quot;, &quot;migration_info&quot;: { &quot;source_mount&quot;: &quot;ns1/ns2/secret&quot;, &quot;target_mount&quot;: &quot;ns1/ns3/new-secret&quot;, &quot;status&quot;: &quot;in-progress&quot;, } }  ","version":"Next","tagName":"h3"},{"title":"/sys/rotate/config","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/rotate-config/","content":"","keywords":"","version":"Next"},{"title":"Configure automatic key rotation​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#configure-automatic-key-rotation","content":" This endpoint configures the automatic rotation of the backend encryption key. By default, the key is rotated after just under 4 billion encryptions, to satisfy the recommendation of NIST SP 800-38D. One can configure rotations after fewer encryptions or on a time based schedule.  ","version":"Next","tagName":"h2"},{"title":"Create or update the auto rotation configuration​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#create-or-update-the-auto-rotation-configuration","content":" Method\tPathPOST\t/sys/rotate/config  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#parameters","content":" max_operations (int: 3865470566) - Specify the limit of encryptions after which the key will be automatically rotated. The number must be between 1,000,000 and the default.interval `(string: &quot;&quot;) - If set, the age of the active key at which an automatic rotation is triggered. Specified as a Go duration string (e.g. 4320h), the value must be at least 24 hours.enabled (bool: true) - If set to false, automatic rotations will not be performed. Tracking of encryption counts will continue.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#sample-payload","content":" { &quot;max_operations&quot;: 2000000000, &quot;interval&quot;: &quot;4320h&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#sample-request","content":" $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rotate/config   ","version":"Next","tagName":"h3"},{"title":"Get the auto rotation configuration​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#get-the-auto-rotation-configuration","content":" Method\tPathGET\t/sys/rotate/config  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#sample-request-1","content":" $ curl \\ --request GET \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rotate/config   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rotate/config","url":"/openbao/api-docs/system/rotate-config/#sample-response","content":" { &quot;request_id&quot;: &quot;f3d91b4a-69bf-4aaf-b928-df7a5486c130&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;max_operations&quot;: 2000000000, &quot;interval&quot;: &quot;4320h&quot;, &quot;enabled&quot;: true }, &quot;warnings&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"/sys/rekey","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/rekey/","content":"","keywords":"","version":"Next"},{"title":"Read rekey progress​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#read-rekey-progress","content":" This endpoint reads the configuration and progress of the current rekey attempt.  Method\tPathGET\t/sys/rekey/init  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rekey/init   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-response","content":" { &quot;started&quot;: true, &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 1, &quot;required&quot;: 3, &quot;pgp_fingerprints&quot;: [&quot;abcd1234&quot;], &quot;backup&quot;: true, &quot;verification_required&quot;: false }   If a rekey is started, then n is the new shares to generate and t is the threshold required for the new shares. progress is how many unseal keys have been provided for this rekey, where required must be reached to complete. Thenonce for the current rekey operation is also displayed. If PGP keys are being used to encrypt the final shares, the key fingerprints and whether the final keys will be backed up to physical storage will also be displayed.verification_required indicates whether verification was enabled for this operation.  ","version":"Next","tagName":"h3"},{"title":"Start rekey​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#start-rekey","content":" This endpoint initializes a new rekey attempt. Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.  Method\tPathPOST\t/sys/rekey/init  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#parameters","content":" secret_shares (int: &lt;required&gt;) – Specifies the number of shares to split the root key into. secret_threshold (int: &lt;required&gt;) – Specifies the number of shares required to reconstruct the root key. This must be less than or equal tosecret_shares. pgp_keys (array&lt;string&gt;: nil) – Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares. backup (bool: false) – Specifies if using PGP-encrypted keys, whether OpenBao should also store a plaintext backup of the PGP-encrypted keys atcore/unseal-keys-backup in the physical storage backend. These can then be retrieved and removed via the sys/rekey/backup endpoint. require_verification (bool: false) – This turns on verification functionality. When verification is turned on, after successful authorization with the current unseal keys, the new unseal keys are returned but the master key is not actually rotated. The new keys must be provided to authorize the actual rotation of the root key. This ensures that the new keys have been successfully saved and protects against a risk of the keys being lost after rotation but before they can be persisted. This can be used with or withoutpgp_keys, and when used with it, it allows ensuring that the returned keys can be successfully decrypted before committing to the new shares, which the backup functionality does not provide.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-payload","content":" { &quot;secret_shares&quot;: 10, &quot;secret_threshold&quot;: 5 }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rekey/init   ","version":"Next","tagName":"h3"},{"title":"Cancel rekey​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#cancel-rekey","content":" This endpoint cancels any in-progress rekey. This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.  Method\tPathDELETE\t/sys/rekey/init  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/rekey/init   ","version":"Next","tagName":"h3"},{"title":"Read backup key​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#read-backup-key","content":" This endpoint returns the backup copy of PGP-encrypted unseal keys. The returned value is the nonce of the rekey operation and a map of PGP key fingerprint to hex-encoded PGP-encrypted key.  Method\tPathGET\t/sys/rekey/backup  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rekey/backup   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-response-1","content":" { &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;keys&quot;: { &quot;abcd1234&quot;: &quot;...&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Delete backup key​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#delete-backup-key","content":" This endpoint deletes the backup copy of PGP-encrypted unseal keys.  Method\tPathDELETE\t/sys/rekey/backup  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/rekey/backup   ","version":"Next","tagName":"h3"},{"title":"Submit key​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#submit-key","content":" This endpoint is used to enter a single root key share to progress the rekey of the OpenBao. If the threshold number of root key shares is reached, OpenBao will complete the rekey. Otherwise, this API must be called multiple times until that threshold is met. The rekey nonce operation must be provided with each call.  When the operation is complete, this will return a response like the example below; otherwise the response will be the same as the GET method againstsys/rekey/init, providing status on the operation itself.  If verification was requested, successfully completing this flow will immediately put the operation into a verification state, and provide the nonce for the verification operation.  Method\tPathPOST\t/sys/rekey/update  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#parameters-1","content":" key (string: &lt;required&gt;) – Specifies a single master share key. nonce (string: &lt;required&gt;) – Specifies the nonce of the rekey operation.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-payload-1","content":" { &quot;key&quot;: &quot;AB32...&quot;, &quot;nonce&quot;: &quot;abcd1234...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rekey/update   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-response-2","content":" { &quot;complete&quot;: true, &quot;keys&quot;: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], &quot;nonce&quot;: &quot;2dbd10f1-8528-6246-09e7-82b25b8aba63&quot;, &quot;pgp_fingerprints&quot;: [&quot;abcd1234&quot;], &quot;keys_base64&quot;: [&quot;base64keyvalue&quot;], &quot;backup&quot;: true, &quot;verification_required&quot;: true, &quot;verification_nonce&quot;: &quot;8b112c9e-2738-929d-bcc2-19aff249ff10&quot; }   If the keys are PGP-encrypted, an array of key fingerprints will also be provided (with the order in which the keys were used for encryption) along with whether or not the keys were backed up to physical storage.  ","version":"Next","tagName":"h3"},{"title":"Read rekey verification progress​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#read-rekey-verification-progress","content":" This endpoint reads the configuration and progress of the current rekey verification attempt.  Method\tPathGET\t/sys/rekey/verify  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/rekey/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-response-3","content":" { &quot;nonce&quot;: &quot;8b112c9e-2738-929d-bcc2-19aff249ff10&quot;, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 1 }   n is the total number of new shares that were generated and t is the threshold required for the new shares to pass verification. progress is how many of the new unseal keys have been provided for this verification operation. The nonce for the current rekey operation is also displayed.  ","version":"Next","tagName":"h3"},{"title":"Cancel rekey verification​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#cancel-rekey-verification","content":" This endpoint cancels any in-progress rekey verification operation. This clears any progress made and resets the nonce. Unlike a DELETE againstsys/rekey/init, this only resets the current verification operation, not the entire rekey attempt. The return value is the same as GET along with the new nonce.  Method\tPathDELETE\t/sys/rekey/verify  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-7","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request DELETE \\ http://127.0.0.1:8200/v1/sys/rekey/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-response-4","content":" { &quot;nonce&quot;: &quot;5827bbc1-0110-5725-cc21-beddc129d942&quot;, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 0 }   ","version":"Next","tagName":"h3"},{"title":"Submit verification key​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#submit-verification-key","content":" This endpoint is used to enter a single new key share to progress the rekey verification operation. If the threshold number of new key shares is reached, OpenBao will complete the rekey by performing the actual rotation of the master key. Otherwise, this API must be called multiple times until that threshold is met. The nonce must be provided with each call.  When the operation is complete, this will return a response like the example below; otherwise the response will be the same as the GET method againstsys/rekey/verify, providing status on the operation itself.  Method\tPathPOST\t/sys/rekey/verify  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#parameters-2","content":" key (string: &lt;required&gt;) – Specifies a single master share key from the new set of shares. nonce (string: &lt;required&gt;) – Specifies the nonce of the rekey verification operation.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-payload-2","content":" { &quot;key&quot;: &quot;A58d...&quot;, &quot;nonce&quot;: &quot;5a27bbc1...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-request-8","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/rekey/verify   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/rekey","url":"/openbao/api-docs/system/rekey/#sample-response-5","content":" { &quot;nonce&quot;: &quot;5827bbc1-0110-5725-cc21-beddc129d942&quot;, &quot;complete&quot;: true }  ","version":"Next","tagName":"h3"},{"title":"/sys/seal-status","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/seal-status/","content":"","keywords":"","version":"Next"},{"title":"Seal status​","type":1,"pageTitle":"/sys/seal-status","url":"/openbao/api-docs/system/seal-status/#seal-status","content":" This endpoint returns the seal status of the OpenBao. This is an unauthenticated endpoint.  Method\tPathGET\t/sys/seal-status  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/seal-status","url":"/openbao/api-docs/system/seal-status/#sample-request","content":" $ curl \\ http://127.0.0.1:8200/v1/sys/seal-status   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/seal-status","url":"/openbao/api-docs/system/seal-status/#sample-response","content":" The &quot;t&quot; parameter is the threshold, and &quot;n&quot; is the number of shares.  { &quot;type&quot;: &quot;shamir&quot;, &quot;initialized&quot;: true, &quot;sealed&quot;: true, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 2, &quot;nonce&quot;: &quot;&quot;, &quot;version&quot;: &quot;1.11.0&quot;, &quot;build_date&quot;: &quot;2022-05-03T08:34:11Z&quot;, &quot;migration&quot;: false, &quot;recovery_seal&quot;: false, &quot;storage_type&quot;: &quot;file&quot; }   Sample response when OpenBao is unsealed.  { &quot;type&quot;: &quot;shamir&quot;, &quot;initialized&quot;: true, &quot;sealed&quot;: false, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 0, &quot;nonce&quot;: &quot;&quot;, &quot;version&quot;: &quot;1.11.0&quot;, &quot;build_date&quot;: &quot;2022-05-03T08:34:11Z&quot;, &quot;migration&quot;: false, &quot;cluster_name&quot;: &quot;openbao-cluster-336172e1&quot;, &quot;cluster_id&quot;: &quot;f94053ad-d80e-4270-2006-2efd67d0910a&quot;, &quot;recovery_seal&quot;: false, &quot;storage_type&quot;: &quot;file&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/rotate","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/rotate/","content":"","keywords":"","version":"Next"},{"title":"Rotate encryption key​","type":1,"pageTitle":"/sys/rotate","url":"/openbao/api-docs/system/rotate/#rotate-encryption-key","content":" This endpoint triggers a rotation of the backend encryption key. This is the key that is used to encrypt data written to the storage backend, and is not provided to operators. This operation is done online. Future values are encrypted with the new key, while old values are decrypted with previous encryption keys.  This path requires sudo capability in addition to update.  Method\tPathPOST\t/sys/rotate  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/rotate","url":"/openbao/api-docs/system/rotate/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/rotate  ","version":"Next","tagName":"h3"},{"title":"/sys/seal","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/seal/","content":"","keywords":"","version":"Next"},{"title":"Seal​","type":1,"pageTitle":"/sys/seal","url":"/openbao/api-docs/system/seal/#seal","content":" This endpoint seals the OpenBao. In HA mode, only an active node can be sealed. Standby nodes should be restarted to get the same effect. Requires a token withroot policy or sudo capability on the path.  Method\tPathPOST\t/sys/seal  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/seal","url":"/openbao/api-docs/system/seal/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/seal  ","version":"Next","tagName":"h3"},{"title":"/sys/step-down","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/step-down/","content":"","keywords":"","version":"Next"},{"title":"Step down leader​","type":1,"pageTitle":"/sys/step-down","url":"/openbao/api-docs/system/step-down/#step-down-leader","content":" This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again. Requires a token with root policy or sudo capability on the path.  Method\tPathPOST\t/sys/step-down  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/step-down","url":"/openbao/api-docs/system/step-down/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/step-down  ","version":"Next","tagName":"h3"},{"title":"/sys/storage","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/storage/","content":"/sys/storage This API sub-section is currently only used to manage Raft storage backend.","keywords":"","version":"Next"},{"title":"/sys/tools","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/tools/","content":"","keywords":"","version":"Next"},{"title":"Generate random bytes​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#generate-random-bytes","content":" This endpoint returns high-quality random bytes of the specified length.  Method\tPathPOST\t/sys/tools/random(/:source)(/:bytes)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#parameters","content":" bytes (int: 32) – Specifies the number of bytes to return. This value can be specified either in the request body, or as a part of the URL. format (string: &quot;base64&quot;) – Specifies the output encoding. Valid options are hex or base64. source (string: &quot;platform&quot;) - Specifies the source of the requested bytes.platform, the default, sources bytes from the platform's entropy source.all mixes bytes from all available sources.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#sample-payload","content":" { &quot;format&quot;: &quot;hex&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/tools/random/164   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#sample-response","content":" { &quot;data&quot;: { &quot;random_bytes&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Hash data​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#hash-data","content":" This endpoint returns the cryptographic hash of given data using the specified algorithm.  Method\tPathPOST\t/sys/tools/hash(/:algorithm)  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#parameters-1","content":" algorithm (string: &quot;sha2-256&quot;) – Specifies the hash algorithm to use. This can also be specified as part of the URL. Currently-supported algorithms are: sha2-224sha2-256sha2-384sha2-512sha3-224sha3-256sha3-384sha3-512  warning Note: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: sha3-224, sha3-256, sha3-384, andsha3-512.  input (string: &lt;required&gt;) – Specifies the base64 encoded input data. format (string: &quot;hex&quot;) – Specifies the output encoding. This can be eitherhex or base64.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#sample-payload-1","content":" { &quot;input&quot;: &quot;adba32==&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/tools/hash/sha2-512   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/tools","url":"/openbao/api-docs/system/tools/#sample-response-1","content":" { &quot;data&quot;: { &quot;sum&quot;: &quot;dGhlIHF1aWNrIGJyb3duIGZveAo=&quot; } }  ","version":"Next","tagName":"h3"},{"title":"/sys/unseal","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/unseal/","content":"","keywords":"","version":"Next"},{"title":"Submit unseal key​","type":1,"pageTitle":"/sys/unseal","url":"/openbao/api-docs/system/unseal/#submit-unseal-key","content":" This endpoint is used to enter a single root key share to progress the unsealing of the OpenBao. If the threshold number of root key shares is reached, OpenBao will attempt to unseal the OpenBao. Otherwise, this API must be called multiple times until that threshold is met.  Either the key or reset parameter must be provided; if both are provided,reset takes precedence.  Method\tPathPOST\t/sys/unseal  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/unseal","url":"/openbao/api-docs/system/unseal/#parameters","content":" key (string: &quot;&quot;) – Specifies a single root key share. This is required unless reset is true. reset (bool: false) – Specifies if previously-provided unseal keys are discarded and the unseal process is reset. migrate (bool: false) - Available in 1.0 - Used to migrate the seal from shamir to autoseal or autoseal to shamir. Must be provided on all unseal key calls.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/unseal","url":"/openbao/api-docs/system/unseal/#sample-payload","content":" { &quot;key&quot;: &quot;abcd1234...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/unseal","url":"/openbao/api-docs/system/unseal/#sample-request","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/unseal   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/unseal","url":"/openbao/api-docs/system/unseal/#sample-response","content":" The &quot;t&quot; parameter is the threshold, and &quot;n&quot; is the number of shares.  { &quot;sealed&quot;: true, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 2, &quot;version&quot;: &quot;0.6.2&quot; }   Sample response when OpenBao is unsealed.  { &quot;sealed&quot;: false, &quot;t&quot;: 3, &quot;n&quot;: 5, &quot;progress&quot;: 0, &quot;version&quot;: &quot;0.6.2&quot;, &quot;cluster_name&quot;: &quot;openbao-cluster-d6ec3c7f&quot;, &quot;cluster_id&quot;: &quot;3e8b3fec-3749-e056-ba41-b62a63b997e8&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/storage/raft","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/storage/raft/","content":"","keywords":"","version":"Next"},{"title":"Join a raft cluster​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#join-a-raft-cluster","content":" This endpoint joins a new server node to the Raft cluster. When using Shamir seal, as soon as the OpenBao server is brought up, this API should be invoked instead of sys/init. This API completes in 2 phases. Once this is invoked, the joining node will receive a challenge from the Raft's leader node. This challenge can be answered by the joining node only after a successful unseal. Hence, the joining node should be unsealed using the unseal keys of the Raft's leader node.  Method\tPathPOST\t/sys/storage/raft/join  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#parameters","content":" leader_api_addr (string: &lt;required&gt;) – Address of the leader node in the Raft cluster to which this node is trying to join. retry (bool: false) - Retry joining the Raft cluster in case of failures. leader_ca_cert (string: &quot;&quot;) - CA certificate used to communicate with Raft's leader node. leader_client_cert (string: &quot;&quot;) - Client certificate used to communicate with Raft's leader node. leader_client_key (string: &quot;&quot;) - Client key used to communicate with Raft's leader node. leader_tls_servername (string: &quot;&quot;) - TLS servername to use when connecting with HTTPS. Should match one of the names in the DNS SANs of the remote server certificate. auto_join (string: &quot;&quot;) - Defines any cloud auto-join metadata. If supplied, OpenBao will attempt to automatically discover peers in addition to what can be provided via 'leader_api_addr'. auto_join_scheme (string: &quot;https&quot;) - URI scheme to be used for auto_join. auto_join_port (int: 8200) - Port to be used for auto_join.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-payload","content":" { &quot;leader_api_addr&quot;: &quot;https://127.0.0.1:8200&quot;, &quot;leader_ca_cert&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDKTCCAhGgAwIBAgIUcd+Uyk1Tz+FhcbYP0zmynlkARoEwDQYJKoZIhvcNAQEL\\nBQAwFDESMBAGA1UEAxMJbG9jYWxob3N0MB4XDTE5MDYyNDIyMjgzNVoXDTE5MDYy\\nNzIyMjkwNVowADCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKdYr6rU\\n21vYf7q/cpPigtBchqHvGZvpbA9DZucuUdQ0g4oAXRyShQ8omzmZOmO4A1GI3gqz\\nHBePSYl+1IZCwgbPBk2CH7MhlMMINdwoEH6IxFgHNBkNK6GbwnGLyKL0Sym88ly1\\n+sPP6+llS8uWNKu5GcObHLysD3Ce6QTt3usDPiw0cxp/KL1EkMi2dT7PvxTsX137\\nsEsuQcylltGEtRb67xvFBP8XhQZAEGw+u4S3EmtwWMwZixB45WQhj2Ncz5U0+w8V\\ncp9DSqB1QheoGPBBI62jHle05kzG85ZKmLBgHE6HEGS8biIHpannM7dgI0cRH6i2\\nF69N0rcbzK+NInUCAwEAAaOBhjCBgzAOBgNVHQ8BAf8EBAMCA6gwHQYDVR0lBBYw\\nFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBQelJT5fthHdbCyD5zaI4tw\\n7mfp8zAfBgNVHSMEGDAWgBSuG6hyoOWoiGvSA3kqwo9DirS+pzASBgNVHREBAf8E\\nCDAGhwR/AAABMA0GCSqGSIb3DQEBCwUAA4IBAQCmetSH5w835RbbyHZD8e3ClHzi\\n210SrvzWkx3N0JcBOjs47jlLuqVTl0HRr2xMoIkErFbhPDBXARYV8eezhQ6G5M60\\n8AwVsG56rCa1l0weK2JfnEWgkwXZ/zbpZ2yNkWatWNSHdlJwGp99JTSriQYNOnMG\\nWvBDA8ukoOkIJd/a8+aXZBdUiAcFvlLWmX73pYGTlnQDiIqJvhrlkgCKPvzZqvV+\\njtz7kCt9EfT6sN6Xcny7GusRBSs+XfEe8u10+mbud+ufE/QSJ2D3tTYrS6eGqpVD\\nrezD8jS9PfZgQfHXVaphMADyw4flaSVxfJ/ZRFxXql3oJSuj02+VX6QsXex+\\n-----END CERTIFICATE-----&quot;, &quot;leader_client_cert&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIDNTCCAh2gAwIBAgIULkPFG+qu7tGv21Plc1sg4eGbMPkwDQYJKoZIhvcNAQEL\\nBQAwFDESMBAGA1UEAxMJbG9jYWxob3N0MB4XDTE5MDYyNDIyMjgwNVoXDTI5MDYy\\nMTIyMjgzNVowFDESMBAGA1UEAxMJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEAwszD+A5vWD8S1N632ElHA5Px2dk97wJBKNYc/7RPNptn\\n+EOmMTXPfuA3LB92FoSMCR7ye3wvSTzyK9nqafS7U2tlOF4PJrJoNZyzrVwBVLXg\\n7Pd8qQxnxbonc3bscWZuEfbFsugkPHgBtnSkyCffXKhhwM5LbJqmK5cfJRZZ0eRy\\nwmOCQCJ8ZmN2KfjHiGSEw9v19CNtvFNLyfiTZZLO9M5n4dgainZZCs+vdKD7tSJf\\nycwWiZ4ezOwLMIgxdbLYKVglbZsPcMVVPLTskmY8WiHUM6sy3HAbFQn20Rj7JGE6\\nldR3NX80YtCMt8/d+xzBfxu4x8juxHCgZFGt3nUS0wIDAQABo38wfTAOBgNVHQ8B\\nAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUrhuocqDlqIhr0gN5\\nKsKPQ4q0vqcwHwYDVR0jBBgwFoAUrhuocqDlqIhr0gN5KsKPQ4q0vqcwGgYDVR0R\\nBBMwEYIJbG9jYWxob3N0hwR/AAABMA0GCSqGSIb3DQEBCwUAA4IBAQBRno9NOaat\\n8g1ma/6OxP1JUt1VRao4+t2GQTCJ697d2SmpHr8CYanMPog+QhDj/lderA/oS0V3\\n2jruH9CyH0smFMIsLBZpnRIwdhTISbIXdU3Uvcd6nne/f7LiUUmqf8YS9SHxWPFq\\nI72QvtPrsjYKCZwJsHZe071lYScjrjGnlUhhbrug2g6/ZMHJ7mndGE022zMn/XD/\\njrrKE6fCDCjJ4PRrta7+G7BvsFHqMSQ+2/947TGohxW69cbNyDeiQVDQ5mpJUy2b\\nnOCVVnq0nafSuvBTHCCLxjd7f+9TiB/B3qT8GA9V6LANDSdQ15MRIhpup/yosmqX\\nl5goCY/j3bDh\\n-----END CERTIFICATE-----&quot;, &quot;leader_client_key&quot;: &quot;-----BEGIN RSA PRIVATE KEY-----\\nMIIEpAIBAAKCAQEAp1ivqtTbW9h/ur9yk+KC0FyGoe8Zm+lsD0Nm5y5R1DSDigBd\\nHJKFDyibOZk6Y7gDUYjeCrMcF49JiX7UhkLCBs8GTYIfsyGUwwg13CgQfojEWAc0\\nGQ0roZvCcYvIovRLKbzyXLX6w8/r6WVLy5Y0q7kZw5scvKwPcJ7pBO3e6wM+LDRz\\nGn8ovUSQyLZ1Ps+/FOxfXfuwSy5BzKWW0YS1FvrvG8UE/xeFBkAQbD67hLcSa3BY\\nzBmLEHjlZCGPY1zPlTT7DxVyn0NKoHVCF6gY8EEjraMeV7TmTMbzlkqYsGAcTocQ\\nZLxuIgelqeczt2AjRxEfqLYXr03StxvMr40idQIDAQABAoIBAHCOhhkw8hnklITX\\nIAm34KSklylz2JW1eqkJfL0huogwigjYFciSBE0d0sn69fr8Wb8Nf8tSjSKLjbqd\\nQ/TKEhbiSCr5yriBbb2AWDmr+OwisW1D6xaudRpN2Yrlqh1wkt2P6LPS8sehodtp\\n9oEIloSqC1o1ii6czAXD3JckJzuJ66yoVyCo2oVC3NETujjJRhdRcNY0dYUGx47M\\n+hQo7b4s79wlMFmccrgyJcKI7Ra3DtMrBIaVXm4WcjX2x4DduZX6L4mfG83uLWng\\nhbvcEPKGamUErjPGYixKE5XOwgJT6Nzq/ZZJZpok6DbHBCtqvwwByWlfLzh8lc4o\\nz+Pl5EECgYEA3pJXRM+SdVUCnWIpMFOAiNstOwz3nm0/c8GDdYYNq0ere1tKCVV0\\nii+ujMQY8vEdRrp7fbqJEPJANyI6sM4Jc2nxMveFuBoEsEClZuE4KBFquW8CQU4R\\nGNkzKF1W0GaTI5O4QDUag+lFG6TPCwZiejTIkt65o5bnSzGLgdC546sCgYEAwHr9\\nlq9HytWkV9OLz0zbcAUEIrFAljnC32Mybsj8LzdSKIZ3wErf9Txh8zqZqMyhedxL\\nOn17cpJAq5Vi71uXOaxnhkf7TPuRs8nBRRJfgyNHPXuXLkuWeuvXEe/PIC+nvOIX\\nas0Ab0Pvx0fRGl4EkZ2pV9oDAEUezbVVZCoO8l8CgYEAp4p3YNfzwpj0d+5tXPBu\\ngBakzJ+tQjewnP1dbLk1TuqLXjdQ2wfVyzOrbFEtCquPwy8bSICDLxt8VURR88eU\\n+6kTJK+InBYR029GUtRUhmzd7qpugyQ14IOXa9ofQI8GUbCf8M1IoWWWXQHJzN3I\\ngX98QHqiOU+d2k94WYb6dzMCgYA3E7p2oMdZShLRss3hzqtH/Zd2WeQSWIrjox3u\\nR4Kp/Bl9UST5GDPHl7SrhcwsWgmmthusq/VkDmeE8aUyurGmJigla3mESMQjfwrX\\nue8sti6PcEsNS0HPAKc1EbriCeDkkomC3RBPxk/ZZTp3YgnKpSOs6MxNCnpLAKVj\\nmQlX3wKBgQCFYyYJdCKMoaoMrNjMM34sAfTqmZT4Hbxg9KM4OMDSxyvIi0ZaVcnB\\nkzssvt0FOMucp4o7h8Iujt8xsgnBHwg81IV7WOw+ZwpUDAzgVc7+kCU6CLd2Q40j\\n5uFnuRgiWeGm1aT4arNLWlJrDLSGbyrf59SlGJV1hmu/7SMaYIZHSQ==\\n-----END RSA PRIVATE KEY-----&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/storage/raft/join   Note: Unseal the joining node immediately after this API is invoked.  ","version":"Next","tagName":"h3"},{"title":"Read raft configuration​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#read-raft-configuration","content":" This endpoint returns the details of all the nodes in the raft cluster.  Method\tPathGET\t/sys/storage/raft/configuration  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/storage/raft/configuration   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-response","content":" { &quot;request_id&quot;: &quot;ca4b5a1d-38d6-e27e-e756-269521328a15&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;config&quot;: { &quot;index&quot;: 24, &quot;servers&quot;: [ { &quot;address&quot;: &quot;127.0.0.1:8201&quot;, &quot;leader&quot;: true, &quot;node_id&quot;: &quot;raft1&quot;, &quot;protocol_version&quot;: &quot;\\u0003&quot;, &quot;voter&quot;: true }, { &quot;address&quot;: &quot;127.0.0.2:8201&quot;, &quot;leader&quot;: false, &quot;node_id&quot;: &quot;raft2&quot;, &quot;protocol_version&quot;: &quot;\\u0003&quot;, &quot;voter&quot;: true } ] } }, &quot;warnings&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Remove a node from raft cluster​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#remove-a-node-from-raft-cluster","content":" This endpoint removes a node from the raft cluster. An optional dr_operation_tokenmay be provided if the node is in a DR secondary cluster.  Method\tPathPOST\t/sys/storage/raft/remove-peer  ","version":"Next","tagName":"h2"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-payload-1","content":" { &quot;server_id&quot;: &quot;raft1&quot;, &quot;dr_operation_token&quot;: &quot;&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/storage/raft/remove-peer   ","version":"Next","tagName":"h3"},{"title":"Take a snapshot of the raft cluster​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#take-a-snapshot-of-the-raft-cluster","content":" This endpoint returns a snapshot of the current state of the raft cluster. The snapshot is returned as binary data and should be redirected to a file. Unavailable if Raft is used exclusively for ha_storage.  Method\tPathGET\t/sys/storage/raft/snapshot  ","version":"Next","tagName":"h2"},{"title":"Large raft snapshots","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/##","content":" Taking and restoring Raft snapshots can exceed OpenBao's default and recommended timeout settings. TheVAULT_CLIENT_TIMEOUT environment variable can be used to allow for more time to take or restore a snapshot.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request-3","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/storage/raft/snapshot &gt; raft.snap   ","version":"Next","tagName":"h3"},{"title":"Restore raft using a snapshot​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#restore-raft-using-a-snapshot","content":" Installs the provided snapshot, returning the cluster to the state defined in it. Unavailable if Raft is used exclusively for ha_storage.  Method\tPathPOST\t/sys/storage/raft/snapshot  ","version":"Next","tagName":"h2"},{"title":"Large raft snapshots","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/##","content":" Taking and restoring Raft snapshots can exceed OpenBao's default and recommended timeout settings. TheVAULT_CLIENT_TIMEOUT environment variable can be used to allow for more time to take or restore a snapshot.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request-4","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data-binary @raft.snap \\ http://127.0.0.1:8200/v1/sys/storage/raft/snapshot   ","version":"Next","tagName":"h3"},{"title":"Force restore raft using a snapshot​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#force-restore-raft-using-a-snapshot","content":" Installs the provided snapshot, returning the cluster to the state defined in it. This is same as writing to /sys/storage/raft/snapshot except that this bypasses checks ensuring the Autounseal or shamir keys are consistent with the snapshot data. Unavailable if Raft is used exclusively for ha_storage.  Method\tPathPOST\t/sys/storage/raft/snapshot-force  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request-5","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data-binary @raft.snap \\ http://127.0.0.1:8200/v1/sys/storage/raft/snapshot-force   ","version":"Next","tagName":"h3"},{"title":"Bootstrap an HA node​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#bootstrap-an-ha-node","content":" When a node uses Raft exclusively for ha_storage, this endpoint is used to activate Raft. It is analogous to using sys/init to initialize storage, in that it only needs to be done once per cluster, after which openbao operator raft joinis used to add more nodes to the Raft cluster.  Method\tPathPOST\t/sys/storage/raft/bootstrap  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft","url":"/openbao/api-docs/system/storage/raft/#sample-request-6","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/storage/raft/bootstrap  ","version":"Next","tagName":"h3"},{"title":"/sys/storage/raft/autopilot","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/storage/raftautopilot/","content":"","keywords":"","version":"Next"},{"title":"Get cluster state​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#get-cluster-state","content":" This endpoint is used to retrieve the raft cluster state. See the docs page for a description of the output.  Method\tPathGET\t/sys/storage/raft/autopilot/state  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/storage/raft/autopilot/state   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#sample-response","content":" { &quot;healthy&quot;: true, &quot;failure_tolerance&quot;: 1, &quot;servers&quot;: { &quot;raft1&quot;: { &quot;id&quot;: &quot;raft1&quot;, &quot;name&quot;: &quot;raft1&quot;, &quot;address&quot;: &quot;127.0.0.1:8201&quot;, &quot;node_status&quot;: &quot;alive&quot;, &quot;last_contact&quot;: &quot;0s&quot;, &quot;last_term&quot;: 3, &quot;last_index&quot;: 459, &quot;healthy&quot;: true, &quot;stable_since&quot;: &quot;2021-03-19T20:14:11.831678-04:00&quot;, &quot;status&quot;: &quot;leader&quot;, &quot;meta&quot;: null }, &quot;raft2&quot;: { &quot;id&quot;: &quot;raft2&quot;, &quot;name&quot;: &quot;raft2&quot;, &quot;address&quot;: &quot;127.0.0.2:8201&quot;, &quot;node_status&quot;: &quot;alive&quot;, &quot;last_contact&quot;: &quot;516.49595ms&quot;, &quot;last_term&quot;: 3, &quot;last_index&quot;: 459, &quot;healthy&quot;: true, &quot;stable_since&quot;: &quot;2021-03-19T20:14:19.831931-04:00&quot;, &quot;status&quot;: &quot;voter&quot;, &quot;meta&quot;: null }, &quot;raft3&quot;: { &quot;id&quot;: &quot;raft3&quot;, &quot;name&quot;: &quot;raft3&quot;, &quot;address&quot;: &quot;127.0.0.3:8201&quot;, &quot;node_status&quot;: &quot;alive&quot;, &quot;last_contact&quot;: &quot;196.706591ms&quot;, &quot;last_term&quot;: 3, &quot;last_index&quot;: 459, &quot;healthy&quot;: true, &quot;stable_since&quot;: &quot;2021-03-19T20:14:25.83565-04:00&quot;, &quot;status&quot;: &quot;voter&quot;, &quot;meta&quot;: null } }, &quot;leader&quot;: &quot;raft1&quot;, &quot;voters&quot;: [&quot;raft1&quot;, &quot;raft2&quot;, &quot;raft3&quot;], &quot;non_voters&quot;: null }   ","version":"Next","tagName":"h3"},{"title":"Get configuration​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#get-configuration","content":" This endpoint is used to get the configuration of the autopilot subsystem of Integrated Storage.  Method\tPathGET\t/sys/storage/raft/autopilot/configuration  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#sample-request-1","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/storage/raft/autopilot/configuration   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#sample-response-1","content":" { &quot;cleanup_dead_servers&quot;: false, &quot;dead_server_last_contact_threshold&quot;: &quot;24h0m0s&quot;, &quot;last_contact_threshold&quot;: &quot;10s&quot;, &quot;max_trailing_logs&quot;: 1000, &quot;min_quorum&quot;: 0, &quot;server_stabilization_time&quot;: &quot;10s&quot; }   ","version":"Next","tagName":"h3"},{"title":"Set configuration​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#set-configuration","content":" This endpoint is used to modify the configuration of the autopilot subsystem of Integrated Storage.  Method\tPathPOST\t/sys/storage/raft/autopilot/configuration  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#parameters","content":" cleanup_dead_servers (bool: false) - Controls whether to remove dead servers from the Raft peer list periodically or when a new server joins. This requires thatmin_quorum is also set. last_contact_threshold (string: &quot;10s&quot;) - Limit on the amount of time a server can go without leader contact before being considered unhealthy. dead_server_last_contact_threshold (string: &quot;24h&quot;) - Limit on the amount of time a server can go without leader contact before being considered failed. This takes effect only when cleanup_dead_servers is true. This can not be set to a value smaller than 1m. max_trailing_logs (int: 1000) - Amount of entries in the Raft Log that a server can be behind before being considered unhealthy. min_quorum (int: 3) - Minimum number of servers allowed in a cluster before autopilot can prune dead servers. This should at least be 3. Applicable only for voting nodes. server_stabilization_time (string: &quot;10s&quot;) - Minimum amount of time a server must be in a stable, healthy state before it can be added to the cluster.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/storage/raft/autopilot/configuration   ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/storage/raft/autopilot","url":"/openbao/api-docs/system/storage/raftautopilot/#sample-payload","content":" { &quot;cleanup_dead_servers&quot;: true, &quot;last_contact_threshold&quot;: &quot;10s&quot;, &quot;dead_server_last_contact_threshold&quot;: &quot;24h&quot;, &quot;max_trailing_logs&quot;: &quot;1000&quot;, &quot;min_quorum&quot;: &quot;3&quot;, &quot;server_stabilization_time&quot;: &quot;10s&quot; }  ","version":"Next","tagName":"h3"},{"title":"/sys/locked-users","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/user-lockout/","content":"","keywords":"","version":"Next"},{"title":"List locked users​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#list-locked-users","content":" The list endpoint returns information on the users currently locked by OpenBao.  The response will include all child namespaces of the namespace in which the request was made. If some namespace has subsequently been deleted, its path will be listed as &quot;deleted namespace :ID:.&quot; Deleted namespaces are reported only for queries in the root namespace because the information about the namespace path is unknown. The response will be returned in the decreasing order of locked user counts.  Method\tPathGET\t/sys/locked-users  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#parameters","content":" mount_accessor (string, optional) - Specifies the identifier of the auth mount entry to which the user belongs in the namespace in which the request was made. If no mount accessor is specified, the response includes locked users in all child namespaces of the namespace in which the request was made.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request GET \\ http://127.0.0.1:8200/v1/sys/locked-users   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#sample-response","content":" { &quot;request_id&quot;:&quot;26be5ab9-dcac-9237-ec12-269a8ca647d5&quot;, &quot;lease_id&quot;:&quot;&quot;, &quot;renewable&quot;:false, &quot;lease_duration&quot;:0, &quot;data&quot;:{ &quot;by_namespace&quot;:[ { &quot;namespace_id&quot;:&quot;BzIex&quot;, &quot;namespace_path&quot;:&quot;ns1/&quot;, &quot;counts&quot;: 3, &quot;mount_accessors&quot;:[ { &quot;mount_accessor&quot;:&quot;auth_userpass_79e2fe02&quot;, &quot;counts&quot;:3, &quot;alias_identifiers&quot;:[ {&quot;user3&quot;}, {&quot;user4&quot;}, {&quot;user5&quot;}, ] }, ] }, { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:2, &quot;mount_accessors&quot;:[ { &quot;mount_accessor&quot;:&quot;auth_userpass_837f35fc&quot;, &quot;counts&quot;:2, &quot;alias_identifiers&quot;:[ {&quot;user1&quot;}, {&quot;user2&quot;} ] }, ] }, { &quot;namespace_id&quot;:&quot;v1lb9&quot;, &quot;namespace_path&quot;:&quot;ns1/ns2/&quot;, &quot;counts&quot;:1, &quot;mount_accessors&quot;:[ { &quot;mount_accessor&quot;:&quot;auth_userpass_af8d1d32&quot;, &quot;counts&quot;:1, &quot;alias_identifiers&quot;:[ {&quot;user6&quot;} ] }, ] } ], &quot;total&quot;:6 }, &quot;wrap_info&quot;:null, &quot;warnings&quot;:null, &quot;auth&quot;:null }   For deleted namespaces, the response will look like:  { &quot;request_id&quot;:&quot;26be5ab9-dcac-9237-ec12-269a8ca647d5&quot;, &quot;lease_id&quot;:&quot;&quot;, &quot;renewable&quot;:false, &quot;lease_duration&quot;:0, &quot;data&quot;:{ &quot;by_namespace&quot;:[ { &quot;namespace_id&quot;:&quot;BzIex&quot;, &quot;namespace_path&quot;:&quot;ns1/&quot;, &quot;counts&quot;: 3, &quot;mount_accessors&quot;:[ { &quot;mount_accessor&quot;:&quot;auth_userpass_79e2fe02&quot;, &quot;counts&quot;:3, &quot;alias_identifiers&quot;:[ {&quot;user3&quot;}, {&quot;user4&quot;}, {&quot;user5&quot;}, ] }, ] }, { &quot;namespace_id&quot;:&quot;root&quot;, &quot;namespace_path&quot;:&quot;&quot;, &quot;counts&quot;:2, &quot;mount_accessors&quot;:[ { &quot;mount_accessor&quot;:&quot;auth_userpass_837f35fc&quot;, &quot;counts&quot;:2, &quot;alias_identifiers&quot;:[ {&quot;user1&quot;}, {&quot;user2&quot;} ] }, ] }, { &quot;namespace_id&quot;:&quot;v1lb9&quot;, &quot;namespace_path&quot;:&quot;deleted namespace v1lb9&quot;, &quot;counts&quot;:1, &quot;mount_accessors&quot;:[ { &quot;mount_accessor&quot;:&quot;auth_userpass_af8d1d32&quot;, &quot;counts&quot;:1, &quot;alias_identifiers&quot;:[ {&quot;user6&quot;} ] }, ] } ], &quot;total&quot;:6 }, &quot;wrap_info&quot;:null, &quot;warnings&quot;:null, &quot;auth&quot;:null }   ","version":"Next","tagName":"h3"},{"title":"Sample request with mount accessor​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#sample-request-with-mount-accessor","content":" Sample payload​  { &quot;mount_accessor&quot;: &quot;auth_userpass_af8d1d32&quot; }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --data @payload.json \\ --request GET \\ http://127.0.0.1:8200/v1/sys/locked-users   ","version":"Next","tagName":"h3"},{"title":"Unlock user​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#unlock-user","content":" The unlock user endpoint frees a locked user with the provided mount_accessor and alias_identifier in the given namespace. The unlock command is idempotent. Calls to the endpoint succeed even if the user matching the provided mount_accessor and alias_identifier is not currently locked.  Method\tPathPOST\t/sys/locked-users/:mount_accessor/unlock/:alias-identifier  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#parameters-1","content":" mount_accessor (string, required) - Specifies the identifier of the auth mount entry to which the user belongsalias_identifier (string, required) - The name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID. If the alias belongs to an ldap auth method, the name should be a valid username.  ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/locked-users","url":"/openbao/api-docs/system/user-lockout/#sample-request-2","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/locked-users/auth_userpass_af8d1d32/unlock/bsmith  ","version":"Next","tagName":"h3"},{"title":"/sys/version-history","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/version-history/","content":"","keywords":"","version":"Next"},{"title":"Read version history​","type":1,"pageTitle":"/sys/version-history","url":"/openbao/api-docs/system/version-history/#read-version-history","content":" This endpoint returns the version history of the OpenBao. The response will contain the following keys:  keys: a list of installed versions in chronological order based on the time installedkey_info: a map indexed by the versions found in the keys list containing the following subkeys: build_date: the time (in UTC) at which the OpenBao binary used to run the OpenBao server was built.previous_version: the version installed prior to this version or null if no prior version existstimestamp_installed: the time (in UTC) at which the version was installed  Method\tPathLIST\t/sys/version-history  ","version":"Next","tagName":"h2"},{"title":"Sample request​","type":1,"pageTitle":"/sys/version-history","url":"/openbao/api-docs/system/version-history/#sample-request","content":" $ curl \\ -X LIST --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/sys/version-history   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/version-history","url":"/openbao/api-docs/system/version-history/#sample-response","content":" { &quot;keys&quot;: [&quot;1.9.0&quot;, &quot;1.9.1&quot;, &quot;1.9.2&quot;, &quot;1.11.0&quot;], &quot;key_info&quot;: { &quot;1.9.0&quot;: { &quot;build_date&quot;: null, &quot;previous_version&quot;: null, &quot;timestamp_installed&quot;: &quot;2021-11-18T10:23:16Z&quot; }, &quot;1.9.1&quot;: { &quot;build_date&quot;: null, &quot;previous_version&quot;: &quot;1.9.0&quot;, &quot;timestamp_installed&quot;: &quot;2021-12-13T11:09:52Z&quot; }, &quot;1.9.2&quot;: { &quot;build_date&quot;: null, &quot;previous_version&quot;: &quot;1.9.1&quot;, &quot;timestamp_installed&quot;: &quot;2021-12-23T10:56:37Z&quot; }, &quot;1.11.0&quot;: { &quot;build_date&quot;: &quot;2022-05-03T08:34:11Z&quot;, &quot;previous_version&quot;: null, &quot;timestamp_installed&quot;: &quot;2022-05-03T13:16:04Z&quot; } } }  ","version":"Next","tagName":"h3"},{"title":"/sys/wrapping/lookup","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/wrapping-lookup/","content":"","keywords":"","version":"Next"},{"title":"Wrapping lookup​","type":1,"pageTitle":"/sys/wrapping/lookup","url":"/openbao/api-docs/system/wrapping-lookup/#wrapping-lookup","content":" This endpoint looks up wrapping properties for the given token.  Method\tPathPOST\t/sys/wrapping/lookup  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/wrapping/lookup","url":"/openbao/api-docs/system/wrapping-lookup/#parameters","content":" token (string: &lt;required&gt;) – Specifies the wrapping token ID.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/wrapping/lookup","url":"/openbao/api-docs/system/wrapping-lookup/#sample-payload","content":" { &quot;token&quot;: &quot;abcd1234&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/wrapping/lookup","url":"/openbao/api-docs/system/wrapping-lookup/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/wrapping/lookup   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/wrapping/lookup","url":"/openbao/api-docs/system/wrapping-lookup/#sample-response","content":" { &quot;request_id&quot;: &quot;481320f5-fdf8-885d-8050-65fa767fd19b&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;creation_path&quot;: &quot;sys/wrapping/wrap&quot;, &quot;creation_time&quot;: &quot;2016-09-28T14:16:13.07103516-04:00&quot;, &quot;creation_ttl&quot;: 300 }, &quot;wrap_info&quot;: null, &quot;warnings&quot;: null, &quot;auth&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"/sys/wrapping/rewrap","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/wrapping-rewrap/","content":"","keywords":"","version":"Next"},{"title":"Wrapping rewrap​","type":1,"pageTitle":"/sys/wrapping/rewrap","url":"/openbao/api-docs/system/wrapping-rewrap/#wrapping-rewrap","content":" This endpoint rewraps a response-wrapped token. The new token will use the same creation TTL as the original token and contain the same response. The old token will be invalidated. This can be used for long-term storage of a secret in a response-wrapped token when rotation is a requirement.  Method\tPathPOST\t/sys/wrapping/rewrap  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/wrapping/rewrap","url":"/openbao/api-docs/system/wrapping-rewrap/#parameters","content":" token (string: &lt;required&gt;) – Specifies the wrapping token ID.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/wrapping/rewrap","url":"/openbao/api-docs/system/wrapping-rewrap/#sample-payload","content":" { &quot;token&quot;: &quot;abcd1234...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/wrapping/rewrap","url":"/openbao/api-docs/system/wrapping-rewrap/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/wrapping/rewrap   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/wrapping/rewrap","url":"/openbao/api-docs/system/wrapping-rewrap/#sample-response","content":" { &quot;request_id&quot;: &quot;&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: { &quot;token&quot;: &quot;3b6f1193-0707-ac17-284d-e41032e74d1f&quot;, &quot;ttl&quot;: 300, &quot;creation_time&quot;: &quot;2016-09-28T14:22:26.486186607-04:00&quot;, &quot;creation_path&quot;: &quot;sys/wrapping/wrap&quot; } }  ","version":"Next","tagName":"h3"},{"title":"/sys/wrapping/unwrap","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/wrapping-unwrap/","content":"","keywords":"","version":"Next"},{"title":"Wrapping unwrap​","type":1,"pageTitle":"/sys/wrapping/unwrap","url":"/openbao/api-docs/system/wrapping-unwrap/#wrapping-unwrap","content":" This endpoint returns the original response inside the given wrapping token. Unlike simply reading cubbyhole/response (which is deprecated), this endpoint provides additional validation checks on the token, returns the original value on the wire rather than a JSON string representation of it, and ensures that the response is properly audit-logged.  This endpoint can be used by using a wrapping token as the client token in the API call, in which case the token parameter is not required; or, a different token with permissions to access this endpoint can make the call and pass in the wrapping token in the token parameter. Do not use the wrapping token in both locations; this will cause the wrapping token to be revoked but the value to be unable to be looked up, as it will basically be a double-use of the token!  Method\tPathPOST\t/sys/wrapping/unwrap  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/wrapping/unwrap","url":"/openbao/api-docs/system/wrapping-unwrap/#parameters","content":" token (string: &quot;&quot;) – Specifies the wrapping token ID. This is required if the client token is not the wrapping token. Do not use the wrapping token in both locations.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/wrapping/unwrap","url":"/openbao/api-docs/system/wrapping-unwrap/#sample-payload","content":" { &quot;token&quot;: &quot;abcd1234...&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/wrapping/unwrap","url":"/openbao/api-docs/system/wrapping-unwrap/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/wrapping/unwrap   Or you can use token to unwrap without authentication in OpenBao:  $ curl \\ --header &quot;X-Vault-Token: abcd1234...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/sys/wrapping/unwrap   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/wrapping/unwrap","url":"/openbao/api-docs/system/wrapping-unwrap/#sample-response","content":" { &quot;request_id&quot;: &quot;8e33c808-f86c-cff8-f30a-fbb3ac22c4a8&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 2592000, &quot;renewable&quot;: false, &quot;data&quot;: { &quot;zip&quot;: &quot;zap&quot; }, &quot;warnings&quot;: null }  ","version":"Next","tagName":"h3"},{"title":"Documentation","type":0,"sectionRef":"#","url":"/openbao/docs/","content":"Documentation Welcome to the OpenBao documentation! This documentation is more of a reference guide for all available features and options of OpenBao. If you're just getting started with OpenBao, please start with the introduction instead, and work your way up to the Getting Started guide.","keywords":"","version":"Next"},{"title":"/sys/wrapping/wrap","type":0,"sectionRef":"#","url":"/openbao/api-docs/system/wrapping-wrap/","content":"","keywords":"","version":"Next"},{"title":"Wrapping wrap​","type":1,"pageTitle":"/sys/wrapping/wrap","url":"/openbao/api-docs/system/wrapping-wrap/#wrapping-wrap","content":" This endpoint wraps the given user-supplied data inside a response-wrapped token.  Method\tPathPOST\t/sys/wrapping/wrap  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"/sys/wrapping/wrap","url":"/openbao/api-docs/system/wrapping-wrap/#parameters","content":" :any (map&lt;string|string&gt;: nil) – Parameters should be supplied as keys/values in a JSON object. The exact set of given parameters will be contained in the wrapped response.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"/sys/wrapping/wrap","url":"/openbao/api-docs/system/wrapping-wrap/#sample-payload","content":" { &quot;foo&quot;: &quot;bar&quot;, &quot;zip&quot;: &quot;zap&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"/sys/wrapping/wrap","url":"/openbao/api-docs/system/wrapping-wrap/#sample-request","content":" $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;X-Vault-Wrap-TTL: 60&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/wrapping/wrap   ","version":"Next","tagName":"h3"},{"title":"Sample response​","type":1,"pageTitle":"/sys/wrapping/wrap","url":"/openbao/api-docs/system/wrapping-wrap/#sample-response","content":" { &quot;request_id&quot;: &quot;&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: null, &quot;warnings&quot;: null, &quot;wrap_info&quot;: { &quot;token&quot;: &quot;fb79b9d3-d94e-9eb6-4919-c559311133d6&quot;, &quot;ttl&quot;: 300, &quot;creation_time&quot;: &quot;2016-09-28T14:41:00.56961496-04:00&quot;, &quot;creation_path&quot;: &quot;sys/wrapping/wrap&quot; } }  ","version":"Next","tagName":"h3"},{"title":"OpenBao agent and OpenBao proxy","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/","content":"","keywords":"","version":"Next"},{"title":"Introduce OpenBao agent and OpenBao proxy to the workflow​","type":1,"pageTitle":"OpenBao agent and OpenBao proxy","url":"/openbao/docs/agent-and-proxy/#introduce-openbao-agent-and-openbao-proxy-to-the-workflow","content":" OpenBao Agent and OpenBao Proxy aim to remove this initial hurdle to adopt OpenBao by providing a more scalable and simpler way for applications to integrate with OpenBao. OpenBao Agent can obtain secrets and provide them to applications, and OpenBao Proxy can act as a proxy between OpenBao and the application, optionally simplifying the authentication process and caching requests.  Capability\tOpenBao Agent\tOpenBao ProxyAuto-Auth to authenticate with OpenBao\tx\tx Caching the newly created tokens and leases\tx\tx Run as a Windows Service\tx Templating to render user-supplied templates\tx API Proxy to act as a proxy for OpenBao API\tWill be deprecated\tx Process Supervisor for injecting secrets as environment variables into a process\tx\t  To learn more, refer to the OpenBao Agent or OpenBao Proxy documentation page. ","version":"Next","tagName":"h3"},{"title":"OpenBao agent API proxy","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/apiproxy/","content":"","keywords":"","version":"Next"},{"title":"Functionality​","type":1,"pageTitle":"OpenBao agent API proxy","url":"/openbao/docs/agent-and-proxy/agent/apiproxy/#functionality","content":" The listener stanza for OpenBao Agent configures a listener for OpenBao Agent. If its role is not set to metrics_only, it will act as a proxy for the OpenBao server that has been configured in the vault stanza of OpenBao Agent. This enables access to the OpenBao API from the Agent API, and can be configured to optionally allow or force the automatic use of the Auto-Auth token for these requests, as described below.  If a listener has been configured alongside a cache stanza, the API Proxy will first attempt to utilize the cache subsystem for qualifying requests, before forwarding the request to OpenBao. See the caching docs for more information on caching.  ","version":"Next","tagName":"h2"},{"title":"Using Auto-Auth token​","type":1,"pageTitle":"OpenBao agent API proxy","url":"/openbao/docs/agent-and-proxy/agent/apiproxy/#using-auto-auth-token","content":" OpenBao Agent allows for easy authentication to OpenBao in a wide variety of environments using Auto-Auth. By setting theuse_auto_auth_token (see below) configuration, clients will not be required to provide an OpenBao token to the requests made to the Agent. When this configuration is set, if the request doesn't already bear a token, then the auto-auth token will be used to forward the request to the OpenBao server. This configuration will be overridden if the request already has a token attached, in which case, the token present in the request will be used to forward the request to the OpenBao server.  ","version":"Next","tagName":"h2"},{"title":"Forcing Auto-Auth token​","type":1,"pageTitle":"OpenBao agent API proxy","url":"/openbao/docs/agent-and-proxy/agent/apiproxy/#forcing-auto-auth-token","content":" OpenBao Agent can be configured to force the use of the auto-auth token by using the value force for the use_auto_auth_token option. This configuration overrides the default behavior described above in Using Auto-Auth Token, and instead ignores any existing OpenBao token in the request and instead uses the auto-auth token.  ","version":"Next","tagName":"h2"},{"title":"Configuration (api_proxy)​","type":1,"pageTitle":"OpenBao agent API proxy","url":"/openbao/docs/agent-and-proxy/agent/apiproxy/#configuration-api_proxy","content":" The top level api_proxy block has the following configuration entries:  use_auto_auth_token (bool/string: false) - If set, the requests made to Agent without an OpenBao token will be forwarded to the OpenBao server with the auto-auth token attached. If the requests already bear a token, this configuration will be overridden and the token in the request will be used to forward the request to the OpenBao server. If set to &quot;force&quot; Agent will use the auto-auth token, overwriting the attached OpenBao token if set.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"OpenBao agent API proxy","url":"/openbao/docs/agent-and-proxy/agent/apiproxy/#example-configuration","content":" Here is an example of a listener configuration alongside api_proxy configuration to force the use of the auto_auth token and enforce consistency.  # Other OpenBao agent configuration blocks # ... api_proxy { use_auto_auth_token = &quot;force&quot; } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true }  ","version":"Next","tagName":"h3"},{"title":"OpenBao agent persistent caching","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/caching/persistent-caches/","content":"","keywords":"","version":"Next"},{"title":"OpenBao agent persistent cache types​","type":1,"pageTitle":"OpenBao agent persistent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/persistent-caches/#openbao-agent-persistent-cache-types","content":" Please see the sidebar for available types and their usage/configuration.  ","version":"Next","tagName":"h2"},{"title":"Persistent cache example configuration​","type":1,"pageTitle":"OpenBao agent persistent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/persistent-caches/#persistent-cache-example-configuration","content":" Here is an example of a persistent cache configuration.  # Other OpenBao agent configuration blocks # ... cache { persist &quot;kubernetes&quot; { path = &quot;/openbao/agent-cache&quot; } }  ","version":"Next","tagName":"h2"},{"title":"OpenBao agent caching","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/caching/","content":"","keywords":"","version":"Next"},{"title":"Caching and renewals​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#caching-and-renewals","content":" Response caching and renewals are managed by the agent only under these specific scenarios.  Token creation requests are made through the agent. This means that any login operations performed using various auth methods and invoking the token creation endpoints of the token auth method via the agent will result in the response getting cached by the agent. Responses containing new tokens will be cached by the agent only if the parent token is already being managed by the agent or if the new token is an orphan token. Leased secret creation requests are made through the agent using tokens that are already managed by the agent. This means that any dynamic credentials that are issued using the tokens managed by the agent, will be cached and its renewals are taken care of.  ","version":"Next","tagName":"h2"},{"title":"Persistent cache​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#persistent-cache","content":" OpenBao Agent can restore tokens and leases from a persistent cache file created by a previous OpenBao Agent process.  Refer to the OpenBao Agent Persistent Caching page for more information on this functionality.  ","version":"Next","tagName":"h2"},{"title":"Cache evictions​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#cache-evictions","content":" The eviction of cache entries pertaining to secrets will occur when the agent can no longer renew them. This can happen when the secrets hit their maximum TTL or if the renewals result in errors.  Agent does some best-effort cache evictions by observing specific request types and response codes. For example, if a token revocation request is made via the agent and if the forwarded request to the OpenBao server succeeds, then agent evicts all the cache entries associated with the revoked token. Similarly, any lease revocation operation will also be intercepted by the agent and the respective cache entries will be evicted.  Note that while agent evicts the cache entries upon secret expirations and upon intercepting revocation requests, it is still possible for the agent to be completely unaware of the revocations that happen through direct client interactions with the OpenBao server. This could potentially lead to stale cache entries. For managing the stale entries in the cache, an endpoint/agent/v1/cache-clear(see below) is made available to manually evict cache entries based on some of the query criteria used for indexing the cache entries.  ","version":"Next","tagName":"h2"},{"title":"Request uniqueness​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#request-uniqueness","content":" In order to detect repeat requests and return cached responses, agent will need to have a way to uniquely identify the requests. This computation as it stands today takes a simplistic approach (may change in future) of serializing and hashing the HTTP request along with all the headers and the request body. This hash value is then used as an index into the cache to check if the response is readily available. The consequence of this approach is that the hash value for any request will differ if any data in the request is modified. This has the side-effect of resulting in false negatives if say, the ordering of the request parameters are modified. As long as the requests come in without any change, caching behavior should be consistent. Identical requests with differently ordered request values will result in duplicated cache entries. A heuristic assumption that the clients will use consistent mechanisms to make requests, thereby resulting in consistent hash values per request is the idea upon which the caching functionality is built upon.  ","version":"Next","tagName":"h2"},{"title":"Renewal management​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#renewal-management","content":" The tokens and leases are renewed by the agent using the secret renewer that is made available via the OpenBao server's Go API. Agent performs all operations in memory and does not persist anything to storage. This means that when the agent is shut down, all the renewal operations are immediately terminated and there is no way for agent to resume renewals after the fact. Note that shutting down the agent does not indicate revocations of the secrets, instead it only means that renewal responsibility for all the valid unrevoked secrets are no longer performed by the OpenBao agent.  ","version":"Next","tagName":"h2"},{"title":"Agent CLI​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#agent-cli","content":" Agent's listener address will be picked up by the CLI through theVAULT_AGENT_ADDR environment variable. This should be a complete URL such as&quot;http://127.0.0.1:8200&quot;.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#api","content":" ","version":"Next","tagName":"h2"},{"title":"Cache clear​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#cache-clear","content":" This endpoint clears the cache based on given criteria. To use this API, some information on how the agent caches values should be known beforehand. Each response that is cached in the agent will be indexed on some factors depending on the type of request. Those factors can be the token that is belonging to the cached response, the token_accessor of the token belonging to the cached response, the request_path that resulted in the cached response, the lease that is attached to the cached response, thenamespace to which the cached response belongs to, and a few more. This API exposes some factors through which associated cache entries are fetched and evicted. For listeners without caching enabled, this API will still be available, but will do nothing (there is no cache to clear) and will return a 200 response.  Method\tPath\tProducesPOST\t/agent/v1/cache-clear\t200 application/json  Parameters​  type (strings: required) - The type of cache entries to evict. Valid values are request_path, lease, token, token_accessor, and all. If the type is set to all, the entire cache is cleared. value (string: required) - An exact value or the prefix of the value for the type selected. This parameter is optional when the type is set to all. namespace (string: optional) - This is only applicable when the type is set torequest_path. The namespace of which the cache entries to be evicted for the given request path.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#sample-payload","content":" { &quot;type&quot;: &quot;token&quot;, &quot;value&quot;: &quot;hvs.rlNjegSKykWcplOkwsjd8bP9&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#sample-request","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:1234/agent/v1/cache-clear   ","version":"Next","tagName":"h3"},{"title":"Configuration (cache)​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#configuration-cache","content":" The presence of the top level cache block in any way (including an empty cache block) will enable the cache. The top level cache block has the following configuration entry:  persist (object: optional) - Configuration for the persistent cache.  The cache block also supports the use_auto_auth_token, enforce_consistency, andwhen_inconsistent configuration values of the api_proxy blockdescribed in the API Proxy documentation only to maintain backwards compatibility. This configuration cannot be specified alongside api_proxy equivalents, should not be preferred over configuring these values in the api_proxy block, and api_proxy should be the preferred place to configure these values.  info Note: When the cache block is defined, at least onetemplate or listener must also be defined in the config, otherwise there is no way to utilize the cache.  ","version":"Next","tagName":"h2"},{"title":"Configuration (Persist)​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#configuration-persist","content":" These are common configuration values that live within the persist block:  type (string: required) - The type of the persistent cache to use, e.g. kubernetes. Note: when using HCL this can be used as the key for the block, e.g. persist &quot;kubernetes&quot; {...}. Currently, only kubernetesis supported. path (string: required) - The path on disk where the persistent cache file should be created or restored from. keep_after_import (bool: optional) - When set to true, a restored cache file is not deleted. Defaults to false. exit_on_err (bool: optional) - When set to true, if any errors occur during a persistent cache restore, OpenBao Agent will exit with an error. Defaults to true. service_account_token_file (string: optional) - When type is set to kubernetes, this configures the path on disk where the Kubernetes service account token can be found. Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token.  ","version":"Next","tagName":"h3"},{"title":"Configuration (listener)​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#configuration-listener","content":" listener (array of objects: required) - Configuration for the listeners.  There can be one or more listener blocks at the top level. Adding a listener enables the API Proxy and enables the API proxy to use the cache, if configured. These configuration values are common to both tcp and unix listener blocks. Blocks of typetcp support the standard tcp listeneroptions. Additionally, the role string option is available as part of the top level of the listener block, which can be configured to metrics_only to serve only metrics, or the default role, default, which serves everything (including metrics).  type (string: required) - The type of the listener to use. Valid values are tcp and unix.Note: when using HCL this can be used as the key for the block, e.g.listener &quot;tcp&quot; {...}. address (string: required) - The address for the listener to listen to. This can either be a URL path when using tcp or a file path when usingunix. For example, 127.0.0.1:8200 or /path/to/socket. Defaults to127.0.0.1:8200. tls_disable (bool: false) - Specifies if TLS will be disabled. tls_key_file (string: optional) - Specifies the path to the private key for the certificate. tls_cert_file (string: optional) - Specifies the path to the certificate for TLS.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#example-configuration","content":" Here is an example of a cache configuration with the optional persist block, alongside a regular listener, and a listener that only serves metrics.  # Other OpenBao agent configuration blocks # ... cache { persist = { type = &quot;kubernetes&quot; path = &quot;/openbao/agent-cache/&quot; keep_after_import = true exit_on_err = true service_account_token_file = &quot;/tmp/serviceaccount/token&quot; } } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true } listener &quot;tcp&quot; { address = &quot;127.0.0.1:3000&quot; tls_disable = true role = &quot;metrics_only&quot; }   ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"OpenBao agent caching","url":"/openbao/docs/agent-and-proxy/agent/caching/#tutorial","content":" Refer to the OpenBao Agent Cachingtutorial to learn how to use the OpenBao Agent to increase the availability of tokens and secrets to clients using its Caching function. ","version":"Next","tagName":"h2"},{"title":"What is OpenBao Agent?","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/","content":"","keywords":"","version":"Next"},{"title":"Auto-Auth​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#auto-auth","content":" OpenBao Agent allows easy authentication to OpenBao in a wide variety of environments. Please see the Auto-Auth docsfor information.  Auto-Auth functionality takes place within an auto_auth configuration stanza.  ","version":"Next","tagName":"h2"},{"title":"API proxy​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#api-proxy","content":" OpenBao Agent can act as an API proxy for OpenBao, allowing you to talk to OpenBao's API via a listener defined for Agent. It can be configured to optionally allow or force the automatic use of the Auto-Auth token for these requests. Please see the API Proxy docsfor more information.  API Proxy functionality takes place within a defined listener, and its behaviour can be configured with anapi_proxy stanza.  ","version":"Next","tagName":"h2"},{"title":"Caching​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#caching","content":" OpenBao Agent allows client-side caching of responses containing newly created tokens and responses containing leased secrets generated off of these newly created tokens. Please see the Caching docs for information.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#api","content":" ","version":"Next","tagName":"h2"},{"title":"Quit​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#quit","content":" This endpoint triggers shutdown of the agent. By default, it is disabled, and can be enabled per listener using the agent_api stanza. It is recommended to only enable this on trusted interfaces, as it does not require any authorization to use.  Method\tPathPOST\t/agent/v1/quit  ","version":"Next","tagName":"h3"},{"title":"Cache​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#cache","content":" See the caching page for details on the cache API.  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Command options​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#command-options","content":" -log-level (string: &quot;info&quot;) - Log verbosity level. Supported values (in order of descending detail) are trace, debug, info, warn, and error. This can also be specified via the VAULT_LOG_LEVEL environment variable. -log-format (string: &quot;standard&quot;) - Log format. Supported values are standard and json. This can also be specified via theVAULT_LOG_FORMAT environment variable. -log-file - the absolute path where OpenBao Agent should save log messages. Paths that end with a path separator use the default file name,agent.log. Paths that do not end with a file extension use the default.log extension. If the log file rotates, OpenBao Agent appends the current timestamp to the file name at the time of rotation. For example: log-file\tFull log file\tRotated log file/var/log\t/var/log/agent.log\t/var/log/agent-{timestamp}.log /var/log/my-diary\t/var/log/my-diary.log\t/var/log/my-diary-{timestamp}.log /var/log/my-diary.txt\t/var/log/my-diary.txt\t/var/log/my-diary-{timestamp}.txt -log-rotate-bytes - to specify the number of bytes that should be written to a log before it needs to be rotated. Unless specified, there is no limit to the number of bytes that can be written to a log file. -log-rotate-duration - to specify the maximum duration a log should be written to before it needs to be rotated. Must be a duration value such as 30s. Defaults to 24h. -log-rotate-max-files - to specify the maximum number of older log file archives to keep. Defaults to 0 (no files are ever deleted). Set to -1 to discard old log files when a new one is created.  ","version":"Next","tagName":"h3"},{"title":"Configuration file options​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#configuration-file-options","content":" These are the currently-available general configuration options:  vault (vault: &lt;optional&gt;) - Specifies the remote OpenBao server the Agent connects to. auto_auth (auto_auth: &lt;optional&gt;) - Specifies the method and other options used for Auto-Auth functionality. api_proxy (api_proxy: &lt;optional&gt;) - Specifies options used for API Proxy functionality. cache (cache: &lt;optional&gt;) - Specifies options used for Caching functionality. listener (listener: &lt;optional&gt;) - Specifies the addresses and ports on which the Agent will respond to requests.  warning Note: On SIGHUP (kill -SIGHUP $(pidof bao)), OpenBao Agent will attempt to reload listener TLS configuration. This method can be used to refresh certificates used by OpenBao Agent without having to restart its process.  pid_file (string: &quot;&quot;) - Path to the file in which the agent's Process ID (PID) should be stored exit_after_auth (bool: false) - If set to true, the agent will exit with code 0 after a single successful auth, where success means that a token was retrieved and all sinks successfully wrote it disable_idle_connections (string array: []) - A list of strings that disables idle connections for various features in OpenBao Agent. Valid values include: auto-auth, caching, proxying, and templating. proxying configures this for the API proxy, which is identical in function to caching for historical reasons. Can also be configured by setting the VAULT_AGENT_DISABLE_IDLE_CONNECTIONSenvironment variable as a comma separated string. This environment variable will override any values found in a configuration file. disable_keep_alives (string array: []) - A list of strings that disables keep alives for various features in OpenBao Agent. Valid values include: auto-auth, caching, proxying, and templating. proxying configures this for the API proxy, which is identical in function to caching for historical reasons. Can also be configured by setting the VAULT_AGENT_DISABLE_KEEP_ALIVESenvironment variable as a comma separated string. This environment variable will override any values found in a configuration file. template (template: &lt;optional&gt;) - Specifies options used for templating OpenBao secrets to files. template_config (template_config: &lt;optional&gt;) - Specifies templating engine behavior. exec (exec: &lt;optional&gt;) - Specifies options for OpenBao agent to run a child process that injects secrets (via env_template stanzas) as environment variables. env_template (env_template: &lt;optional&gt;) - Multiple blocks accepted. Each block contains the options used for templating OpenBao secrets as environment variables via theprocess supervisor mode. telemetry (telemetry: &lt;optional&gt;) – Specifies the telemetry reporting system. See the telemetry Stanza section below for a list of metrics specific to Agent. log_level - Equivalent to the -log-level command-line flag.  warning Note: On SIGHUP (kill -SIGHUP $(pidof bao)), OpenBao Agent will update the log level to the value specified by configuration file (including overriding values set using CLI or environment variable parameters).  log_format - Equivalent to the -log-format command-line flag. log_file - Equivalent to the -log-file command-line flag. log_rotate_duration - Equivalent to the -log-rotate-duration command-line flag. log_rotate_bytes - Equivalent to the -log-rotate-bytes command-line flag. log_rotate_max_files - Equivalent to the -log-rotate-max-files command-line flag.  ","version":"Next","tagName":"h3"},{"title":"vault stanza​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#vault-stanza","content":" There can at most be one top level vault block, and it has the following configuration entries:  address (string: \\&lt;optional&gt;) - The address of the OpenBao server to connect to. This should be a Fully Qualified Domain Name (FQDN) or IP such as https://openbao-fqdn:8200 or https://172.16.9.8:8200. This value can be overridden by setting the VAULT_ADDR environment variable. ca_cert (string: \\&lt;optional&gt;) - Path on the local disk to a single PEM-encoded CA certificate to verify the OpenBao server's SSL certificate. This value can be overridden by setting the VAULT_CACERT environment variable. ca_path (string: \\&lt;optional&gt;) - Path on the local disk to a directory of PEM-encoded CA certificates to verify the OpenBao server's SSL certificate. This value can be overridden by setting the VAULT_CAPATH environment variable. client_cert (string: \\&lt;optional&gt;) - Path on the local disk to a single PEM-encoded CA certificate to use for TLS authentication to the OpenBao server. This value can be overridden by setting the VAULT_CLIENT_CERT environment variable. client_key (string: \\&lt;optional&gt;) - Path on the local disk to a single PEM-encoded private key matching the client certificate from client_cert. This value can be overridden by setting the VAULT_CLIENT_KEY environment variable. tls_skip_verify (string: \\&lt;optional&gt;) - Disable verification of TLS certificates. Using this option is highly discouraged as it decreases the security of data transmissions to and from the OpenBao server. This value can be overridden by setting the VAULT_SKIP_VERIFY environment variable. tls_server_name (string: \\&lt;optional&gt;) - Name to use as the SNI host when connecting via TLS. This value can be overridden by setting theVAULT_TLS_SERVER_NAME environment variable.  retry stanza​  The vault stanza may contain a retry stanza that controls how failing OpenBao requests are handled, whether these requests are issued in order to render templates, or are proxied requests coming from the api proxy subsystem. Auto-auth, however, has its own notion of retrying and is not affected by this section.  For requests from the templating engine, Vaul Agent will reset its retry counter and perform retries again once all retries are exhausted. This means that templating will retry on failures indefinitely unless exit_on_retry_failure from thetemplate_config stanza is set to true.  Here are the options for the retry stanza:  num_retries (int: 12) - Specify how many times a failing request will be retried. A value of 0 translates to the default, i.e. 12 retries. A value of -1 disables retries. The environment variable VAULT_MAX_RETRIESoverrides this setting.  There are a few subtleties to be aware of here. First, requests originating from the proxy cache will only be retried if they resulted in specific HTTP result codes: any 50x code except 501 (&quot;not implemented&quot;). Requests coming from the template subsystem are retried regardless of the failure.  Second, templating retries may be performed by both the templating engine andthe cache proxy if OpenBao Agent persistent cache is enabled. This is due to the fact that templating requests go through the cache proxy when persistence is enabled.  Third, the backoff algorithm used to set the time between retries differs for the template and cache subsystems. This is a technical limitation we hope to address in the future.  ","version":"Next","tagName":"h3"},{"title":"listener stanza​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#listener-stanza","content":" OpenBao Agent supports one or more listener stanzas. Listeners can be configured with or without caching, but will use the cache if it has been configured, and will enable the API proxy. In addition to the standard listener configuration, an Agent's listener configuration also supports the following:  require_request_header (bool: false) - Require that all incoming HTTP requests on this listener must have an X-Vault-Request: true header entry. Using this option offers an additional layer of protection from Server Side Request Forgery attacks. Requests on the listener that do not have the properX-Vault-Request header will fail, with a HTTP response status code of 412: Precondition Failed. role (string: default) - role determines which APIs the listener serves. It can be configured to metrics_only to serve only metrics, or the default role, default, which serves everything (including metrics). The require_request_header does not apply to metrics_only listeners. agent_api (agent_api: &lt;optional&gt;) - Manages optional Agent API endpoints.  agent_api stanza​  enable_quit (bool: false) - If set to true, the agent will enable the quit API.  ","version":"Next","tagName":"h3"},{"title":"telemetry stanza​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#telemetry-stanza","content":" OpenBao Agent supports the telemetry stanza and collects various runtime metrics about its performance, the auto-auth and the cache status:  Metric\tDescription\tTypevault.agent.auth.failure\tNumber of authentication failures\tcounter vault.agent.auth.success\tNumber of authentication successes\tcounter vault.agent.proxy.success\tNumber of requests successfully proxied\tcounter vault.agent.proxy.client_error\tNumber of requests for which OpenBao returned an error\tcounter vault.agent.proxy.error\tNumber of requests the agent failed to proxy\tcounter vault.agent.cache.hit\tNumber of cache hits\tcounter vault.agent.cache.miss\tNumber of cache misses\tcounter  ","version":"Next","tagName":"h3"},{"title":"Start OpenBao agent​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#start-openbao-agent","content":" To run OpenBao Agent:  Download the OpenBao binary where the client application runs (virtual machine, Kubernetes pod, etc.) Create an OpenBao Agent configuration file. (See the Example Configuration section for an example configuration.) Start an OpenBao Agent with the configuration file. Example: $ bao agent -config=/etc/openbao/agent-config.hcl To get help, run: $ bao agent -h   As with OpenBao, the -config flag can be used in three different ways:  Use the flag once to name the path to a single specific configuration file.Use the flag multiple times to name multiple configuration files, which will be composed at runtime.Use the flag to name a directory of configuration files, the contents of which will be composed at runtime.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"What is OpenBao Agent?","url":"/openbao/docs/agent-and-proxy/agent/#example-configuration","content":" An example configuration, with very contrived values, follows:  pid_file = &quot;./pidfile&quot; vault { address = &quot;https://openbao-fqdn:8200&quot; retry { num_retries = 5 } } auto_auth { method &quot;kubernetes&quot; { config = { role = &quot;foobar&quot; } } sink &quot;file&quot; { config = { path = &quot;/tmp/file-foo&quot; } } sink &quot;file&quot; { wrap_ttl = &quot;5m&quot; aad_env_var = &quot;TEST_AAD_ENV&quot; dh_type = &quot;curve25519&quot; dh_path = &quot;/tmp/file-foo-dhpath2&quot; config = { path = &quot;/tmp/file-bar&quot; } } } cache { // An empty cache stanza still enables caching } api_proxy { use_auto_auth_token = true } listener &quot;unix&quot; { address = &quot;/path/to/socket&quot; tls_disable = true agent_api { enable_quit = true } } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true } template { source = &quot;/etc/openbao/server.key.ctmpl&quot; destination = &quot;/etc/openbao/server.key&quot; } template { source = &quot;/etc/openbao/server.crt.ctmpl&quot; destination = &quot;/etc/openbao/server.crt&quot; }  ","version":"Next","tagName":"h2"},{"title":"OpenBao agent kubernetes persistent cache","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/caching/persistent-caches/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao agent kubernetes persistent cache","url":"/openbao/docs/agent-and-proxy/agent/caching/persistent-caches/kubernetes/#configuration","content":" service_account_token_file (string: optional) - When type is set to kubernetes, this configures the path on disk where the Kubernetes service account token can be found. Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token. ","version":"Next","tagName":"h2"},{"title":"OpenBao agent's process supervisor mode","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/","content":"","keywords":"","version":"Next"},{"title":"Functionality​","type":1,"pageTitle":"OpenBao agent's process supervisor mode","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/#functionality","content":" OpenBao Agent will inject secrets referenced in the env_template configuration blocks as environment variables into the child process specified in the exec block.  When you start OpenBao Agent in process supervisor mode, it will wait until each environment variable template has rendered at least once before starting the process. If restart_on_secret_changes is set to always (default), Agent will restart the process whenever an update to an injected secret is detected. This could be either a static secret update (done onstatic_secret_render_interval) or dynamic secret being close to its expiration.  In many ways, OpenBao Agent will mirror the child process. Standard intput and output streams (stdin / stdout / stderr) are all forwarded to the child process. Additionally, OpenBao Agent will exit when the child process exits on its own with the same exit code.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao agent's process supervisor mode","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/#configuration","content":" info Agent's generate-configtool will help you get started by generating a valid agent configuration file from the given inputs.  The process supervisor mode requires at least one env_template block and exactly one top level exec block. It is incompatible with regular filetemplate entries.  ","version":"Next","tagName":"h2"},{"title":"env_template​","type":1,"pageTitle":"OpenBao agent's process supervisor mode","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/#env_template","content":" env_template stanza maps the template specified in the contents field or referenced in the source field to the environment variable name in the title of the stanza. It uses the sametemplating languageas file templates but permits only a subset ofits configuration parameters:  environment variable name (string: &lt;required&gt;) - the name of the environment variable to which the contents of the template should map. contents (string: &quot;&quot;) - This option allows embedding the contents of a template in the configuration file rather then supplying the source path to the template file. This is useful for short templates. This option is mutually exclusive with the source option. source (string: &quot;&quot;) - Path on disk to use as the input template. This option is required if not using the contents option. error_on_missing_key (bool: false) - Exit with an error when accessing a struct or map field/key that does notexist. The default behavior will print &lt;no value&gt;when accessing a field that does not exist. It is highly recommended you set this to &quot;true&quot;. Also seeexit_on_retry_failure in global OpenBao Agent Template Config. left_delimiter (string: &quot;\\{\\{&quot;) - Delimiter to use in the template. The default is &quot;{{&quot; but for some templates, it may be easier to use a different delimiter that does not conflict with the output file itself. right_delimiter (string: &quot;}}&quot;) - Delimiter to use in the template. The default is &quot;}}&quot; but for some templates, it may be easier to use a different delimiter that does not conflict with the output file itself.  ","version":"Next","tagName":"h3"},{"title":"exec​","type":1,"pageTitle":"OpenBao agent's process supervisor mode","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/#exec","content":" The top level exec block has the following configuration entries.  command (string array: required) - Specify the command for the child process with optional arguments. The executable's path must be either absolute or relative to the current working directory. restart_on_secret_changes (string: &quot;always&quot;) - Controls whether agent will restart the child process on secret changes. There are two types of secret changes relevant to this configuration: a static secret update (on [static_secret_render_interval](/docs/agent-and-proxy/agent/template#static_secret_render_interval)) and dynamic secret being close to its expiration. The configuration supports two options: alwaysandnever`. restart_stop_signal (string: &quot;SIGTERM&quot;) - Signal to send to the child process when a secret has been updated and the process needs to be restarted. The process has 30 seconds after this signal is sent until SIGKILL is sent to force the child process to stop.  ","version":"Next","tagName":"h3"},{"title":"Configuration example​","type":1,"pageTitle":"OpenBao agent's process supervisor mode","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/#configuration-example","content":" The following example was generated usingbao agent generate-config, a configuration helper tool. Given this configuration, OpenBao Agent will run the child process (./my-app arg1 arg2) with two additional environment variables (FOO_USER and FOO_PASSWORD) populated with secrets from OpenBao.  auto_auth { method { type = &quot;token_file&quot; config { token_file_path = &quot;/Users/avean/.vault-token&quot; } } } template_config { static_secret_render_interval = &quot;5m&quot; exit_on_retry_failure = true } vault { address = &quot;http://localhost:8200&quot; } env_template &quot;FOO_PASSWORD&quot; { contents = &quot;{{ with secret \\&quot;secret/data/foo\\&quot; }}{{ .Data.data.password }}{{ end }}&quot; error_on_missing_key = true } env_template &quot;FOO_USER&quot; { contents = &quot;{{ with secret \\&quot;secret/data/foo\\&quot; }}{{ .Data.data.user }}{{ end }}&quot; error_on_missing_key = true } exec { command = [&quot;./my-app&quot;, &quot;arg1&quot;, &quot;arg2&quot;] restart_on_secret_changes = &quot;always&quot; restart_stop_signal = &quot;SIGTERM&quot; }   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"OpenBao agent's process supervisor mode","url":"/openbao/docs/agent-and-proxy/agent/process-supervisor/#tutorial","content":" Refer to the OpenBao Agent - secrets as environment variables tutorial for an end-to-end example. ","version":"Next","tagName":"h2"},{"title":"agent generate-config","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/generate-config/","content":"","keywords":"","version":"Next"},{"title":"Example​","type":1,"pageTitle":"agent generate-config","url":"/openbao/docs/agent-and-proxy/agent/generate-config/#example","content":" Before generating a configuration file, let's insert a secret foo:  $ bao kv put -mount=secret foo user=&quot;admin&quot; password=&quot;s3cr3t&quot;   Generate an agent configuration file which will reference secret/foo:  $ bao agent generate-config \\ -type=&quot;env-template&quot; \\ -exec=&quot;./my-app arg1 arg2&quot; \\ -namespace=&quot;my/ns/&quot; \\ -path=&quot;secret/foo&quot; \\ my-config.hcl   Expected output:  Successfully generated &quot;my-config.hcl&quot; configuration file! Warning: the generated file uses 'token_file' authentication method, which is not suitable for production environments.   This will produce my-config.hcl file in the current directory with contents similar to the following:  auto_auth { method { type = &quot;token_file&quot; config { token_file_path = &quot;/Users/avean/.vault-token&quot; } } } template_config { static_secret_render_interval = &quot;5m&quot; exit_on_retry_failure = true } vault { address = &quot;http://localhost:8200&quot; } env_template &quot;FOO_PASSWORD&quot; { contents = &quot;{{ with secret \\&quot;secret/data/foo\\&quot; }}{{ .Data.data.password }}{{ end }}&quot; error_on_missing_key = true } env_template &quot;FOO_USER&quot; { contents = &quot;{{ with secret \\&quot;secret/data/foo\\&quot; }}{{ .Data.data.user }}{{ end }}&quot; error_on_missing_key = true } exec { command = [&quot;./my-app&quot;, &quot;arg1&quot;, &quot;arg2&quot;] restart_on_secret_changes = &quot;always&quot; restart_stop_signal = &quot;SIGTERM&quot; }   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"agent generate-config","url":"/openbao/docs/agent-and-proxy/agent/generate-config/#usage","content":" The following flags are available in addition to the standard set of flags included in all commands.  type (string: &lt;required&gt;) - The type of configuration file to generate; currently, only env-template is supported. path (string: &quot;&quot;) - Path to a kv-v1 or kv-v2 secret (e.g. secret/data/foo, kv-v2/my-app/*); multiple secrets and tail *wildcards are allowed. -exec (string: &quot;env&quot;) - The command to execute in agent process supervisor mode.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"agent generate-config","url":"/openbao/docs/agent-and-proxy/agent/generate-config/#tutorial","content":" Refer to the OpenBao Agent - secrets as environment variables tutorial for an end-to-end example. ","version":"Next","tagName":"h2"},{"title":"Running different versions of agent and server","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/versions/","content":"","keywords":"","version":"Next"},{"title":"Older version of agent than server​","type":1,"pageTitle":"Running different versions of agent and server","url":"/openbao/docs/agent-and-proxy/agent/versions/#older-version-of-agent-than-server","content":" We do not anticipate any problems stemming from continuing to run an older Agent version after the server nodes are upgraded to a later version. Existing deployments using Agent should not be impacted, as we don't generally make backwards-incompatible changes to OpenBao Server.  Auto-auth:  new auth methods that have been introduced since Agent was built will be unavailableexisting auth methods should continue to function normally  Proxy:  since Agent simply mirrors the incoming requests, even if an incoming request uses an endpoint that didn't exist when that version of Agent was compiled, that won't impede Agent's ability to proxy the request  Templating:  the templating language features that interact with the OpenBao server use stable OpenBao APIs to retrieve and renew secretseven if new secret engine types are introduced in newer OpenBao releases, these should not require an Agent upgrade to access via templates  ","version":"Next","tagName":"h2"},{"title":"Newer version of agent than server​","type":1,"pageTitle":"Running different versions of agent and server","url":"/openbao/docs/agent-and-proxy/agent/versions/#newer-version-of-agent-than-server","content":" It is possible that an Agent could depend on features that don’t exist in older Server versions.  Auto-auth:  Agent may claim to support newer auth methods that have been introduced since Server was built, but they won't work due to Server not supporting themAgent may make use of new functionality for existing auth methods that isn't available in an older Server you're using Generally we will try to make such a change be opt-in, or to gracefully degrade when connecting to an older Server instance, unless there's a very good reason (such as a serious security flaw being patched)  Proxy:  since Agent simply mirrors the incoming requests, it is unlikely that incompatibilities would surface in proxying, but new functionality may not be available  Templating:  we don't anticipate a scenario where changes to Agent's templating itself gives rise to an incompatibility with older OpenBao Servers, though of course with any Agent version it's possible to write templates that issue requests which make use of functionality not yet present in the upstream OpenBao server, e.g. {{ with secret &quot;secret/my-secret?some-new-option&quot; }}we would not deliberately make a change to templating that breaks existing deployments ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth methods","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/","content":"OpenBao Auto-Auth methods Auto-auth is a mechanism used by OpenBao Agent and OpenBao Proxy to authenticate to OpenBao in an automatic manner, given a set of parameters allowing the authentication. Please see the sidebar for available methods and their usage/configuration.","keywords":"","version":"Next"},{"title":"OpenBao agent windows service","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/winsvc/","content":"","keywords":"","version":"Next"},{"title":"Register OpenBao agent as a windows service​","type":1,"pageTitle":"OpenBao agent windows service","url":"/openbao/docs/agent-and-proxy/agent/winsvc/#register-openbao-agent-as-a-windows-service","content":" There are multiple ways to register OpenBao Agent as a Windows service. One way is to usesc.exe. sc.exe works best if the path to your OpenBao binary and its associated agent config file do not contain spaces. sc.exe can be pretty tricky to get working correctly if your path contains spaces, as paths containing spaces must be quoted, and escaping quotes correctly in a way that makes sc.exe happy is non-trivial. If your path contains spaces, or you prefer not to use sc.exe, another alternative is to use theNew-Servicecmdlet. New-Service is less picky about the method used to escape quotes, and can sometimes be easier. Examples of both will be shown below.  ","version":"Next","tagName":"h2"},{"title":"Using sc.exe​","type":1,"pageTitle":"OpenBao agent windows service","url":"/openbao/docs/agent-and-proxy/agent/winsvc/#using-scexe","content":" warning Important Note: Ensure the executable path of the service is quoted, especially when it contains spaces, to avoid potential privilege escalation risks.  If you use sc.exe, make sure you specify sc.exe explicitly, and not just sc. The command below shows the creation of OpenBao Agent as a service, using &quot;OpenBao Agent&quot; as the display name, and starting automatically when Windows starts. The binPath argument should include the fully qualified path to the OpenBao executable, as well as any arguments required.  PS C:\\Windows\\system32&gt; sc.exe create OpenBaoAgent binPath=&quot;C:\\openbao\\bao.exe agent -config=C:\\openbao\\agent-config.hcl&quot; displayName=&quot;OpenBao Agent&quot; start=auto [SC] CreateService SUCCESS   Note that the spacing after the = in all of the arguments is intentional and required.  If you receive a success message, your service is registered with the service manager.  If you get an error, please verify the path to the binary and check the arguments, by running the contents ofbinPath= directly in a PowerShell session and observing the results.  ","version":"Next","tagName":"h3"},{"title":"Using New-Service​","type":1,"pageTitle":"OpenBao agent windows service","url":"/openbao/docs/agent-and-proxy/agent/winsvc/#using-new-service","content":" The syntax is slightly different for New-Service, but the gist is the same. The invocation below is equivalent to thesc.exe one above.  PS C:\\Windows\\system32&gt; New-Service -Name &quot;OpenBaoAgent&quot; -BinaryPathName &quot;C:\\openbao\\bao.exe agent -config=C:\\openbao\\agent-config.hcl&quot; -DisplayName &quot;OpenBao Agent&quot; -StartupType &quot;Automatic&quot; Status Name DisplayName ------ ---- ----------- Stopped OpenBaoAgent OpenBao Agent   As mentioned previously, New-Service is easier to use if the path to your OpenBao executable and/or agent config contains spaces. Below is an example of how to configure OpenBao Agent as a service using a path with spaces.  PS C:\\Windows\\system32&gt; New-Service -Name &quot;OpenBaoAgent&quot; -BinaryPathName '&quot;C:\\my dir\\bao.exe&quot; agent -config=&quot;C:\\my dir\\agent-config.hcl&quot;' -DisplayName &quot;OpenBao Agent&quot; -StartupType &quot;Automatic&quot; Status Name DisplayName ------ ---- ----------- Stopped OpenBaoAgent OpenBao Agent   Note that only the paths themselves are double quoted, and the entire BinaryPathName is wrapped in single quotes, in order to escape the double quotes used for the paths.  If anything goes wrong during this process, and you need to manually edit the path later, use the Registry Editor to find the following key: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\OpenBaoAgent. You can edit the ImagePath value at that key to the correct path.  ","version":"Next","tagName":"h3"},{"title":"Start the OpenBao agent service​","type":1,"pageTitle":"OpenBao agent windows service","url":"/openbao/docs/agent-and-proxy/agent/winsvc/#start-the-openbao-agent-service","content":" There are multiple ways to start the service.  Using the sc.exe command.Using the Start-Service cmdlet.Go to the Windows Service Manager, and look for OpenBaoAgent in the service name column. Click theStart button to start the service.  ","version":"Next","tagName":"h2"},{"title":"Example starting OpenBao agent using sc.exe​","type":1,"pageTitle":"OpenBao agent windows service","url":"/openbao/docs/agent-and-proxy/agent/winsvc/#example-starting-openbao-agent-using-scexe","content":" PS C:\\Windows\\system32&gt; sc.exe start OpenBaoAgent SERVICE_NAME: OpenBaoAgent TYPE : 10 WIN32_OWN_PROCESS STATE : 4 RUNNING (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 PID : 6548 FLAGS :   ","version":"Next","tagName":"h3"},{"title":"Example starting OpenBao agent using Start-Service​","type":1,"pageTitle":"OpenBao agent windows service","url":"/openbao/docs/agent-and-proxy/agent/winsvc/#example-starting-openbao-agent-using-start-service","content":" PS C:\\Windows\\system32&gt; Start-Service -Name &quot;OpenBaoAgent&quot;   Note that in the case where the service was started successfully, New-Service does not return any output. ","version":"Next","tagName":"h3"},{"title":"OpenBao Agent and OpenBao Proxy Auto-Auth","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/","content":"","keywords":"","version":"Next"},{"title":"Functionality​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#functionality","content":" Auto-Auth consists of two parts: a Method, which is the authentication method that should be used in the current environment; and any number of Sinks, which are locations where the agent should write a token any time the current token value has changed.  When OpenBao Agent or OpenBao Proxy are started with Auto-Auth enabled, it will attempt to acquire a OpenBao token using the configured Method. On failure, it will exponentially back off and then retry. On success, unless the auth method is configured to wrap the tokens, it will keep the resulting token renewed until renewal is no longer allowed or fails, at which point it will attempt to reauthenticate.  Every time an authentication is successful, the token is written to the configured Sinks, subject to their configuration.  ","version":"Next","tagName":"h2"},{"title":"Advanced functionality​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#advanced-functionality","content":" Sinks support some advanced features, including the ability for the written values to be encrypted orresponse-wrapped.  Both mechanisms can be used concurrently; in this case, the value will be response-wrapped, then encrypted.  ","version":"Next","tagName":"h2"},{"title":"Response-Wrapping tokens​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#response-wrapping-tokens","content":" There are two ways that tokens can be response-wrapped:  By the auth method. This allows the end client to introspect thecreation_path of the token, helping prevent Man-In-The-Middle (MITM) attacks. However, because auto-auth cannot then unwrap the token and rewrap it without modifying the creation_path, we are not able to renew the token; it is up to the end client to renew the token. Agent and Proxy both stay daemonized in this mode since some auth methods allow for reauthentication on certain events. By any of the token sinks. Because more than one sink can be configured, the token must be wrapped after it is fetched, rather than wrapped by OpenBao as it's being returned. As a result, the creation_path will always besys/wrapping/wrap, and validation of this field cannot be used as protection against MITM attacks. However, this mode allows auto-auth to keep the token renewed for the end client and automatically reauthenticate when it expires.  ","version":"Next","tagName":"h3"},{"title":"Encrypting tokens​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#encrypting-tokens","content":" warning Support for encrypted tokens is experimental; if input/output formats change, we will make every effort to provide backwards compatibility.  Tokens can be encrypted, using a Diffie-Hellman exchange to generate an ephemeral key. In this mechanism, the client receiving the token writes a generated public key to a file. The sink responsible for writing the token to that client looks for this public key and uses it to compute a shared secret key, which is then used to encrypt the token via AES-GCM. The nonce, encrypted payload, and the sink's public key are then written to the output file, where the client can compute the shared secret and decrypt the token value.  warning NOTE: Token encryption is not a protection against MITM attacks! The purpose of this feature is for forward-secrecy and coverage against bare token values being persisted. A MITM that can write to the sink's output and/or client public-key input files could attack this exchange. Using TLS to protect the transit of tokens is highly recommended.  To help mitigate MITM attacks, additional authenticated data (AAD) can be provided to Agent and Proxy. This data is written as part of the AES-GCM tag and must match on both Agent and Proxy and the client. This of course means that protecting this AAD becomes important, but it provides another layer for an attacker to have to overcome. For instance, if the attacker has access to the file system where the token is being written, but not to read configuration or read environment variables, this AAD can be generated and passed to Agent or Proxy and the client in ways that would be difficult for the attacker to find.  When using AAD, it is always a good idea for this to be as fresh as possible; generate a value and pass it to your client and Agent or Proxy on startup. Additionally, Agent and Proxy a Trust On First Use model; after it finds a generated public key, it will reuse that public key instead of looking for new values that have been written.  If writing a client that uses this feature, it will likely be helpful to look at thedhutillibrary. This shows the expected format of the public key input and envelope output formats.  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#configuration","content":" The top level auto_auth block has two configuration entries:  method (object: required) - Configuration for the method sinks (array of objects: optional) - Configuration for the sinks  ","version":"Next","tagName":"h2"},{"title":"Configuration (Method)​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#configuration-method","content":" warning Auto-auth does not support using tokens with a limited number of uses. Auto-auth does not track the number of uses remaining, and may allow the token to expire before attempting to renew it. For example, if using AppRole auto-auth, you must use 0 (meaning unlimited) as the value fortoken_num_uses.  These are common configuration values that live within the method block:  type (string: required) - The type of the method to use, e.g. jwt,ldap, cert, etc. Note: when using HCL this can be used as the key for the block, e.g. method &quot;jwt&quot; {...}. mount_path (string: optional) - The mount path of the method. If not specified, defaults to a value of auth/&lt;method type&gt;. namespace (string: optional) - Namespace in which the mount lives. The order of precedence is: this setting lowest, followed by the environment variable VAULT_NAMESPACE, and then the highest precedence command-line option -namespace. If none of these are specified, defaults to the root namespace. Note that because sink response wrapping and templating are also based on the client created by auto-auth, they use the same namespace. wrap_ttl (string or integer: optional) - If specified, the written token will be response-wrapped by auto-auth. This is more secure than wrapping by sinks, but does not allow the auto-auth to keep the token renewed or automatically reauthenticate when it expires. Rather than a simple string, the written value will be a JSON-encodedSecretWrapInfostructure. Uses duration format strings. min_backoff (string or integer: &quot;1s&quot;) - The minimum backoff time auto-auth will delay before retrying after a failed auth attempt. The backoff will start at the configured value and double (with some randomness) after successive failures, capped by max_backoff. If Agent templating is being used, this value is also used as the min backoff time for the templating server. Uses duration format strings. max_backoff (string or integer: &quot;5m&quot;) - The maximum time Agent will delay before retrying after a failed auth attempt. The backoff will start atmin_backoff and double (with some randomness) after successive failures, capped by max_backoff. If Agent templating is being used, this value is also used as the max backoff time for the templating server. max_backoff is the duration between retries, and not the duration that retries will be performed before giving up. Uses duration format strings. exit_on_err (bool: false) - When set to true, OpenBao Agent and OpenBao Proxy will exit if any errors occur during authentication. This configurable only affects login attempts for new tokens (either initial or expired tokens) and will not exit for errors on valid token renewals. config (object: required) - Configuration of the method itself. See the sidebar for information about each method.  ","version":"Next","tagName":"h3"},{"title":"Configuration (Sinks)​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#configuration-sinks","content":" These configuration values are common to all Sinks:  type (string: required) - The type of the method to use, e.g. file.Note: when using HCL this can be used as the key for the block, e.g. sink &quot;file&quot; {...}. wrap_ttl (string or integer: optional) - If specified, the written token will be response-wrapped by the sink. This is less secure than wrapping by the method, but allows auto-auth to keep the token renewed and automatically reauthenticate when it expires. Rather than a simple string, the written value will be a JSON-encodedSecretWrapInfostructure. Uses duration format strings. dh_type (string: optional) - If specified, the type of Diffie-Hellman exchange to perform, meaning, which ciphers and/or curves. Currently only curve25519 is supported. dh_path (string: required if dh_type is set) - The path from which the auto-auth should read the client's initial parameters (e.g. curve25519 public key). derive_key (bool: false) - If specified, the final encryption key is calculated by using HKDF-SHA256 to derive a key from the calculated shared secret and the two public keys for enhanced security. This is recommended if backward compatibility isn't a concern. aad (string: optional) - If specified, additional authenticated data to use with the AES-GCM encryption of the token. Can be any string, including serialized data. aad_env_var (string: optional) - If specified, AAD will be read from the given environment variable rather than a value in the configuration file. config (object: required) - Configuration of the sink itself. See the sidebar for information about each sink.  ","version":"Next","tagName":"h3"},{"title":"Auto auth examples​","type":1,"pageTitle":"OpenBao Agent and OpenBao Proxy Auto-Auth","url":"/openbao/docs/agent-and-proxy/autoauth/#auto-auth-examples","content":" Auto-Auth configuration objects take two separate forms when specified in HCL and JSON. The following examples are meant to clarify the differences between the two formats.  Sinks (HCL format)​  The HCL format may define any number of sink objects with an optional wrappingsinks {...} object.  warning Note: The corresponding JSON format must specify a&quot;sinks&quot; : [...] array to encapsulate all sink JSON objects.  // Other OpenBao Agent or OpenBao Proxy configuration blocks // ... auto_auth { method { type = &quot;approle&quot; config = { role_id_file_path = &quot;/etc/openbao/roleid&quot; secret_id_file_path = &quot;/etc/openbao/secretid&quot; } } sinks { sink { type = &quot;file&quot; config = { path = &quot;/tmp/file-foo&quot; } } } }   The following valid HCL omits the wrapping sinks object while specifying multiple sinks.  // Other OpenBao Agent or OpenBao Proxy configuration blocks // ... auto_auth { method { type = &quot;approle&quot; config = { role_id_file_path = &quot;/etc/openbao/roleid&quot; secret_id_file_path = &quot;/etc/openbao/secretid&quot; } } sink { type = &quot;file&quot; config = { path = &quot;/tmp/file-foo&quot; } } sink { type = &quot;file&quot; config = { path = &quot;/tmp/file-bar&quot; } } }   Sinks (JSON format)​  The following JSON configuration illustrates the need for a sinks: [...] array wrapping any number of sink objects.  { &quot;auto_auth&quot; : { &quot;method&quot; : [ { type = &quot;approle&quot; config = { role_id_file_path = &quot;/etc/openbao/roleid&quot; secret_id_file_path = &quot;/etc/openbao/secretid&quot; } } ], &quot;sinks&quot; : [ { &quot;sink&quot; : { type = &quot;file&quot; config = { path = &quot;/tmp/file-foo&quot; } } } ] } }   Multiple sinks are defined by appending more sink objects within the sinksarray:  { &quot;auto_auth&quot; : { &quot;method&quot; : [ { type = &quot;approle&quot; config = { role_id_file_path = &quot;/etc/openbao/roleid&quot; secret_id_file_path = &quot;/etc/openbao/secretid&quot; } } ], &quot;sinks&quot; : [ { &quot;sink&quot; : { type = &quot;file&quot; config = { path = &quot;/tmp/file-foo&quot; } } }, { &quot;sink&quot; : { type = &quot;file&quot; config = { path = &quot;/tmp/file-bar&quot; } } } ] } }  ","version":"Next","tagName":"h3"},{"title":"OpenBao agent templates","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/agent/template/","content":"","keywords":"","version":"Next"},{"title":"Functionality​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#functionality","content":" The template_config stanza configures overall default behavior for the templating engine. Note that template_config can only be defined once, and is different from the template stanza. Unlike template which focuses on where and how a specific secret is rendered, template_config contains parameters affecting how the templating engine as a whole behaves and its interaction with the rest of Agent. This includes, but is not limited to, program exit behavior. Other parameters that apply to the templating engine as a whole may be added over time.  The template stanza configures the OpenBao agent for rendering secrets to files using Consul Template markup language. Multiple template stanzas can be defined to render multiple files.  When the agent is started with templating enabled, it will attempt to acquire a OpenBao token using the configured auto-auth Method. On failure, it will back off for a short while (including some randomness to help prevent thundering herd scenarios) and retry. On success, secrets defined in the templates will be retrieved from OpenBao and rendered locally.  ","version":"Next","tagName":"h2"},{"title":"Templating language​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#templating-language","content":" The template output content can be provided directly as part of the contentsoption in a template stanza or as a separate .ctmpl file and specified in the source option of a template stanza.  In order to fetch secrets from OpenBao, whether those are static secrets, dynamic credentials, or certificates, OpenBao Agent templates require the use of thesecretfunctionor pkiCertfunctionfrom Consul Template.  The secret function works for all types of secrets and depending on the type of secret that's being rendered by this function, template will have different renewal behavior as detailed in the Renewals section. The pkiCert function is intended to work specifically for certificates issued by the PKI Secrets Engine. Refer to the Certificates section for differences in certificate renewal behavior between secret and pkiCert.  The following links contain additional resources for the templating language used by OpenBao Agent templating.  Consul Templating DocumentationGo Templating Language Documentation  ","version":"Next","tagName":"h2"},{"title":"Template language example​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#template-language-example","content":" The following is an example of a template that retrieves a generic secret from OpenBao's KV store:  {{ with secret &quot;secret/my-secret&quot; }} {{ .Data.data.foo }} {{ end }}   The following is an example of a template that issues a PKI certificate in OpenBao's PKI secrets engine. The fetching of the certificate or key from a PKI role through this function will be based on the certificate's expiration.  To generate a new certificate and create a bundle with the key, certificate, and CA, use:  {{ with pkiCert &quot;pki/issue/my-domain-dot-com&quot; &quot;common_name=foo.example.com&quot; }} {{ .Data.Key }} {{ .Data.Cert }} {{ .Data.CA }} {{ end }}   To fetch only the issuing CA for this mount, use:  {{- with secret &quot;pki/cert/ca&quot; -}} {{ .Data.certificate }} {{- end -}}   Alternatively, pki/cert/ca_chain can be used to fetch the full CA chain.  ","version":"Next","tagName":"h3"},{"title":"Global configurations​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#global-configurations","content":" The top level template_config block has the following configuration entries that affect all templates:  exit_on_retry_failure (bool: false) - This option configures OpenBao Agent to exit after it has exhausted its number of template retry attempts due to failures. static_secret_render_interval (string or integer: 5m) - If specified, configures how often OpenBao Agent Template should render non-leased secrets such as KV v2. This setting will not change how often OpenBao Agent Templating renders leased secrets. Uses duration format strings.  ","version":"Next","tagName":"h2"},{"title":"template_config stanza example​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#template_config-stanza-example","content":" template_config { exit_on_retry_failure = true static_secret_render_interval = &quot;10m&quot; }   In another example template_config with error_on_missing_key parameter in the template stanzaas well as exit_on_retry_failure result in the agent exiting in case of no key / value issues instead of the default retry behavior.  template_config { exit_on_retry_failure = true static_secret_render_interval = &quot;10m&quot; } template { source = &quot;/tmp/agent/template.ctmpl&quot; destination = &quot;/tmp/agent/render.txt&quot; error_on_missing_key = true }   ","version":"Next","tagName":"h3"},{"title":"Interaction between exit_on_retry_failure and error_on_missing_key​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#interaction-between-exit_on_retry_failure-and-error_on_missing_key","content":" The parametererror_on_missing_key can be specified within the template stanza which determines if a template should error when a key is missing in the secret. When error_on_missing_key is not specified or set to false and the key to render is not in the secret's response, the templating engine will ignore it (or render &quot;&lt;no value&gt;&quot;) and continue on with its rendering.  If the desire is to have Agent fail and exit on a missing key, bothtemplate.error_on_missing_key and template_config.exit_on_retry_failure must be set to true. Otherwise, the templating engine will error and render to its destination, but agent will not exit and will retry until the key exists or until the process is terminated.  Note that a missing key from a secret's response is different from a missing or non-existent secret. The templating engine will always error if a secret is missing, but will only error for a missing key if error_on_missing_key is set. Whether OpenBao Agent will exit when the templating engine errors depends on the value of exit_on_retry_failure.  ","version":"Next","tagName":"h3"},{"title":"Template configurations​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#template-configurations","content":" The top level template block has multiple configuration entries. The parameters found in the template configuration section in the consul-templatedocumentation pagecan be used here:  tip The parameters marked with Δ below are only applicable to file templates and cannot be used with env_template entries in process supervisor mode.  source (string: &quot;&quot;) - Path on disk to use as the input template. This option is required if not using the contents option.destinationΔ (string: required) - Path on disk where the rendered secrets should be created. If the parent directories do not exist, OpenBao Agent will attempt to create them, unless create_dest_dirs is false.create_dest_dirsΔ (bool: true) - This option tells OpenBao Agent to create the parent directories of the destination path if they do not exist.contents (string: &quot;&quot;) - This option allows embedding the contents of a template in the configuration file rather then supplying the source path to the template file. This is useful for short templates. This option is mutually exclusive with the source option.commandΔ (string: &quot;&quot;) - This is the optional command to run when the template is rendered. The command will only run if the resulting template changes. The command must return within 30s (configurable), and it must have a successful exit code. OpenBao Agent is not a replacement for a process monitor or init system. This is deprecated in favor of the exec option.command_timeoutΔ (duration: 30s) - This is the maximum amount of time to wait for the optional command to return. This is deprecated in favor of theexec option.error_on_missing_key (bool: false) - Exit with an error when accessing a struct or map field/key that does notexist. The default behavior will print &lt;no value&gt;when accessing a field that does not exist. It is highly recommended you set this to &quot;true&quot;. Also see exit_on_retry_failure in global OpenBao Agent Template Config.execΔ (object: optional) - The exec block executes a command when the template is rendered and the output has changed. The block parameters arecommand (string or array: required) and timeout (string: optional, defaults to 30s). command can be given as a string or array of strings to execute, such as&quot;touch myfile&quot; or [&quot;touch&quot;, &quot;myfile&quot;]. To protect against command injection, we strongly recommend using an array of strings, and we attempt to parse that way first. Note also that using a comma with the string approach will cause it to be interpreted as an array, which may not be desirable.permsΔ (string: &quot;&quot;) - This is the permission to render the file. If this option is left unspecified, OpenBao Agent will attempt to match the permissions of the file that already exists at the destination path. If no file exists at that path, the permissions are 0644.backupΔ (bool: true) - This option backs up the previously rendered template at the destination path before writing a new one. It keeps exactly one backup. This option is useful for preventing accidental changes to the data without having a rollback strategy.left_delimiter (string: &quot;\\{\\{&quot;) - Delimiter to use in the template. The default is &quot;{{&quot; but for some templates, it may be easier to use a different delimiter that does not conflict with the output file itself.right_delimiter (string: &quot;}}&quot;) - Delimiter to use in the template. The default is &quot;}}&quot; but for some templates, it may be easier to use a different delimiter that does not conflict with the output file itself.sandbox_pathΔ (string: &quot;&quot;) - If a sandbox path is provided, any path provided to the file function is checked that it falls within the sandbox path. Relative paths that try to traverse outside the sandbox path will exit with an error.waitΔ (object: required) - This is the minimum(:maximum) to wait before rendering a new template to disk and triggering a command, separated by a colon (:).  ","version":"Next","tagName":"h2"},{"title":"Example template stanza​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#example-template-stanza","content":" template { source = &quot;/tmp/agent/template.ctmpl&quot; destination = &quot;/tmp/agent/render.txt&quot; error_on_missing_key = true }   If you only want to use the OpenBao agent to render one or more templates and do not need to sink the acquired credentials, you can omit the sink stanza from the auto_auth stanza in the agent configuration.  ","version":"Next","tagName":"h3"},{"title":"Renewals and updating secrets​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#renewals-and-updating-secrets","content":" The OpenBao Agent templating automatically renews and fetches secrets/tokens. Unlike OpenBao Agent caching, the behavior of how OpenBao Agent templating does this depends on the type of secret or token. The following is a high level overview of different behaviors.  ","version":"Next","tagName":"h2"},{"title":"Renewable secrets​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#renewable-secrets","content":" If a secret or token is renewable, OpenBao Agent will renew the secret after 2/3 of the secret's lease duration has elapsed.  ","version":"Next","tagName":"h3"},{"title":"Non-Renewable secrets​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#non-renewable-secrets","content":" If a secret or token isn't renewable or leased, OpenBao Agent will fetch the secret every 5 minutes. This can be configured using Template config static_secret_render_interval. Non-renewable secrets include (but not limited to) KV Version 2.  ","version":"Next","tagName":"h3"},{"title":"Non-Renewable leased secrets​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#non-renewable-leased-secrets","content":" If a secret or token is non-renewable but leased, OpenBao Agent will fetch the secret when 85% of the secrets time-to-live (TTL) is reached. Leased, non-renewable secrets include (but not limited to) dynamic secrets such as database credentials and KV Version 1.  ","version":"Next","tagName":"h3"},{"title":"Static roles​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#static-roles","content":" If a secret has a rotation_period, such as a database static role, OpenBao Agent template will fetch the new secret as it changes in OpenBao. It does this by inspecting the secret's time-to-live (TTL).  ","version":"Next","tagName":"h3"},{"title":"Certificates​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#certificates","content":" Certificates can be rendered using either pkiCert orsecret template functions, although it is recommended to use pkiCert to avoid unnecessarily generating certificates whenever Agent restarts or re-authenticates.  Rendering using the pkiCert template function​  If a certificate is rendered using the pkiCert template function, OpenBao Agent template will have the following fetching and re-rendering behaviors on certificates:  Fetches a new certificate on Agent startup if none has been previously rendered or the current rendered one has expired.On Agent's auto-auth re-authentication, due to a token expiry for example, skip fetching unless the current rendered one has expired.  Rendering using the secret template function​  If a certificate is rendered using the secret template function, OpenBao Agent template will have the following fetching and re-rendering behaviors on certificates:  Fetches a new certificate on Agent startup, even if previously rendered certificates are still valid.If generate_lease is unset or set to false, it uses the certificate'svalidTo field to determine re-fetch interval.If generate_lease is set to true, apply the non-renewable, leased secret rules.On Agent's auto-auth re-authentication, due to a token expiry for example, it fetches and re-renders a new certificate even if the existing certificate is valid.  ","version":"Next","tagName":"h3"},{"title":"Templating configuration example​","type":1,"pageTitle":"OpenBao agent templates","url":"/openbao/docs/agent-and-proxy/agent/template/#templating-configuration-example","content":" The following demonstrates OpenBao Agent Templates configuration blocks.  # Other OpenBao agent configuration blocks # ... template_config { static_secret_render_interval = &quot;10m&quot; exit_on_retry_failure = true } template { source = &quot;/tmp/agent/template.ctmpl&quot; destination = &quot;/tmp/agent/render.txt&quot; } template { contents = &quot;{{ with secret \\&quot;secret/my-secret\\&quot; }}{{ .Data.data.foo }}{{ end }}&quot; destination = &quot;/tmp/agent/render-content.txt&quot; }   And the following demonstrates how the templates look when using env_template withProcess Supervisor Mode  # Other OpenBao agent configuration blocks # ... template_config { static_secret_render_interval = &quot;10m&quot; exit_on_retry_failure = true } env_template &quot;MY_ENV_VAR&quot; { contents = &quot;{{ with secret \\&quot;secret/my-secret\\&quot; }}{{ .Data.data.foo }}{{ end }}&quot; } env_template &quot;ENV_VAR_FROM_FILE&quot; { source = &quot;/tmp/agent/template.ctmpl&quot; }  ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth AppRole method","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/approle/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Auto-Auth AppRole method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/approle/#configuration","content":" role_id_file_path (string: required) - The path to the file with role ID secret_id_file_path (string: optional) - The path to the file with secret ID. If not set, only the role-id will be used. In that case, the AppRole should have bind_secret_id set to false otherwise OpenBao Agent wouldn't be able to login. remove_secret_id_file_after_reading (bool: optional, defaults to true) - This can be set to false to disable the default behavior of removing the secret ID file after it's been read. secret_id_response_wrapping_path (string: optional) - If set, the value at secret_id_file_path will be expected to be a Response-Wrapping Tokencontaining the output of the secret ID retrieval endpoint for the role (e.g.auth/approle/role/webservers/secret-id) and the creation path for the response-wrapping token must match the value set here.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"OpenBao Auto-Auth AppRole method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/approle/#example-configuration","content":" An example configuration, using approle to enable auto-authand creating both a plaintext token sink and a response-wrapped token sink file, follows:  pid_file = &quot;./pidfile&quot; vault { address = &quot;https://127.0.0.1:8200&quot; } auto_auth { method { type = &quot;approle&quot; config = { role_id_file_path = &quot;roleid&quot; secret_id_file_path = &quot;secretid&quot; remove_secret_id_file_after_reading = false } } sink { type = &quot;file&quot; wrap_ttl = &quot;30m&quot; config = { path = &quot;sink_file_wrapped_1.txt&quot; } } sink { type = &quot;file&quot; config = { path = &quot;sink_file_unwrapped_2.txt&quot; } } } api_proxy { use_auto_auth_token = true } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true } template { source = &quot;/etc/openbao/server.key.ctmpl&quot; destination = &quot;/etc/openbao/server.key&quot; } template { source = &quot;/etc/openbao/server.crt.ctmpl&quot; destination = &quot;/etc/openbao/server.crt&quot; }  ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth cert method","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/cert/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Auto-Auth cert method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/cert/#configuration","content":" name (string: optional) - The trusted certificate role which should be used when authenticating with TLS. If a name is not specified, the auth method will try to authenticate against all trusted certificates. ca_cert (string: optional) - Path on the local disk to a single PEM-encoded CA certificate to verify the OpenBao server's SSL certificate. client_cert (string: optional) - Path on the local disk to a single PEM-encoded client certificate to use for cert auth method authentication. client_key (string: optional) - Path on the local disk to a single PEM-encoded private key matching the client certificate from client_cert. reload (bool: optional, default: false) - If true, causes the local x509 key-pair to be reloaded from disk on each authentication attempt. This is useful in situations where client certificates are short-lived and automatically renewed. ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth JWT method","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/jwt/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Auto-Auth JWT method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/jwt/#configuration","content":" path (string: required) - The path to the JWT file role (string: required) - The role to authenticate against on OpenBao remove_jwt_after_reading (bool: optional, defaults to true) - This can be set to false to disable the default behavior of removing the JWT after it's been read. remove_jwt_follows_symlinks (bool: optional, defaults to false) - This can be set to true to follow symlinks when removing the JWT after it has been read when executing the remove_jwt_after_reading behaviour. If set to false, it will delete the symlink, not the JWT. Does nothing if remove_jwt_after_reading is false. jwt_read_period (duration: &quot;0.5s&quot;, optional) - The duration after which Agent will attempt to read the JWT stored at path. Defaults to 1m ifremove_jwt_after_reading is set to true, or 0.5s otherwise. Uses duration format strings. ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth Kerberos method","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/kerberos/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Auto-Auth Kerberos method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/kerberos/#configuration","content":" krb5conf_path (string: required) is the path to a valid krb5.conf file describing how to communicate with the Kerberos environment.keytab_path (string: required) is the path to the keytab in which the entry lives for the entity authenticating to OpenBao. Keytab files should be protected from other users on a shared server using appropriate file permissions.username (string: required) is the username for the entry within the keytab to use for logging into Kerberos. This username must match a service account in LDAP.service (string: required) is the service principal name to use in obtaining a service ticket for gaining a SPNEGO token. This service must exist in LDAP.realm (string: required) is the name of the Kerberos realm. This realm must match the UPNDomain configured on the LDAP connection. This check is case-sensitive.disable_fast_negotiation (bool: optional) is for disabling the Kerberos auth method's default of using FAST negotiation. FAST is a pre-authentication framework for Kerberos. It includes a mechanism for tunneling pre-authentication exchanges using armoured KDC messages. FAST provides increased resistance to passive password guessing attacks. Some common Kerberos implementations do not support FAST negotiation. The default is false. ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth kubernetes method","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Auto-Auth kubernetes method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/kubernetes/#configuration","content":" role (string: required) - The role to authenticate against on OpenBaotoken_path (string: optional) - The file path to a custom JWT token to use for authentication. If omitted, the default service account token path is used.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"OpenBao Auto-Auth kubernetes method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/kubernetes/#tutorial","content":" Refer to the OpenBao Agent with Kubernetestutorial to learn how to authenticate the clients using a Kubernetes Service Account Token and manage the tokens lifecycle. ","version":"Next","tagName":"h2"},{"title":"OpenBao Auto-Auth token file method","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/methods/token_file/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao Auto-Auth token file method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/token_file/#configuration","content":" token_file_path (string: required) - The path to the file with the token inside. This token cannot be a wrapping token.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"OpenBao Auto-Auth token file method","url":"/openbao/docs/agent-and-proxy/autoauth/methods/token_file/#example-configuration","content":" An example configuration for OpenBao Agent, using the token_file method to enable auto-auth, follows:  pid_file = &quot;./pidfile&quot; vault { address = &quot;https://127.0.0.1:8200&quot; } auto_auth { method { type = &quot;token_file&quot; config = { token_file_path = &quot;/home/username/.vault-token&quot; } } } api_proxy { use_auto_auth_token = true } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true } template { source = &quot;/etc/openbao/server.key.ctmpl&quot; destination = &quot;/etc/openbao/server.key&quot; } template { source = &quot;/etc/openbao/server.crt.ctmpl&quot; destination = &quot;/etc/openbao/server.crt&quot; }  ","version":"Next","tagName":"h2"},{"title":"OpenBao agent and OpenBao proxy Auto-Auth sinks","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/sinks/","content":"OpenBao agent and OpenBao proxy Auto-Auth sinks Every time an auto-auth authentication is successful, the token is written to the enabled Sinks, subject to their configuration. Today, we only support one type of sink, file sink.","keywords":"","version":"Next"},{"title":"OpenBao agent and OpenBao proxy Auto-Auth file sink","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/autoauth/sinks/file/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao agent and OpenBao proxy Auto-Auth file sink","url":"/openbao/docs/agent-and-proxy/autoauth/sinks/file/#configuration","content":" path (string: required) - The path to use to write the token filemode (int: optional) - A string containing an octal number representing the bit pattern for the file mode, similar to chmod. Set to 0000 to prevent OpenBao from modifying the file mode.  Note: Configuration options for response-wrapping and encryption for the sink file are located within the options common to all sinks documentation. ","version":"Next","tagName":"h2"},{"title":"OpenBao proxy persistent caching","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/proxy/caching/persistent-caches/","content":"","keywords":"","version":"Next"},{"title":"OpenBao proxy persistent cache types​","type":1,"pageTitle":"OpenBao proxy persistent caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/persistent-caches/#openbao-proxy-persistent-cache-types","content":" Please see the sidebar for available types and their usage/configuration.  ","version":"Next","tagName":"h2"},{"title":"Persistent cache example configuration​","type":1,"pageTitle":"OpenBao proxy persistent caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/persistent-caches/#persistent-cache-example-configuration","content":" Here is an example of a persistent cache configuration.  # Other OpenBao proxy configuration blocks # ... cache { persist &quot;kubernetes&quot; { path = &quot;/openbao/proxy-cache&quot; } }  ","version":"Next","tagName":"h2"},{"title":"OpenBao proxy API proxy","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/proxy/apiproxy/","content":"","keywords":"","version":"Next"},{"title":"Functionality​","type":1,"pageTitle":"OpenBao proxy API proxy","url":"/openbao/docs/agent-and-proxy/proxy/apiproxy/#functionality","content":" The listener stanza for OpenBao Proxy configures a listener for OpenBao Proxy. If its role is not set to metrics_only, it will act as a proxy for the OpenBao server that has been configured in the vault stanza of Proxy Agent. This enables access to the OpenBao API from the Proxy API, and can be configured to optionally allow or force the automatic use of the Auto-Auth token for these requests, as described below.  If a listener has been configured alongside a cache stanza, the API Proxy will first attempt to utilize the cache subsystem for qualifying requests, before forwarding the request to OpenBao. See the caching docs for more information on caching.  ","version":"Next","tagName":"h2"},{"title":"Using Auto-Auth token​","type":1,"pageTitle":"OpenBao proxy API proxy","url":"/openbao/docs/agent-and-proxy/proxy/apiproxy/#using-auto-auth-token","content":" OpenBao Proxy allows for easy authentication to OpenBao in a wide variety of environments using Auto-Auth. By setting theuse_auto_auth_token (see below) configuration, clients will not be required to provide an OpenBao token to the requests made to the Agent. When this configuration is set, if the request doesn't already bear a token, then the auto-auth token will be used to forward the request to the OpenBao server. This configuration will be overridden if the request already has a token attached, in which case, the token present in the request will be used to forward the request to the OpenBao server.  ","version":"Next","tagName":"h2"},{"title":"Forcing Auto-Auth token​","type":1,"pageTitle":"OpenBao proxy API proxy","url":"/openbao/docs/agent-and-proxy/proxy/apiproxy/#forcing-auto-auth-token","content":" OpenBao Proxy can be configured to force the use of the auto-auth token by using the value force for the use_auto_auth_token option. This configuration overrides the default behavior described above in Using Auto-Auth Token, and instead ignores any existing OpenBao token in the request and instead uses the auto-auth token.  ","version":"Next","tagName":"h2"},{"title":"Configuration (api_proxy)​","type":1,"pageTitle":"OpenBao proxy API proxy","url":"/openbao/docs/agent-and-proxy/proxy/apiproxy/#configuration-api_proxy","content":" The top level api_proxy block has the following configuration entries:  use_auto_auth_token (bool/string: false) - If set, the requests made to Agent without an OpenBao token will be forwarded to the OpenBao server with the auto-auth token attached. If the requests already bear a token, this configuration will be overridden and the token in the request will be used to forward the request to the OpenBao server. If set to &quot;force&quot; Agent will use the auto-auth token, overwriting the attached OpenBao token if set.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"OpenBao proxy API proxy","url":"/openbao/docs/agent-and-proxy/proxy/apiproxy/#example-configuration","content":" Here is an example of a listener configuration alongside api_proxy configuration to force the use of the auto_auth token and enforce consistency.  # Other OpenBao proxy configuration blocks # ... api_proxy { use_auto_auth_token = &quot;force&quot; } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true }  ","version":"Next","tagName":"h3"},{"title":"OpenBao proxy kubernetes persistent cache","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/proxy/caching/persistent-caches/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"OpenBao proxy kubernetes persistent cache","url":"/openbao/docs/agent-and-proxy/proxy/caching/persistent-caches/kubernetes/#configuration","content":" service_account_token_file (string: optional) - When type is set to kubernetes, this configures the path on disk where the Kubernetes service account token can be found. Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token. ","version":"Next","tagName":"h2"},{"title":"OpenBao proxy caching","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/proxy/caching/","content":"","keywords":"","version":"Next"},{"title":"Caching and renewals​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#caching-and-renewals","content":" Response caching and renewals are managed by the proxy only under these specific scenarios.  Token creation requests are made through the proxy. This means that any login operations performed using various auth methods and invoking the token creation endpoints of the token auth method via the proxy will result in the response getting cached by the proxy. Responses containing new tokens will be cached by the proxy only if the parent token is already being managed by the proxy or if the new token is an orphan token. Leased secret creation requests are made through the proxy using tokens that are already managed by the proxy. This means that any dynamic credentials that are issued using the tokens managed by the proxy, will be cached and its renewals are taken care of.  ","version":"Next","tagName":"h2"},{"title":"Persistent cache​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#persistent-cache","content":" OpenBao Proxy can restore tokens and leases from a persistent cache file created by a previous OpenBao Proxy process.  Refer to the OpenBao Proxy Persistent Caching page for more information on this functionality.  ","version":"Next","tagName":"h2"},{"title":"Cache evictions​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#cache-evictions","content":" The eviction of cache entries pertaining to secrets will occur when the proxy can no longer renew them. This can happen when the secrets hit their maximum TTL or if the renewals result in errors.  OpenBao Proxy does some best-effort cache evictions by observing specific request types and response codes. For example, if a token revocation request is made via the proxy and if the forwarded request to the OpenBao server succeeds, then proxy evicts all the cache entries associated with the revoked token. Similarly, any lease revocation operation will also be intercepted by the proxy and the respective cache entries will be evicted.  Note that while proxy evicts the cache entries upon secret expirations and upon intercepting revocation requests, it is still possible for the proxy to be completely unaware of the revocations that happen through direct client interactions with the OpenBao server. This could potentially lead to stale cache entries. For managing the stale entries in the cache, an endpoint/proxy/v1/cache-clear(see below) is made available to manually evict cache entries based on some of the query criteria used for indexing the cache entries.  ","version":"Next","tagName":"h2"},{"title":"Request uniqueness​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#request-uniqueness","content":" In order to detect repeat requests and return cached responses, proxy will need to have a way to uniquely identify the requests. This computation as it stands today takes a simplistic approach (may change in future) of serializing and hashing the HTTP request along with all the headers and the request body. This hash value is then used as an index into the cache to check if the response is readily available. The consequence of this approach is that the hash value for any request will differ if any data in the request is modified. This has the side-effect of resulting in false negatives if say, the ordering of the request parameters are modified. As long as the requests come in without any change, caching behavior should be consistent. Identical requests with differently ordered request values will result in duplicated cache entries. A heuristic assumption that the clients will use consistent mechanisms to make requests, thereby resulting in consistent hash values per request is the idea upon which the caching functionality is built upon.  ","version":"Next","tagName":"h2"},{"title":"Renewal management​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#renewal-management","content":" The tokens and leases are renewed by the proxy using the secret renewer that is made available via the OpenBao server's Go API. Proxy performs all operations in memory and does not persist anything to storage. This means that when the proxy is shut down, all the renewal operations are immediately terminated and there is no way for the proxy to resume renewals after the fact. Note that shutting down the proxy does not indicate revocations of the secrets, instead it only means that renewal responsibility for all the valid unrevoked secrets are no longer performed by the OpenBao proxy.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#api","content":" ","version":"Next","tagName":"h2"},{"title":"Cache clear​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#cache-clear","content":" This endpoint clears the cache based on given criteria. To use this API, some information on how the proxy caches values should be known beforehand. Each response that is cached in the proxy will be indexed on some factors depending on the type of request. Those factors can be the token that is belonging to the cached response, the token_accessor of the token belonging to the cached response, the request_path that resulted in the cached response, the lease that is attached to the cached response, thenamespace to which the cached response belongs to, and a few more. This API exposes some factors through which associated cache entries are fetched and evicted. For listeners without caching enabled, this API will still be available, but will do nothing (there is no cache to clear) and will return a 200 response.  Method\tPath\tProducesPOST\t/proxy/v1/cache-clear\t200 application/json  Parameters​  type (strings: required) - The type of cache entries to evict. Valid values are request_path, lease, token, token_accessor, and all. If the type is set to all, the entire cache is cleared. value (string: required) - An exact value or the prefix of the value for the type selected. This parameter is optional when the type is set to all. namespace (string: optional) - This is only applicable when the type is set torequest_path. The namespace of which the cache entries to be evicted for the given request path.  ","version":"Next","tagName":"h3"},{"title":"Sample payload​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#sample-payload","content":" { &quot;type&quot;: &quot;token&quot;, &quot;value&quot;: &quot;hvs.rlNjegSKykWcplOkwsjd8bP9&quot; }   ","version":"Next","tagName":"h3"},{"title":"Sample request​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#sample-request","content":" $ curl \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:1234/proxy/v1/cache-clear   ","version":"Next","tagName":"h3"},{"title":"Configuration (cache)​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#configuration-cache","content":" The presence of the top level cache block in any way (including an empty cache block) will enable the cache. The top level cache block has the following configuration entry:  persist (object: optional) - Configuration for the persistent cache.  info Note: When the cache block is defined, a listener must also be defined in the config, otherwise there is no way to utilize the cache.  ","version":"Next","tagName":"h2"},{"title":"Configuration (Persist)​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#configuration-persist","content":" These are common configuration values that live within the persist block:  type (string: required) - The type of the persistent cache to use, e.g. kubernetes. Note: when using HCL this can be used as the key for the block, e.g. persist &quot;kubernetes&quot; {...}. Currently, only kubernetesis supported. path (string: required) - The path on disk where the persistent cache file should be created or restored from. keep_after_import (bool: optional) - When set to true, a restored cache file is not deleted. Defaults to false. exit_on_err (bool: optional) - When set to true, if any errors occur during a persistent cache restore, OpenBao Proxy will exit with an error. Defaults to true. service_account_token_file (string: optional) - When type is set to kubernetes, this configures the path on disk where the Kubernetes service account token can be found. Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token.  ","version":"Next","tagName":"h3"},{"title":"Configuration (listener)​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#configuration-listener","content":" listener (array of objects: required) - Configuration for the listeners.  There can be one or more listener blocks at the top level. Adding a listener enables the API Proxy and enables the API proxy to use the cache, if configured. These configuration values are common to both tcp and unix listener blocks. Blocks of typetcp support the standard tcp listeneroptions. Additionally, the role string option is available as part of the top level of the listener block, which can be configured to metrics_only to serve only metrics, or the default role, default, which serves everything (including metrics).  type (string: required) - The type of the listener to use. Valid values are tcp and unix.Note: when using HCL this can be used as the key for the block, e.g.listener &quot;tcp&quot; {...}. address (string: required) - The address for the listener to listen to. This can either be a URL path when using tcp or a file path when usingunix. For example, 127.0.0.1:8200 or /path/to/socket. Defaults to127.0.0.1:8200. tls_disable (bool: false) - Specifies if TLS will be disabled. tls_key_file (string: optional) - Specifies the path to the private key for the certificate. tls_cert_file (string: optional) - Specifies the path to the certificate for TLS.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"OpenBao proxy caching","url":"/openbao/docs/agent-and-proxy/proxy/caching/#example-configuration","content":" Here is an example of a cache configuration with the optional persist block, alongside a regular listener, and a listener that only serves metrics.  # Other OpenBao proxy configuration blocks # ... cache { persist = { type = &quot;kubernetes&quot; path = &quot;/openbao/proxy-cache/&quot; keep_after_import = true exit_on_err = true service_account_token_file = &quot;/tmp/serviceaccount/token&quot; } } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true } listener &quot;tcp&quot; { address = &quot;127.0.0.1:3000&quot; tls_disable = true role = &quot;metrics_only&quot; }  ","version":"Next","tagName":"h3"},{"title":"What is OpenBao Proxy?","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/proxy/","content":"","keywords":"","version":"Next"},{"title":"Auto-Auth​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#auto-auth","content":" OpenBao Proxy allows easy authentication to OpenBao in a wide variety of environments. Please see the Auto-Auth docsfor information.  Auto-Auth functionality takes place within an auto_auth configuration stanza.  ","version":"Next","tagName":"h2"},{"title":"API proxy​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#api-proxy","content":" OpenBao Proxy's primary purpose is to act as an API proxy for OpenBao, allowing you to talk to OpenBao's API via a listener. It can be configured to optionally allow or force the automatic use of the Auto-Auth token for these requests. Please see the API Proxy docsfor more information.  API Proxy functionality takes place within a defined listener, and its behaviour can be configured with anapi_proxy stanza.  ","version":"Next","tagName":"h2"},{"title":"Caching​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#caching","content":" OpenBao Proxy allows client-side caching of responses containing newly created tokens and responses containing leased secrets generated off of these newly created tokens. Please see the Caching docs for information.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#api","content":" ","version":"Next","tagName":"h2"},{"title":"Quit​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#quit","content":" This endpoint triggers shutdown of the proxy. By default, it is disabled, and can be enabled per listener using the proxy_api stanza. It is recommended to only enable this on trusted interfaces, as it does not require any authorization to use.  Method\tPathPOST\t/proxy/v1/quit  ","version":"Next","tagName":"h3"},{"title":"Cache​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#cache","content":" See the caching page for details on the cache API.  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Command options​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#command-options","content":" -log-level (string: &quot;info&quot;) - Log verbosity level. Supported values (in order of descending detail) are trace, debug, info, warn, and error. This can also be specified via the VAULT_LOG_LEVEL environment variable. -log-format (string: &quot;standard&quot;) - Log format. Supported values are standard and json. This can also be specified via theVAULT_LOG_FORMAT environment variable. -log-file - the absolute path where OpenBao Proxy should save log messages. Paths that end with a path separator use the default file name,proxy.log. Paths that do not end with a file extension use the default.log extension. If the log file rotates, OpenBao Proxy appends the current timestamp to the file name at the time of rotation. For example: log-file\tFull log file\tRotated log file/var/log\t/var/log/proxy.log\t/var/log/proxy-{timestamp}.log /var/log/my-diary\t/var/log/my-diary.log\t/var/log/my-diary-{timestamp}.log /var/log/my-diary.txt\t/var/log/my-diary.txt\t/var/log/my-diary-{timestamp}.txt -log-rotate-bytes - to specify the number of bytes that should be written to a log before it needs to be rotated. Unless specified, there is no limit to the number of bytes that can be written to a log file. -log-rotate-duration - to specify the maximum duration a log should be written to before it needs to be rotated. Must be a duration value such as 30s. Defaults to 24h. -log-rotate-max-files - to specify the maximum number of older log file archives to keep. Defaults to 0 (no files are ever deleted). Set to -1 to discard old log files when a new one is created.  ","version":"Next","tagName":"h3"},{"title":"Configuration file options​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#configuration-file-options","content":" These are the currently-available general configuration options:  vault (vault: &lt;optional&gt;) - Specifies the remote OpenBao server the Proxy connects to. auto_auth (auto_auth: &lt;optional&gt;) - Specifies the method and other options used for Auto-Auth functionality. api_proxy (api_proxy: &lt;optional&gt;) - Specifies options used for API Proxy functionality. cache (cache: &lt;optional&gt;) - Specifies options used for Caching functionality. listener (listener: &lt;optional&gt;) - Specifies the addresses and ports on which the Proxy will respond to requests.  warning Note: On SIGHUP (kill -SIGHUP $(pidof bao)), OpenBao Proxy will attempt to reload listener TLS configuration. This method can be used to refresh certificates used by OpenBao Proxy without having to restart its process.  pid_file (string: &quot;&quot;) - Path to the file in which the Proxy's Process ID (PID) should be stored exit_after_auth (bool: false) - If set to true, the proxy will exit with code 0 after a single successful auth, where success means that a token was retrieved and all sinks successfully wrote it disable_idle_connections (string array: []) - A list of strings that disables idle connections for various features in OpenBao Proxy. Valid values include: auto-auth, and proxying. Can also be configured by setting the VAULT_PROXY_DISABLE_IDLE_CONNECTIONSenvironment variable as a comma separated string. This environment variable will override any values found in a configuration file. disable_keep_alives (string array: []) - A list of strings that disables keep alives for various features in OpenBao Agent. Valid values include: auto-auth, and proxying. Can also be configured by setting the VAULT_PROXY_DISABLE_KEEP_ALIVESenvironment variable as a comma separated string. This environment variable will override any values found in a configuration file. template (template: &lt;optional&gt;) - Specifies options used for templating OpenBao secrets to files. template_config (template_config: &lt;optional&gt;) - Specifies templating engine behavior. telemetry (telemetry: &lt;optional&gt;) – Specifies the telemetry reporting system. See the telemetry Stanza section below for a list of metrics specific to Proxy. log_level - Equivalent to the -log-level command-line flag.  warning Note: On SIGHUP (kill -SIGHUP $(pidof bao)), OpenBao Proxy will update the log level to the value specified by configuration file (including overriding values set using CLI or environment variable parameters).  log_format - Equivalent to the -log-format command-line flag. log_file - Equivalent to the -log-file command-line flag. log_rotate_duration - Equivalent to the -log-rotate-duration command-line flag. log_rotate_bytes - Equivalent to the -log-rotate-bytes command-line flag. log_rotate_max_files - Equivalent to the -log-rotate-max-files command-line flag.  ","version":"Next","tagName":"h3"},{"title":"vault stanza​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#vault-stanza","content":" There can at most be one top level vault block, and it has the following configuration entries:  address (string: &lt;optional&gt;) - The address of the OpenBao server to connect to. This should be a Fully Qualified Domain Name (FQDN) or IP such as https://openbao-fqdn:8200 or https://172.16.9.8:8200. This value can be overridden by setting the VAULT_ADDR environment variable. ca_cert (string: &lt;optional&gt;) - Path on the local disk to a single PEM-encoded CA certificate to verify the OpenBao server's SSL certificate. This value can be overridden by setting the VAULT_CACERT environment variable. ca_path (string: &lt;optional&gt;) - Path on the local disk to a directory of PEM-encoded CA certificates to verify the OpenBao server's SSL certificate. This value can be overridden by setting the VAULT_CAPATH environment variable. client_cert (string: &lt;optional&gt;) - Path on the local disk to a single PEM-encoded CA certificate to use for TLS authentication to the OpenBao server. This value can be overridden by setting the VAULT_CLIENT_CERT environment variable. client_key (string: &lt;optional&gt;) - Path on the local disk to a single PEM-encoded private key matching the client certificate from client_cert. This value can be overridden by setting the VAULT_CLIENT_KEY environment variable. tls_skip_verify (string: &lt;optional&gt;) - Disable verification of TLS certificates. Using this option is highly discouraged as it decreases the security of data transmissions to and from the OpenBao server. This value can be overridden by setting the VAULT_SKIP_VERIFY environment variable. tls_server_name (string: &lt;optional&gt;) - Name to use as the SNI host when connecting via TLS. This value can be overridden by setting theVAULT_TLS_SERVER_NAME environment variable.  retry stanza​  The vault stanza may contain a retry stanza that controls how failing OpenBao requests are handled. Auto-auth, however, has its own notion of retrying and is not affected by this section.  Here are the options for the retry stanza:  num_retries (int: 12) - Specify how many times a failing request will be retried. A value of 0 translates to the default, i.e. 12 retries. A value of -1 disables retries. The environment variable VAULT_MAX_RETRIESoverrides this setting.  Requests originating from the proxy cache will only be retried if they resulted in specific HTTP result codes: any 50x code except 501 (&quot;not implemented&quot;). Requests coming from the template subsystem are retried regardless of the failure.  ","version":"Next","tagName":"h3"},{"title":"listener stanza​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#listener-stanza","content":" OpenBao Proxy supports one or more listener stanzas. Listeners can be configured with or without caching, but will use the cache if it has been configured, and will enable the API proxy. In addition to the standard listener configuration, a Proxy's listener configuration also supports the following:  require_request_header (bool: false) - Require that all incoming HTTP requests on this listener must have an X-Vault-Request: true header entry. Using this option offers an additional layer of protection from Server Side Request Forgery attacks. Requests on the listener that do not have the properX-Vault-Request header will fail, with a HTTP response status code of 412: Precondition Failed. role (string: default) - role determines which APIs the listener serves. It can be configured to metrics_only to serve only metrics, or the default role, default, which serves everything (including metrics). The require_request_header does not apply to metrics_only listeners. proxy_api (proxy_api: &lt;optional&gt;) - Manages optional Proxy API endpoints.  proxy_api stanza​  enable_quit (bool: false) - If set to true, the Proxy will enable the quit API.  ","version":"Next","tagName":"h3"},{"title":"telemetry stanza​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#telemetry-stanza","content":" OpenBao Proxy supports the telemetry stanza and collects various runtime metrics about its performance, the auto-auth and the cache status:  Metric\tDescription\tTypevault.proxy.auth.failure\tNumber of authentication failures\tcounter vault.proxy.auth.success\tNumber of authentication successes\tcounter vault.proxy.proxy.success\tNumber of requests successfully proxied\tcounter vault.proxy.proxy.client_error\tNumber of requests for which OpenBao returned an error\tcounter vault.proxy.proxy.error\tNumber of requests the proxy failed to proxy\tcounter vault.proxy.cache.hit\tNumber of cache hits\tcounter vault.proxy.cache.miss\tNumber of cache misses\tcounter  ","version":"Next","tagName":"h3"},{"title":"Start OpenBao proxy​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#start-openbao-proxy","content":" To run OpenBao Proxy:  Download the OpenBao binary where the client application runs (virtual machine, Kubernetes pod, etc.) Create an OpenBao Proxy configuration file. (See the Example Configuration section for an example configuration.) Start an OpenBao Proxy with the configuration file.  Example:  $ bao proxy -config=/etc/openbao/proxy-config.hcl   To get help, run:  $ bao proxy -h   As with OpenBao, the -config flag can be used in three different ways:  Use the flag once to name the path to a single specific configuration file.Use the flag multiple times to name multiple configuration files, which will be composed at runtime.Use the flag to name a directory of configuration files, the contents of which will be composed at runtime.  ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"What is OpenBao Proxy?","url":"/openbao/docs/agent-and-proxy/proxy/#example-configuration","content":" An example configuration, with very contrived values, follows:  pid_file = &quot;./pidfile&quot; vault { address = &quot;https://openbao-fqdn:8200&quot; retry { num_retries = 5 } } auto_auth { method &quot;kubernetes&quot; { config = { role = &quot;foobar&quot; } } sink &quot;file&quot; { config = { path = &quot;/tmp/file-foo&quot; } } sink &quot;file&quot; { wrap_ttl = &quot;5m&quot; aad_env_var = &quot;TEST_AAD_ENV&quot; dh_type = &quot;curve25519&quot; dh_path = &quot;/tmp/file-foo-dhpath2&quot; config = { path = &quot;/tmp/file-bar&quot; } } } cache { // An empty cache stanza still enables caching } api_proxy { use_auto_auth_token = true } listener &quot;unix&quot; { address = &quot;/path/to/socket&quot; tls_disable = true agent_api { enable_quit = true } } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8100&quot; tls_disable = true }  ","version":"Next","tagName":"h2"},{"title":"Running different versions of proxy and server","type":0,"sectionRef":"#","url":"/openbao/docs/agent-and-proxy/proxy/versions/","content":"","keywords":"","version":"Next"},{"title":"Older version of proxy than server​","type":1,"pageTitle":"Running different versions of proxy and server","url":"/openbao/docs/agent-and-proxy/proxy/versions/#older-version-of-proxy-than-server","content":" We do not anticipate any problems stemming from continuing to run an older Proxy version after the server nodes are upgraded to a later version. Existing deployments using Proxy should not be impacted, as we don't generally make backwards-incompatible changes to OpenBao Server.  Auto-auth:  new auth methods that have been introduced since Proxy was built will be unavailableexisting auth methods should continue to function normally  Proxy:  since Proxy simply mirrors the incoming requests, even if an incoming request uses an endpoint that didn't exist when that version of Proxy was compiled, that won't impede Proxy's ability to proxy the request  ","version":"Next","tagName":"h2"},{"title":"Newer version of proxy than server​","type":1,"pageTitle":"Running different versions of proxy and server","url":"/openbao/docs/agent-and-proxy/proxy/versions/#newer-version-of-proxy-than-server","content":" It is possible that an Proxy could depend on features that don’t exist in older Server versions.  Auto-auth:  Proxy may claim to support newer auth methods that have been introduced since Server was built, but they won't work due to Server not supporting themProxy may make use of new functionality for existing auth methods that isn't available in an older Server you're using Generally we will try to make such a change be opt-in, or to gracefully degrade when connecting to an older Server instance, unless there's a very good reason (such as a serious security flaw being patched)  Proxy:  since Proxy simply mirrors the incoming requests, it is unlikely that incompatibilities would surface in proxying, but new functionality may not be available ","version":"Next","tagName":"h2"},{"title":"File audit device","type":0,"sectionRef":"#","url":"/openbao/docs/audit/file/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"File audit device","url":"/openbao/docs/audit/file/#examples","content":" Enable at the default path:  $ bao audit enable file file_path=/var/log/openbao_audit.log   Enable at a different path. It is possible to enable multiple copies of an audit device:  $ bao audit enable -path=&quot;openbao_audit_1&quot; file file_path=/home/user/openbao_audit.log   Enable logs on stdout. This is useful when running in a container:  $ bao audit enable file file_path=stdout   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"File audit device","url":"/openbao/docs/audit/file/#configuration","content":" Note the difference between audit enable command options and the file backend configuration options. Use bao audit enable -help to see the command options.  The file audit device supports the common configuration options documented on the main Audit Devices page, and these device-specific options:  file_path (string: &lt;required&gt;) - The path to where the audit log will be written. If a file already exists at the given path, the audit backend will append to it. There are some special keywords: stdout writes the audit log to standard output discard discards output, instead of writing it to a device (useful in testing scenarios) mode (string: &quot;0600&quot;) - A string containing an octal number representing the bit pattern for the file mode, similar to chmod. Set to &quot;0000&quot; to prevent OpenBao from modifying the file mode.  ","version":"Next","tagName":"h2"},{"title":"Log file rotation​","type":1,"pageTitle":"File audit device","url":"/openbao/docs/audit/file/#log-file-rotation","content":" To properly rotate OpenBao File Audit Device log files on BSD, Darwin, or Linux-based OpenBao servers, it is important that you configure your log rotation software to send the bao process a signal hang up / SIGHUP after each rotation of the log file. ","version":"Next","tagName":"h2"},{"title":"Audit devices","type":0,"sectionRef":"#","url":"/openbao/docs/audit/","content":"","keywords":"","version":"Next"},{"title":"Enabling multiple devices​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#enabling-multiple-devices","content":" When multiple audit devices are enabled, OpenBao will attempt to send the audit logs to all of them. This allows you to not only have redundant copies, but also a way to check for data tampering in the logs themselves.  OpenBao considers a request to be successful if it can log to at least one configured audit device (see: Blocked Audit Devices section below). Therefore in order to build a complete picture of all audited actions, use the aggregate/union of the logs from each audit device.  warning Note: It is highly recommended that you configure OpenBao to use multiple audit devices. Audit failures can prevent OpenBao from servicing requests, so it is important to provide at least one other device.  ","version":"Next","tagName":"h2"},{"title":"Format​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#format","content":" Each line in the audit log is a JSON object. The type field specifies what type of object it is. Currently, only two types exist: request and response. The line contains all of the information for any given request and response. By default, all the sensitive information is first hashed before logging in the audit logs.  ","version":"Next","tagName":"h2"},{"title":"Sensitive information​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#sensitive-information","content":" The audit logs contain the full request and response objects for every interaction with OpenBao. The request and response can be matched utilizing a unique identifier assigned to each request.  Most strings contained within requests and responses are hashed with a salt using HMAC-SHA256. The purpose of the hash is so that secrets aren't in plaintext within your audit logs. However, you're still able to check the value of secrets by generating HMACs yourself; this can be done with the audit device's hash function and salt by using the /sys/audit-hash API endpoint (see the documentation for more details).  warning Currently, only strings that come from JSON or returned in JSON are HMAC'd. Other data types, like integers, booleans, and so on, are passed through in plaintext. We recommend that all sensitive data be provided as string values inside all JSON sent to OpenBao (i.e., that integer values are provided in quotes).  While most strings are hashed, OpenBao does make some exceptions, such as auth and secrets, and users can enable additional exceptions using the secrets enable command, and then tune it afterward.  see also:  secrets tune  auth enable  auth tune  ","version":"Next","tagName":"h2"},{"title":"Enabling/Disabling audit devices​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#enablingdisabling-audit-devices","content":" When an OpenBao server is first initialized, no auditing is enabled. Audit devices must be enabled by a root user using bao audit enable.  When enabling an audit device, options can be passed to it to configure it. For example, the command below enables the file audit device:  $ bao audit enable file file_path=/var/log/openbao_audit.log   In the command above, we passed the &quot;file_path&quot; parameter to specify the path where the audit log will be written to. Each audit device has its own set of parameters. See the documentation to the left for more details.  warning Note: Audit device configuration is replicated to all nodes within a cluster by default. Before enabling an audit device, ensure that all nodes within the cluster(s) will be able to successfully log to the audit device to avoid OpenBao being blocked from serving requests. An audit device can be limited to only within the node's cluster with the local parameter.  When an audit device is disabled, it will stop receiving logs immediately. The existing logs that it did store are untouched.  warning Note: Once an audit device is disabled, you will no longer be able to HMAC values for comparison with entries in the audit logs. This is true even if you re-enable the audit device at the same path, as a new salt will be created for hashing.  ","version":"Next","tagName":"h2"},{"title":"Blocked audit devices​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#blocked-audit-devices","content":" Audit device logs are critically important and ignoring auditing failures opens an avenue for attack. OpenBao will not respond to requests when no enabled audit devices can record them.  OpenBao can distinguish between two types of audit device failures.  A blocking failure is one where an attempt to write to the audit device never completes. This is unlikely with a local disk device, but could occure with a network-based audit device. When multiple audit devices are enabled, if any of them fail in a non-blocking fashion, OpenBao requests can still complete successfully provided at least one audit device successfully writes the audit record. If any of the audit devices fail in a blocking fashion however, OpenBao requests will hang until the blocking is resolved.  In other words, OpenBao will not complete any requests until the blocked audit device can write.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#tutorial","content":" Refer to Blocked Audit Devices for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#api","content":" Audit devices also have a full HTTP API. Please see the Audit device API docs for more details.  ","version":"Next","tagName":"h2"},{"title":"Common configuration options​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#common-configuration-options","content":" elide_list_responses (bool: false) - See Eliding list response bodies below. format (string: &quot;json&quot;) - Allows selecting the output format. Valid values are &quot;json&quot; and &quot;jsonx&quot;, which formats the normal log entries as XML. hmac_accessor (bool: true) - If enabled, enables the hashing of token accessor. log_raw (bool: false) - If enabled, logs the security sensitive information without hashing, in the raw format. prefix (string: &quot;&quot;) - A customizable string prefix to write before the actual log line.  ","version":"Next","tagName":"h2"},{"title":"Eliding list response bodies​","type":1,"pageTitle":"Audit devices","url":"/openbao/docs/audit/#eliding-list-response-bodies","content":" Some OpenBao responses can be very large. Primarily, this affects list operations - as OpenBao lacks pagination in its APIs, listing a very large collection can result in a response that is tens of megabytes long. Some audit backends are unable to process individual audit records of larger sizes.  The contents of the response for a list operation is often not very interesting; most contain only a &quot;keys&quot; field, containing a list of IDs. Select API endpoints additionally return a &quot;key_info&quot; field, a map from ID to some additional information about the list entry - identity/entity/id/ is an example of this. Even in this case, the response to a list operation is usually less-confidential or public information, for which having the full response in the audit logs is of lesser importance.  The elide_list_responses audit option provides the flexibility to not write the full list response data from the audit log, to mitigate the creation of very long individual audit records.  When enabled, it affects only audit records of type=response andrequest.operation=list. The values of response.data.keys andresponse.data.key_info will be replaced with a simple integer, recording how many entries were contained in the list (keys) or map (key_info) - therefore even with this feature enabled, it is still possible to see how many items were returned by a list operation.  This extra processing only affects the response data fields keys and key_info, and only when they have the expected data types - in the event a list response contains data outside of the usual conventions that apply to OpenBao list responses, it will be left as is by this feature.  Here is an example of an audit record that has been processed by this feature (formatted with extra whitespace, and with fields not relevant to the example omitted):  { &quot;type&quot;: &quot;response&quot;, &quot;request&quot;: { &quot;operation&quot;: &quot;list&quot; }, &quot;response&quot;: { &quot;data&quot;: { &quot;key_info&quot;: 4, &quot;keys&quot;: 4 } } }  ","version":"Next","tagName":"h2"},{"title":"Socket audit device","type":0,"sectionRef":"#","url":"/openbao/docs/audit/socket/","content":"","keywords":"","version":"Next"},{"title":"Enabling​","type":1,"pageTitle":"Socket audit device","url":"/openbao/docs/audit/socket/#enabling","content":" Enable at the default path:  $ bao audit enable socket   Supply configuration parameters via K=V pairs:  $ bao audit enable socket address=127.0.0.1:9090 socket_type=tcp   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Socket audit device","url":"/openbao/docs/audit/socket/#configuration","content":" The socket audit device supports the common configuration options documented on the main Audit Devices page, and these device-specific options:  address (string: &quot;&quot;) - The socket server address to use. Example127.0.0.1:9090 or /tmp/audit.sock. socket_type (string: &quot;tcp&quot;) - The socket type to use, any type compatible with net.Dial is acceptable. It's important to note if TCP is used and the destination socket becomes unavailable OpenBao may become unresponsive per Blocked Audit Devices. write_timeout (string: 2s) - The (deadline) time in seconds to allow writes to be completed over the socket. A zero value means that write attempts will not time out. ","version":"Next","tagName":"h2"},{"title":"Syslog audit device","type":0,"sectionRef":"#","url":"/openbao/docs/audit/syslog/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"Syslog audit device","url":"/openbao/docs/audit/syslog/#examples","content":" Audit syslog device can be enabled by the following command:  $ bao audit enable syslog   Supply configuration parameters via K=V pairs:  $ bao audit enable syslog tag=&quot;openbao&quot; facility=&quot;AUTH&quot;   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Syslog audit device","url":"/openbao/docs/audit/syslog/#configuration","content":" The syslog audit device supports the common configuration options documented on the main Audit Devices page, and these device-specific options:  facility (string: &quot;AUTH&quot;) - The syslog facility to use. tag (string: &quot;openbao&quot;) - The syslog tag to use. ","version":"Next","tagName":"h2"},{"title":"Auth methods","type":0,"sectionRef":"#","url":"/openbao/docs/auth/","content":"","keywords":"","version":"Next"},{"title":"Enabling/Disabling auth methods​","type":1,"pageTitle":"Auth methods","url":"/openbao/docs/auth/#enablingdisabling-auth-methods","content":" Auth methods can be enabled/disabled using the CLI or the API.  $ bao auth enable userpass   When enabled, auth methods are similar to secrets engines: they are mounted within the OpenBao mount table and can be accessed and configured using the standard read/write API. All auth methods are mounted underneath the auth/ prefix.  By default, auth methods are mounted to auth/&lt;type&gt;. For example, if you enable &quot;ldap&quot;, then you can interact with it at auth/ldap. However, this path is customizable, allowing users with advanced use cases to mount a single auth method multiple times.  $ bao auth enable -path=my-login userpass   When an auth method is disabled, all users authenticated via that method are automatically logged out.  ","version":"Next","tagName":"h2"},{"title":"External auth method considerations​","type":1,"pageTitle":"Auth methods","url":"/openbao/docs/auth/#external-auth-method-considerations","content":" When using an external auth method (e.g., Kubernetes), OpenBao will call the external service at the time of authentication and for subsequent token renewals. If the status of an entity changes in the external system (e.g., an account expires or is disabled), OpenBao denies requests to renew tokens associated with the entity. However, any existing token remain valid for the original grant period unless they are explicitly revoked within OpenBao. Operators should set appropriatetoken TTLs when using external authN methods. ","version":"Next","tagName":"h2"},{"title":"OIDC provider configuration","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/","content":"OIDC provider configuration This page collects high-level setup steps on how to configure an OIDC application for various providers. For more general usage and operation information, see the OpenBao JWT/OIDC method documentation. OIDC providers are often highly configurable, and you should become familiar with their recommended settings and best practices. The guides listed below are largely community-driven and intended to help you get started. Corrections and additions may be submitted via the OpenBao Github repository. Auth0Azure ADForgeRockGitlabGoogleKeycloakKubernetesOktaSecureAuthIBMISAM","keywords":"","version":"Next"},{"title":"TLS certificates auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/cert/","content":"","keywords":"","version":"Next"},{"title":"Revocation checking​","type":1,"pageTitle":"TLS certificates auth method","url":"/openbao/docs/auth/cert/#revocation-checking","content":" An authorized user can submit PEM-formatted CRLs identified by a given name; these can be updated or deleted at will. They may also set the URL of a trusted CRL distribution point, and have OpenBao fetch the CRL as needed.  When there are CRLs present, at the time of client authentication:  If the client presents any chain where no certificate in the chain matches a revoked serial number, authentication is allowed If there is no chain presented by the client without a revoked serial number, authentication is denied  This method provides good security while also allowing for flexibility. For instance, if an intermediate CA is going to be retired, a client can be configured with two certificate chains: one that contains the initial intermediate CA in the path, and the other that contains the replacement. When the initial intermediate CA is revoked, the chain containing the replacement will still allow the client to successfully authenticate.  N.B.: Matching is performed by serial number only. For most CAs, including OpenBao's pki method, multiple CRLs can successfully be used as serial numbers are globally unique. However, since RFCs only specify that serial numbers must be unique per-CA, some CAs issue serial numbers in-order, which may cause clashes if attempting to use CRLs from two such CAs in the same mount of the method. The workaround here is to mount multiple copies of thecert method, configure each with one CA/CRL, and have clients connect to the appropriate mount.  In addition, if a CRL distribution point is not set the method will not fetch the CRLs itself, the CRL's designated time to next update is not considered. If a CRL is no longer in use, it is up to the administrator to remove it from the method.  In addition to automatic or manual CRL management, OCSP may be enabled for a configured certificate, in which case OpenBao will query the OCSP server either specified in the presented certificate or configured in the auth method to check revocation.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"TLS certificates auth method","url":"/openbao/docs/auth/cert/#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"TLS certificates auth method","url":"/openbao/docs/auth/cert/#via-the-cli","content":" The below authenticates against the web cert role by presenting a certificate (cert.pem) and key (key.pem) signed by the CA associated with the web cert role. Note that the name web ties to the configuration example below writing to a path of auth/cert/certs/web. If a certificate role name is not specified, the auth method will try to authenticate against all trusted certificates.  warning NOTE The -ca-cert value used here is for the OpenBao TLS Listener CA certificate, not the CA that issued the client authentication certificate. This can be omitted if the CA used to issue the OpenBao server certificate is trusted by the local system executing this command.  $ bao login \\ -method=cert \\ -ca-cert=openbao-ca.pem \\ -client-cert=cert.pem \\ -client-key=key.pem \\ name=web   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"TLS certificates auth method","url":"/openbao/docs/auth/cert/#via-the-api","content":" The endpoint for the login is /login. The client simply connects with their TLS certificate and when the login endpoint is hit, the auth method will determine if there is a matching trusted certificate to authenticate the client. Optionally, you may specify a single certificate role to authenticate against.  warning NOTE The --cacert value used here is for the OpenBao TLS Listener CA certificate, not the CA that issued the client authentication certificate. This can be omitted if the CA used to issue the OpenBao server certificate is trusted by the local system executing this command.  $ curl \\ --request POST \\ --cacert openbao-ca.pem \\ --cert cert.pem \\ --key key.pem \\ --data '{&quot;name&quot;: &quot;web&quot;}' \\ https://127.0.0.1:8200/v1/auth/cert/login   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"TLS certificates auth method","url":"/openbao/docs/auth/cert/#configuration","content":" Auth methods must be configured in advance before users or machines can authenticate. These steps are usually completed by an operator or configuration management tool.  Enable the certificate auth method: $ bao auth enable cert Configure it with trusted certificates that are allowed to authenticate: $ bao write auth/cert/certs/web \\ display_name=web \\ policies=web,prod \\ certificate=@web-cert.pem \\ ttl=3600 This creates a new trusted certificate &quot;web&quot; with same display name and the &quot;web&quot; and &quot;prod&quot; policies. The certificate (public key) used to verify clients is given by the &quot;web-cert.pem&quot; file. Lastly, an optional ttl value can be provided in seconds to limit the lease duration.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"TLS certificates auth method","url":"/openbao/docs/auth/cert/#api","content":" The TLS Certificate auth method has a full HTTP API. Please see theTLS Certificate API for more details. ","version":"Next","tagName":"h2"},{"title":"JWT/OIDC auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/","content":"","keywords":"","version":"Next"},{"title":"OIDC authentication​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#oidc-authentication","content":" This section covers the setup and use of OIDC roles. If a JWT is to be provided directly, refer to the JWT Authentication section below. Basic familiarity with OIDC conceptsis assumed. The Authorization Code flow makes use of the Proof Key for Code Exchange (PKCE) extension.  OpenBao includes two built-in OIDC login flows: the OpenBao UI, and the CLI using a bao login.  ","version":"Next","tagName":"h2"},{"title":"Redirect URIs​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#redirect-uris","content":" An important part of OIDC role configuration is properly setting redirect URIs. This must be done both in OpenBao and with the OIDC provider, and these configurations must align. The redirect URIs are specified for a role with the allowed_redirect_uris parameter. There are different redirect URIs to configure the OpenBao UI and CLI flows, so one or both will need to be set up depending on the installation.  CLI  If you plan to support authentication via bao login -method=oidc, a localhost redirect URI must be set. This can usually be: http://localhost:8250/oidc/callback. Logins via the CLI may specify a different host and/or listening port if needed, and a URI with this host/port must match one of the configured redirected URIs. These same &quot;localhost&quot; URIs must be added to the provider as well.  OpenBao UI  Logging in via the OpenBao UI requires a redirect URI of the form:  https://{host:port}/ui/vault/auth/{path}/oidc/callback  The &quot;host:port&quot; must be correct for the OpenBao server, and &quot;path&quot; must match the path the JWT backend is mounted at (e.g. &quot;oidc&quot; or &quot;jwt&quot;).  If the oidc_response_mode is set to form_post, then logging in via the OpenBao UI requires a redirect URI of the form:  https://{host:port}/v1/auth/{path}/oidc/callback  ","version":"Next","tagName":"h3"},{"title":"OIDC login (OpenBao UI)​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#oidc-login-openbao-ui","content":" Select the &quot;OIDC&quot; login method.Enter a role name if necessary.Press &quot;Sign In&quot; and complete the authentication with the configured provider.  ","version":"Next","tagName":"h3"},{"title":"OIDC login (CLI)​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#oidc-login-cli","content":" The CLI login defaults to path of /oidc. If this auth method was enabled at a different path, specify -path=/my-path in the CLI.  $ bao login -method=oidc port=8400 role=test Complete the login via your OIDC provider. Launching browser to: https://myco.auth0.com/authorize?redirect_uri=http%3A%2F%2Flocalhost%3A8400%2Foidc%2Fcallback&amp;client_id=r3qXc2bix9eF...   The browser will open to the generated URL to complete the provider's login. The URL may be entered manually if the browser cannot be automatically opened.  skip_browser (default: &quot;false&quot;). Toggle the automatic launching of the default browser to the login URL.  The callback listener may be customized with the following optional parameters. These are typically not required to be set:  mount (default: &quot;oidc&quot;)listenaddress (default: &quot;localhost&quot;)port (default: 8250)callbackhost (default: &quot;localhost&quot;)callbackmethod (default: &quot;http&quot;)callbackport (default: value set for port). This value is used in the redirect_uri, whereasport is the localhost port that the listener is using. These two may be different in advanced setups.  ","version":"Next","tagName":"h3"},{"title":"OIDC provider configuration​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#oidc-provider-configuration","content":" The OIDC authentication flow has been successfully tested with a number of providers. A full guide to configuring OAuth/OIDC applications is beyond the scope of OpenBao documentation, but a collection of provider configuration steps has been collected to help get started:OIDC Provider Setup  ","version":"Next","tagName":"h3"},{"title":"OIDC configuration troubleshooting​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#oidc-configuration-troubleshooting","content":" This amount of configuration required for OIDC is relatively small, but it can be tricky to debug why things aren't working. Some tips for setting up OIDC:  If a role parameter (e.g. bound_claims) requires a map value, it can't be set individually using the OpenBao CLI. In these cases the best approach is to write the entire configuration as a single JSON object:  bao write auth/oidc/role/demo -&lt;&lt;EOF { &quot;user_claim&quot;: &quot;sub&quot;, &quot;bound_audiences&quot;: &quot;abc123&quot;, &quot;role_type&quot;: &quot;oidc&quot;, &quot;policies&quot;: &quot;demo&quot;, &quot;ttl&quot;: &quot;1h&quot;, &quot;bound_claims&quot;: { &quot;groups&quot;: [&quot;mygroup/mysubgroup&quot;] } } EOF   Monitor OpenBao's log output. Important information about OIDC validation failures will be emitted. Ensure Redirect URIs are correct in OpenBao and on the provider. They need to match exactly. Check: http/https, 127.0.0.1/localhost, port numbers, whether trailing slashes are present. Start simple. The only claim configuration a role requires is user_claim. After authentication is known to work, you can add additional claims bindings and metadata copying. bound_audiences is optional for OIDC roles and typically not required. OIDC providers will use the client_id as the audience and OIDC validation expects this. Check your provider for what scopes are required in order to receive all of the information you need. The scopes &quot;profile&quot; and &quot;groups&quot; often need to be requested, and can be added by setting oidc_scopes=&quot;profile,groups&quot; on the role. If you're seeing claim-related errors in logs, review the provider's docs very carefully to see how they're naming and structuring their claims. Depending on the provider, you may be able to construct a simple curl implicit grant request to obtain a JWT that you can inspect. An example of how to decode the JWT (in this case located in the &quot;access_token&quot; field of a JSON response): cat jwt.json | jq -r .access_token | cut -d. -f2 | base64 -D The verbose_oidc_logging role option is available which will log the received OIDC token to the server logs if debug-level logging is enabled. This can be helpful when debugging provider setup and verifying that the received claims are what you expect. Since claims data is logged verbatim and may contain sensitive information, this option should not be used in production. Azure requires some additional configuration when a user is a member of more than 200 groups, described in Azure-specific handling configuration  ","version":"Next","tagName":"h3"},{"title":"JWT authentication​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#jwt-authentication","content":" The authentication flow for roles of type &quot;jwt&quot; is simpler than OIDC since OpenBao only needs to validate the provided JWT.  ","version":"Next","tagName":"h2"},{"title":"JWT verification​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#jwt-verification","content":" JWT signatures will be verified against public keys from the issuer. This process can be done in three different ways, though only one method may be configured for a single backend:  Static Keys. A set of public keys is stored directly in the backend configuration. JWKS. A JSON Web Key Set (JWKS) URL (and optional certificate chain) is configured. Keys will be fetched from this endpoint during authentication. OIDC Discovery. An OIDC Discovery URL (and optional certificate chain) is configured. Keys will be fetched from this URL during authentication. When OIDC Discovery is used, OIDC validation criteria (e.g. iss, aud, etc.) will be applied.  If multiple methods are needed, another instance of the backend can be mounted and configured at a different path.  ","version":"Next","tagName":"h3"},{"title":"Via the CLI​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#via-the-cli","content":" The default path is /jwt. If this auth method was enabled at a different path, specify -path=/my-path in the CLI.  $ bao write auth/jwt/login role=demo jwt=...   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#via-the-api","content":" The default endpoint is auth/jwt/login. If this auth method was enabled at a different path, use that value instead of jwt.  $ curl \\ --request POST \\ --data '{&quot;jwt&quot;: &quot;your_jwt&quot;, &quot;role&quot;: &quot;demo&quot;}' \\ http://127.0.0.1:8200/v1/auth/jwt/login   The response will contain a token at auth.client_token:  { &quot;auth&quot;: { &quot;client_token&quot;: &quot;38fe9691-e623-7238-f618-c94d4e7bc674&quot;, &quot;accessor&quot;: &quot;78e87a38-84ed-2692-538f-ca8b9f400ab3&quot;, &quot;policies&quot;: [&quot;default&quot;], &quot;metadata&quot;: { &quot;role&quot;: &quot;demo&quot; }, &quot;lease_duration&quot;: 2764800, &quot;renewable&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#configuration","content":" Auth methods must be configured in advance before users or machines can authenticate. These steps are usually completed by an operator or configuration management tool.  Enable the JWT auth method. Either the &quot;jwt&quot; or &quot;oidc&quot; name may be used. The backend will be mounted at the chosen name. $ bao auth enable jwt or $ bao auth enable oidc Use the /config endpoint to configure OpenBao. To support JWT roles, either local keys, a JWKS URL, or an OIDC Discovery URL must be present. For OIDC roles, OIDC Discovery URL, OIDC Client ID and OIDC Client Secret are required. For the list of available configuration options, please see the API documentation. $ bao write auth/jwt/config \\ oidc_discovery_url=&quot;https://myco.auth0.com/&quot; \\ oidc_client_id=&quot;m5i8bj3iofytj&quot; \\ oidc_client_secret=&quot;f4ubv72nfiu23hnsj&quot; \\ default_role=&quot;demo&quot; If you need to perform JWT verification with JWT token validation, then leave the oidc_client_id and oidc_client_secret blank. $ bao write auth/jwt/config \\ oidc_discovery_url=&quot;https://MYDOMAIN.eu.auth0.com/&quot; \\ oidc_client_id=&quot;&quot; \\ oidc_client_secret=&quot;&quot; \\    1. Create a named role: ```text bao write auth/jwt/role/demo \\ allowed_redirect_uris=&quot;http://localhost:8250/oidc/callback&quot; \\ bound_subject=&quot;r3qX9DljwFIWhsiqwFiu38209F10atW6@clients&quot; \\ bound_audiences=&quot;https://vault.plugin.auth.jwt.test&quot; \\ user_claim=&quot;https://vault/user&quot; \\ groups_claim=&quot;https://vault/groups&quot; \\ policies=webapps \\ ttl=1h   This role authorizes JWTs with the given subject and audience claims, gives it the webapps policy, and uses the given user/groups claims to set up Identity aliases.  For the complete list of configuration options, please see the API documentation.  ","version":"Next","tagName":"h2"},{"title":"Bound claims​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#bound-claims","content":" Once a JWT has been validated as being properly signed and not expired, the authorization flow will validate that any configured &quot;bound&quot; parameters match. In some cases there are dedicated parameters, for example bound_subject, which must match the JWT's sub parameter. A role may also be configured to check arbitrary claims through the bound_claims map. The map contains a set of claims and their required values. For example, assume bound_claims is set to:  { &quot;division&quot;: &quot;Europe&quot;, &quot;department&quot;: &quot;Engineering&quot; }   Only JWTs containing both the &quot;division&quot; and &quot;department&quot; claims, and respective matching values of &quot;Europe&quot; and &quot;Engineering&quot;, would be authorized. If the expected value is a list, the claim must match one of the items in the list. To limit authorization to a set of email addresses:  { &quot;email&quot;: [&quot;fred@example.com&quot;, &quot;julie@example.com&quot;] }   Bound claims can optionally be configured with globs. See the API documentation for more details.  ","version":"Next","tagName":"h3"},{"title":"Claims as metadata​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#claims-as-metadata","content":" Data from claims can be copied into the resulting auth token and alias metadata by configuring claim_mappings. This role parameter is a map of items to copy. The map elements are of the form: &quot;&lt;JWT claim&gt;&quot;:&quot;&lt;metadata key&gt;&quot;. Assumeclaim_mappings is set to:  { &quot;division&quot;: &quot;organization&quot;, &quot;department&quot;: &quot;department&quot; }   This specifies that the value in the JWT claim &quot;division&quot; should be copied to the metadata key &quot;organization&quot;. The JWT &quot;department&quot; claim value will also be copied into metadata but will retain the key name. If a claim is configured in claim_mappings, it must existing in the JWT or else the authentication will fail.  Note: the metadata key name &quot;role&quot; is reserved and may not be used for claim mappings.  ","version":"Next","tagName":"h3"},{"title":"Claim specifications and JSON pointer​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#claim-specifications-and-json-pointer","content":" Some parameters (e.g. bound_claims, groups_claim, claim_mappings, user_claim) are used to point to data within the JWT. If the desired key is at the top of level of the JWT, the name can be provided directly. If it is nested at a lower level, a JSON Pointer may be used.  Assume the following JSON data to be referenced:  { &quot;division&quot;: &quot;North America&quot;, &quot;groups&quot;: { &quot;primary&quot;: &quot;Engineering&quot;, &quot;secondary&quot;: &quot;Software&quot; } }   A parameter of &quot;division&quot; will reference &quot;North America&quot;, as this is a top level key. A parameter&quot;/groups/primary&quot; uses JSON Pointer syntax to reference &quot;Engineering&quot; at a lower level. Any valid JSON Pointer can be used as a selector. Refer to theJSON Pointer RFC for a full description of the syntax.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#tutorial","content":" Refer to the following tutorials for OIDC auth method usage examples:  OIDC Auth MethodAzure Active Directory with OIDC Auth Method and External GroupsOIDC Authentication with OktaOIDC Authentication with Google Workspace  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"JWT/OIDC auth method","url":"/openbao/docs/auth/jwt/#api","content":" The JWT Auth Plugin has a full HTTP API. Please see theAPI docs for more details. ","version":"Next","tagName":"h2"},{"title":"auth0","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/auth0/","content":"","keywords":"","version":"Next"},{"title":"Auth0​","type":1,"pageTitle":"auth0","url":"/openbao/docs/auth/jwt/oidc-providers/auth0/#auth0","content":" Select Create Application (Regular Web App).Configure Allowed Callback URLs.Copy client ID and secret.If you see OpenBao errors involving signature, check the application's Advanced &gt; OAuth settings and verify that signing algorithm is &quot;RS256&quot;. ","version":"Next","tagName":"h2"},{"title":"AppRole auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/approle/","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#via-the-cli","content":" The default path is /approle. If this auth method was enabled at a different path, specify auth/my-path/login instead.  $ bao write auth/approle/login \\ role_id=db02de05-fa39-4855-059b-67221c5c2f63 \\ secret_id=6a174c20-f6de-a53c-74d2-6018fcceff64 Key Value --- ----- token 65b74ffd-842c-fd43-1386-f7d7006e520a token_accessor 3c29bc22-5c72-11a6-f778-2bc8f48cea0e token_duration 20m0s token_renewable true token_policies [default]   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#via-the-api","content":" The default endpoint is auth/approle/login. If this auth method was enabled at a different path, use that value instead of approle.  $ curl \\ --request POST \\ --data '{&quot;role_id&quot;:&quot;988a9df-...&quot;,&quot;secret_id&quot;:&quot;37b74931...&quot;}' \\ http://127.0.0.1:8200/v1/auth/approle/login   The response will contain the token at auth.client_token:  { &quot;auth&quot;: { &quot;renewable&quot;: true, &quot;lease_duration&quot;: 2764800, &quot;metadata&quot;: {}, &quot;policies&quot;: [&quot;default&quot;, &quot;dev-policy&quot;, &quot;test-policy&quot;], &quot;accessor&quot;: &quot;5d7fb475-07cb-4060-c2de-1ca3fcbf0c56&quot;, &quot;client_token&quot;: &quot;98a4c7ab-b1fe-361b-ba0b-e307aacfd587&quot; } }   info Application Integration: See the Code Example section for a code snippet demonstrating the authentication with OpenBao using the AppRole auth method.  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#configuration","content":" Auth methods must be configured in advance before users or machines can authenticate. These steps are usually completed by an operator or configuration management tool.  ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#via-the-cli-1","content":" Enable the AppRole auth method: $ bao auth enable approle Create a named role: $ bao write auth/approle/role/my-role \\ secret_id_ttl=10m \\ token_num_uses=10 \\ token_ttl=20m \\ token_max_ttl=30m \\ secret_id_num_uses=40   warning Note: If the token issued by your approle needs the ability to create child tokens, you will need to set token_num_uses to 0.  For the complete list of configuration options, please see the API documentation.  Fetch the RoleID of the AppRole: $ bao read auth/approle/role/my-role/role-id role_id db02de05-fa39-4855-059b-67221c5c2f63 Get a SecretID issued against the AppRole: $ bao write -f auth/approle/role/my-role/secret-id secret_id 6a174c20-f6de-a53c-74d2-6018fcceff64 secret_id_accessor c454f7e5-996e-7230-6074-6ef26b7bcf86 secret_id_ttl 10m secret_id_num_uses 40   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#via-the-api-1","content":" Enable the AppRole auth method: $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data '{&quot;type&quot;: &quot;approle&quot;}' \\ http://127.0.0.1:8200/v1/sys/auth/approle Create an AppRole with desired set of policies: $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data '{&quot;policies&quot;: &quot;dev-policy,test-policy&quot;}' \\ http://127.0.0.1:8200/v1/auth/approle/role/my-role Fetch the identifier of the role: $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ http://127.0.0.1:8200/v1/auth/approle/role/my-role/role-id The response will look like: { &quot;data&quot;: { &quot;role_id&quot;: &quot;988a9dfd-ea69-4a53-6cb6-9d6b86474bba&quot; } } Create a new secret identifier under the role: $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ http://127.0.0.1:8200/v1/auth/approle/role/my-role/secret-id The response will look like: { &quot;data&quot;: { &quot;secret_id_accessor&quot;: &quot;45946873-1d96-a9d4-678c-9229f74386a5&quot;, &quot;secret_id&quot;: &quot;37b74931-c4cd-d49a-9246-ccc62d682a25&quot;, &quot;secret_id_ttl&quot;: 600, &quot;secret_id_num_uses&quot;: 40 } }   ","version":"Next","tagName":"h3"},{"title":"Credentials/Constraints​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#credentialsconstraints","content":" ","version":"Next","tagName":"h2"},{"title":"RoleID​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#roleid","content":" RoleID is an identifier that selects the AppRole against which the other credentials are evaluated. When authenticating against this auth method's login endpoint, the RoleID is a required argument (via role_id) at all times. By default, RoleIDs are unique UUIDs, which allow them to serve as secondary secrets to the other credential information. However, they can be set to particular values to match introspected information by the client (for instance, the client's domain name).  ","version":"Next","tagName":"h3"},{"title":"SecretID​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#secretid","content":" SecretID is a credential that is required by default for any login (viasecret_id) and is intended to always be secret. (For advanced usage, requiring a SecretID can be disabled via an AppRole's bind_secret_idparameter, allowing machines with only knowledge of the RoleID, or matching other set constraints, to fetch a token). SecretIDs can be created against an AppRole either via generation of a 128-bit purely random UUID by the role itself (Pull mode) or via specific, custom values (Push mode). Similarly to tokens, SecretIDs have properties like usage-limit, TTLs and expirations.  Pull and push SecretID modes​  If the SecretID used for login is fetched from an AppRole, this is operating in Pull mode. If a &quot;custom&quot; SecretID is set against an AppRole by the client, it is referred to as a Push mode. Push mode mimics the behavior of the deprecated App-ID auth method; however, in most cases Pull mode is the better approach. The reason is that Push mode requires some other system to have knowledge of the full set of client credentials (RoleID and SecretID) in order to create the entry, even if these are then distributed via different paths. However, in Pull mode, even though the RoleID must be known in order to distribute it to the client, the SecretID can be kept confidential from all parties except for the final authenticating client by using Response Wrapping.  Push mode is available for App-ID workflow compatibility, which in some specific cases is preferable, but in most cases Pull mode is more secure and should be preferred.  ","version":"Next","tagName":"h3"},{"title":"Further constraints​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#further-constraints","content":" role_id is a required credential at the login endpoint. AppRole pointed to by the role_id will have constraints set on it. This dictates other requiredcredentials for login. The bind_secret_id constraint requires secret_id to be presented at the login endpoint. Going forward, this auth method can support more constraint parameters to support varied set of Apps. Some constraints will not require a credential, but still enforce constraints for login. For example, secret_id_bound_cidrs will only allow logins coming from IP addresses belonging to configured CIDR blocks on the AppRole.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#tutorial","content":" Refer to the AppRole Pull Authenticationtutorial to learn how to use the AppRole method to generate tokens for machines or apps.  ","version":"Next","tagName":"h2"},{"title":"User lockout​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#user-lockout","content":" If a user provides bad credentials several times in quick succession, OpenBao will stop trying to validate their credentials for a while, instead returning immediately with a permission denied error. We call this behavior &quot;user lockout&quot;. The time for which a user will be locked out is called “lockout duration”. The user will be able to login after the lockout duration has passed. The number of failed login attempts after which the user is locked out is called “lockout threshold”. The lockout threshold counter is reset to zero after a few minutes without login attempts, or upon a successful login attempt. The duration after which the counter will be reset to zero after no login attempts is called &quot;lockout counter reset&quot;. This can defeat both automated and targeted requests i.e, user-based password guessing attacks as well as automated attacks.  The user lockout feature is enabled by default. The default values for &quot;lockout threshold&quot; is 5 attempts, &quot;lockout duration&quot; is 15 minutes, &quot;lockout counter reset&quot; is 15 minutes.  The user lockout feature can be disabled as follows:  It can be disabled globally using environment variable VAULT_DISABLE_USER_LOCKOUT.It can be disabled for all supported auth methods (ldap, userpass and approle) or a specific supported auth method using the disable_lockoutparameter within user_lockout stanza in configuration file. Please see user lockout configuration for more details.It can be disabled for a specific auth mount using &quot;auth tune&quot;. Please see auth tune commandor auth tune api for more details.  warning NOTE: This feature is only supported by the userpass, ldap, and approle auth methods.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#api","content":" The AppRole auth method has a full HTTP API. Please see theAppRole API for more details.  ","version":"Next","tagName":"h2"},{"title":"Code example​","type":1,"pageTitle":"AppRole auth method","url":"/openbao/docs/auth/approle/#code-example","content":" The following example demonstrates AppRole authentication with response wrapping.  Go package main import ( &quot;context&quot; &quot;fmt&quot; &quot;os&quot; openbao &quot;github.com/openbao/openbao/api&quot; auth &quot;github.com/openbao/openbao/api/auth/approle&quot; ) // Fetches a key-value secret (kv-v2) after authenticating via AppRole. func getSecretWithAppRole() (string, error) { config := openbao.DefaultConfig() // modify for more granular configuration client, err := openbao.NewClient(config) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to initialize OpenBao client: %w&quot;, err) } // A combination of a Role ID and Secret ID is required to log in to OpenBao // with an AppRole. // First, let's get the role ID given to us by our OpenBao administrator. roleID := os.Getenv(&quot;APPROLE_ROLE_ID&quot;) if roleID == &quot;&quot; { return &quot;&quot;, fmt.Errorf(&quot;no role ID was provided in APPROLE_ROLE_ID env var&quot;) } // The Secret ID is a value that needs to be protected, so instead of the // app having knowledge of the secret ID directly, we have a trusted orchestrator (https://learn.hashicorp.com/tutorials/vault/secure-introduction?in=vault/app-integration#trusted-orchestrator) // give the app access to a short-lived response-wrapping token (https://www.vaultproject.io/docs/concepts/response-wrapping). // Read more at: https://learn.hashicorp.com/tutorials/vault/approle-best-practices?in=vault/auth-methods#secretid-delivery-best-practices secretID := &amp;auth.SecretID{FromFile: &quot;path/to/wrapping-token&quot;} appRoleAuth, err := auth.NewAppRoleAuth( roleID, secretID, auth.WithWrappingToken(), // Only required if the secret ID is response-wrapped. ) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to initialize AppRole auth method: %w&quot;, err) } authInfo, err := client.Auth().Login(context.Background(), appRoleAuth) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to login to AppRole auth method: %w&quot;, err) } if authInfo == nil { return &quot;&quot;, fmt.Errorf(&quot;no auth info was returned after login&quot;) } // get secret from the default mount path for KV v2 in dev mode, &quot;secret&quot; secret, err := client.KVv2(&quot;secret&quot;).Get(context.Background(), &quot;creds&quot;) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to read secret: %w&quot;, err) } // data map can contain more than one key-value pair, // in this case we're just grabbing one of them value, ok := secret.Data[&quot;password&quot;].(string) if !ok { return &quot;&quot;, fmt.Errorf(&quot;value type assertion failed: %T %#v&quot;, secret.Data[&quot;password&quot;], secret.Data[&quot;password&quot;]) } return value, nil }  ","version":"Next","tagName":"h2"},{"title":"azuread","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/azuread/","content":"","keywords":"","version":"Next"},{"title":"Azure active directory (AAD)​","type":1,"pageTitle":"azuread","url":"/openbao/docs/auth/jwt/oidc-providers/azuread/#azure-active-directory-aad","content":" warning Note: Azure Active Directory Applications that have custom signing keys as a result of using the claims-mappingfeature are currently not supported for OIDC authentication.  Reference: Azure Active Directory v2.0 and the OpenID Connect protocol  Choose your Azure tenant. Go to Azure Active Directory andregister an applicationfor OpenBao. Add Redirect URIs with the &quot;Web&quot; type. You may include two redirect URIs, one for CLI access another one for OpenBao UI access. http://localhost:8250/oidc/callbackhttps://hostname:port_number/ui/vault/auth/oidc/oidc/callback Record the &quot;Application (client) ID&quot; as you will need it as the oidc_client_id. Under Endpoints, copy the OpenID Connect metadata document URL, omitting the /well-known... portion. The endpoint URL (oidc_discovery_url) will look like: https://login.microsoftonline.com/tenant-guid-dead-beef-aaaa-aaaa/v2.0 Under Certificates &amp; secrets,add a client secretRecord the secret's value as you will need it as the oidc_client_secret for OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Connect AD group with OpenBao external group​","type":1,"pageTitle":"azuread","url":"/openbao/docs/auth/jwt/oidc-providers/azuread/#connect-ad-group-with-openbao-external-group","content":" Reference: Azure Active Directory with OIDC Auth Method and External Groups  To connect the AD group with a OpenBao external groups, you will needAzure AD v2.0 endpoints. You should set up a OpenBao policy for the Azure AD group to use.  Go to Azure Active Directory and choose your OpenBao application. Go to Token configuration and Add groups claim. Select &quot;All&quot; or &quot;SecurityGroup&quot; based onwhich groups for a useryou want returned in the claim. In OpenBao, enable the OIDC auth method. Configure the OIDC auth method with the oidc_client_id (application ID), oidc_client_secret(client secret), and oidc_discovery_url (endpoint URL) you recorded from Azure. bao write auth/oidc/config \\ oidc_client_id=&quot;your_client_id&quot; \\ oidc_client_secret=&quot;your_client_secret&quot; \\ default_role=&quot;your_default_role&quot; \\ oidc_discovery_url=&quot;https://login.microsoftonline.com/tenant_id/v2.0&quot; Configure the OIDC Role with the following: user_claim should be &quot;sub&quot; or &quot;oid&quot; following therecommendationfrom Azure.allowed_redirect_uris should be the two redirect URIs for OpenBao CLI and UI access.groups_claim should be set to &quot;groups&quot;.oidc_scopes should be set to &quot;https://graph.microsoft.com/.default&quot;. bao write auth/oidc/role/your_default_role \\ user_claim=&quot;sub&quot; \\ allowed_redirect_uris=&quot;http://localhost:8250/oidc/callback,https://online_version_hostname:port_number/ui/vault/auth/oidc/oidc/callback&quot; \\ groups_claim=&quot;groups&quot; \\ oidc_scopes=&quot;https://graph.microsoft.com/.default&quot; \\ policies=default In OpenBao, create the external group. Record the group ID as you will need it for the group alias. From OpenBao, retrieve the OIDC accessor IDfrom the OIDC auth method as you will need it for the group alias's mount_accessor. Go to the Azure AD Group you want to attach to OpenBao's external group. Record the objectIdas you will need it as the group alias name in OpenBao. In OpenBao, create a group aliasfor the external group and set the objectId as the group alias name. bao write identity/group-alias \\ name=&quot;your_ad_group_object_id&quot; \\ mount_accessor=&quot;openbao_oidc_accessor_id&quot; \\ canonical_id=&quot;openbao_external_group_id&quot;   ","version":"Next","tagName":"h3"},{"title":"Optional azure-specific configuration​","type":1,"pageTitle":"azuread","url":"/openbao/docs/auth/jwt/oidc-providers/azuread/#optional-azure-specific-configuration","content":" If a user is a member of more than 200 groups (directly or indirectly), Azure will send _claim_names and _claim_sources. For example, returned claims might look like:  { &quot;_claim_names&quot;: { &quot;groups&quot;: &quot;src1&quot; }, &quot;_claim_sources&quot;: { &quot;src1&quot;: { &quot;endpoint&quot;: &quot;https://graph.windows.net....&quot; } } }   The OIDC auth method role can be configured to include the user ID in the endpoint URL, which will be used by OpenBao to retrieve the groups for the user. Additional API permissions must be added to the Azure app in order to request the additional groups from the Microsoft Graph API.  To set the proper permissions on the Azure app:  Locate the application under &quot;App Registrations&quot; in Azure Navigate to the &quot;API Permissions&quot; page for the application Add a permission Select &quot;Microsoft Graph&quot; Select &quot;Delegated permissions&quot; Add the User.Read permission Check the &quot;Grant admin consent for Default Directory&quot; checkbox Configure the OIDC auth method in OpenBao by setting &quot;provider_config&quot; to Azure. bao write auth/oidc/config -&lt;&lt;&quot;EOH&quot; { &quot;oidc_client_id&quot;: &quot;your_client_id&quot;, &quot;oidc_client_secret&quot;: &quot;your_client_secret&quot;, &quot;default_role&quot;: &quot;your_default_role&quot;, &quot;oidc_discovery_url&quot;: &quot;https://login.microsoftonline.com/tenant_id/v2.0&quot;, &quot;provider_config&quot;: { &quot;provider&quot;: &quot;azure&quot; } } EOH Add &quot;profile&quot; to oidc_scopes so the user's ID comes back on the JWT. bao write auth/oidc/role/your_default_role \\ user_claim=&quot;email&quot; \\ allowed_redirect_uris=&quot;http://localhost:8250/oidc/callback,https://online_version_hostname:port_number/ui/vault/auth/oidc/oidc/callback&quot; \\ groups_claim=&quot;groups&quot; \\ oidc_scopes=&quot;profile&quot; \\ policies=&quot;default&quot;  ","version":"Next","tagName":"h3"},{"title":"forgerock","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/forgerock/","content":"","keywords":"","version":"Next"},{"title":"ForgeRock​","type":1,"pageTitle":"forgerock","url":"/openbao/docs/auth/jwt/oidc-providers/forgerock/#forgerock","content":" Navigate to Applications -&gt; OAuth 2.0 -&gt; Clients in ForgeRock Access Management.Create new client.Configure Client ID, Client Secret, Scopes and Redirection URIs.  client IDclient secretallowed_redirect_uris should be the two redirect URIs for OpenBao CLI and UI access.oidc_scopes should be set to the OIDC scopes.  Save Client ID and Client Secret.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"forgerock","url":"/openbao/docs/auth/jwt/oidc-providers/forgerock/#configuration","content":" In OpenBao, enable the OIDC auth method. Configure the OIDC auth method with the oidc_client_id (client ID), oidc_client_secret(client secret), and oidc_discovery_url (endpoint URL) from ForgeRock. bao write auth/oidc/config \\ oidc_client_id=&quot;your_client_id&quot; \\ oidc_client_secret=&quot;your_client_secret&quot; \\ default_role=&quot;your_default_role&quot; \\ oidc_discovery_url=&quot;https://openam.example.com:8443/openam/oauth2&quot; Configure the OIDC Role with the following:  user_claim should be &quot;sub&quot;.allowed_redirect_uris should be the two redirect URIs for OpenBao CLI and UI access.oidc_scopes should be set to the OIDC scopes.  bao write auth/oidc/role/your_default_role \\ user_claim=&quot;sub&quot; \\ allowed_redirect_uris=&quot;http://localhost:8250/oidc/callback,https://online_version_hostname:port_number/ui/vault/auth/oidc/oidc/callback&quot; \\ oidc_scopes=&quot;your_oidc_scopes&quot; \\ policies=default  ","version":"Next","tagName":"h3"},{"title":"gitlab","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/gitlab/","content":"","keywords":"","version":"Next"},{"title":"Gitlab​","type":1,"pageTitle":"gitlab","url":"/openbao/docs/auth/jwt/oidc-providers/gitlab/#gitlab","content":" Visit Settings &gt; Applications.Fill out Name and Redirect URIs.Making sure to select the &quot;openid&quot; scope.Copy client ID and secret. ","version":"Next","tagName":"h2"},{"title":"google","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/google/","content":"","keywords":"","version":"Next"},{"title":"Google​","type":1,"pageTitle":"google","url":"/openbao/docs/auth/jwt/oidc-providers/google/#google","content":" Main reference: Using OAuth 2.0 to Access Google APIs  Visit the Google API Console.Create or a select a project.Navigate to Menu &gt; APIs &amp; ServicesCreate a new credential via Credentials &gt; Create Credentials &gt; OAuth Client ID.Configure the OAuth Consent Screen. Application Name is required. Save.Select application type: &quot;Web Application&quot;.Configure Authorized Redirect URIs.Save client ID and secret.  ","version":"Next","tagName":"h2"},{"title":"Optional google-specific configuration​","type":1,"pageTitle":"google","url":"/openbao/docs/auth/jwt/oidc-providers/google/#optional-google-specific-configuration","content":" Google-specific configuration is available when using Google as an identity provider from the OpenBao JWT/OIDC auth method. The configuration allows OpenBao to obtain Google Workspace group membership and user information during the JWT/OIDC authentication flow. The group membership obtained from Google Workspace may be used for Identity group alias association. The user information obtained from Google Workspace can be used to copy claims data into resulting auth token and alias metadata via claim_mappings.  Setup​  To set up the Google-specific handling, you'll need:  A Google Workspace account with the super admin rolefor granting domain-wide delegation API client access.The ability to create a service account in Google Cloud Platform.To enable the Admin SDK API.An OAuth 2.0 application with an internal user type. We do not recommend using an external user type since it would allow any user with a Google account to authenticate with OpenBao.  The Google-specific handling that's used to fetch Google Workspace groups and user information in OpenBao uses Google Workspace Domain-Wide Delegation of Authority for authentication and authorization. You need to followall steps in the guideto obtain the key file for a Google service account capable of making requests to the Google WorkspaceUser Accounts andGroups APIs.  In step 11 within the section titledOptional: Set up domain-wide delegation for a service account, the only OAuth scopes that should be granted are:  https://www.googleapis.com/auth/admin.directory.group.readonlyhttps://www.googleapis.com/auth/admin.directory.user.readonly  warning This is an important security step in order to give the service account the least set of privileges that enable the feature.  Configuration​  provider (string: &lt;required&gt;) - Name of the provider. Must be set to &quot;gsuite&quot;.gsuite_service_account (string: &lt;required&gt;) - Either the path to or the contents of a Google service account key file in JSON format. If given as a file path, it must refer to a file that's readable on the host that OpenBao is running on. If given directly as JSON contents, the JSON must be properly escaped.gsuite_admin_impersonate (string: &lt;required&gt;) - Email address of a Google Workspace admin to impersonate.fetch_groups (bool: false) - If set to true, groups will be fetched from Google Workspace.fetch_user_info (bool: false) - If set to true, user info will be fetched from Google Workspace using the configured user_custom_schemas.groups_recurse_max_depth (int: &lt;optional&gt;) - Group membership recursion max depth. Defaults to 0, which means don't recurse.user_custom_schemas (string: &lt;optional&gt;) - Comma-separated list of Google Workspace custom schemas. Values set for Google Workspace users using custom schema fields will be fetched and made available as claims that can be used with claim_mappings. Required if fetch_user_info is set to true.  Example configuration:  bao write auth/oidc/config -&lt;&lt;EOF { &quot;oidc_discovery_url&quot;: &quot;https://accounts.google.com&quot;, &quot;oidc_client_id&quot;: &quot;your_client_id&quot;, &quot;oidc_client_secret&quot;: &quot;your_client_secret&quot;, &quot;default_role&quot;: &quot;your_default_role&quot;, &quot;provider_config&quot;: { &quot;provider&quot;: &quot;gsuite&quot;, &quot;gsuite_service_account&quot;: &quot;/path/to/service-account.json&quot;, &quot;gsuite_admin_impersonate&quot;: &quot;admin@gsuitedomain.com&quot;, &quot;fetch_groups&quot;: true, &quot;fetch_user_info&quot;: true, &quot;groups_recurse_max_depth&quot;: 5, &quot;user_custom_schemas&quot;: &quot;Education,Preferences&quot; } } EOF   Role​  The user_claim value of the role must be set to one of either sub or email for the Google Workspace group and user information queries to succeed.  Example role:  bao write auth/oidc/role/your_default_role \\ allowed_redirect_uris=&quot;http://localhost:8200/ui/vault/auth/oidc/oidc/callback,http://localhost:8250/oidc/callback&quot; \\ user_claim=&quot;sub&quot; \\ groups_claim=&quot;groups&quot; \\ claim_mappings=&quot;/Education/graduation_date&quot;=&quot;graduation_date&quot; \\ claim_mappings=&quot;/Preferences/shirt_size&quot;=&quot;shirt_size&quot;  ","version":"Next","tagName":"h3"},{"title":"ibmisam","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/ibmisam/","content":"","keywords":"","version":"Next"},{"title":"IBM ISAM​","type":1,"pageTitle":"ibmisam","url":"/openbao/docs/auth/jwt/oidc-providers/ibmisam/#ibm-isam","content":" The IBM ISAM identity provider returns group membership claims as a space-separated list of strings (e.g.groups: &quot;group-1 group-2&quot;) instead of a list of strings.  To properly obtain group membership when using IBMISAM as the identity provider for OpenBao's OIDC Auth Method, the ibmisam provider must be explicitly configured as shown below.  bao write auth/oidc/config -&lt;&lt;&quot;EOH&quot; { &quot;oidc_client_id&quot;: &quot;your_client_id&quot;, &quot;oidc_client_secret&quot;: &quot;your_client_secret&quot;, &quot;default_role&quot;: &quot;your_default_role&quot;, &quot;oidc_discovery_url&quot;: &quot;https://your.idp.host&quot;, &quot;provider_config&quot;: { &quot;provider&quot;: &quot;ibmisam&quot; } } EOH   This will instruct the OIDC Auth Method to parse the space-separated groups claims string into individual groups. Note that the role's groups_claimvalue must be properly configured to target the groups claim for your IBM ISAM identity provider. ","version":"Next","tagName":"h2"},{"title":"keycloak","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/keycloak/","content":"","keywords":"","version":"Next"},{"title":"Keycloak​","type":1,"pageTitle":"keycloak","url":"/openbao/docs/auth/jwt/oidc-providers/keycloak/#keycloak","content":" Select/create a Realm and Client. Select a Client and visit Settings.Client Protocol: openid-connectAccess Type: confidentialStandard Flow Enabled: OnConfigure Valid Redirect URIs.Save.Visit Credentials. Select Client ID and Secret and note the generated secret. ","version":"Next","tagName":"h2"},{"title":"okta","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/okta/","content":"","keywords":"","version":"Next"},{"title":"Okta​","type":1,"pageTitle":"okta","url":"/openbao/docs/auth/jwt/oidc-providers/okta/#okta","content":" Make sure an Authorization Server has been created. The &quot;Issuer&quot; field shown on the Setting page will be used as the oidc_discovery_url.Visit Applications &gt; Add Application (Web).Configure Login redirect URIs. Save.Save client ID and secret.  Note your policy will need oidc_scopes to include profile to get a full profile (&quot;Fat Token&quot;). You will also need to configure bound audience along the lines of&quot;bound_audiences&quot;: [&quot;api://default&quot;, &quot;0a4.........&quot;] if you are using the default authorization server. ","version":"Next","tagName":"h2"},{"title":"secureauth","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/secureauth/","content":"","keywords":"","version":"Next"},{"title":"SecureAuth​","type":1,"pageTitle":"secureauth","url":"/openbao/docs/auth/jwt/oidc-providers/secureauth/#secureauth","content":" The SecureAuth identity provider returns group membership claims as a comma-separated list of strings (e.g. groups: &quot;group-1,group-2&quot;) instead of a list of strings.  To properly obtain group membership when using SecureAuth as the identity provider for OpenBao's OIDC Auth Method, the secureauth provider must be explicitly configured as shown below.  bao write auth/oidc/config -&lt;&lt;&quot;EOH&quot; { &quot;oidc_client_id&quot;: &quot;your_client_id&quot;, &quot;oidc_client_secret&quot;: &quot;your_client_secret&quot;, &quot;default_role&quot;: &quot;your_default_role&quot;, &quot;oidc_discovery_url&quot;: &quot;https://idp.sasp.gosecureauth.com/your_secure_auth&quot;, &quot;provider_config&quot;: { &quot;provider&quot;: &quot;secureauth&quot; } } EOH   This will instruct the OIDC Auth Method to parse the comma-separated groups claims string into individual groups. Note that the role's groups_claimvalue must be properly configured to target the groups claim for your SecureAuth identity provider. ","version":"Next","tagName":"h2"},{"title":"kubernetes","type":0,"sectionRef":"#","url":"/openbao/docs/auth/jwt/oidc-providers/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Kubernetes​","type":1,"pageTitle":"kubernetes","url":"/openbao/docs/auth/jwt/oidc-providers/kubernetes/#kubernetes","content":" Kubernetes can function as an OIDC provider such that OpenBao can validate its service account tokens using JWT/OIDC auth.  info Note: The JWT auth engine does not use Kubernetes' TokenReview API during authentication, and instead uses public key cryptography to verify the contents of JWTs. This means tokens that have been revoked by Kubernetes will still be considered valid by OpenBao until their expiry time. To mitigate this risk, use short TTLs for service account tokens or useKubernetes auth which does use the TokenReview API.  ","version":"Next","tagName":"h2"},{"title":"Using service account issuer discovery​","type":1,"pageTitle":"kubernetes","url":"/openbao/docs/auth/jwt/oidc-providers/kubernetes/#using-service-account-issuer-discovery","content":" When using service account issuer discovery, you only need to provide the JWT auth mount with an OIDC discovery URL, and sometimes a TLS certificate authority to trust. This makes it the most straightforward method to configure if your Kubernetes cluster meets the requirements.  Kubernetes cluster requirements:  ServiceAccountIssuerDiscovery feature enabled. Present from 1.18, defaults to enabled from 1.20. kube-apiserver's --service-account-issuer flag is set to a URL that is reachable from OpenBao. Public by default for most managed Kubernetes solutions.Must use short-lived service account tokens when logging in. Tokens mounted into pods default to short-lived from 1.21.  Configuration steps:  Ensure OIDC discovery URLs do not require authentication, as detailedhere: kubectl create clusterrolebinding oidc-reviewer \\ --clusterrole=system:service-account-issuer-discovery \\ --group=system:unauthenticated Find the issuer URL of the cluster. ISSUER=&quot;$(kubectl get --raw /.well-known/openid-configuration | jq -r '.issuer')&quot; Enable and configure JWT auth in OpenBao. If OpenBao is running in Kubernetes: kubectl exec openbao-0 -- bao auth enable jwt kubectl exec openbao-0 -- bao write auth/jwt/config \\ oidc_discovery_url=https://kubernetes.default.svc.cluster.local \\ oidc_discovery_ca_pem=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt Alternatively, if OpenBao is not running in Kubernetes:  info Note: When OpenBao is outside the cluster, the $ISSUER endpoint below may or may not be reachable. If not, you can configure JWT auth usingjwt_validation_pubkeys instead.  bao auth enable jwt bao write auth/jwt/config oidc_discovery_url=&quot;${ISSUER}&quot;   Configure a role and log in as detailed below.  ","version":"Next","tagName":"h3"},{"title":"Using JWT validation public keys​","type":1,"pageTitle":"kubernetes","url":"/openbao/docs/auth/jwt/oidc-providers/kubernetes/#using-jwt-validation-public-keys","content":" This method can be useful if Kubernetes' API is not reachable from OpenBao or if you would like a single JWT auth mount to service multiple Kubernetes clusters by chaining their public signing keys.  Kubernetes cluster requirements:  ServiceAccountIssuerDiscovery feature enabled. Present from 1.18, defaults to enabled from 1.20.This requirement can be avoided if you can access the Kubernetes master nodes to read the public signing key directly from disk at/etc/kubernetes/pki/sa.pub. In this case, you can skip the steps to retrieve and then convert the key as it will already be in PEM format. Must use short-lived service account tokens when logging in. Tokens mounted into pods default to short-lived from 1.21.  Configuration steps:  Fetch the service account signing public key from your cluster's JWKS URI. # Query the jwks_uri specified in /.well-known/openid-configuration kubectl get --raw &quot;$(kubectl get --raw /.well-known/openid-configuration | jq -r '.jwks_uri' | sed -r 's/.*\\.[^/]+(.*)/\\1/')&quot; Convert the keys from JWK format to PEM. You can use a CLI tool or an online converter such as this one. Configure the JWT auth mount with those public keys. bao write auth/jwt/config \\ jwt_validation_pubkeys=&quot;-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9... -----END PUBLIC KEY-----&quot;,&quot;-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9... -----END PUBLIC KEY-----&quot; Configure a role and log in as detailed below.  ","version":"Next","tagName":"h3"},{"title":"Creating a role and logging in​","type":1,"pageTitle":"kubernetes","url":"/openbao/docs/auth/jwt/oidc-providers/kubernetes/#creating-a-role-and-logging-in","content":" Once your JWT auth mount is configured, you're ready to configure a role and log in. The following assumes you use the projected service account token available in all pods by default. See Specifying TTL and audiencebelow if you'd like to control the audience or TTL.  Choose any value from the array of default audiences. In these examples, there is only one audience in the aud array,https://kubernetes.default.svc.cluster.local. To find the default audiences, either create a fresh token (requireskubectl v1.24.0+): $ kubectl create token default | cut -f2 -d. | base64 --decode {&quot;aud&quot;:[&quot;https://kubernetes.default.svc.cluster.local&quot;], ... &quot;sub&quot;:&quot;system:serviceaccount:default:default&quot;} Or read a token from a running pod's filesystem: $ kubectl exec my-pod -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -f2 -d. | base64 --decode {&quot;aud&quot;:[&quot;https://kubernetes.default.svc.cluster.local&quot;], ... &quot;sub&quot;:&quot;system:serviceaccount:default:default&quot;} Create a role for JWT auth that the default service account from thedefault namespace can use. bao write auth/jwt/role/my-role \\ role_type=&quot;jwt&quot; \\ bound_audiences=&quot;&lt;AUDIENCE-FROM-PREVIOUS-STEP&gt;&quot; \\ user_claim=&quot;sub&quot; \\ bound_subject=&quot;system:serviceaccount:default:default&quot; \\ policies=&quot;default&quot; \\ ttl=&quot;1h&quot; Pods or other clients with access to a service account JWT can then log in. bao write auth/jwt/login \\ role=my-role \\ jwt=@/var/run/secrets/kubernetes.io/serviceaccount/token # OR equivalent to: curl \\ --fail \\ --request POST \\ --header &quot;X-Vault-Request: true&quot; \\ --data '{&quot;jwt&quot;:&quot;&lt;JWT-TOKEN-HERE&gt;&quot;,&quot;role&quot;:&quot;my-role&quot;}' \\ &quot;${VAULT_ADDR}/v1/auth/jwt/login&quot;   ","version":"Next","tagName":"h3"},{"title":"Specifying TTL and audience​","type":1,"pageTitle":"kubernetes","url":"/openbao/docs/auth/jwt/oidc-providers/kubernetes/#specifying-ttl-and-audience","content":" If you would like to specify a custom TTL or audience for service account tokens, the following pod spec illustrates a volume mount that overrides the default admission injected token. This is especially relevant if you are unable to disable the --service-account-extend-token-expirationflag for kube-apiserver and want to use short TTLs.  When using the resulting token, you will need to set bound_audiences=openbaowhen creating roles in OpenBao's JWT auth mount.  apiVersion: v1 kind: Pod metadata: name: nginx spec: # automountServiceAccountToken is redundant in this example because the # mountPath used overlaps with the default path. The overlap stops the default # admission injected token from being created. You can use this option to # ensure only a single token is mounted if you choose a different mount path. automountServiceAccountToken: false containers: - name: nginx image: nginx volumeMounts: - name: custom-token mountPath: /var/run/secrets/kubernetes.io/serviceaccount volumes: - name: custom-token projected: defaultMode: 420 sources: - serviceAccountToken: path: token expirationSeconds: 600 # 10 minutes is the minimum TTL audience: openbao # Must match your JWT role's `bound_audiences` # The remaining sources are included to mimic the rest of the default # admission injected volume. - configMap: name: kube-root-ca.crt items: - key: ca.crt path: ca.crt - downwardAPI: items: - fieldRef: apiVersion: v1 fieldPath: metadata.namespace path: namespace  ","version":"Next","tagName":"h3"},{"title":"LDAP auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/ldap/","content":"","keywords":"","version":"Next"},{"title":"A note on escaping​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#a-note-on-escaping","content":" It is up to the administrator to provide properly escaped DNs. This includes the user DN, bind DN for search, and so on.  The only DN escaping performed by this method is on usernames given at login time when they are inserted into the final bind DN, and uses escaping rules defined in RFC 4514.  Additionally, Active Directory has escaping rules that differ slightly from the RFC; in particular it requires escaping of '#' regardless of position in the DN (the RFC only requires it to be escaped when it is the first character), and '=', which the RFC indicates can be escaped with a backslash, but does not contain in its set of required escapes. If you are using Active Directory and these appear in your usernames, please ensure that they are escaped, in addition to being properly escaped in your configured DNs.  For reference, see RFC 4514 and thisTechNet post on characters to escape in Active Directory.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#via-the-cli","content":" $ bao login -method=ldap username=mitchellh Password (will be hidden): Successfully authenticated! The policies that are associated with this token are listed below: admins   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#via-the-api","content":" $ curl \\ --request POST \\ --data '{&quot;password&quot;: &quot;foo&quot;}' \\ http://127.0.0.1:8200/v1/auth/ldap/login/mitchellh   The response will be in JSON. For example:  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;auth&quot;: { &quot;client_token&quot;: &quot;c4f280f6-fdb2-18eb-89d3-589e2e834cdb&quot;, &quot;policies&quot;: [ &quot;admins&quot; ], &quot;metadata&quot;: { &quot;username&quot;: &quot;mitchellh&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false } }   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#configuration","content":" Auth methods must be configured in advance before users or machines can authenticate. These steps are usually completed by an operator or configuration management tool.  Enable the ldap auth method: $ bao auth enable ldap Configure connection details for your LDAP server, information on how to authenticate users, and instructions on how to query for group membership. The configuration options are categorized and detailed below.  ","version":"Next","tagName":"h2"},{"title":"Connection parameters​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#connection-parameters","content":" url (string, required) - The LDAP server to connect to. Examples: ldap://ldap.myorg.com, ldaps://ldap.myorg.com:636. This can also be a comma-delineated list of URLs, e.g. ldap://ldap.myorg.com,ldaps://ldap.myorg.com:636, in which case the servers will be tried in-order if there are errors during the connection process.starttls (bool, optional) - If true, issues a StartTLS command after establishing an unencrypted connection.insecure_tls - (bool, optional) - If true, skips LDAP server SSL certificate verification - insecure, use with caution!certificate - (string, optional) - CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded.client_tls_cert - (string, optional) - Client certificate to provide to the LDAP server, must be x509 PEM encoded.client_tls_key - (string, optional) - Client certificate key to provide to the LDAP server, must be x509 PEM encoded.  ","version":"Next","tagName":"h3"},{"title":"Binding parameters​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#binding-parameters","content":" There are two alternate methods of resolving the user object used to authenticate the end user: Search or User Principal Name. When using Search, the bind can be either anonymous or authenticated. User Principal Name is a method of specifying users supported by Active Directory. More information on UPN can be found here.  Binding - authenticated search​  binddn (string, optional) - Distinguished name of object to bind when performing user and group search. Example: cn=openbao,ou=Users,dc=example,dc=combindpass (string, optional) - Password to use along with binddn when performing user search.userdn (string, optional) - Base DN under which to perform user search. Example: ou=Users,dc=example,dc=comuserattr (string, optional) - Attribute on user attribute object matching the username passed when authenticating. Examples: sAMAccountName, cn, uiduserfilter (string, optional) - Go template used to construct a ldap user search filter. The template can access the following context variables: [UserAttr, Username]. The default userfilter is ({{.UserAttr}}={{.Username}}) or (userPrincipalName={{.Username}}@UPNDomain) if the upndomain parameter is set. The user search filter can be used to restrict what user can attempt to log in. For example, to limit login to users that are not contractors, you could write (&amp;(objectClass=user)({{.UserAttr}}={{.Username}})(!(employeeType=Contractor))).  warning When specifying a userfilter, either the templated value {{.UserAttr}} or the literal value that matches userattr should be present in the filter to ensure that the search returns a unique result that takes userattr into consideration for entity alias mapping purposes and avoid possible collisions on login.  Binding - anonymous search​  discoverdn (bool, optional) - If true, use anonymous bind to discover the bind DN of a useruserdn (string, optional) - Base DN under which to perform user search. Example: ou=Users,dc=example,dc=comuserattr (string, optional) - Attribute on user attribute object matching the username passed when authenticating. Examples: sAMAccountName, cn, uiduserfilter (string, optional) - Go template used to construct a ldap user search filter. The template can access the following context variables: [UserAttr, Username]. The default userfilter is ({{.UserAttr}}={{.Username}}) or (userPrincipalName={{.Username}}@UPNDomain) if the upndomain parameter is set. The user search filter can be used to restrict what user can attempt to log in. For example, to limit login to users that are not contractors, you could write (&amp;(objectClass=user)({{.UserAttr}}={{.Username}})(!(employeeType=Contractor))).deny_null_bind (bool, optional) - This option prevents users from bypassing authentication when providing an empty password. The default is true.anonymous_group_search (bool, optional) - Use anonymous binds when performing LDAP group searches. Defaults to false.  warning When specifying a userfilter, either the templated value {{.UserAttr}} or the literal value that matches userattr should be present in the filter to ensure that the search returns a unique result that takes userattr into consideration for entity alias mapping purposes and avoid possible collisions on login.  Alias dereferencing​  dereference_aliases (string, optional) - Control how aliases are dereferenced when performing the search. Possible values are: never, finding, searching, and always. finding will only dereference aliases during name resolution of the base. searching will dereference aliases after name resolution.  Binding - user principal name (AD)​  upndomain (string, optional) - userPrincipalDomain used to construct the UPN string for the authenticating user. The constructed UPN will appear as [username]@UPNDomain. Example: example.com, which will cause OpenBao to bind as username@example.com.  ","version":"Next","tagName":"h3"},{"title":"Group membership resolution​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#group-membership-resolution","content":" Once a user has been authenticated, the LDAP auth method must know how to resolve which groups the user is a member of. The configuration for this can vary depending on your LDAP server and your directory schema. There are two main strategies when resolving group membership - the first is searching for the authenticated user object and following an attribute to groups it is a member of. The second is to search for group objects of which the authenticated user is a member of. Both methods are supported.  groupfilter (string, optional) - Go template used when constructing the group membership query. The template can access the following context variables: [UserDN, Username]. The default is (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}})), which is compatible with several common directory schemas. To support nested group resolution for Active Directory, instead use the following query: (&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})).groupdn (string, required) - LDAP search base to use for group membership search. This can be the root containing either groups or users. Example: ou=Groups,dc=example,dc=comgroupattr (string, optional) - LDAP attribute to follow on objects returned by groupfilter in order to enumerate user group membership. Examples: for groupfilter queries returning group objects, use: cn. For queries returning user objects, use: memberOf. The default is cn.  Note: When using Authenticated Search for binding parameters (see above) the distinguished name defined for binddn is used for the group search. Otherwise, the authenticating user is used to perform the group search.  Use bao path-help for more details.  ","version":"Next","tagName":"h3"},{"title":"Other​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#other","content":" username_as_alias (bool, optional) - If set to true, forces the auth method to use the username passed by the user as the alias name.max_page_size (int, optional) - If set to a value greater than 0, the LDAP backend will use the LDAP server's paged search control to request pages of up to the given size. This can be used to avoid hitting the LDAP server's maximum result size limit. Otherwise, the LDAP backend will not use the paged search control.  ","version":"Next","tagName":"h3"},{"title":"Examples:​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Scenario 1​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#scenario-1","content":" LDAP server running on ldap.example.com, port 389.Server supports STARTTLS command to initiate encryption on the standard port.CA Certificate stored in file named ldap_ca_cert.pemServer is Active Directory supporting the userPrincipalName attribute. Users are identified as username@example.com.Groups are nested, we will use LDAP_MATCHING_RULE_IN_CHAIN to walk the ancestry graph.Group search will start under ou=Groups,dc=example,dc=com. For all group objects under that path, the member attribute will be checked for a match against the authenticated user.Group names are identified using their cn attribute.  $ bao write auth/ldap/config \\ url=&quot;ldap://ldap.example.com&quot; \\ userdn=&quot;ou=Users,dc=example,dc=com&quot; \\ groupdn=&quot;ou=Groups,dc=example,dc=com&quot; \\ groupfilter=&quot;(&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))&quot; \\ groupattr=&quot;cn&quot; \\ upndomain=&quot;example.com&quot; \\ certificate=@ldap_ca_cert.pem \\ insecure_tls=false \\ starttls=true ...   ","version":"Next","tagName":"h3"},{"title":"Scenario 2​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#scenario-2","content":" LDAP server running on ldap.example.com, port 389.Server supports STARTTLS command to initiate encryption on the standard port.CA Certificate stored in file named ldap_ca_cert.pemServer does not allow anonymous binds for performing user search.Bind account used for searching is cn=openbao,ou=users,dc=example,dc=com with password My$ecrt3tP4ss.User objects are under the ou=Users,dc=example,dc=com organizational unit.Username passed to openbao when authenticating maps to the sAMAccountName attribute.Group membership will be resolved via the memberOf attribute of user objects. That search will begin under ou=Users,dc=example,dc=com.  $ bao write auth/ldap/config \\ url=&quot;ldap://ldap.example.com&quot; \\ userattr=sAMAccountName \\ userdn=&quot;ou=Users,dc=example,dc=com&quot; \\ groupdn=&quot;ou=Users,dc=example,dc=com&quot; \\ groupfilter=&quot;(&amp;(objectClass=person)(uid={{.Username}}))&quot; \\ groupattr=&quot;memberOf&quot; \\ binddn=&quot;cn=openbao,ou=users,dc=example,dc=com&quot; \\ bindpass='My$ecrt3tP4ss' \\ certificate=@ldap_ca_cert.pem \\ insecure_tls=false \\ starttls=true ...   ","version":"Next","tagName":"h3"},{"title":"Scenario 3​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#scenario-3","content":" LDAP server running on ldap.example.com, port 636 (LDAPS)CA Certificate stored in file named ldap_ca_cert.pemUser objects are under the ou=Users,dc=example,dc=com organizational unit.Username passed to OpenBao when authenticating maps to the uid attribute.User bind DN will be auto-discovered using anonymous binding.Group membership will be resolved via any one of memberUid, member, or uniqueMember attributes. That search will begin under ou=Groups,dc=example,dc=com.Group names are identified using the cn attribute.  $ bao write auth/ldap/config \\ url=&quot;ldaps://ldap.example.com&quot; \\ userattr=&quot;uid&quot; \\ userdn=&quot;ou=Users,dc=example,dc=com&quot; \\ discoverdn=true \\ groupdn=&quot;ou=Groups,dc=example,dc=com&quot; \\ certificate=@ldap_ca_cert.pem \\ insecure_tls=false \\ starttls=true ...   ","version":"Next","tagName":"h3"},{"title":"LDAP group -> policy mapping​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#ldap-group---policy-mapping","content":" Next we want to create a mapping from an LDAP group to an OpenBao policy:  $ bao write auth/ldap/groups/scientists policies=foo,bar   This maps the LDAP group &quot;scientists&quot; to the &quot;foo&quot; and &quot;bar&quot; OpenBao policies. We can also add specific LDAP users to additional (potentially non-LDAP) groups. Note that policies can also be specified on LDAP users as well.  $ bao write auth/ldap/groups/engineers policies=foobar $ bao write auth/ldap/users/tesla groups=engineers policies=zoobar   This adds the LDAP user &quot;tesla&quot; to the &quot;engineers&quot; group, which maps to the &quot;foobar&quot; OpenBao policy. User &quot;tesla&quot; itself is associated with &quot;zoobar&quot; policy.  Finally, we can test this by authenticating:  $ bao login -method=ldap username=tesla Password (will be hidden): Successfully authenticated! The policies that are associated with this token are listed below: default, foobar, zoobar   ","version":"Next","tagName":"h2"},{"title":"Note on policy mapping​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#note-on-policy-mapping","content":" It should be noted that user -&gt; policy mapping happens at token creation time. And changes in group membership on the LDAP server will not affect tokens that have already been provisioned. To see these changes, old tokens should be revoked and the user should be asked to reauthenticate.  ","version":"Next","tagName":"h2"},{"title":"User lockout​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#user-lockout","content":" If a user provides bad credentials several times in quick succession, OpenBao will stop trying to validate their credentials for a while, instead returning immediately with a permission denied error. We call this behavior &quot;user lockout&quot;. The time for which a user will be locked out is called “lockout duration”. The user will be able to login after the lockout duration has passed. The number of failed login attempts after which the user is locked out is called “lockout threshold”. The lockout threshold counter is reset to zero after a few minutes without login attempts, or upon a successful login attempt. The duration after which the counter will be reset to zero after no login attempts is called &quot;lockout counter reset&quot;. This can defeat both automated and targeted requests i.e, user-based password guessing attacks as well as automated attacks.  The user lockout feature is enabled by default. The default values for &quot;lockout threshold&quot; is 5 attempts, &quot;lockout duration&quot; is 15 minutes, &quot;lockout counter reset&quot; is 15 minutes.  The user lockout feature can be disabled as follows:  It can be disabled globally using environment variable VAULT_DISABLE_USER_LOCKOUT.It can be disabled for all supported auth methods (ldap, userpass and approle) or a specific supported auth method using the disable_lockoutparameter within user_lockout stanza in configuration file. Please see user lockout configuration for more details.It can be disabled for a specific auth mount using &quot;auth tune&quot;. Please see auth tune commandor auth tune api for more details.  warning NOTE: This feature is only supported by the userpass, ldap, and approle auth methods.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"LDAP auth method","url":"/openbao/docs/auth/ldap/#api","content":" The LDAP auth method has a full HTTP API. Please see theLDAP auth method API for more details. ","version":"Next","tagName":"h2"},{"title":"Kerberos auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/kerberos/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#prerequisites","content":" Kerberos is a very hands-on auth method. Other auth methods likeLDAP only require a cursory amount of knowledge for configuration and use. Kerberos, on the other hand, is best used by people already familiar with it. We recommend that you use simpler authentication methods if your use case is achievable through them. If not, we recommend that before approaching Kerberos, you become familiar with its fundamentals.  MicroNugget: How Kerberos Works in Windows Active DirectoryMIT's Kerberos DocumentationKerberos: The Definitive Guide  Regardless of how you gain your knowledge, before using this auth method, ensure you are comfortable with Kerberos' high-level architecture, and ensure you've gone through the exercise of:  Creating a valid krb5.conf fileCreating a valid keytab fileAuthenticating to your domain server with your keytab file using kinit  With that knowledge in hand, and with an environment that's already tested and confirmed working, you will be ready to use Kerberos with OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#configuration","content":" Enable Kerberos authentication in OpenBao:  $ bao auth enable \\ -passthrough-request-headers=Authorization \\ -allowed-response-headers=www-authenticate \\ kerberos   Create a keytab for the Kerberos plugin (this keytab is used by the OpenBao server itself, another keytab should be generated for login purposes):  $ ktutil ktutil: addent -password -p your_service_account@REALM.COM -e aes256-cts -k 1 Password for your_service_account@REALM.COM: ktutil: list -e slot KVNO Principal ---- ---- --------------------------------------------------------------------- 1 1 your_service_account@REALM.COM (aes256-cts-hmac-sha1-96) ktutil: wkt openbao.keytab   The KVNO (-k 1) should match the KVNO of the service account. An error will show in the OpenBao logs if this is incorrect.  Different encryption types can also be added to the keytab, for example -e rc4-hmac with additional addent commands.  Then base64 encode it:  $ base64 openbao.keytab &gt; openbao.keytab.base64   Configure the Kerberos auth method with the keytab and entry name that will be used to verify inbound login requests:  $ bao write auth/kerberos/config \\ keytab=@openbao.keytab.base64 \\ service_account=&quot;openbao_svc&quot;   Configure the Kerberos auth method to communicate with LDAP using the service account configured above. This is a sample LDAP configuration. Yours will vary. Ensure you've first tested your configuration from the OpenBao server using a tool like ldapsearch.  $ bao write auth/kerberos/config/ldap \\ binddn=openbao_svc@MATRIX.LAN \\ bindpass=$OPENBAO_SVC_PASSWORD \\ groupattr=sAMAccountName \\ groupdn=&quot;DC=MATRIX,DC=LAN&quot; \\ groupfilter=&quot;(&amp;(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}}))&quot; \\ userdn=&quot;CN=Users,DC=MATRIX,DC=LAN&quot; \\ userattr=sAMAccountName \\ upndomain=MATRIX.LAN \\ url=ldaps://somewhere.foo   The LDAP above relies upon the same code as the LDAP auth method. See its documentationfor further discussion of available parameters.  Configure the OpenBao policies that should be granted to those who successfully authenticate based on their LDAP group membership. Since this is identical to the LDAP auth method, seeGroup Membership Resolutionand LDAP Group -&gt; Policy Mappingfor further discussion.  $ bao write auth/kerberos/groups/engineering-team \\ policies=engineers   The above group grants the &quot;engineers&quot; policy to those who authenticate via Kerberos and are found to be members of the &quot;engineering-team&quot; LDAP group.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#authentication","content":" From a client machine with a valid krb5.conf and keytab, perform a command like the following:  $ bao login -method=kerberos \\ username=grace \\ service=HTTP/my-service \\ realm=MATRIX.LAN \\ keytab_path=/etc/krb5/krb5.keytab \\ krb5conf_path=/etc/krb5.conf \\ disable_fast_negotiation=false   krb5conf_path is the path to a valid krb5.conf file describing how to communicate with the Kerberos environment.keytab_path is the path to the keytab in which the entry lives for the entity authenticating to OpenBao. Keytab files should be protected from other users on a shared server using appropriate file permissions.username is the username for the entry within the keytab to use for logging into Kerberos. This username must match a service account in LDAP.service is the service principal name to use in obtaining a service ticket for gaining a SPNEGO token. This service must exist in LDAP.realm is the name of the Kerberos realm. This realm must match the UPNDomain configured on the LDAP connection. This check is case-sensitive.disable_fast_negotiation is for disabling the Kerberos auth method's default of using FAST negotiation. FAST is a pre-authentication framework for Kerberos. It includes a mechanism for tunneling pre-authentication exchanges using armoured KDC messages. FAST provides increased resistance to passive password guessing attacks. Some common Kerberos implementations do not support FAST negotiation.remove_instance_name removes any instance names from a Kerberos service principal name when parsing the keytab file. For example when this is set to true, if a keytab has the service principal name foo/localhost@example.com, the CLI will strip the service principal name to just be foo@example.com.  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#troubleshooting","content":" ","version":"Next","tagName":"h2"},{"title":"Identify the malfunctioning piece​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#identify-the-malfunctioning-piece","content":" Once the malfunctioning piece of the journey is identified, you can focus your debugging efforts in the most useful direction.  Use ldapsearch while logged into your machine hosting OpenBao to ensure your LDAP configuration is functional.Authenticate to your domain server using kinit, your keytab, and yourkrb5.conf. Do this with both OpenBao's keytab, and any client keytab being used for logging in. This ensures your Kerberos network is working.While logged into your client machine, verify you can reach OpenBao through the following command: $ curl $VAULT_ADDR/v1/sys/health.  ","version":"Next","tagName":"h3"},{"title":"Build clear steps to reproduce the problem​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#build-clear-steps-to-reproduce-the-problem","content":" If possible, make it easy for someone else to reproduce the problem who is outside of your company. For instance, if you expect that you should be able to login using a command like:  $ bao login -method=kerberos \\ username=my-name \\ service=HTTP/my-service \\ realm=EXAMPLE.COM \\ keytab_path=/etc/krb5/krb5.keytab \\ krb5conf_path=/etc/krb5.conf   Then make sure you're ready to share the error output of that command, the contents of the krb5.conf file, and the entries listedin the keytab file.  ","version":"Next","tagName":"h3"},{"title":"Additional troubleshooting resources​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#additional-troubleshooting-resources","content":" Troubleshooting OpenBaoThe plugin's code  The OpenBao Kerberos library has a working integration test environment that can be referenced as an example of a full Kerberos and LDAP environment. It runs through Docker and can be started through either one of the following commands:  $ make integration $ make dev-env   These commands run variations of a scriptthat spins up a full environment, adds users, and executes a login from a client.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"Kerberos auth method","url":"/openbao/docs/auth/kerberos/#api","content":" The Kerberos auth method has a full HTTP API. Please see theKerberos auth method API for more details. ","version":"Next","tagName":"h2"},{"title":"Login MFA","type":0,"sectionRef":"#","url":"/openbao/docs/auth/login-mfa/","content":"","keywords":"","version":"Next"},{"title":"MFA types​","type":1,"pageTitle":"Login MFA","url":"/openbao/docs/auth/login-mfa/#mfa-types","content":" MFA in OpenBao includes the following login types:  Time-based One-time Password (TOTP) - If configured and enabled on a login path, this would require a TOTP passcode along with an OpenBao token to be presented while invoking the API login request. The passcode will be validated against the TOTP key present in the caller's identify in OpenBao. Okta - If Okta push is configured and enabled on a login path, then the enrolled device of the user will receive a push notification to either approve or deny access to the API. The Okta username will be derived from the caller identity's alias. Duo - If Duo push is configured and enabled on a login path, then the enrolled device of the user will receive a push notification to either approve or deny access to the API. The Duo username will be derived from the caller identity's alias. Note that Duo could also be configured to use passcodes for authentication. PingID - If PingID push is configured and enabled on a login path, the enrolled device of the user will receive a push notification to either approve or deny access to the API. The PingID username will be derived from the caller identity's alias.  ","version":"Next","tagName":"h2"},{"title":"Login MFA procedure​","type":1,"pageTitle":"Login MFA","url":"/openbao/docs/auth/login-mfa/#login-mfa-procedure","content":" warning NOTE: OpenBao's built-in Login MFA feature does not protect against brute forcing of TOTP passcodes by default. We recommend that per-client rate limitsare applied to the relevant login and/or mfa paths (e.g. /sys/mfa/validate). External MFA methods (Duo, Ping and Okta) may already provide configurable rate limiting. Rate limiting of Login MFA paths are enforced by default.  Login MFA can be configured to secure further authenticating to an auth method. To enable login MFA, an MFA method needs to be configured. Please see Login MFA API for details on how to configure an MFA method. Once an MFA method is configured, an operator can configure an MFA enforcement using the returned unique MFA method ID. Please see Login MFA Enforcement APIfor details on how to configure an MFA enforcement config. MFA could be enforced for an entity, a group of entities, a specific auth method accessor, or an auth method type. A login request that matches any MFA enforcement restrictions is subject to further MFA validation, such as a one-time passcode, before being authenticated.  There are two ways to validate a login request that is subject to MFA validation.  ","version":"Next","tagName":"h2"},{"title":"Single-Phase login​","type":1,"pageTitle":"Login MFA","url":"/openbao/docs/auth/login-mfa/#single-phase-login","content":" In the Single-phase login, the required MFA information is embedded in a login request using the X-Vault-MFA header. In this case, the MFA validation is done as a part of the login request.  MFA credentials are retrieved from the X-Vault-MFA HTTP header. The format of the header is either mfa_method_id[:passcode] ormfa_method_id[:passcode=&lt;passcode&gt;], and one can use either of the above two formats. The item in the [] is optional. If there are multiple MFA methods that need to be validated, a user can pass in multiple X-Vault-MFA HTTP headers.  Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;X-Vault-MFA: d16fd3c2-50de-0b9b-eed3-0301dadeca10:695452&quot; \\ http://127.0.0.1:8200/v1/auth/userpass/login/alice   If an MFA method does not require a passcode, the login request MFA header only contains the method ID.   $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;X-Vault-MFA: d16fd3c2-50de-0b9b-eed3-0301dadeca10&quot; \\ http://127.0.0.1:8200/v1/auth/userpass/login/alice   An operator can configure a name for an MFA method. This name should be unique in the namespace in which the MFA method is configured. The MFA method name can be used in the MFA header.  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;X-Vault-MFA: sample_mfa_method_name:695452&quot; \\ http://127.0.0.1:8200/v1/auth/userpass/login/alice   In cases where the MFA method is configured in a specific namespace, the MFA method name should be prefixed with the namespace path. Below shows an example where an MFA method is configured in ns1.  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --header &quot;X-Vault-MFA: ns1/sample_mfa_method_name:695452&quot; \\ http://127.0.0.1:8200/v1/auth/userpass/login/alice   ","version":"Next","tagName":"h3"},{"title":"Two-Phase login​","type":1,"pageTitle":"Login MFA","url":"/openbao/docs/auth/login-mfa/#two-phase-login","content":" The more conventional and prevalent MFA method is a two-request mechanism, also referred to as Two-phase Login MFA. In Two-phase login, the X-Vault-MFA header is not provided in the request. In this case, after sending a regular login request, the user receives an auth response in which MFA requirements are included. MFA requirements contain an MFA request ID which identifies the login request that needs validation. In addition, MFA requirements contain MFA constraints that determine which MFA types should be used to validate the request, the corresponding method IDs, and a boolean value showing whether the MFA method uses passcodes or not. MFA constraints form a nested map in MFA Requirement and represent all MFA enforcements that match a login request. While the example below is for the userpass login, note that this can affect the login response on any auth mount protected by MFA validation.  Sample Two-Phase login response​  { &quot;request_id&quot;: &quot;1044c151-13ea-1cf5-f6ed-000c42efd477&quot;, &quot;lease_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;data&quot;: null, &quot;warnings&quot;: [ &quot;A login request was issued that is subject to MFA validation. Please make sure to validate the login by sending another request to mfa/validate endpoint.&quot; ], &quot;auth&quot;: { &quot;client_token&quot;: &quot;&quot;, &quot;accessor&quot;: &quot;&quot;, &quot;policies&quot;: null, &quot;token_policies&quot;: null, &quot;identity_policies&quot;: null, &quot;metadata&quot;: null, &quot;orphan&quot;: false, &quot;entity_id&quot;: &quot;&quot;, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false, &quot;mfa_requirement&quot;: { &quot;mfa_request_id&quot;: &quot;d0c9eec7-6921-8cc0-be62-202b289ef163&quot;, &quot;mfa_constraints&quot;: { &quot;enforcementConfigUserpass&quot;: { &quot;any&quot;: [ { &quot;type&quot;: &quot;totp&quot;, &quot;id&quot;: &quot;820997b3-110e-c251-7e8b-ff4aa428a6e1&quot;, &quot;uses_passcode&quot;: true, &quot;name&quot;: &quot;sample_mfa_method_name&quot;, } ] } } } } }   Note that the uses_passcode boolean value will always show true for TOTP, and false for Okta and PingID. For Duo method, the value can be configured as part of the method configuration, using the use_passcode parameter. Please see Duo API for details on how to configure the boolean value for Duo.  To validate the MFA restricted login request, the user sends a second request to the validateendpoint including the MFA request ID and MFA payload. MFA payload contains a map of methodIDs and their associated credentials. If the configured MFA methods, such as PingID, Okta, and Duo, do not require a passcode, the associated credentials will be a list with one empty string.  Sample payload​  { &quot;mfa_request_id&quot;: &quot;5879c74a-1418-1948-7be9-97b209d693a7&quot;, &quot;mfa_payload&quot;: { &quot;d16fd3c2-50de-0b9b-eed3-0301dadeca10&quot;: [&quot;910201&quot;] } }   If an MFA method is configured in a namespace, the MFA method name prefixed with the namespace path can be used in the validation payload.  { &quot;mfa_request_id&quot;: &quot;5879c74a-1418-1948-7be9-97b209d693a7&quot;, &quot;mfa_payload&quot;: { &quot;ns1/sample_mfa_method_name&quot;: [&quot;910201&quot;] } }   Sample request​  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/mfa/validate   Sample CLI request​  A user is also able to use the CLI write command to validate the login request.  $ bao write sys/mfa/validate -format=json @payload.json   Interactive CLI for login MFA​  OpenBao supports an interactive way of authenticating to an auth method using CLI only if the login request is subject to a single MFA method validation. In this situation, if the MFA method is configured to use passcodes, after sending a regular login request, the user is prompted to insert the passcode. Upon successful MFA validation, a client token is returned. If the configured MFA methods, such as PingID, Okta, and Duo, do not require a passcode and have out of band mechanisms for verifying the extra factor, the user is notified to check their authenticator application. This alleviates a user from sending the second request separately to validate a login request. To disable the interactive login experience, a user needs to pass in the non-interactive flag to the login request.  $ bao write -non-interactive sys/mfa/validate -format=json @payload.json   To get started with Login MFA, refer to the Login MFA tutorial.  ","version":"Next","tagName":"h3"},{"title":"TOTP passcode validation rate limit​","type":1,"pageTitle":"Login MFA","url":"/openbao/docs/auth/login-mfa/#totp-passcode-validation-rate-limit","content":" Rate limiting of Login MFA paths are enforced by default. OpenBao allows for 5 consecutive failed TOTP passcode validations. This value can also be configured by adding max_validation_attempts to the TOTP configuration. If the number of consecutive failed TOTP passcode validation exceeds the configured value, the user needs to wait until a fresh TOTP passcode is available. ","version":"Next","tagName":"h3"},{"title":"Kubernetes auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#via-the-cli","content":" The default path is /kubernetes. If this auth method was enabled at a different path, specify -path=/my-path in the CLI.  $ bao write auth/kubernetes/login role=demo jwt=...   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#via-the-api","content":" The default endpoint is auth/kubernetes/login. If this auth method was enabled at a different path, use that value instead of kubernetes.  $ curl \\ --request POST \\ --data '{&quot;jwt&quot;: &quot;&lt;your service account jwt&gt;&quot;, &quot;role&quot;: &quot;demo&quot;}' \\ http://127.0.0.1:8200/v1/auth/kubernetes/login   The response will contain a token at auth.client_token:  { &quot;auth&quot;: { &quot;client_token&quot;: &quot;38fe9691-e623-7238-f618-c94d4e7bc674&quot;, &quot;accessor&quot;: &quot;78e87a38-84ed-2692-538f-ca8b9f400ab3&quot;, &quot;policies&quot;: [&quot;default&quot;], &quot;metadata&quot;: { &quot;role&quot;: &quot;demo&quot;, &quot;service_account_name&quot;: &quot;myapp&quot;, &quot;service_account_namespace&quot;: &quot;default&quot;, &quot;service_account_secret_name&quot;: &quot;myapp-token-pd21c&quot;, &quot;service_account_uid&quot;: &quot;aa9aa8ff-98d0-11e7-9bb7-0800276d99bf&quot; }, &quot;lease_duration&quot;: 2764800, &quot;renewable&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#configuration","content":" Auth methods must be configured in advance before users or machines can authenticate. These steps are usually completed by an operator or configuration management tool.  Enable the Kubernetes auth method:  bao auth enable kubernetes   Use the /config endpoint to configure OpenBao to talk to Kubernetes. Usekubectl cluster-info to validate the Kubernetes host address and TCP port. For the list of available configuration options, please see theAPI documentation.  bao write auth/kubernetes/config \\ token_reviewer_jwt=&quot;&lt;your reviewer service account JWT&gt;&quot; \\ kubernetes_host=https://192.168.99.100:&lt;your TCP port or blank for 443&gt; \\ kubernetes_ca_cert=@ca.crt   danger Note: The pattern OpenBao uses to authenticate Pods depends on sharing the JWT token over the network. Given the security model of OpenBao, this is allowable because OpenBao is part of the trusted compute base. In general, Kubernetes applications shouldnot share this JWT with other applications, as it allows API calls to be made on behalf of the Pod and can result in unintended access being granted to 3rd parties.  Create a named role:  bao write auth/kubernetes/role/demo \\ bound_service_account_names=myapp \\ bound_service_account_namespaces=default \\ policies=default \\ ttl=1h   This role authorizes the &quot;myapp&quot; service account in the default namespace and it gives it the default policy.  For the complete list of configuration options, please see the API documentation.  ","version":"Next","tagName":"h2"},{"title":"Kubernetes 1.21​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#kubernetes-121","content":" Starting in version 1.21, the KubernetesBoundServiceAccountTokenVolume feature defaults to enabled. This changes the JWT token mounted into containers by default in two ways that are important for Kubernetes auth:  It has an expiry time and is bound to the lifetime of the pod and service account.The value of the JWT's &quot;iss&quot; claim depends on the cluster's configuration.  The changes to token lifetime are important when configuring thetoken_reviewer_jwt option. If a short-lived token is used, Kubernetes will revoke it as soon as the pod or service account are deleted, or if the expiry time passes, and OpenBao will no longer be able to use theTokenReview API. See How to work with short-lived Kubernetes tokensbelow for details on handling this change.  In response to the issuer changes, Kubernetes auth has been updated to not validate the issuer by default. The Kubernetes API does the same validation when reviewing tokens, so enabling issuer validation on the OpenBao side is duplicated work. Without disabling OpenBao's issuer validation, it is not possible for a single Kubernetes auth configuration to work for default mounted pod tokens with both Kubernetes 1.20 and 1.21.. See Discovering the service account issuer below for guidance if you wish to enable issuer validation in OpenBao.  ","version":"Next","tagName":"h2"},{"title":"How to work with short-lived kubernetes tokens​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#how-to-work-with-short-lived-kubernetes-tokens","content":" There are a few different ways to configure auth for Kubernetes pods when default mounted pod tokens are short-lived, each with their own tradeoffs. This table summarizes the options, each of which is explained in more detail below.  Option\tAll tokens are short-lived\tCan revoke tokens early\tOther considerationsUse local token as reviewer JWT\tYes\tYes\tRequires OpenBao to be deployed on the Kubernetes cluster Use client JWT as reviewer JWT\tYes\tYes\tOperational overhead Use long-lived token as reviewer JWT\tNo\tYes Use JWT auth instead\tYes\tNo\t  info Note: By default, Kubernetes currently extends the lifetime of admission injected service account tokens to a year to help smooth the transition to short-lived tokens. If you would like to disable this, set--service-account-extend-token-expiration=false forkube-apiserver or specify your own serviceAccountToken volume mount. Seehere for an example.  Use local service account token as the reviewer JWT​  When running OpenBao in a Kubernetes pod the recommended option is to use the pod's local service account token. OpenBao will periodically re-read the file to support short-lived tokens. To use the local token and CA certificate, omittoken_reviewer_jwt and kubernetes_ca_cert when configuring the auth method. OpenBao will attempt to load them from token and ca.crt respectively inside the default mount folder /var/run/secrets/kubernetes.io/serviceaccount/.  bao write auth/kubernetes/config \\ kubernetes_host=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT   Use the OpenBao client's JWT as the reviewer JWT​  When configuring Kubernetes auth, you can omit the token_reviewer_jwt, and OpenBao will use the OpenBao client's JWT as its own auth token when communicating with the Kubernetes TokenReview API. If OpenBao is running in Kubernetes, you also need to set disable_local_ca_jwt=true.  This means OpenBao does not store any JWTs and allows you to use short-lived tokens everywhere but adds some operational overhead to maintain the cluster role bindings on the set of service accounts you want to be able to authenticate with OpenBao. Each client of OpenBao would need the system:auth-delegator ClusterRole:  kubectl create clusterrolebinding openbao-client-auth-delegator \\ --clusterrole=system:auth-delegator \\ --group=group1 \\ --serviceaccount=default:svcaccount1 \\ ...   Continue using long-lived tokens​  You can create a long-lived secret using the instructions hereand use that as the token_reviewer_jwt. In this example, the openbao service account would need the system:auth-delegator ClusterRole:  kubectl apply -f - &lt;&lt;EOF apiVersion: v1 kind: Secret metadata: name: openbao-k8s-auth-secret annotations: kubernetes.io/service-account.name: openbao type: kubernetes.io/service-account-token EOF   Using this maintains previous workflows but does not benefit from the improved security posture of short-lived tokens.  Use JWT auth​  Kubernetes auth is specialized to use Kubernetes' TokenReview API. However, the JWT tokens Kubernetes generates can also be verified using Kubernetes as an OIDC provider. The JWT auth method documentation has instructions for setting up JWT auth with Kubernetes as the OIDC provider.  This solution allows you to use short-lived tokens for all clients and removes the need for a reviewer JWT. However, the client tokens cannot be revoked before their TTL expires, so it is recommended to keep the TTL short with that limitation in mind.  ","version":"Next","tagName":"h3"},{"title":"Discovering the service account issuer​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#discovering-the-service-account-issuer","content":" info Note: disable_iss_validation and issuer are deprecated and the default for disable_iss_validation has changed to true for new Kubernetes auth mounts. The following section only applies if you have setdisable_iss_validation=false , but disable_iss_validation=true is the new recommended value for all versions of OpenBao.  Kubernetes 1.21+ clusters may require setting the service accountissuer to the same value askube-apiserver's --service-account-issuer flag. This is because the service account JWTs for these clusters may have an issuer specific to the cluster itself, instead of the old default of kubernetes/serviceaccount. If you are unable to check this value directly, you can run the following and look for the&quot;iss&quot; field to find the required value:  echo '{&quot;apiVersion&quot;: &quot;authentication.k8s.io/v1&quot;, &quot;kind&quot;: &quot;TokenRequest&quot;}' \\ | kubectl create -f- --raw /api/v1/namespaces/default/serviceaccounts/default/token \\ | jq -r '.status.token' \\ | cut -d . -f2 \\ | base64 -d   Most clusters will also have that information available at the.well-known/openid-configuration endpoint:  kubectl get --raw /.well-known/openid-configuration | jq -r .issuer   This value is then used when configuring Kubernetes auth, e.g.:  bao write auth/kubernetes/config \\ kubernetes_host=&quot;https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT&quot; \\ issuer=&quot;\\&quot;test-aks-cluster-dns-d6cbb78e.hcp.uksouth.azmk8s.io\\&quot;&quot;   ","version":"Next","tagName":"h3"},{"title":"Configuring kubernetes​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#configuring-kubernetes","content":" This auth method accesses the Kubernetes TokenReview API to validate the provided JWT is still valid. Kubernetes should be running with--service-account-lookup. This is defaulted to true from Kubernetes 1.7. Otherwise deleted tokens in Kubernetes will not be properly revoked and will be able to authenticate to this auth method.  Service Accounts used in this auth method will need to have access to the TokenReview API. If Kubernetes is configured to use RBAC roles, the Service Account should be granted permissions to access this API. The following example ClusterRoleBinding could be used to grant these permissions:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: role-tokenreview-binding namespace: default roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:auth-delegator subjects: - kind: ServiceAccount name: openbao-auth namespace: default   ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#api","content":" The Kubernetes Auth Plugin has a full HTTP API. Please see theAPI docs for more details.  ","version":"Next","tagName":"h2"},{"title":"Code example​","type":1,"pageTitle":"Kubernetes auth method","url":"/openbao/docs/auth/kubernetes/#code-example","content":" The following example demonstrates the Kubernetes auth method to authenticate with OpenBao.  Go package main import ( &quot;fmt&quot; &quot;os&quot; openbao &quot;github.com/openbao/openbao/api&quot; auth &quot;github.com/openbao/openbao/api/auth/kubernetes&quot; ) // Fetches a key-value secret (kv-v2) after authenticating to OpenBao with a Kubernetes service account. // For a more in-depth setup explanation, please see the relevant readme in the hashicorp/vault-examples repo. func getSecretWithKubernetesAuth() (string, error) { // If set, the VAULT_ADDR environment variable will be the address that // your pod uses to communicate with OpenBao. config := openbao.DefaultConfig() // modify for more granular configuration client, err := openbao.NewClient(config) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to initialize OpenBao client: %w&quot;, err) } // The service-account token will be read from the path where the token's // Kubernetes Secret is mounted. By default, Kubernetes will mount it to // /var/run/secrets/kubernetes.io/serviceaccount/token, but an administrator // may have configured it to be mounted elsewhere. // In that case, we'll use the option WithServiceAccountTokenPath to look // for the token there. k8sAuth, err := auth.NewKubernetesAuth( &quot;dev-role-k8s&quot;, auth.WithServiceAccountTokenPath(&quot;path/to/service-account-token&quot;), ) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to initialize Kubernetes auth method: %w&quot;, err) } authInfo, err := client.Auth().Login(context.TODO(), k8sAuth) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to log in with Kubernetes auth: %w&quot;, err) } if authInfo == nil { return &quot;&quot;, fmt.Errorf(&quot;no auth info was returned after login&quot;) } // get secret from OpenBao, from the default mount path for KV v2 in dev mode, &quot;secret&quot; secret, err := client.KVv2(&quot;secret&quot;).Get(context.Background(), &quot;creds&quot;) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;unable to read secret: %w&quot;, err) } // data map can contain more than one key-value pair, // in this case we're just grabbing one of them value, ok := secret.Data[&quot;password&quot;].(string) if !ok { return &quot;&quot;, fmt.Errorf(&quot;value type assertion failed: %T %#v&quot;, secret.Data[&quot;password&quot;], secret.Data[&quot;password&quot;]) } return value, nil }  ","version":"Next","tagName":"h2"},{"title":"Login MFA FAQ","type":0,"sectionRef":"#","url":"/openbao/docs/auth/login-mfa/faq/","content":"","keywords":"","version":"Next"},{"title":"Q: what are the various MFA workflows that are available to me as an OpenBao user and how are they different?​","type":1,"pageTitle":"Login MFA FAQ","url":"/openbao/docs/auth/login-mfa/faq/#q-what-are-the-various-mfa-workflows-that-are-available-to-me-as-an-openbao-user-and-how-are-they-different","content":" MFA workflow\tWhat does it do?\tWho manages the MFA?Login MFA\tMFA in OpenBao provides MFA on login. CLI, API, and UI-based login are supported.\tMFA is managed by OpenBao Okta Auth MFA\tThis is MFA as part of Okta Auth method in OpenBao, where MFA is enforced by Okta on login. MFA must be satisfied for authentication to be successful. This is different from the Okta MFA method used with Login MFA. CLI/API login are supported.\tMFA is managed externally by Okta  ","version":"Next","tagName":"h3"},{"title":"Q: what is Single-Phase MFA vs. Two-Phase MFA?​","type":1,"pageTitle":"Login MFA FAQ","url":"/openbao/docs/auth/login-mfa/faq/#q-what-is-single-phase-mfa-vs-two-phase-mfa","content":" Single-Phase MFA: This is a single request mechanism where the required MFA information, such as MFA method ID, is provided via the X-Vault-MFA header in a single MFA request that is used to authenticate into Openbao.  warning Note: If the configured MFA methods need a passcode, it needs to be provided in the request, such as in the case of TOTP or Duo. If the configured MFA methods, such as PingID, Okta, or Duo, do not require a passcode and have out of band mechanisms for verifying the extra factor, Openbao will send an inquiry to the other service's APIs to determine whether the MFA request has yet been verified.  Two-Phase MFA: This is a two-request MFA method that is more conventionally used. The MFA passcode required for the configured MFA method is not provided in a header of the login request that is MFA-restricted. Instead, the user first authenticates to the auth method, and on successful authentication to the auth method, an MFA requirement is returned to the user. The MFA requirement contains the MFA RequestID and constraints applicable to the MFA as configured by the operator.The user then must make a second request to the new endpoint sys/mfa/validate, providing the MFA RequestID in the request, and an MFA payload which includes the MFA methodIDs passcode (if applicable). If MFA validation passes, the new Openbao token will be persisted and returned to the user in the response, just like a regular Openbao token created using a non-MFA-restricted auth method.  ","version":"Next","tagName":"h3"},{"title":"Q: what are the ways to configure the various MFA workflows?​","type":1,"pageTitle":"Login MFA FAQ","url":"/openbao/docs/auth/login-mfa/faq/#q-what-are-the-ways-to-configure-the-various-mfa-workflows","content":" MFA workflow\tConfiguration methods\tDetailsLogin MFA\tCLI/API\tConfigured using the identity/mfa/method endpoints, then passing those method IDs to the identity/mfa/login-enforcement endpoint. MFA methods supported: TOTP, Okta, Duo, PingID. Okta Auth MFA\tCLI/API\tMFA methods supported: TOTP , Okta Verify Push.  ","version":"Next","tagName":"h3"},{"title":"Q: which MFA mechanism is used with the different MFA workflows in OpenBao?​","type":1,"pageTitle":"Login MFA FAQ","url":"/openbao/docs/auth/login-mfa/faq/#q-which-mfa-mechanism-is-used-with-the-different-mfa-workflows-in-openbao","content":" MFA workflow\tUI\tCLI/API\tSingle-Phase\tTwo-PhaseLogin MFA\tSupported\tSupported. You can select single-phase MFA by supplying the X-Vault-MFA header. In the absence of this header, the Two- Phase MFA is used\tN/A\tSupported Okta Auth MFA\tN/A\tN/A\tMFA is not managed by OpenBao\tMFA is not managed by OpenBao  ","version":"Next","tagName":"h3"},{"title":"Q: i use the OpenBao agent. does MFA pose any challenges for me?​","type":1,"pageTitle":"Login MFA FAQ","url":"/openbao/docs/auth/login-mfa/faq/#q-i-use-the-openbao-agent-does-mfa-pose-any-challenges-for-me","content":" The OpenBao Agent should not use MFA to authenticate to OpenBao; it should be able to relay requests with MFA-related headers to OpenBao successfully. ","version":"Next","tagName":"h3"},{"title":"RADIUS auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/radius/","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"RADIUS auth method","url":"/openbao/docs/auth/radius/#authentication","content":" The default path is /radius. If this auth method was enabled at a different path, specify -path=/my-path in the CLI.  ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"RADIUS auth method","url":"/openbao/docs/auth/radius/#via-the-cli","content":" $ bao login -method=radius username=sethvargo   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"RADIUS auth method","url":"/openbao/docs/auth/radius/#via-the-api","content":" The default endpoint is auth/radius/login. If this auth method was enabled at a different path, use that value instead of radius.  $ curl \\ --request POST \\ --data '{&quot;password&quot;: &quot;...&quot;}' \\ http://127.0.0.1:8200/v1/auth/radius/login/sethvargo   The response will contain a token at auth.client_token:  { &quot;auth&quot;: { &quot;client_token&quot;: &quot;c4f280f6-fdb2-18eb-89d3-589e2e834cdb&quot;, &quot;policies&quot;: [&quot;admins&quot;], &quot;metadata&quot;: { &quot;username&quot;: &quot;mitchellh&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"RADIUS auth method","url":"/openbao/docs/auth/radius/#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"RADIUS auth method","url":"/openbao/docs/auth/radius/#via-the-cli-1","content":" Enable the radius auth method: $ bao auth enable radius Configure connection details for your RADIUS server. $ bao write auth/radius/users/mitchellh policies=admins For the complete list of configuration options, please see the API documentation. The above creates a new mapping for user &quot;mitchellh&quot; that will be associated with the &quot;admins&quot; policy. Alternatively, OpenBao can assign a configurable set of policies to any user that successfully authenticates with the RADIUS server but has no explicit mapping in the users/ path. This is done through theunregistered_user_policies configuration parameter.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"RADIUS auth method","url":"/openbao/docs/auth/radius/#api","content":" The RADIUS auth method has a full HTTP API. Please see theRADIUS Auth API for more details. ","version":"Next","tagName":"h2"},{"title":"Token auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/token/","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"Token auth method","url":"/openbao/docs/auth/token/#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"Token auth method","url":"/openbao/docs/auth/token/#via-the-cli","content":" $ bao login token=&lt;token&gt;   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"Token auth method","url":"/openbao/docs/auth/token/#via-the-api","content":" The token is set directly as a header for the HTTP API. The header should be either X-Vault-Token: &lt;token&gt; or Authorization: Bearer &lt;token&gt;.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"Token auth method","url":"/openbao/docs/auth/token/#api","content":" The Token auth method has a full HTTP API. Please see theToken auth method API for more details. ","version":"Next","tagName":"h2"},{"title":"OpenBao UI browser support","type":0,"sectionRef":"#","url":"/openbao/docs/browser-support/","content":"OpenBao UI browser support OpenBao currently supports all 'evergreen' and updated browsers. the following browsers are supported: ChromeFirefoxSafariMicrosoft Edge danger Warning: Using an unsupported browser such as Internet Explorer 11 (IE 11) may cause degradation in feature functionality, and in some cases, OpenBao features may not operate. We encourage using one of the supported browsers listed for OpenBao UI. Please note that OpenBao, in alignment with Microsoft's stance on IE 11, no longer supports Internet Explorer 11 (IE 11). For further information on IE 11, please reference Microsoft's support site.","keywords":"","version":"Next"},{"title":"Userpass auth method","type":0,"sectionRef":"#","url":"/openbao/docs/auth/userpass/","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"Userpass auth method","url":"/openbao/docs/auth/userpass/#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"Userpass auth method","url":"/openbao/docs/auth/userpass/#via-the-cli","content":" $ bao login -method=userpass \\ username=mitchellh \\ password=foo   ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"Userpass auth method","url":"/openbao/docs/auth/userpass/#via-the-api","content":" $ curl \\ --request POST \\ --data '{&quot;password&quot;: &quot;foo&quot;}' \\ http://127.0.0.1:8200/v1/auth/userpass/login/mitchellh   The response will contain the token at auth.client_token:  { &quot;lease_id&quot;: &quot;&quot;, &quot;renewable&quot;: false, &quot;lease_duration&quot;: 0, &quot;data&quot;: null, &quot;auth&quot;: { &quot;client_token&quot;: &quot;c4f280f6-fdb2-18eb-89d3-589e2e834cdb&quot;, &quot;policies&quot;: [&quot;admins&quot;], &quot;metadata&quot;: { &quot;username&quot;: &quot;mitchellh&quot; }, &quot;lease_duration&quot;: 0, &quot;renewable&quot;: false } }   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Userpass auth method","url":"/openbao/docs/auth/userpass/#configuration","content":" Auth methods must be configured in advance before users or machines can authenticate. These steps are usually completed by an operator or configuration management tool.  Enable the userpass auth method: $ bao auth enable userpass This enables the userpass auth method at auth/userpass. To enable it at a different path, use the -path flag: $ bao auth enable -path=&lt;path&gt; userpass Configure it with users that are allowed to authenticate: $ bao write auth/&lt;userpass:path&gt;/users/mitchellh \\ password=foo \\ policies=admins This creates a new user &quot;mitchellh&quot; with the password &quot;foo&quot; that will be associated with the &quot;admins&quot; policy. This is the only configuration necessary.  ","version":"Next","tagName":"h2"},{"title":"User lockout​","type":1,"pageTitle":"Userpass auth method","url":"/openbao/docs/auth/userpass/#user-lockout","content":" If a user provides bad credentials several times in quick succession, OpenBao will stop trying to validate their credentials for a while, instead returning immediately with a permission denied error. We call this behavior &quot;user lockout&quot;. The time for which a user will be locked out is called “lockout duration”. The user will be able to login after the lockout duration has passed. The number of failed login attempts after which the user is locked out is called “lockout threshold”. The lockout threshold counter is reset to zero after a few minutes without login attempts, or upon a successful login attempt. The duration after which the counter will be reset to zero after no login attempts is called &quot;lockout counter reset&quot;. This can defeat both automated and targeted requests i.e, user-based password guessing attacks as well as automated attacks.  The user lockout feature is enabled by default. The default values for &quot;lockout threshold&quot; is 5 attempts, &quot;lockout duration&quot; is 15 minutes, &quot;lockout counter reset&quot; is 15 minutes.  The user lockout feature can be disabled as follows:  It can be disabled globally using environment variable VAULT_DISABLE_USER_LOCKOUT.It can be disabled for all supported auth methods (ldap, userpass and approle) or a specific supported auth method using the disable_lockoutparameter within user_lockout stanza in configuration file. Please see user lockout configuration for more details.It can be disabled for a specific auth mount using &quot;auth tune&quot;. Please see auth tune commandor auth tune api for more details.  warning NOTE: This feature is only supported by the userpass, ldap, and approle auth methods.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Userpass auth method","url":"/openbao/docs/auth/userpass/#api","content":" The Userpass auth method has a full HTTP API. Please see the Userpass auth method API for more details. ","version":"Next","tagName":"h2"},{"title":"agent","type":0,"sectionRef":"#","url":"/openbao/docs/commands/agent/","content":"agent Please see the OpenBao Agent documentation page.","keywords":"","version":"Next"},{"title":"audit","type":0,"sectionRef":"#","url":"/openbao/docs/commands/audit/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"audit","url":"/openbao/docs/commands/audit/#examples","content":" Enable an audit device:  $ bao audit enable file file_path=/tmp/my-file.txt Success! Enabled the file audit device at: file/   List all audit devices:  $ bao audit list Path Type Description ---- ---- ----------- file/ file n/a   Disable an audit device:  $ bao audit disable file/ Success! Disabled audit device (if it was enabled) at: file/   warning Note: Once an audit device is disabled, you will no longer be able to HMAC values for comparison with entries in the audit logs. This is true even if you re-enable the audit device at the same path, as a new salt will be created for hashing.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"audit","url":"/openbao/docs/commands/audit/#usage","content":" Usage: bao audit &lt;subcommand&gt; [options] [args] # ... Subcommands: disable Disables an audit device enable Enables an audit device list Lists enabled audit devices   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"audit enable","type":0,"sectionRef":"#","url":"/openbao/docs/commands/audit/enable/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"audit enable","url":"/openbao/docs/commands/audit/enable/#examples","content":" Enable the audit device &quot;file&quot; enabled at &quot;file/&quot;:  $ bao audit enable file file_path=/tmp/my-file.txt Success! Enabled the file audit device at: file/   Full configuration parameters for each audit device are available on theAudit Devices page.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"audit enable","url":"/openbao/docs/commands/audit/enable/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -description (string: &quot;&quot;) - Human-friendly description for the purpose of this audit device. -local (bool: false) - Mark the audit device as a local-only device. Local devices are not replicated or removed by replication. -path (string: &quot;&quot;) - Place where the audit device will be accessible. This must be unique across all audit devices. This defaults to the &quot;type&quot; of the audit device. ","version":"Next","tagName":"h2"},{"title":"audit disable","type":0,"sectionRef":"#","url":"/openbao/docs/commands/audit/disable/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"audit disable","url":"/openbao/docs/commands/audit/disable/#examples","content":" Disable the audit device enabled at &quot;file/&quot;:  $ bao audit disable file/ Success! Disabled audit device (if it was enabled) at: file/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"audit disable","url":"/openbao/docs/commands/audit/disable/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"audit list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/audit/list/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"audit list","url":"/openbao/docs/commands/audit/list/#examples","content":" List all audit devices:  $ bao audit list Path Type Description ---- ---- ----------- file/ file n/a   List detailed audit device information:  $ bao audit list -detailed Path Type Description Replication Options ---- ---- ----------- ----------- ------- file/ file n/a replicated file_path=/var/log/audit.log   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"audit list","url":"/openbao/docs/commands/audit/list/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"audit list","url":"/openbao/docs/commands/audit/list/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"audit list","url":"/openbao/docs/commands/audit/list/#command-options","content":" -detailed (bool: false) - Print detailed information such as options and replication status about each auth device. ","version":"Next","tagName":"h3"},{"title":"auth disable","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/disable/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"auth disable","url":"/openbao/docs/commands/auth/disable/#examples","content":" Disable the auth method enabled at &quot;userpass/&quot;:  $ bao auth disable userpass/ Success! Disabled the auth method (if it existed) at: userpass/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"auth disable","url":"/openbao/docs/commands/auth/disable/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"auth","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"auth","url":"/openbao/docs/commands/auth/#examples","content":" Enable an auth method:  $ bao auth enable userpass Success! Enabled userpass auth method at: userpass/   List all auth methods:  $ bao auth list Path Type Description ---- ---- ----------- token/ token token based credentials userpass/ userpass n/a   Get help about how to authenticate to a particular auth method:  $ bao auth help userpass/ Usage: bao login -method=userpass [CONFIG K=V...] # ...   Disable an auth method:  $ bao auth disable userpass/ Success! Disabled the auth method (if it existed) at: userpass/   Tune an auth method:  $ bao auth tune -max-lease-ttl=30m userpass/ Success! Tuned the auth method at: userpass/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"auth","url":"/openbao/docs/commands/auth/#usage","content":" Usage: bao auth &lt;subcommand&gt; [options] [args] # ... Subcommands: disable Disables an auth method enable Enables a new auth method help Prints usage for an auth method list Lists enabled auth methods tune Tunes an auth method configuration   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"OpenBao commands (CLI)","type":0,"sectionRef":"#","url":"/openbao/docs/commands/","content":"","keywords":"","version":"Next"},{"title":"CLI command structure​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#cli-command-structure","content":" Each command is represented as a command or subcommand, and there are a number of command and subcommand options available: HTTP options, output options, and command-specific options.  Construct your OpenBao CLI command such that the command options precede its path and arguments if any:  bao &lt;command&gt; [options] [path] [args]   options - Flags to specify additional settingsargs - API arguments specific to the operation  info NOTE: Use the command help to display available options and arguments.  Examples:​  The following write command creates a new user (bob) in the userpass auth method. It passes the -address flag to specify the OpenBao server address which precedes the path (auth/userpass/users/bob) and itsargument(password=&quot;long-password&quot;) at last.  $ bao write -address=&quot;http://127.0.0.1:8200&quot; auth/userpass/users/bob password=&quot;long-password&quot;   If multiple options (-address and -namespace) andarguments (password andpolicies) are specified, the command would look like:  $ bao write -address=&quot;http://127.0.0.1:8200&quot; -namespace=&quot;my-organization&quot; \\ auth/userpass/users/bob password=&quot;long-password&quot; policies=&quot;admin&quot;   The options (flags) come after the command (or subcommand) preceding the path, and the args always follow the path to set API parameter values.  The four most common operations in OpenBao are read,write, delete, andlist. These operations work on most paths in OpenBao. Some paths will contain secrets while other paths may contain configuration. Whatever it is, the primary interface for reading and writing data to OpenBao is similar.  ","version":"Next","tagName":"h2"},{"title":"Print cURL command​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#print-curl-command","content":" To see the equivalent API call to perform the same operation, use the-output-curl-string flag after the subcommand.  $ bao write -output-curl-string auth/userpass/users/bob password=&quot;long-password&quot; curl -X PUT -H &quot;X-Vault-Request: true&quot; -H &quot;X-Vault-Token: $(bao print token)&quot; -d '{&quot;password&quot;:&quot;long-password&quot;}' http://127.0.0.1:8200/v1/auth/userpass/users/bob   Print policy requirements​  To view the policy requirements to perform an operation, use the -output-policy flag after the subcommand.  $ bao kv put -output-policy kv/secret value=itsasecret path &quot;kv/data/secret&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Command help​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#command-help","content":" There are two primary ways to get help in OpenBao: CLI help (help)and API help (path-help).  ","version":"Next","tagName":"h2"},{"title":"CLI help​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#cli-help","content":" Use help (or -h for shorthand) to see the CLI help output which corresponds to your OpenBao version.  To get CLI help:  $ bao help   Example: To get help on the kv command.  $ bao kv help   The help output displays available subcommands, parameters, and command flags.  ","version":"Next","tagName":"h3"},{"title":"API help​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#api-help","content":" To invoke the OpenBao API paths, you can use the read (for HTTP GET), write (for HTTP PUT or POST),delete (for HTTP DELETE), andlist (for HTTP LIST) commands.  Use path-help to get OpenBao API help:  $ bao path-help -h   The path-help retrieves API help on any API paths. OpenBao API paths provide built-in help in markdown format. This includes system paths, secret engines, and auth methods.  Example: API help on the sys/mounts/ path.  $ bao path-help sys/mounts Request: mounts Matching Route: ^mounts$ List the currently mounted backends. ## DESCRIPTION This path responds to the following HTTP methods. GET / Lists all the mounted secret backends. GET /&lt;mount point&gt; Get information about the mount at the specified path. POST /&lt;mount point&gt; Mount a new secret backend to the mount point in the URL. POST /&lt;mount point&gt;/tune Tune configuration parameters for the given mount point. DELETE /&lt;mount point&gt; Unmount the specified mount point.   The help output displays supported child-paths and available parameters if there are any.  ","version":"Next","tagName":"h3"},{"title":"Command input​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#command-input","content":" To write data to OpenBao, the input can be a part of the command in key-value format.  $ bao kv put secret/password value=itsasecret   However, some OpenBao API require more advanced structures such as maps. You can use stdin or file input instead.  ","version":"Next","tagName":"h2"},{"title":"stdin​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#stdin","content":" Some commands in OpenBao can read data from stdin using - as the value. If -is the entire argument, OpenBao expects to read a JSON object from stdin:  $ echo -n '{&quot;value&quot;:&quot;itsasecret&quot;}' | bao kv put secret/password -   In addition to reading full JSON objects, OpenBao can read just a value from stdin:  $ echo -n &quot;itsasecret&quot; | bao kv put secret/password value=-   ","version":"Next","tagName":"h3"},{"title":"Files​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#files","content":" Some commands can also read data from a file on disk. The usage is similar to stdin as documented above. If an argument starts with @, OpenBao will read it as a file:  $ bao kv put secret/password @data.json   Or specify the contents of a file as a value:  $ bao kv put secret/password value=@data.txt   Note that if an argument is supplied in a @key=value format, OpenBao will treat that as a kv pair with the key being @key, not a file called key=value. This also means that OpenBao does not support filenames with = in them.  ","version":"Next","tagName":"h3"},{"title":"Mount flag syntax (KV)​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#mount-flag-syntax-kv","content":" All kv commands can alternatively refer to the path to the KV secrets engine using a flag-based syntax like $ bao kv get -mount=secret passwordinstead of $ bao kv get secret/password. The mount flag syntax was created to mitigate confusion caused by the fact that for KV v2 secrets, their full path (used in policies and raw API calls) actually contains a nested /data/ element (e.g. secret/data/password) which can be easily overlooked when using the above KV v1-like syntax secret/password. To avoid this confusion, all KV-specific docs pages will use the -mount flag.  ","version":"Next","tagName":"h2"},{"title":"Exit codes​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#exit-codes","content":" The OpenBao CLI aims to be consistent and well-behaved unless documented otherwise.  Local errors such as incorrect flags, failed validations, or wrong numbers of arguments return an exit code of 1. Any remote errors such as API failures, bad TLS, or incorrect API parameters return an exit status of 2  Some commands override this default where it makes sense. These commands document this anomaly.  ","version":"Next","tagName":"h2"},{"title":"Autocompletion​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#autocompletion","content":" The bao command features opt-in autocompletion for flags, subcommands, and arguments (where supported).  Enable autocompletion by running:  $ bao -autocomplete-install   warning Be sure to restart your shell after installing autocompletion!  When you start typing an OpenBao command, press the &lt;tab&gt; character to show a list of available completions. Type -&lt;tab&gt; to show available flag completions.  If the VAULT_* environment variables are set, the autocompletion will automatically query the OpenBao server and return helpful argument suggestions.  ","version":"Next","tagName":"h2"},{"title":"Token helper​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#token-helper","content":" By default, the OpenBao CLI uses a &quot;token helper&quot; to cache the token after authentication. This is conceptually similar to how a website securely stores your session information as a cookie in the browser. Token helpers are customizable, and you can even build your own.  The default token helper stores the token in ~/.vault-token. You can delete this file at any time to &quot;logout&quot; of OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Environment variables​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#environment-variables","content":" The CLI reads the following environment variables to set behavioral defaults. This can alleviate the need to repetitively type a flag. Flags always take precedence over the environment variables. Each of the following environment variables must be set on the OpenBao process. All environment variables available to the OpenBao process will be logged during startup.  ","version":"Next","tagName":"h2"},{"title":"VAULT_TOKEN​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_token","content":" OpenBao authentication token. Conceptually similar to a session token on a website, the VAULT_TOKEN environment variable holds the contents of the token. For more information, please see the token concepts page.  ","version":"Next","tagName":"h3"},{"title":"VAULT_ADDR​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_addr","content":" Address of the OpenBao server expressed as a URL and port, for example:https://127.0.0.1:8200/.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CACERT​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_cacert","content":" Path to a PEM-encoded CA certificate file on the local disk. This file is used to verify the OpenBao server's SSL certificate. This environment variable takes precedence over VAULT_CAPATH.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CAPATH​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_capath","content":" Path to a directory of PEM-encoded CA certificate files on the local disk. These certificates are used to verify the OpenBao server's SSL certificate.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CLIENT_CERT​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_client_cert","content":" Path to a PEM-encoded client certificate on the local disk. This file is used for TLS communication with the OpenBao server.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CLIENT_KEY​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_client_key","content":" Path to an unencrypted, PEM-encoded private key on disk which corresponds to the matching client certificate.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CLIENT_TIMEOUT​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_client_timeout","content":" Timeout variable. The default value is 60s.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CLUSTER_ADDR​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_cluster_addr","content":" Address that should be used for other cluster members to connect to this node when in High Availability mode.  ","version":"Next","tagName":"h3"},{"title":"VAULT_FORMAT​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_format","content":" Provide OpenBao output (read/status/write) in the specified format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;.  ","version":"Next","tagName":"h3"},{"title":"VAULT_LOG_LEVEL​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_log_level","content":" Set the OpenBao server's log level. The supported values are trace, debug,info, warn, and err. The default log leve is info.  ","version":"Next","tagName":"h3"},{"title":"VAULT_MAX_RETRIES​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_max_retries","content":" Maximum number of retries when certain error codes are encountered. The default is 2, for three total attempts. Set this to 0 or less to disable retrying.  Error codes that are retried are 412 (client consistency requirement not satisfied) and all 5xx except for 501 (not implemented).  ","version":"Next","tagName":"h3"},{"title":"VAULT_REDIRECT_ADDR​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_redirect_addr","content":" Address that should be used when clients are redirected to this node when in High Availability mode.  ","version":"Next","tagName":"h3"},{"title":"VAULT_SKIP_VERIFY​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_skip_verify","content":" Do not verify OpenBao's presented certificate before communicating with it. Setting this variable is not recommended and voids OpenBao's security model.  ","version":"Next","tagName":"h3"},{"title":"VAULT_TLS_SERVER_NAME​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_tls_server_name","content":" Name to use as the SNI host when connecting via TLS.  ","version":"Next","tagName":"h3"},{"title":"VAULT_CLI_NO_COLOR​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_cli_no_color","content":" If provided, OpenBao output will not include ANSI color escape sequence characters.  ","version":"Next","tagName":"h3"},{"title":"VAULT_RATE_LIMIT​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_rate_limit","content":" This environment variable will limit the rate at which the bao command sends requests to OpenBao.  This environment variable has the format rate[:burst] (where items in [] are optional). If not specified, the burst value defaults to rate. Both rate and burst are specified in &quot;operations per second&quot;. If the environment variable is not specified, then the rate and burst will be unlimited i.e. rate limiting is off by default.  Note: The rate is limited for each invocation of the bao CLI. Since each invocation of the bao CLI typically only makes a few requests, this environment variable is most useful when using the GoOpenBao client API.  ","version":"Next","tagName":"h3"},{"title":"VAULT_NAMESPACE​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_namespace","content":" The namespace to use for the command. Setting this is not necessary but allows using relative paths.  ","version":"Next","tagName":"h3"},{"title":"VAULT_SRV_LOOKUP​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_srv_lookup","content":" Enables the client to lookup the host through DNS SRV look up as described in thisdraft. This is not designed for high-availability, just discovery. The draft specifies that the SRV record lookup is ignored if a port is given.  ","version":"Next","tagName":"h3"},{"title":"VAULT_HTTP_PROXY​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_http_proxy","content":" HTTP or HTTPS proxy location which should be used by all requests to access OpenBao. When present, this overrides the default proxy resolution behavior. Format should be http://server:port or https://server:port.  (See VAULT_PROXY_ADDR below).  ","version":"Next","tagName":"h3"},{"title":"VAULT_PROXY_ADDR​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_proxy_addr","content":" HTTP or HTTPS proxy location which should be used by all requests to access OpenBao. When present, this overrides the default proxy resolution behavior. Format should be http://server:port or https://server:port.  warning Note: When using VAULT_HTTP_PROXY or VAULT_PROXY_ADDR any of the standard proxy variables found in the environment will be ignored. Specifically HTTP_PROXY, HTTPS_PROXY and NO_PROXY. All requests will resolve the specified proxy; there is no way to exclude domains from consulting the proxy server.  warning Note: If both VAULT_HTTP_PROXY and VAULT_PROXY_ADDR environment variables are supplied, VAULT_PROXY_ADDR will be prioritized and preferred.  ","version":"Next","tagName":"h3"},{"title":"VAULT_DISABLE_REDIRECTS​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#vault_disable_redirects","content":" Prevents the OpenBao client from following redirects. By default, the OpenBao client will automatically follow a single redirect.  warning Note: Disabling redirect following behavior could cause issues with commands such as 'bao operator raft snapshot' as this command redirects the request to the cluster's primary node.  ","version":"Next","tagName":"h3"},{"title":"Flags​","type":1,"pageTitle":"OpenBao commands (CLI)","url":"/openbao/docs/commands/#flags","content":" There are different CLI flags that are available depending on subcommands. Some flags, such as those used for setting HTTP and output options, are available globally, while others are specific to a particular subcommand. For a complete list of available flags, run:  $ bao &lt;subcommand&gt; -h  ","version":"Next","tagName":"h2"},{"title":"auth help","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/help/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"auth help","url":"/openbao/docs/commands/auth/help/#examples","content":" Get usage instructions for the userpass auth method:  $ bao auth help userpass Usage: bao login -method=userpass [CONFIG K=V...] The userpass auth method allows users to authenticate using OpenBao's internal user database. # ...   Print usage for the auth method enabled at my-method/  $ bao auth help my-method/ # ...   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"auth help","url":"/openbao/docs/commands/auth/help/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"auth enable","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/enable/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"auth enable","url":"/openbao/docs/commands/auth/enable/#examples","content":" Enable the auth method &quot;userpass&quot; enabled at &quot;userpass/&quot;:  $ bao auth enable userpass Success! Enabled the userpass auth method at: userpass/   Create a user:  $ bao write auth/userpass/users/sethvargo password=secret Success! Data written to: auth/userpass/users/sethvargo   For more information on the specific configuration options and paths, please see the auth method documentation.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"auth enable","url":"/openbao/docs/commands/auth/enable/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -audit-non-hmac-request-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the request data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. An example of this is provided in the tune section. -audit-non-hmac-response-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the response data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -default-lease-ttl (duration: &quot;&quot;) - The default lease TTL for this auth method. If unspecified, this defaults to the OpenBao server's globally configured default lease TTL, or a previously configured value for the auth method. Uses duration format strings. -passthrough-request-headers (string: &quot;&quot;) - request header values that will be sent to the auth method. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -allowed-response-headers (string: &quot;&quot;) - response header values that the auth method will be allowed to set. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -description (string: &quot;&quot;) - Human-friendly description for the purpose of this auth method. -listing-visibility (string: &quot;&quot;) - The flag to toggle whether to show the mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or &quot;hidden&quot;, with the default &quot;&quot; being equivalent to &quot;hidden&quot;. -local (bool: false) - Mark the auth method as local-only. Local auth methods are not replicated nor removed by replication. -max-lease-ttl (string: &quot;&quot;) - The maximum lease duration, specified as a string duration like &quot;5s&quot; or &quot;30m&quot;. -path (string: &quot;&quot;) - Place where the auth method will be accessible. This must be unique across all auth methods. This defaults to the &quot;type&quot; of the auth method. The auth method will be accessible at /auth/&lt;path&gt;. -seal-wrap (bool: false) - Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability. -token-type (string: &quot;&quot;) - Specifies the type of tokens that should be returned by the auth method. -plugin-version (string: &quot;&quot;) - Configures the semantic version of the plugin to use. If unspecified, implies the built-in or any matching unversioned plugin that may have been registered. ","version":"Next","tagName":"h2"},{"title":"auth list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/list/","content":"","keywords":"","version":"Next"},{"title":"Deprecation status column​","type":1,"pageTitle":"auth list","url":"/openbao/docs/commands/auth/list/#deprecation-status-column","content":" As of 1.12, all built-in auth engines will have an associated Deprecation Status. This status will be reflected in the Deprecation Status column, seen below. All auth engines which are not provided by built-in plugins will show aDeprecation Status of &quot;n/a&quot;.  ","version":"Next","tagName":"h2"},{"title":"Version columns​","type":1,"pageTitle":"auth list","url":"/openbao/docs/commands/auth/list/#version-columns","content":" The -detailed view displays some version information for each mount.  The Version field indicates the configured version for the plugin. Empty, or &quot;n/a&quot;, indicates the built-in or any matching unversioned plugin that may have been registered.  Running Version indicates the actual plugin version running, which may differ from Version if the plugin hasn't been reloaded since the configured version was updated using the secrets tune command. Finally, the Running SHA256 field indicates the SHA256 sum of the running plugin's binary. This may be different from the SHA256 registered in the catalog if the plugin hasn't been reloaded since the plugin version was overwritten in the catalog.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"auth list","url":"/openbao/docs/commands/auth/list/#examples","content":" List all auth methods:  $ bao auth list Path Type Description ---- ---- ----------- token/ token token based credentials userpass/ userpass n/a   List detailed auth method information:  $ bao auth list -detailed Path Plugin Accessor Default TTL Max TTL Token Type Replication Seal Wrap External Entropy Access Options Description UUID Deprecation Status ---- ------ -------- ----------- ------- ---------- ----------- --------- ----------------------- ------- ----------- ---- ------------------ app-id/ app-id auth_app-id_c88ad56f system system default-service replicated false false map[] n/a a7c702b4-0dba-02b6-483c-2fd6be33240a pending removal approle/ approle auth_approle_95df932e system system default-service replicated false false map[] n/a 931df9d1-8737-b7dc-4ca2-3e0e892fce92 supported token/ token auth_token_aafab997 system system default-service replicated false false map[] token based credentials 6eb5db7b-ac7f-4304-1f52-9b802c6f06c1 n/a   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"auth list","url":"/openbao/docs/commands/auth/list/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"auth list","url":"/openbao/docs/commands/auth/list/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"auth list","url":"/openbao/docs/commands/auth/list/#command-options","content":" -detailed (bool: false) - Print detailed information such as configuration and replication status about each auth method. ","version":"Next","tagName":"h3"},{"title":"auth move","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/move/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"auth move","url":"/openbao/docs/commands/auth/move/#examples","content":" Move the existing auth method at ns1/approle/ to ns2/new-approle/:  $ bao auth move ns1/auth/approle/ ns2/auth/new-approle/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"auth move","url":"/openbao/docs/commands/auth/move/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"delete","type":0,"sectionRef":"#","url":"/openbao/docs/commands/delete/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"delete","url":"/openbao/docs/commands/delete/#examples","content":" Remove data in the static secrets engine:  $ bao delete secret/my-secret   Uninstall an encryption key in the transit backend:  $ bao delete transit/keys/my-key   Note: changing the deletion_allowed parameter to true is necessary for the key to be successfully deleted, you can read more on key parameters here  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"delete","url":"/openbao/docs/commands/delete/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"auth tune","type":0,"sectionRef":"#","url":"/openbao/docs/commands/auth/tune/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"auth tune","url":"/openbao/docs/commands/auth/tune/#examples","content":" Before tuning the auth method configuration, view the current configuration of the auth method enabled at github/.  $ bao read sys/auth/github/tune Key Value --- ----- default_lease_ttl 768h description n/a force_no_cache false max_lease_ttl 768h token_type default-service   The default lease for the auth method enabled at github/ is currently set to 768 hours. Tune this value to 72 hours.  $ bao auth tune -default-lease-ttl=72h github/ Success! Tuned the auth method at: github/   Verify the updated configuration.  $ bao read sys/auth/github/tune Key Value --- ----- default_lease_ttl 72h description n/a force_no_cache false max_lease_ttl 768h token_type default-service   To restore back to the system default, you can use -1.  $ bao auth tune -default-lease-ttl=-1 github/ Success! Tuned the auth method at: github/   Verify the updated configuration.  $ bao read sys/auth/github/tune Key Value --- ----- default_lease_ttl 768h description n/a force_no_cache false max_lease_ttl 768h token_type default-service   You can specify multiple audit non-hmac request keys.  $ bao auth tune -audit-non-hmac-request-keys=value1 -audit-non-hmac-request-keys=value2 github/ Success! Tuned the auth method at: github/   ","version":"Next","tagName":"h2"},{"title":"Enable user lockout​","type":1,"pageTitle":"auth tune","url":"/openbao/docs/commands/auth/tune/#enable-user-lockout","content":" User lockout feature is only supported foruserpass, ldap, andapprole auth methods.  Tune the userpass/ auth method to lock out the user after 10 failed login attempts within 10 minutes.  $ bao auth tune -user-lockout-threshold=10 -user-lockout-duration=10m userpass/ Success! Tuned the auth method at: userpass/   View the current configuration of the auth method enabled at userpass/.  $ bao read sys/auth/userpass/tune Key Value --- ----- default_lease_ttl 768h description n/a force_no_cache false max_lease_ttl 768h token_type default-service user_lockout_counter_reset_duration 0s user_lockout_disable false user_lockout_duration 10m user_lockout_threshold 10   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"auth tune","url":"/openbao/docs/commands/auth/tune/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -allowed-response-headers (string: &quot;&quot;) - response header values that the auth method will be allowed to set. -audit-non-hmac-request-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the request data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -audit-non-hmac-response-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the response data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -default-lease-ttl (duration: &quot;&quot;) - The default lease TTL for this auth method. If unspecified, this defaults to the OpenBao server's globally configured default lease TTL, or a previously configured value for the auth method. -description (string: &quot;&quot;) - Specifies the description of the auth method. This overrides the current stored value, if any. -listing-visibility (string: &quot;&quot;) - The flag to toggle whether to show the mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or &quot;hidden&quot;. Passing empty string leaves the current setting unchanged. -max-lease-ttl (duration: &quot;&quot;) - The maximum lease TTL for this auth method. If unspecified, this defaults to the OpenBao server's globally configured maximum lease TTL, or a previously configured value for the auth method. This value is allowed to override the server's global max TTL; it can be longer or shorter. -passthrough-request-headers (string: &quot;&quot;) - request header values that will be sent to the auth method. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -token-type (string: &quot;&quot;) - Specifies the type of tokens that should be returned by the auth method. -plugin-version (string: &quot;&quot;) - Configures the semantic version of the plugin to use. The new version will not start running until the mount isreloaded. -user-lockout-threshold (string: &quot;&quot;) - Specifies the number of failed login attempts after which the user is locked out. -user-lockout-duration (duration: &quot;&quot;) - Specifies the duration for which a user will be locked out. -user-lockout-counter-reset-duration (duration: &quot;&quot;) - Specifies the duration after which the lockout counter is reset with no failed login attempts. -user-lockout-disable (bool: false) - Disables the user lockout feature if set to true. ","version":"Next","tagName":"h2"},{"title":"debug","type":0,"sectionRef":"#","url":"/openbao/docs/commands/debug/","content":"","keywords":"","version":"Next"},{"title":"Permissions​","type":1,"pageTitle":"debug","url":"/openbao/docs/commands/debug/#permissions","content":" Regardless of whether a particular target is provided, the ability for debugto fetch data for the target depends on the token provided. Some targets, such as server-status, queries unauthenticated endpoints which means that it can be queried all the time. Other targets require the token to have ACL permissions to query the matching endpoint in order to get a proper response. Any errors encountered during capture due to permissions or otherwise will be logged in the index file.  The following policy can be used for generating debug packages with all targets:  path &quot;auth/token/lookup-self&quot; { capabilities = [&quot;read&quot;] } path &quot;sys/pprof/*&quot; { capabilities = [&quot;read&quot;] } path &quot;sys/config/state/sanitized&quot; { capabilities = [&quot;read&quot;] } path &quot;sys/monitor&quot; { capabilities = [&quot;read&quot;] } path &quot;sys/host-info&quot; { capabilities = [&quot;read&quot;] } path &quot;sys/in-flight-req&quot; { capabilities = [&quot;read&quot;] }   ","version":"Next","tagName":"h2"},{"title":"Capture targets​","type":1,"pageTitle":"debug","url":"/openbao/docs/commands/debug/#capture-targets","content":" The -target flag can be specified multiple times to capture specific information when debug is running. By default, it captures all information.  Target\tDescriptionconfig\tSanitized version of the configuration state. host\tInformation about the instance running the server, such as CPU, memory, and disk. metrics\tTelemetry information. pprof\tRuntime profiling data, including heap, CPU, goroutine, and trace profiling. replication-status\tReplication status. server-status\tHealth and seal status.  Note that the config, host,metrics, and pprof targets are only queried on active nodes due to the the fact that the information pertains to the local node and the request should not be forwarded.  Additionally, host information is not available on the OpenBSD platform due to library limitations in fetching the data without enabling cgo.  ","version":"Next","tagName":"h2"},{"title":"Output layout​","type":1,"pageTitle":"debug","url":"/openbao/docs/commands/debug/#output-layout","content":" The output of the bundled information, once decompressed, is contained within a single directory. Each target, with the exception of profiling data, is captured in a single file. For each of those targets collection is represented as a JSON array object, with each entry captured at each interval as a JSON object.  $ tree openbao-debug-2019-10-15T21-44-49Z/ openbao-debug-2019-10-15T21-44-49Z/ ├── 2019-10-15T21-44-49Z │ ├── goroutine.prof │ ├── heap.prof │ ├── profile.prof │ └── trace.out ├── 2019-10-15T21-45-19Z │ ├── goroutine.prof │ ├── heap.prof │ ├── profile.prof │ └── trace.out ├── 2019-10-15T21-45-49Z │ ├── goroutine.prof │ ├── heap.prof │ ├── profile.prof │ └── trace.out ├── 2019-10-15T21-46-19Z │ ├── goroutine.prof │ ├── heap.prof │ ├── profile.prof │ └── trace.out ├── 2019-10-15T21-46-49Z │ ├── goroutine.prof │ └── heap.prof ├── config.json ├── host_info.json ├── index.json ├── metrics.json ├── replication_status.json └── server_status.json   ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"debug","url":"/openbao/docs/commands/debug/#examples","content":" Start debug using reasonable defaults:  $ bao debug   Start debug with different duration, intervals, and metrics interval values, and skip compression:  $ bao debug -duration=1m -interval=10s -metrics-interval=5s -compress=false   Start debug with specific targets:  $ bao debug -target=host -target=metrics   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"debug","url":"/openbao/docs/commands/debug/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Command options​","type":1,"pageTitle":"debug","url":"/openbao/docs/commands/debug/#command-options","content":" -compress (bool: true) - Toggles whether to compress output package The default is true. -duration (int or time string: &quot;2m&quot;) - Duration to run the command. The default is 2m0s. -interval (int or time string: &quot;30s&quot;) - The polling interval at which to collect profiling data and server state. The default is 30s. -log-format (string: &quot;standard&quot;) - Log format to be captured if &quot;log&quot; target specified. Supported values are &quot;standard&quot; and &quot;json&quot;. The default is &quot;standard&quot;. -metrics-interval (int or time string: &quot;10s&quot;) - The polling interval at which to collect metrics data. The default is 10s. -output (string) - Specifies the output path for the debug package. Defaults to an time-based generated file name. -target (string: all targets) - Target to capture, defaulting to all if none specified. This can be specified multiple times to capture multiple targets. Available targets are: config, host, metrics, pprof, replication-status, server-status. ","version":"Next","tagName":"h3"},{"title":"kv","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/","content":"","keywords":"","version":"Next"},{"title":"Syntax​","type":1,"pageTitle":"kv","url":"/openbao/docs/commands/kv/#syntax","content":" Option flags for a given subcommand are provided after the subcommand, but before the arguments.  The path to where the secrets engine is mounted can be indicated with the -mount flag, such as bao kv get -mount=secret creds.  The deprecated path-like syntax can also be used (e.g. bao kv get secret/creds), but this should be avoided for KV v2, because it is not actually the full API path to the secret (secret/data/foo) and may cause confusion.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"kv","url":"/openbao/docs/commands/kv/#examples","content":" Create or update the key named &quot;creds&quot; in the K/V Version 2 enabled at &quot;secret&quot; with the value &quot;passcode=my-long-passcode&quot;:  $ bao kv put -mount=secret creds passcode=my-long-passcode == Secret Path == secret/data/creds ======= Metadata ======= Key Value --- ----- created_time 2022-06-15T20:14:17.107852Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1   Read this value back:  $ bao kv get -mount=secret creds == Secret Path == secret/data/creds ======= Metadata ======= Key Value --- ----- created_time 2022-06-15T20:14:17.107852Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 ====== Data ====== Key Value --- ----- passcode my-long-passcode   Get metadata for the key named &quot;creds&quot;:  $ bao kv metadata get -mount=secret creds === Metadata Path === secret/metadata/creds ========== Metadata ========== Key Value --- ----- cas_required false created_time 2022-06-15T20:14:17.107852Z current_version 1 custom_metadata &lt;nil&gt; delete_version_after 0s max_versions 0 oldest_version 0 updated_time 2022-06-15T20:14:17.107852Z ====== Version 1 ====== Key Value --- ----- created_time 2022-06-15T20:14:17.107852Z deletion_time n/a destroyed false   Get a specific version of the key named &quot;creds&quot;:  $ bao kv get -mount=secret -version=1 creds == Secret Path == secret/data/creds ======= Metadata ======= Key Value --- ----- created_time 2022-06-15T20:14:17.107852Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 ====== Data ====== Key Value --- ----- passcode my-long-passcode   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv","url":"/openbao/docs/commands/kv/#usage","content":" Usage: bao kv &lt;subcommand&gt; [options] [args] # ... Subcommands: delete Deletes versions in the KV store destroy Permanently removes one or more versions in the KV store enable-versioning Turns on versioning for a KV store get Retrieves data from the KV store list List data or secrets metadata Interact with OpenBao's Key-Value storage patch Sets or updates data in the KV store without overwriting put Sets or updates data in the KV store rollback Rolls back to a previous version of data undelete Undeletes versions in the KV store   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"kv delete","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/delete/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv delete","url":"/openbao/docs/commands/kv/delete/#examples","content":" Delete the latest version of the key &quot;creds&quot;:  $ bao kv delete -mount=secret creds Success! Data deleted (if it existed) at: secret/creds   [K/V Version 2] Delete version 11 of key &quot;creds&quot;:  $ bao kv delete -mount=secret -versions=11 creds Success! Data deleted (if it existed) at: secret/data/creds   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv delete","url":"/openbao/docs/commands/kv/delete/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Command options​","type":1,"pageTitle":"kv delete","url":"/openbao/docs/commands/kv/delete/#command-options","content":" -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. -versions ([]int: &lt;required&gt;) - The versions to be deleted. The versioned data will not be deleted, but it will no longer be returned in normal get requests.  NOTE: The -versions command option is only for K/V v2. ","version":"Next","tagName":"h3"},{"title":"kv destroy","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/destroy/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv destroy","url":"/openbao/docs/commands/kv/destroy/#examples","content":" Destroy version 11 of the key &quot;creds&quot;:  $ bao kv destroy -mount=secret -versions=11 creds Success! Data written to: secret/destroy/creds   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv destroy","url":"/openbao/docs/commands/kv/destroy/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv destroy","url":"/openbao/docs/commands/kv/destroy/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"kv destroy","url":"/openbao/docs/commands/kv/destroy/#command-options","content":" -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. -versions ([]int: &lt;required&gt;) - The versions to destroy. Their data will be permanently deleted. ","version":"Next","tagName":"h3"},{"title":"kv enable-versioning","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/enable-versioning/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv enable-versioning","url":"/openbao/docs/commands/kv/enable-versioning/#examples","content":" This command turns on versioning for the K/V Version 1 secrets engine enabled at &quot;secret&quot;.  $ bao kv enable-versioning secret Success! Tuned the secrets engine at: secret/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv enable-versioning","url":"/openbao/docs/commands/kv/enable-versioning/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv enable-versioning","url":"/openbao/docs/commands/kv/enable-versioning/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"kv get","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/get/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv get","url":"/openbao/docs/commands/kv/get/#examples","content":" Retrieve the data of the key &quot;creds&quot;:  $ bao kv get -mount=secret creds == Secret Path == secret/data/creds ======= Metadata ======= Key Value --- ----- created_time 2022-06-15T20:23:40.067093Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 ====== Data ====== Key Value --- ----- passcode my-long-passcode   If K/V Version 1 secrets engine is enabled at &quot;secret&quot;, the output has no metadata since there is no versioning information associated with the data:  $ bao kv get -mount=secret creds ====== Data ====== Key Value --- ----- passcode my-long-passcode   Return only the &quot;creds&quot; &quot;passcode&quot; key:  $ bao kv get -mount=secret -field=passcode creds my-long-passcode   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv get","url":"/openbao/docs/commands/kv/get/#usage","content":" ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv get","url":"/openbao/docs/commands/kv/get/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"kv get","url":"/openbao/docs/commands/kv/get/#command-options","content":" -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. -version (int: 0) - Specifies the version to return. If not set the latest version is returned. ","version":"Next","tagName":"h3"},{"title":"kv metadata","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/metadata/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"kv metadata","url":"/openbao/docs/commands/kv/metadata/#usage","content":" Usage: bao kv metadata &lt;subcommand&gt; [options] [args] # ... Subcommands: delete Deletes all versions and metadata for a key in the KV store get Retrieves key metadata from the KV store put Sets or updates key settings in the KV store   ","version":"Next","tagName":"h2"},{"title":"kv metadata delete​","type":1,"pageTitle":"kv metadata","url":"/openbao/docs/commands/kv/metadata/#kv-metadata-delete","content":" The kv metadata delete command deletes all versions and metadata for the provided key.  Examples​  Deletes all versions and metadata of the key &quot;creds&quot;:  $ bao kv metadata delete -mount=secret creds Success! Data deleted (if it existed) at: secret/metadata/creds   ","version":"Next","tagName":"h3"},{"title":"kv metadata get​","type":1,"pageTitle":"kv metadata","url":"/openbao/docs/commands/kv/metadata/#kv-metadata-get","content":" The kv metadata get command retrieves the metadata of the versioned secrets at the given key name. If no key exists with that name, an error is returned.  Examples​  Retrieves the metadata of the key name, &quot;creds&quot;:  $ bao kv metadata get -mount=secret creds === Metadata Path === secret/metadata/creds ========== Metadata ========== Key Value --- ----- cas_required false created_time 2019-06-28T15:53:30.395814Z current_version 5 delete_version_after 0s max_versions 0 oldest_version 0 updated_time 2019-06-28T16:01:47.40064Z ====== Version 1 ====== Key Value --- ----- created_time 2019-06-28T15:53:30.395814Z deletion_time n/a destroyed false ====== Version 2 ====== Key Value --- ----- created_time 2019-06-28T16:01:36.676912Z deletion_time n/a destroyed false ...   ","version":"Next","tagName":"h3"},{"title":"kv metadata put​","type":1,"pageTitle":"kv metadata","url":"/openbao/docs/commands/kv/metadata/#kv-metadata-put","content":" The kv metadata put command can be used to create a blank key in the K/V v2 secrets engine or to update key configuration for a specified key.  Examples​  Create a key in the K/V v2 with no data at the key &quot;creds&quot;:  $ bao kv metadata put -mount=secret creds Success! Data written to: secret/metadata/creds   Set the maximum number of versions to keep for the key &quot;creds&quot;:  $ bao kv metadata put -mount=secret -max-versions=5 creds Success! Data written to: secret/metadata/creds   NOTE: If not set, the backend’s configured max version is used. Once a key has more than the configured allowed versions the oldest version will be permanently deleted.  Require Check-and-Set for the key &quot;creds&quot;:  $ bao kv metadata put -mount=secret -cas-required creds   NOTE: When check-and-set is required, the key will require the casparameter to be set on all write requests. Otherwise, the backend’s configuration will be used.  Set the length of time before a version is deleted for the key &quot;creds&quot;:  $ bao kv metadata put -mount=secret -delete-version-after=&quot;3h25m19s&quot; creds   NOTE: If not set, the backend's configured Delete-Version-After is used. If set to a duration greater than the backend's, the backend's Delete-Version-After setting will be used. Any changes to the Delete-Version-After setting will only be applied to new versions.  Output options​  -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  Subcommand options​  -cas-required (bool: false) - If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used. The default is false. -max-versions (int: 0) - The number of versions to keep per key. If not set, the backend’s configured max version is used. Once a key has more than the configured allowed versions the oldest version will be permanently deleted. -delete-version-after (string:&quot;0s&quot;) – Set the delete-version-after value to a duration to specify the deletion_time for all new versions written to this key. If not set, the backend's delete_version_after will be used. If the value is greater than the backend's delete_version_after, the backend'sdelete_version_after will be used. Accepts duration format strings. -custom-metadata (string: &quot;&quot;) - Specifies a key-value pair for thecustom_metadata field. This can be specified multiple times to add multiple pieces of metadata. -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. ","version":"Next","tagName":"h3"},{"title":"kv patch","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/patch/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv patch","url":"/openbao/docs/commands/kv/patch/#examples","content":" If you wish to add an additional key-value (ttl=48h) to the existing data at the key &quot;creds&quot;:  $ bao kv patch -mount=secret creds ttl=48h == Secret Path == secret/data/creds ======= Metadata ======= Key Value --- ----- created_time 2019-06-06T16:46:22.090654Z deletion_time n/a destroyed false version 6   NOTE: The kv put command requires both the existing data and the data you wish to add in order to accomplish the same result.  $ bao kv put -mount=secret creds ttl=48h passcode=my-long-passcode   The data can also be consumed from a file on disk by prefixing with the &quot;@&quot; symbol. For example:  $ bao kv patch -mount=secret creds @data.json   Or it can be read from stdin using the &quot;-&quot; symbol:  $ echo &quot;abcd1234&quot; | bao kv patch -mount=secret foo bar=-   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv patch","url":"/openbao/docs/commands/kv/patch/#usage","content":" ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv patch","url":"/openbao/docs/commands/kv/patch/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"kv patch","url":"/openbao/docs/commands/kv/patch/#command-options","content":" -method (string: &quot;patch&quot;) - Specifies the patch method to use. Valid methods are patch and rw. The patch method uses an HTTP PATCH request to apply the partial update. The rw method will fetch the secret's data, perform an in-memory update, and write the updated data. -cas (int: 0) - Specifies the value to use for the Check-And-Set operation. This flag will only be used for the patch method. This flag is required ifcas_required is set to true on either the secret or the engine's config. In order for a patch to be successful, -cas must be set to the current version of the secret. This flag will be ignored for the rw method. Instead, its value will be derived from fetching the current version of the secret. -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. ","version":"Next","tagName":"h3"},{"title":"kv put","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/put/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv put","url":"/openbao/docs/commands/kv/put/#examples","content":" Writes the data to the key &quot;creds&quot;:  $ bao kv put -mount=secret creds passcode=my-long-passcode   The data can also be consumed from a file on disk by prefixing with the &quot;@&quot; symbol. For example:  $ bao kv put -mount=secret foo @data.json   Or it can be read from stdin using the &quot;-&quot; symbol:  $ echo &quot;abcd1234&quot; | bao kv put -mount=secret foo bar=-   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv put","url":"/openbao/docs/commands/kv/put/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv put","url":"/openbao/docs/commands/kv/put/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"kv put","url":"/openbao/docs/commands/kv/put/#command-options","content":" -cas (int: 0) - Specifies to use a Check-And-Set operation. If not set the write will be allowed. In order for a write to be successful, cas must be set to the current version of the secret. If set to 0 a write will only be allowed if the key doesn’t exist as unset keys do not have any version information. Also remember that soft deletes do not remove any underlying version data from storage. In order to write to a soft deleted key, the cas parameter must match the key's current version. The default is -1. -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. ","version":"Next","tagName":"h3"},{"title":"kv list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/list/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv list","url":"/openbao/docs/commands/kv/list/#examples","content":" List values under the key &quot;my-app&quot;:  $ bao kv list -mount=secret my-app/ Keys ---- admin_creds domain eng_creds qa_creds release   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv list","url":"/openbao/docs/commands/kv/list/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv list","url":"/openbao/docs/commands/kv/list/#output-options","content":" -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"kv rollback","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/rollback/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv rollback","url":"/openbao/docs/commands/kv/rollback/#examples","content":" Restores the version 2 of the data at key &quot;creds&quot;:  $ bao kv rollback -mount=secret -version=2 creds Key Value --- ----- created_time 2019-06-06T17:07:19.299831Z deletion_time n/a destroyed false version 6   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv rollback","url":"/openbao/docs/commands/kv/rollback/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv rollback","url":"/openbao/docs/commands/kv/rollback/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"kv rollback","url":"/openbao/docs/commands/kv/rollback/#command-options","content":" -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. -version (int: 0) - Specifies the version number that should be made current again. ","version":"Next","tagName":"h3"},{"title":"kv undelete","type":0,"sectionRef":"#","url":"/openbao/docs/commands/kv/undelete/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"kv undelete","url":"/openbao/docs/commands/kv/undelete/#examples","content":" Undelete version 3 of the key &quot;creds&quot;:  $ bao kv undelete -mount=secret -versions=3 creds Success! Data written to: secret/undelete/creds   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"kv undelete","url":"/openbao/docs/commands/kv/undelete/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"kv undelete","url":"/openbao/docs/commands/kv/undelete/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"kv undelete","url":"/openbao/docs/commands/kv/undelete/#command-options","content":" -mount (string: &quot;&quot;) - Specifies the path where the KV backend is mounted. If specified, the next argument will be interpreted as the secret path. If this flag is not specified, the next argument will be interpreted as the combined mount path and secret path, with /data/ automatically inserted for KV v2 secrets. -versions ([]int: &lt;required&gt;) - Specifies the version number that should be made current again. ","version":"Next","tagName":"h3"},{"title":"lease","type":0,"sectionRef":"#","url":"/openbao/docs/commands/lease/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"lease","url":"/openbao/docs/commands/lease/#examples","content":" Lookup a lease:  $ bao lease lookup database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 Key Value --- ----- expire_time 2021-03-17T11:55:50.755313-05:00 id database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 issue_time 2021-03-17T11:45:50.755312-05:00 last_renewal &lt;nil&gt; renewable true ttl 9m52s   Renew a lease:  $ bao lease renew database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 Key Value --- ----- lease_id database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 lease_duration 5m lease_renewable true   Revoke a lease:  $ bao lease revoke database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 Success! Revoked lease: database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"lease","url":"/openbao/docs/commands/lease/#usage","content":" Usage: bao lease &lt;subcommand&gt; [options] [args] # ... Subcommands: lookup Lookup lease information by lease id renew Renews the lease of a secret revoke Revokes leases and secrets   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/list/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"list","url":"/openbao/docs/commands/list/#examples","content":" List available entities by their identifiers:  $ bao list identity/entity/id   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"list","url":"/openbao/docs/commands/list/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"lease revoke","type":0,"sectionRef":"#","url":"/openbao/docs/commands/lease/revoke/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"lease revoke","url":"/openbao/docs/commands/lease/revoke/#examples","content":" Revoke a lease:  $ bao lease revoke database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 Success! Revoked lease: database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83   Revoke a lease which starts with a prefix:  $ bao lease revoke -prefix database/creds Success! Revoked any leases with prefix: database/creds   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"lease revoke","url":"/openbao/docs/commands/lease/revoke/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -force (bool: false) - Delete the lease from OpenBao even if the secret engine revocation fails. This is meant for recovery situations where the secret in the target secrets engine was manually removed. If this flag is specified, -prefix is also required. This is aliased as &quot;-f&quot;. The default is false. -prefix (bool: false) - Treat the ID as a prefix instead of an exact lease ID. This can revoke multiple leases simultaneously. The default is false. -sync (bool: false) - Make the operation synchronous instead of queuing the revocations to be done in the background. ","version":"Next","tagName":"h2"},{"title":"lease renew","type":0,"sectionRef":"#","url":"/openbao/docs/commands/lease/renew/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"lease renew","url":"/openbao/docs/commands/lease/renew/#examples","content":" Renew a lease:  $ bao lease renew database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 Key Value --- ----- lease_id database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 lease_duration 5m lease_renewable true   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"lease renew","url":"/openbao/docs/commands/lease/renew/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -increment (duration: &quot;&quot;) - Request a specific increment in seconds. OpenBao is not required to honor this request. ","version":"Next","tagName":"h2"},{"title":"login","type":0,"sectionRef":"#","url":"/openbao/docs/commands/login/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"login","url":"/openbao/docs/commands/login/#examples","content":" By default, login uses a &quot;token&quot; method and reads from stdin:  $ bao login Token (will be hidden): Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run &quot;bao login&quot; again. Future OpenBao requests will automatically use this token. Key Value --- ----- token s.nDj4BB2tK8NaFffwBZBxyIa1 token_accessor ZuaObqdTeCHZ4oa9HWmdQJuZ token_duration ∞ token_renewable false token_policies [&quot;root&quot;] identity_policies [] policies [&quot;root&quot;]   Alternatively, the token may be provided as a command line argument (note that this may be captured by shell history or process listings):  $ bao login s.3jnbMAKl1i4YS3QoKdbHzGXq Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run &quot;bao login&quot; again. Future OpenBao requests will automatically use this token. Key Value --- ----- token s.3jnbMAKl1i4YS3QoKdbHzGXq token_accessor 7Uod1Rm0ejUAz77Oh7SxpAM0 token_duration 767h59m49s token_renewable true token_policies [&quot;admin&quot; &quot;default&quot;] identity_policies [] policies [&quot;admin&quot; &quot;default&quot;]   To login with a different method, use -method:  $ bao login -method=userpass username=my-username Password (will be hidden): Success! You are now authenticated. The token information below is already stored in the token helper. You do NOT need to run &quot;bao login&quot; again. Future requests will use this token automatically. Key Value --- ----- token s.2y4SU3Sk46dK3p2Y8q2jSBwL token_accessor 8J125x9SZyB76MI9uF2jSJZf token_duration 768h token_renewable true token_policies [&quot;default&quot;] identity_policies [] policies [&quot;default&quot;] token_meta_username my-username   warning Notice that the command option (-method=userpass) precedes the command argument (username=my-username).  If a github auth method was enabled at the path &quot;github-prod&quot;:  $ bao login -method=github -path=github-prod Success! You are now authenticated. The token information below is already stored in the token helper. You do NOT need to run &quot;bao login&quot; again. Future requests will use this token automatically. Key Value --- ----- token s.2f3c5L1MHtnqbuNCbx90utmC token_accessor JLUIXJ6ltUftTt2UYRl2lTAC token_duration 768h token_renewable true token_policies [&quot;default&quot;] identity_policies [] policies [&quot;default&quot;] token_meta_org hashicorp token_meta_username my-username   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"login","url":"/openbao/docs/commands/login/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"login","url":"/openbao/docs/commands/login/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"login","url":"/openbao/docs/commands/login/#command-options","content":" -method (string &quot;token&quot;) - Type of authentication to use such as &quot;userpass&quot; or &quot;ldap&quot;. Note this corresponds to the TYPE, not the enabled path. Use -path to specify the path where the authentication is enabled. -no-print (bool: false) - Do not display the token. The token will still be stored to the configured token helper. The default is false. -no-store (bool: false) - Do not persist the token to the token helper (usually the local filesystem) after authentication for use in future requests. The token will only be displayed in the command output. -path (string: &quot;&quot;) - Remote path in OpenBao where the auth method is enabled. This defaults to the TYPE of method (e.g. userpass -&gt; userpass/). -token-only (bool: false) - Output only the token with no verification. This flag is a shortcut for &quot;-field=token -no-store&quot;. Setting those flags to other values will have no affect. ","version":"Next","tagName":"h3"},{"title":"lease lookup","type":0,"sectionRef":"#","url":"/openbao/docs/commands/lease/lookup/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"lease lookup","url":"/openbao/docs/commands/lease/lookup/#examples","content":" Lookup a lease:  $ bao lease lookup database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 Key Value --- ----- expire_time 2021-03-17T11:55:50.755313-05:00 id database/creds/readonly/27e1b9a1-27b8-83d9-9fe0-d99d786bdc83 issue_time 2021-03-17T11:45:50.755312-05:00 last_renewal &lt;nil&gt; renewable true ttl 9m52s   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"lease lookup","url":"/openbao/docs/commands/lease/lookup/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"monitor","type":0,"sectionRef":"#","url":"/openbao/docs/commands/monitor/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"monitor","url":"/openbao/docs/commands/monitor/#examples","content":" Monitor server logs at the debug log level:  $ bao monitor -log-level=debug   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"monitor","url":"/openbao/docs/commands/monitor/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"monitor","url":"/openbao/docs/commands/monitor/#output-options","content":" -log-level (string: &quot;info&quot;) - Monitor the OpenBao server at this log level. Valid log levels are (in order of detail) &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;. If this option is not specified, &quot;info&quot; is used. -log-format (string: &quot;standard&quot;) - Format to emit logs. Valid formats are &quot;standard&quot;, and &quot;json&quot;. If this option is not specified, &quot;standard&quot; is used. ","version":"Next","tagName":"h3"},{"title":"operator","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator","url":"/openbao/docs/commands/operator/#examples","content":" Initialize a new OpenBao cluster:  $ bao operator init Unseal Key 1: sP/4C/fwIDjJmHEC2bi/1Pa43uKhsUQMmiB31GRzFc0R Unseal Key 2: kHkw2xTBelbDFIMEgEC8NVX7NDSAZ+rdgBJ/HuJwxOX+ Unseal Key 3: +1+1ZnkQDfJFHDZPRq0wjFxEuEEHxDDOQxa8JJ/AYWcb Unseal Key 4: cewseNJTLovmFrgpyY+9Hi5OgJlJgGGCg7PZyiVdPwN0 Unseal Key 5: wyd7rMGWX5fi0k36X4e+C4myt5CoTmJsHJ0rdYT7BQcF Initial Root Token: 6662bb4a-afd0-4b6b-faad-e237fb564568 # ...   Force an OpenBao to resign leadership in a cluster:  $ bao operator step-down Success! Stepped down: https://127.0.0.1:8200   Rotate OpenBao's underlying encryption key:  $ bao operator rotate Success! Rotated key Key Term 2 Install Time 01 Jan 07 12:30 UTC   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator","url":"/openbao/docs/commands/operator/#usage","content":" Usage: bao operator &lt;subcommand&gt; [options] [args] # ... Subcommands: generate-root Generates a new root token init Initializes a server key-status Provides information about the active encryption key rekey Generates new unseal keys rotate Rotates the underlying encryption key seal Seals the OpenBao server step-down Forces OpenBao to resign active duty unseal Unseals the OpenBao server   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"operator generate-root","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/generate-root/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator generate-root","url":"/openbao/docs/commands/operator/generate-root/#examples","content":" Generate an OTP code for the final token:  $ bao operator generate-root -generate-otp   Start a root token generation:  $ bao operator generate-root -init -otp=&quot;...&quot;   Enter an unseal key to progress root token generation:  $ bao operator generate-root -otp=&quot;...&quot;   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator generate-root","url":"/openbao/docs/commands/operator/generate-root/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator generate-root","url":"/openbao/docs/commands/operator/generate-root/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"operator generate-root","url":"/openbao/docs/commands/operator/generate-root/#command-options","content":" -cancel (bool: false) - Reset the root token generation progress. This will discard any submitted unseal keys or configuration. -decode (string: &quot;&quot;) - Decode and output the generated root token. This option requires the -otp flag be set to the OTP used during initialization. If value is &quot;-&quot; then read the encoded token from stdin. -generate-otp (bool: false) - Generate and print a high-entropy one-time-password (OTP) suitable for use with the &quot;-init&quot; flag. -init (bool: false) - Start a root token generation. This can only be done if there is not currently one in progress. -nonce (string; &quot;&quot;)- Nonce value provided at initialization. The same nonce value must be provided with each unseal key. -otp (string: &quot;&quot;) - OTP code to use with -decode or -init. -pgp-key (keybase or pgp)- Path to a file on disk containing a binary or base64-encoded public PGP key. This can also be specified as a Keybase username using the format keybase:&lt;username&gt;. When supplied, the generated root token will be encrypted and base64-encoded with the given public key. -status (bool: false) - Print the status of the current attempt without providing an unseal key. The default is false. -dr-token (bool: false) - Generate DR operational token -recovery-token (bool: false) - Generate recovery operational token ","version":"Next","tagName":"h3"},{"title":"operator key-status","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/key-status/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator key-status","url":"/openbao/docs/commands/operator/key-status/#examples","content":" Get the key status:  $ bao operator key-status Key Term 2 Install Time 01 Jan 17 12:30 UTC Encryption Count 4494   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator key-status","url":"/openbao/docs/commands/operator/key-status/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator key-status","url":"/openbao/docs/commands/operator/key-status/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"operator diagnose","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/diagnose/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"operator diagnose","url":"/openbao/docs/commands/operator/diagnose/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator diagnose","url":"/openbao/docs/commands/operator/diagnose/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  Output layout​  The operator diagnose command will output a set of lines in the CLI. Each line will begin with a prefix in parenthesis. These are:.  [ success ] - Denotes that the check was successful.[ warning ] - Denotes that the check has passed, but that there may be potential issues to look into that may relate to the issues OpenBao is experiencing. Diagnose warns frequently. These warnings are meant to serve as starting points in the debugging process.[ failure ] - Denotes that the check has failed. Failures are critical issues in the eyes of the diagnose command.  In addition to these prefixed lines, there may be output lines that are not prefixed, but are color-coded purple. These are advice lines from Diagnose, and are meant to offer general guidance on how to go about fixing potential warnings or failures that may arise.  Warn or fail prefixes in nested checks will bubble up to the parent if the prefix superceeds the parent prefix. Fail superceeds warn, and warn superceeds ok. For example, if the TLS checks under the Storage check fails, the [ failure ] prefix will bubble up to the Storage check.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"operator diagnose","url":"/openbao/docs/commands/operator/diagnose/#command-options","content":" -config (string; &quot;&quot;) - The path to the OpenBao configuration file used by the OpenBao server on startup.  ","version":"Next","tagName":"h3"},{"title":"Diagnose checks​","type":1,"pageTitle":"operator diagnose","url":"/openbao/docs/commands/operator/diagnose/#diagnose-checks","content":" The following section details the various checks that Diagnose runs. Check names in documentation will be separated by slashes to denote that they are nested, when applicable. For example, a check documented as A / B will show up as B in the operator diagnose output, and will be nested (indented) under A.  OpenBao diagnose​  OpenBao Diagnose is the top level check that contains the rest of the checks. It will report the status of the check  Check operating system / check open file limit​  Check Open File Limit verifies that the open file limit value is set high enough for OpenBao to run effectively. We recommend setting these limits to at least 1024768.  This check will be skipped on openbsd, arm, and windows.  Check operating system / check disk usage​  Check Disk Usage will report disk usage for each partition. For each partition on a prod host, we recommend having at least 5% of the partition free to use, and at least 1 GB of space.  This check will be skipped on openbsd and arm.  Parse configuration​  Parse Configuration will check the OpenBao server config file for syntax errors. It will check for extra values in the configuration file, repeated stanzas, and stanzas that do not belong in the configuration file (for example a &quot;tcpp&quot; listener as opposed to a tcp listener).  Currently, the storage stanza is not checked.  Check storage / create storage backend​  Create Storage Backend ensures that the storage stanza configured in the OpenBao server config has enough information to create a storage object internally. Common errors will have to do with misconfigured fields in the storage stanza.  Check storage / check raft folder permissions​  Check Raft Folder Permissions computes the permissions on the raft folder, checks that a boltDB file has been initialized within the folder previously, and ensures that the folder is not too permissive, but at the same time has enough permissions to be used. The raft folder should not have other permissions, but should have group rw or owner rw, depending on different setups. This check also warns if it detects a symlink being used.  Note that this check will warn that a raft file has not been created if diagnose is run without any pre-existing server runs.  This check will be skipped on windows.  Check storage / check raft folder ownership​  Check Raft Folder Ownership ensures that OpenBao does not need to run as root to access the boltDB folder.  Note that this check will warn that a raft file has not been created if diagnose is run without any pre-existing server runs.  This check will be skipped on windows.  Check storage / check for raft quorum​  Check For Raft Quorum uses the FSM to ensure that there were an odd number of voters in the raft quorum when OpenBao was last running.  Note that this check will warn that there are 0 voters if diagnose is run without any pre-existing server runs.  Check storage / check storage access​  Check Storage Access will try to write a dud value, named diagnose/latency/&lt;uuid&gt;, to storage. Ensure that there is no important data at this location before running diagnose, as this check will overwrite that data. This check will then try to list and read the value it wrote to ensure the name and value is as expected.  Check Storage Access will warn if any operation takes longer than 100ms, and error out if the entire check takes longer than 30s.  Check service discovery / check consul service discovery TLS​  Check Consul Service Discovery TLS verifies TLS information included in the service discovery stanza if the storage type is consul. If a certificate chain is provided, Diagnose parses the root, intermediate, and leaf certificates, and checks each one for correctness.  Check service discovery / check consul direct service discovery​  Check Consul Direct Service Discovery is a consul-specific check that ensures OpenBao is not accessing the consul server directly, but rather through a local agent.  Create OpenBao server configuration seals​  Create OpenBao Server Configuration Seals creates seals from the OpenBao configuration stanza and verifies they can be initialized and finalized.  Check transit seal TLS​  Check Transit Seal TLS checks the TLS client certificate, key, and CA certificate provided in a transit seal stanza (if one exists) for correctness.  Create core configuration / initialize randomness for core​  Initialize Randomness for Core ensures that OpenBao has access to the randReader that the OpenBao core uses.  HA storage​  This check and any nested checks will be the same as the Check Storage checks. The only difference is that the checks here will be run on whatever is specified in theha_storage section of the OpenBao configuration, as opposed to the storage section.  Determine redirect address​  Ensures that one of the VAULT_API_ADDR, VAULT_REDIRECT_ADDR, or VAULT_ADVERTISE_ADDRenvironment variables are set, or that the redirect address is specified in the OpenBao configuration.  Check cluster address​  Parses the cluster address from the VAULT_CLUSTER_ADDR environment variable, or from the redirect address or cluster address specified in the OpenBao configuration, and checks that the address is of the form host:port.  Check core creation​  Check Core Creation verifies the logical configuration checks that OpenBao does when it creates a core object. These are runtime checks, meaning any errors thrown by this diagnose test will also be thrown by the OpenBao server itself when it is run.  Start listeners / check listener TLS​  Check Listener TLS verifies the server certificate file and key are valid and matching. It also checks the client CA file, if one is provided, for a valid certificate, and performs the standard runtime listener checks on the listener configuration stanza, such as verifying that the minimum and maximum TLS versions are within the bounds of what OpenBao supports.  Like all the other Diagnose TLS checks, it will warn if any of the certificates provided are set to expire within the next month.  Start listeners / create listeners​  Create Listeners uses the listener configuration to initialize the listeners, erroring with a server error if anything goes wrong.  Check autounseal encryption​  Check Autounseal Encryption will initialize the barrier using the seal stanza, if the seal type is not a shamir seal, and use it to encrypt and decrypt a dud value.  Check server before runtime​  Check Server Before Runtime achieves parity with the server run command, running through the runtime code checks before the server is initialized to ensure that nothing fails. This check will never fail without another diagnose check failing. ","version":"Next","tagName":"h3"},{"title":"operator init","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/init/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator init","url":"/openbao/docs/commands/operator/init/#examples","content":" Start initialization with the default options:  $ bao operator init   Initialize, but encrypt the unseal keys with pgp keys:  $ bao operator init \\ -key-shares=3 \\ -key-threshold=2 \\ -pgp-keys=&quot;keybase:hashicorp,keybase:jefferai,keybase:sethvargo&quot;   Initialize Auto Unseal with a non-default threshold and number of recovery keys, and encrypt the recovery keys with pgp keys:  $ bao operator init \\ -recovery-shares=7 \\ -recovery-threshold=4 \\ -recovery-pgp-keys=&quot;keybase:jeff,keybase:chris,keybase:brian,keybase:calvin,keybase:matthew,keybase:vishal,keybase:nick&quot;   Encrypt the initial root token using a pgp key:  $ bao operator init -root-token-pgp-key=&quot;keybase:hashicorp&quot;   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator init","url":"/openbao/docs/commands/operator/init/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator init","url":"/openbao/docs/commands/operator/init/#output-options","content":" -format (string: &quot;&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. The default is table. This can also be specified via the VAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Common options​","type":1,"pageTitle":"operator init","url":"/openbao/docs/commands/operator/init/#common-options","content":" -key-shares (int: 5) - Number of key shares to split the generated master key into. This is the number of &quot;unseal keys&quot; to generate. This is aliased as-n. -key-threshold (int: 3) - Number of key shares required to reconstruct the root key. This must be less than or equal to -key-shares. This is aliased as-t. -pgp-keys (string: &quot;...&quot;) - Comma-separated list of paths to files on disk containing public PGP keys OR a comma-separated list of Keybase usernames using the format keybase:&lt;username&gt;. When supplied, the generated unseal keys will be encrypted and base64-encoded in the order specified in this list. The number of entries must match -key-shares, unless -stored-shares are used. -root-token-pgp-key (string: &quot;&quot;) - Path to a file on disk containing a binary or base64-encoded public PGP key. This can also be specified as a Keybase username using the format keybase:&lt;username&gt;. When supplied, the generated root token will be encrypted and base64-encoded with the given public key. -status (bool&quot;: false) - Print the current initialization status. An exit code of 0 means the OpenBao is already initialized. An exit code of 1 means an error occurred. An exit code of 2 means the OpenBao is not initialized.  ","version":"Next","tagName":"h3"},{"title":"Consul options​","type":1,"pageTitle":"operator init","url":"/openbao/docs/commands/operator/init/#consul-options","content":" -consul-auto (bool: false) - Perform automatic service discovery using Consul in HA mode. When all nodes in an OpenBao HA cluster are registered with Consul, enabling this option will trigger automatic service discovery based on the provided -consul-service value. Ensure the proper Consul environment variables are set (CONSUL_HTTP_ADDR, etc). When only one OpenBao server is discovered, it will be initialized automatically. When more than one OpenBao server is discovered, they will each be output for selection. The default is false. -consul-service (string: &quot;openbao&quot;) - Name of the service in Consul under which the OpenBao servers are registered.  ","version":"Next","tagName":"h3"},{"title":"HSM and KMS options​","type":1,"pageTitle":"operator init","url":"/openbao/docs/commands/operator/init/#hsm-and-kms-options","content":" -recovery-pgp-keys (string: &quot;...&quot;) - Behaves like -pgp-keys, but for the recovery key shares. This is only available with Auto Unseal seals (HSM, KMS and Transit seals). -recovery-shares (int: 5) - Number of key shares to split the recovery key into. This is only available with Auto Unseal seals (HSM, KMS and Transit seals). -recovery-threshold (int: 3) - Number of key shares required to reconstruct the recovery key. This is only available with Auto Unseal seals (HSM, KMS and Transit seals). -stored-shares (int: 0) - Number of unseal keys to store on an HSM. This must be equal to -key-shares.  Recovery keys: Refer to theSeal/Unseal documentation to learn more about recovery keys. ","version":"Next","tagName":"h3"},{"title":"operator members","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/members/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator members","url":"/openbao/docs/commands/operator/members/#examples","content":" Get the key status:  $ bao operator members Host Name API Address Cluster Address Active Node Version Upgrade Version Redundancy Zone Last Echo --------- ----------- --------------- ----------- ------- --------------- --------------- --------- josh-C02ZT9DYMD6R http://127.0.0.1:8200 https://127.0.0.1:8201 true 1.11.0 1.11.0 a n/a josh-C02ZT9DYMD6R http://127.0.0.2:8200 https://127.0.0.2:8201 false 1.11.0 1.11.0 a 2022-05-23T15:51:19-07:00 josh-C02ZT9DYMD6R http://127.0.0.3:8200 https://127.0.0.3:8201 false 1.11.0 1.11.0 b 2022-05-23T15:51:19-07:00 josh-C02ZT9DYMD6R http://127.0.0.4:8200 https://127.0.0.4:8201 false 1.11.0 1.11.0 b 2022-05-23T15:51:22-07:00 josh-C02ZT9DYMD6R http://127.0.0.5:8200 https://127.0.0.5:8201 false 1.11.0 1.12.0 a 2022-05-23T15:51:20-07:00 ~   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator members","url":"/openbao/docs/commands/operator/members/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator members","url":"/openbao/docs/commands/operator/members/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"operator migrate","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/migrate/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#examples","content":" Migrate all keys:  $ bao operator migrate -config migrate.hcl 2018-09-20T14:23:23.656-0700 [INFO ] copied key: data/core/seal-config 2018-09-20T14:23:23.657-0700 [INFO ] copied key: data/core/wrapping/jwtkey 2018-09-20T14:23:23.658-0700 [INFO ] copied key: data/logical/fd1bed89-ffc4-d631-00dd-0696c9f930c6/31c8e6d9-2a17-d98f-bdf1-aa868afa1291/archive/metadata 2018-09-20T14:23:23.660-0700 [INFO ] copied key: data/logical/fd1bed89-ffc4-d631-00dd-0696c9f930c6/31c8e6d9-2a17-d98f-bdf1-aa868afa1291/metadata/5kKFZ4YnzgNfy9UcWOzxxzOMpqlp61rYuq6laqpLQDnB3RawKpqi7yBTrawj1P ...   Migration is done in a consistent, sorted order. If the migration is halted or exits before completion (e.g. due to a connection error with a storage backend), it may be resumed from an arbitrary key prefix:  $ bao operator migrate -config migrate.hcl -start &quot;data/logical/fd&quot;   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#configuration","content":" The operator migrate command uses a dedicated configuration file to specify the source and destination storage backends. The format of the storage stanzas is identical to that used to configure OpenBao, with the only difference being that two stanzas are required: storage_source and storage_destination.  storage_source &quot;inmem&quot; {} storage_destination &quot;file&quot; { path = &quot;/mnt/openbao/data&quot; }   ","version":"Next","tagName":"h2"},{"title":"Migrating to integrated raft storage​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#migrating-to-integrated-raft-storage","content":" ","version":"Next","tagName":"h2"},{"title":"Example configuration​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#example-configuration","content":" The below configuration will migrate away from Filesystem storage to integrated raft storage. The raft data will be stored on the local filesystem in the defined path. node_id can optionally be set to identify this node.cluster_addr must be set to the cluster hostname of this node. For more configuration options see the raft storage configuration documentation.  If the original configuration uses &quot;raft&quot; for ha_storage a differentpath needs to be declared for the path in storage_destination and the new configuration for the node post-migration.  storage_source &quot;file&quot; { path = &quot;/mnt/openbao/data&quot; } storage_destination &quot;raft&quot; { path = &quot;/path/to/raft/data&quot; node_id = &quot;raft_node_1&quot; } cluster_addr = &quot;http://127.0.0.1:8201&quot;   ","version":"Next","tagName":"h3"},{"title":"Run the migration​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#run-the-migration","content":" OpenBao will need to be offline during the migration process. First, stop OpenBao. Then, run the migration on the server you wish to become a the new OpenBao node.  $ bao operator migrate -config migrate.hcl 2018-09-20T14:23:23.656-0700 [INFO ] copied key: data/core/seal-config 2018-09-20T14:23:23.657-0700 [INFO ] copied key: data/core/wrapping/jwtkey 2018-09-20T14:23:23.658-0700 [INFO ] copied key: data/logical/fd1bed89-ffc4-d631-00dd-0696c9f930c6/31c8e6d9-2a17-d98f-bdf1-aa868afa1291/archive/metadata 2018-09-20T14:23:23.660-0700 [INFO ] copied key: data/logical/fd1bed89-ffc4-d631-00dd-0696c9f930c6/31c8e6d9-2a17-d98f-bdf1-aa868afa1291/metadata/5kKFZ4YnzgNfy9UcWOzxxzOMpqlp61rYuq6laqpLQDnB3RawKpqi7yBTrawj1P ...   After migration has completed, the data is stored on the local file system. To use the new storage backend with OpenBao, update OpenBao's configuration file as described in the raft storage configuration documentation. Then start and unseal the OpenBao server.  ","version":"Next","tagName":"h3"},{"title":"Join additional nodes​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#join-additional-nodes","content":" After migration the raft cluster will only have a single node. Additional peers should be joined to this node.  If the cluster was previously HA-enabled using &quot;raft&quot; as the ha_storage, the nodes will have to re-join to the migrated node before unsealing.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"operator migrate","url":"/openbao/docs/commands/operator/migrate/#usage","content":" The following flags are available for the operator migrate command.  -config (string: &lt;required&gt;) - Path to the migration configuration file. -start (string: &quot;&quot;) - Migration starting key prefix. Only keys at or after this value will be copied. -reset - Reset the migration lock. A lock file is added during migration to prevent starting the OpenBao server or another migration. The -reset option can be used to remove a stale lock file if present. -max-parallel int: 10 - Allows the operator to specify the maximum number of lightweight threads (goroutines) which may be used to migrate data in parallel. This can potentially speed up migration on slower backends at the cost of more resources (e.g. CPU, memory). Permitted values range from 1 (synchronous) to the maximum value for an integer. If not supplied, a default of 10 parallel goroutines will be used.  Note: The maximum number of concurrent requests handled by a storage backend is ultimately governed by the storage backend configuration setting, which enforces a maximum number of concurrent requests (max_parallel). ","version":"Next","tagName":"h2"},{"title":"operator rotate","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/rotate/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator rotate","url":"/openbao/docs/commands/operator/rotate/#examples","content":" Rotate OpenBao's encryption key:  $ bao operator rotate Key Term 3 Install Time 01 May 17 10:30 UTC   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator rotate","url":"/openbao/docs/commands/operator/rotate/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator rotate","url":"/openbao/docs/commands/operator/rotate/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"operator rekey","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/rekey/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator rekey","url":"/openbao/docs/commands/operator/rekey/#examples","content":" Initialize a rekey:  $ bao operator rekey \\ -init \\ -key-shares=15 \\ -key-threshold=9   Initialize a rekey when Auto Unseal is used for the OpenBao cluster:  $ bao operator rekey \\ -target=recovery \\ -init \\ -key-shares=15 \\ -key-threshold=9   Initialize a rekey and activate the verification process:  $ bao operator rekey \\ -init \\ -key-shares=15 \\ -key-threshold=9 \\ -verify   Rekey and encrypt the resulting unseal keys with PGP:  $ bao operator rekey \\ -init \\ -key-shares=3 \\ -key-threshold=2 \\ -pgp-keys=&quot;keybase:hashicorp,keybase:jefferai,keybase:sethvargo&quot;   Rekey an Auto Unseal OpenBao and encrypt the resulting recovery keys with PGP:  $ bao operator rekey \\ -target=recovery \\ -init \\ -pgp-keys=keybase:grahamhashicorp -key-shares=1 -key-threshold=1   Store encrypted PGP keys in OpenBao's core:  $ bao operator rekey \\ -init \\ -pgp-keys=&quot;...&quot; \\ -backup   Retrieve backed-up unseal keys:  $ bao operator rekey -backup-retrieve   Delete backed-up unseal keys:  $ bao operator rekey -backup-delete   Perform the verification of the rekey using the verification nonce:  $ bao operator rekey -verify -nonce=&quot;...&quot;   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator rekey","url":"/openbao/docs/commands/operator/rekey/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator rekey","url":"/openbao/docs/commands/operator/rekey/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"operator rekey","url":"/openbao/docs/commands/operator/rekey/#command-options","content":" -cancel (bool: false) - Reset the rekeying progress. This will discard any submitted unseal keys or configuration. The default is false. -init (bool: false) - Initialize the rekeying operation. This can only be done if no rekeying operation is in progress. Customize the new number of key shares and key threshold using the -key-shares and -key-threshold flags. -key-shares (int: 5) - Number of key shares to split the generated master key into. This is the number of &quot;unseal keys&quot; to generate. This is aliased as-n -key-threshold (int: 3) - Number of key shares required to reconstruct the root key. This must be less than or equal to -key-shares. This is aliased as-t. -nonce (string: &quot;&quot;) - Nonce value provided at initialization. The same nonce value must be provided with each unseal key. -pgp-keys (string: &quot;...&quot;) - Comma-separated list of paths to files on disk containing public PGP keys OR a comma-separated list of Keybase usernames using the format keybase:&lt;username&gt;. When supplied, the generated unseal keys will be encrypted and base64-encoded in the order specified in this list. -status (bool: false) - Print the status of the current attempt without providing an unseal key. The default is false. -target (string: &quot;barrier&quot;) - Target for rekeying. &quot;recovery&quot; only applies when HSM support is enabled or using Auto Unseal. -verify (bool: false) - Indicate during the phase -init that the verification process is activated for the rekey. Along with -nonce option it indicates that the nonce given is for the verification process.  ","version":"Next","tagName":"h3"},{"title":"Backup options​","type":1,"pageTitle":"operator rekey","url":"/openbao/docs/commands/operator/rekey/#backup-options","content":" -backup (bool: false) - Store a backup of the current PGP encrypted unseal keys in OpenBao's core. The encrypted values can be recovered in the event of failure or discarded after success. See the -backup-delete and -backup-retrieve options for more information. This option only applies when the existing unseal keys were PGP encrypted. -backup-delete (bool: false) - Delete any stored backup unseal keys. -backup-retrieve (bool: false) - Retrieve the backed-up unseal keys. This option is only available if the PGP keys were provided and the backup has not been deleted. ","version":"Next","tagName":"h3"},{"title":"operator seal","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/seal/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator seal","url":"/openbao/docs/commands/operator/seal/#examples","content":" Seal an OpenBao server:  $ bao operator seal Success! OpenBao is sealed.   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator seal","url":"/openbao/docs/commands/operator/seal/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"operator step-down","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/step-down/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator step-down","url":"/openbao/docs/commands/operator/step-down/#examples","content":" Force an OpenBao server to step down as the leader:  $ bao operator step-down Success! Stepped down: http://127.0.0.1:8200   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator step-down","url":"/openbao/docs/commands/operator/step-down/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"operator raft","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/raft/","content":"","keywords":"","version":"Next"},{"title":"join​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#join","content":" This command is used to join a new node as a peer to the Raft cluster. In order to join, there must be at least one existing member of the cluster. If Shamir seal is in use, then unseal keys are to be supplied before or after the join process, depending on whether it's being used exclusively for HA.  If raft is used for storage, the node must be joined before unsealing and theleader-api-addr argument must be provided. If raft is used for ha_storage, the node must be first unsealed before joining and the leader-api-addr mustnot be provided.  Usage: bao operator raft join [options] &lt;leader-api-addr&gt; Join the current node as a peer to the Raft cluster by providing the address of the Raft leader node. $ bao operator raft join &quot;http://127.0.0.2:8200&quot;   The join command also allows operators to specify cloud auto-join configuration instead of a static IP address or hostname. When provided, OpenBao will attempt to automatically discover and resolve potential leader addresses based on the provided auto-join configuration.  OpenBao uses go-discover to support the auto-join functionality. Please see the go-discoverREADME for details on the format.  By default, OpenBao will attempt to reach discovered peers using HTTPS and port 8200. Operators may override these through the --auto-join-scheme and --auto-join-portCLI flags respectively.  Usage: bao operator raft join [options] &lt;auto-join-configuration&gt; Join the current node as a peer to the Raft cluster by providing cloud auto-join metadata configuration. $ bao operator raft join &quot;provider=aws region=eu-west-1 ...&quot;   ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#parameters","content":" The following flags are available for the operator raft join command.  -leader-ca-cert (string: &quot;&quot;) - CA cert to communicate with Raft leader. -leader-client-cert (string: &quot;&quot;) - Client cert to authenticate to Raft leader. -leader-client-key (string: &quot;&quot;) - Client key to authenticate to Raft leader. -retry (bool: false) - Continuously retry joining the Raft cluster upon failures. The default is false.  note Please be aware that the content (not the path to the file) of the certificate or key is expected for these parameters: -leader-ca-cert, -leader-client-cert, -leader-client-key.  ","version":"Next","tagName":"h3"},{"title":"list-peers​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#list-peers","content":" This command is used to list the full set of peers in the Raft cluster.  Usage: bao operator raft list-peers Provides the details of all the peers in the Raft cluster. $ bao operator raft list-peers   ","version":"Next","tagName":"h2"},{"title":"Example output​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#example-output","content":" { ... &quot;data&quot;: { &quot;config&quot;: { &quot;index&quot;: 62, &quot;servers&quot;: [ { &quot;address&quot;: &quot;127.0.0.2:8201&quot;, &quot;leader&quot;: true, &quot;node_id&quot;: &quot;node1&quot;, &quot;protocol_version&quot;: &quot;3&quot;, &quot;voter&quot;: true }, { &quot;address&quot;: &quot;127.0.0.4:8201&quot;, &quot;leader&quot;: false, &quot;node_id&quot;: &quot;node3&quot;, &quot;protocol_version&quot;: &quot;3&quot;, &quot;voter&quot;: true } ] } } }   ","version":"Next","tagName":"h3"},{"title":"remove-peer​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#remove-peer","content":" This command is used to remove a node from being a peer to the Raft cluster. In certain cases where a peer may be left behind in the Raft configuration even though the server is no longer present and known to the cluster, this command can be used to remove the failed server so that it is no longer affects the Raft quorum.  Usage: bao operator raft remove-peer &lt;server_id&gt; Removes a node from the Raft cluster. $ bao operator raft remove-peer node1   note Once a node is removed, its Raft data needs to be deleted before it may be joined back into an existing cluster. This requires shutting down the OpenBao process, deleting the data, then restarting the OpenBao process on the removed node.  ","version":"Next","tagName":"h2"},{"title":"snapshot​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#snapshot","content":" This command groups subcommands for operators interacting with the snapshot functionality of the integrated Raft storage backend. There are 2 subcommands supported: save and restore.  Usage: bao operator raft snapshot &lt;subcommand&gt; [options] [args] This command groups subcommands for operators interacting with the snapshot functionality of the integrated Raft storage backend. Subcommands: restore Installs the provided snapshot, returning the cluster to the state defined in it save Saves a snapshot of the current state of the Raft cluster into a file   ","version":"Next","tagName":"h2"},{"title":"snapshot save​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#snapshot-save","content":" Takes a snapshot of the OpenBao data. The snapshot can be used to restore OpenBao to the point in time when a snapshot was taken.  Usage: bao operator raft snapshot save &lt;snapshot_file&gt; Saves a snapshot of the current state of the Raft cluster into a file. $ bao operator raft snapshot save raft.snap   note Snapshot is not supported when Raft is used only for ha_storage.  ","version":"Next","tagName":"h3"},{"title":"snapshot restore​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#snapshot-restore","content":" Restores a snapshot of OpenBao data taken with bao operator raft snapshot save.  Usage: bao operator raft snapshot restore &lt;snapshot_file&gt; Installs the provided snapshot, returning the cluster to the state defined in it. $ bao operator raft snapshot restore raft.snap   ","version":"Next","tagName":"h3"},{"title":"autopilot​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#autopilot","content":" This command groups subcommands for operators interacting with the autopilot functionality of the integrated Raft storage backend. There are 3 subcommands supported: get-config, set-config and state.  For a more detailed overview of autopilot features, see the concepts page.  Usage: bao operator raft autopilot &lt;subcommand&gt; [options] [args] This command groups subcommands for operators interacting with the autopilot functionality of the integrated Raft storage backend. Subcommands: get-config Returns the configuration of the autopilot subsystem under integrated storage set-config Modify the configuration of the autopilot subsystem under integrated storage state Displays the state of the raft cluster under integrated storage as seen by autopilot   ","version":"Next","tagName":"h2"},{"title":"autopilot state​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#autopilot-state","content":" Displays the state of the raft cluster under integrated storage as seen by autopilot. It shows whether autopilot thinks the cluster is healthy or not, and how many nodes could fail before the cluster becomes unhealthy (&quot;Failure Tolerance&quot;).  State includes a list of all servers by nodeID and IP address. Last Index indicates how close the state on each node is to the leader's.  A node can have a status of &quot;leader&quot; or &quot;voter&quot;.  Usage: bao operator raft autopilot state Displays the state of the raft cluster under integrated storage as seen by autopilot. $ bao operator raft autopilot state   Example output​  Healthy: true Failure Tolerance: 1 Leader: raft1 Voters: raft1 raft2 raft3 Servers: raft1 Name: raft1 Address: 127.0.0.1:8201 Status: leader Node Status: alive Healthy: true Last Contact: 0s Last Term: 3 Last Index: 38 raft2 Name: raft2 Address: 127.0.0.2:8201 Status: voter Node Status: alive Healthy: true Last Contact: 2.514176729s Last Term: 3 Last Index: 38   ","version":"Next","tagName":"h3"},{"title":"autopilot get-config​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#autopilot-get-config","content":" Returns the configuration of the autopilot subsystem under integrated storage.  Usage: bao operator raft autopilot get-config Returns the configuration of the autopilot subsystem under integrated storage. $ bao operator raft autopilot get-config   ","version":"Next","tagName":"h3"},{"title":"autopilot set-config​","type":1,"pageTitle":"operator raft","url":"/openbao/docs/commands/operator/raft/#autopilot-set-config","content":" Modify the configuration of the autopilot subsystem under integrated storage.  Usage: bao operator raft autopilot set-config [options] Modify the configuration of the autopilot subsystem under integrated storage. $ bao operator raft autopilot set-config -server-stabilization-time 10s   Flags applicable to this command are the following:  cleanup-dead-servers (bool) - Controls whether to remove dead servers from the Raft peer list periodically or when a new server joins. This requires thatmin-quorum is also set. Defaults to false. last-contact-threshold (string) - Limit on the amount of time a server can go without leader contact before being considered unhealthy. Defaults to 10s. dead-server-last-contact-threshold (string) - Limit on the amount of time a server can go without leader contact before being considered failed. This takes effect only when cleanup_dead_servers is set as true. Defaults to 24h.  note A failed server that autopilot has removed from the raft configuration cannot rejoin the cluster without being reinitialized.  max-trailing-logs (int) - Amount of entries in the Raft Log that a server can be behind before being considered unhealthy. Defaults to 1000. min-quorum (int) - Minimum number of servers that should always be present in a cluster. Autopilot will not prune servers below this number. This should be set to the expected number of voters in your cluster. There is no default. server-stabilization-time (string) - Minimum amount of time a server must be in a healthy state before it can become a voter. Until that happens, it will be visible as a peer in the cluster, but as a non-voter, meaning it won't contribute to quorum. Defaults to 10s. ","version":"Next","tagName":"h3"},{"title":"patch","type":0,"sectionRef":"#","url":"/openbao/docs/commands/patch/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"patch","url":"/openbao/docs/commands/patch/#examples","content":" Updates a PKI role to modify a single parameter:  $ bao patch pki/roles/example allow_localhost=false   ","version":"Next","tagName":"h2"},{"title":"API versus CLI​","type":1,"pageTitle":"patch","url":"/openbao/docs/commands/patch/#api-versus-cli","content":" Updates a PKI role to modify the allow_localhost parameter:  $ bao patch pki/roles/example allow_localhost=false   Equivalent cURL command for this operation:  $ tee request_payload.json -&lt;&lt;EOF { &quot;organization&quot;: &quot;hashicorp&quot; } EOF $ curl --header &quot;X-Vault-Token: $VAULT_TOKEN&quot; \\ --request PATCH \\ --header 'Content-Type: application/merge-patch+json' --data @request_payload.json \\ $VAULT_ADDR/v1/pki/roles/example   The bao patch command simplifies the API call.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"patch","url":"/openbao/docs/commands/patch/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"patch","url":"/openbao/docs/commands/patch/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"patch","url":"/openbao/docs/commands/patch/#command-options","content":" -force (bool: false) - Allow the operation to continue with no key=value pairs. This allows writing to keys that do not need or expect data. This is aliased as -f. ","version":"Next","tagName":"h3"},{"title":"operator usage","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/usage/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator usage","url":"/openbao/docs/commands/operator/usage/#examples","content":" Retrieve the client counts for the default reporting period:  $ bao operator usage Period start: 2019-11-01T00:00:00Z Period end: 2020-10-31T23:59:59Z Namespace path Distinct entities Non-Entity tokens Active clients -------------- ----------------- ----------------- -------------- [root] 1581 332 1913 Total 1581 332 1913   Retrieve the client counts for a specific month in the past:  $ bao operator usage -start-time=2020-01 -end-time=2020-01 Period start: 2020-01-01T00:00:00Z Period end: 2020-01-31T23:59:59Z Namespace path Distinct entities Non-Entity tokens Active clients -------------- ----------------- ----------------- -------------- [root] 954 176 1130 Total 954 176 1130   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator usage","url":"/openbao/docs/commands/operator/usage/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator usage","url":"/openbao/docs/commands/operator/usage/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"operator usage","url":"/openbao/docs/commands/operator/usage/#command-options","content":" -start-time (date) - Start month of the report to generate. May be given as YYYY-MM-DD, YYYY-MM-DD, a full RFC3339 timestamp, or a Unix epoch timestamp. Defaults to the configurable default_report_monthsprior to end-time. -end-time (date: previous month) - End month of the report to generate. Defaults to the end of the previous calendar month.  The output shows the exact time range being reported, which may not match the input parameters if a full month is not available, or if the available reports are a subset of the months requested. ","version":"Next","tagName":"h3"},{"title":"operator unseal","type":0,"sectionRef":"#","url":"/openbao/docs/commands/operator/unseal/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"operator unseal","url":"/openbao/docs/commands/operator/unseal/#examples","content":" Provide an unseal key:  $ bao operator unseal Key (will be hidden): Sealed: false Key Shares: 1 Key Threshold: 1 Unseal Progress: 0   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"operator unseal","url":"/openbao/docs/commands/operator/unseal/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"operator unseal","url":"/openbao/docs/commands/operator/unseal/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"operator unseal","url":"/openbao/docs/commands/operator/unseal/#command-options","content":" -migrate (bool: false) - Indicate that this share is provided with the intent that it is part of a seal migration process. -reset (bool: false) - Discard any previously entered keys to the unseal process. ","version":"Next","tagName":"h3"},{"title":"path-help","type":0,"sectionRef":"#","url":"/openbao/docs/commands/path-help/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"path-help","url":"/openbao/docs/commands/path-help/#examples","content":" Get help output for the KV secrets engine:  $ bao path-help secret ## DESCRIPTION The KV backend reads and writes arbitrary secrets to the backend. The secrets are encrypted/decrypted by OpenBao: they are never stored unencrypted in the backend and the backend never has an opportunity to see the unencrypted value. Leases can be set on a per-secret basis. These leases will be sent down when that secret is read, and it is assumed that some outside process will revoke and/or replace the secret at that path. ## PATHS The following paths are supported by this backend. To view help for any of the paths below, use the help command with any route matching the path pattern. Note that depending on the policy of your auth token, you may or may not be able to access certain paths. ^.*$ Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.   Once you've found a path you like, you can learn more about it by using bao path-help &lt;path&gt; where &quot;path&quot; is a path that matches one of the regular expressions from the backend help.  $ bao path-help secret/password Request: password Matching Route: ^.*$ Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage. ## PARAMETERS lease (string) Lease time for this key when read. Ex: 1h ## DESCRIPTION The pass-through backend reads and writes arbitrary data into secret storage, encrypting it along the way. A lease can be specified when writing with the &quot;lease&quot; field. If given, then when the secret is read, OpenBao will report a lease with that duration. It is expected that the consumer of this backend properly writes renewed keys before the lease is up. In addition, revocation must be handled by the user of this backend.   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"path-help","url":"/openbao/docs/commands/path-help/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"pki","type":0,"sectionRef":"#","url":"/openbao/docs/commands/pki/","content":"","keywords":"","version":"Next"},{"title":"Syntax​","type":1,"pageTitle":"pki","url":"/openbao/docs/commands/pki/#syntax","content":" Option flags for a given subcommand are provided after the subcommand, but before the arguments.  ","version":"Next","tagName":"h2"},{"title":"Example health check​","type":1,"pageTitle":"pki","url":"/openbao/docs/commands/pki/#example-health-check","content":" To health check a mount, use thebao pki health-check &lt;mount&gt; command:  $ bao pki health-check pki ca_validity_period ------------------ status endpoint message ------ -------- ------- ok /pki/issuer/da41ffb1-cc6d-5a5c-f147-e4d7beeb1b73 Issuer's validity (2032-12-17) is OK ... more output elided ...   ","version":"Next","tagName":"h2"},{"title":"Example verify sign​","type":1,"pageTitle":"pki","url":"/openbao/docs/commands/pki/#example-verify-sign","content":" To verify the signature between two issuer certificates, use the bao pki verify-sign &lt;parent&gt; &lt;child&gt; command:  $ bao pki verify-sign pki_root/issuer/root pki_int/issuer/FirstDepartment issuer:pki_root/issuer/root issued:pki_int/issuer/FirstDepartment field value ----- ----- subject_match true path_match true trust_match true key_id_match true signature_match true   ","version":"Next","tagName":"h2"},{"title":"Example list child issuers​","type":1,"pageTitle":"pki","url":"/openbao/docs/commands/pki/#example-list-child-issuers","content":" To list intermediate certificates potentially issued by a certificate inside OpenBao, use thebao pki list-intermediates &lt;parent&gt; command:  $ bao pki list-intermediates /pki_root/issuer/default intermediate match? ------------ ------ pki_int_2/issuer/d4404ccc-3ad4-83a9-f5df-398637654b3b true pki_int_2/issuer/db0b0a6c-6641-ac15-363a-4e5261315581 true pki_root/issuer/9464c4fe-e8a6-d96a-0566-021575e7382c true pki_int/issuer/2f958ec5-1838-336e-331b-07032379b958 true pki_int/issuer/b8cc0b41-e0e9-1a92-12c4-6849c9d6f837 true   ","version":"Next","tagName":"h2"},{"title":"Example issue​","type":1,"pageTitle":"pki","url":"/openbao/docs/commands/pki/#example-issue","content":" To issue a new issuer certificate, use thebao pki issue &lt;parent-certificate-path&gt; &lt;mount&gt; command:  $ bao pki issue -issuer_name=&quot;FirstDepartment&quot; /pki_root/issuer/default /pki_int/ common_name=&quot;first-department.example.com&quot; Key Value --- ----- ca_chain [-----BEGIN CERTIFICATE----- MIIDsDCCApigAwIBAgIULEPuHTW7UDtAQg+qcc18osNWgZIwDQYJKoZIhvcNAQEL...   ","version":"Next","tagName":"h2"},{"title":"Example reissue​","type":1,"pageTitle":"pki","url":"/openbao/docs/commands/pki/#example-reissue","content":" To reissue an issuer certificate, using the same fields as an existing issuer template, use thebao pki reissue &lt;parent-certificate-path&gt; &lt;template&gt; &lt;mount&gt; command:  $ bao pki reissue -issuer_name=&quot;SecondDepartment&quot; /pki_root/issuer/default /pki_int/issuer/FirstDepartment /pki_int_2/ common_name=&quot;second-department.example.com&quot; Key Value --- ----- ca_chain [-----BEGIN CERTIFICATE----- MIID0DCCArigAwIBAgIUdfRe05B5eRXsg3pvsJ/g94eYuWkwDQYJKoZIhvcNAQEL```  ","version":"Next","tagName":"h2"},{"title":"pki issue","type":0,"sectionRef":"#","url":"/openbao/docs/commands/pki/issue/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"pki issue","url":"/openbao/docs/commands/pki/issue/#usage","content":" Usage: bao pki issue [flags] &lt;parent&gt; &lt;child_mount&gt; [options]  [flags] are optional arguments described below &lt;parent&gt; is the fully qualified path of the Certificate Authority in OpenBao which will issue the new intermediate certificate. &lt;child_mount&gt; is the path of the mount in OpenBao where the new issuer is saved. [options] are the superset of the k=v options passed to generate-intermediate-csr and sign-intermediate commands. At least one option must be set. See below.  ","version":"Next","tagName":"h2"},{"title":"Flags​","type":1,"pageTitle":"pki issue","url":"/openbao/docs/commands/pki/issue/#flags","content":" -type (string: &quot;internal&quot;) - This determines the type of key use for the newly created certificate. Valid types are &quot;existing&quot; - where we link to a key already present in the OpenBao-backend to be used (and expect option arguments &quot;key_ref&quot;) - &quot;internal&quot; - to generate a new key for this certificate - or &quot;kms&quot; - to link to an external key. Exported keys are not available through this API. -issuer_name (string: &quot;&quot;) - If present, the newly created issuer will be given this name.  ","version":"Next","tagName":"h3"},{"title":"Options​","type":1,"pageTitle":"pki issue","url":"/openbao/docs/commands/pki/issue/#options","content":" Other than type (which is passed as a flag, see above), this command accepts all options provided to theGenerate CSR andSign Intermediate endpoints.  ","version":"Next","tagName":"h3"},{"title":"Accessed APIs​","type":1,"pageTitle":"pki issue","url":"/openbao/docs/commands/pki/issue/#accessed-apis","content":" Note that the openbao user running this command will need to have access to the following API endpoints, each representing a step in the process:  READ /:parent - used to check validityWRITE /:child_mount/intermediate/generate/:type - used to generate the csrWRITE /:parent/sign-intermediate - used to sign the csrWRITE /:child_mount/issuers/import/cert - used to import the new issuer, and the issuer chainUPDATE /:child_mount/issuer/:issuer_refs - used to both name the new issuer, and also set the name of the parent in the issuer chainREAD /:child_mount/issuer/:new_issuer_ref - used to verify completion, generate the output  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"pki issue","url":"/openbao/docs/commands/pki/issue/#examples","content":" $ bao pki issue -issuer_name=&quot;FirstDepartment&quot; /pki_root/issuer/default /pki_int/ common_name=&quot;first-department.example.com&quot; Key Value --- ----- ca_chain [-----BEGIN CERTIFICATE----- MIIDsDCCApigAwIBAgIULEPuHTW7UDtAQg+qcc18osNWgZIwDQYJKoZIhvcNAQEL...  ","version":"Next","tagName":"h2"},{"title":"pki list-intermediates","type":0,"sectionRef":"#","url":"/openbao/docs/commands/pki/list-intermediates/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"pki list-intermediates","url":"/openbao/docs/commands/pki/list-intermediates/#usage","content":" Usage: bao pki list-intermediates [flags] &lt;parent&gt; [child] [child] [child...  Lists the set of intermediate CAs issued by this parent issuer.  [flags] listed below determine the type of match required between the &lt;parent&gt;and each potential child, and the type of output &lt;parent&gt; is the certificate that might be the issuer which everything is verified against. [child] is an optional path to a certificate to be compared to the &lt;parent&gt;, or pki mounts to look for certificates on. If [child] is omitted entirely, the list will be constructed from all accessible pki mounts.  This returns a list of issuing certificates and whether they are a match. By default, the type of match required is whether the &lt;parent&gt; has the expected subject, authority/subject key id match, and could have (directly) signed this issuer. The match criteria can be updated by changed the corresponding flag.  ","version":"Next","tagName":"h2"},{"title":"Flags​","type":1,"pageTitle":"pki list-intermediates","url":"/openbao/docs/commands/pki/list-intermediates/#flags","content":" -use_names (bool: &quot;false&quot;) - this determines how issuers are referred to in the output, whether by issuer_id (the default), or by their name, or status as default issuer (when use_names is true)  The following flags determine what sorts of relationship between the parent and potential child issuers are considered a match.  -subject_match (bool: &quot;true&quot;) - determines whether the subject of the parent-issuer must match the issuer of the potential child for this to be considered a match -key_id_match (bool: &quot;true&quot;) - determines whether the identifier of the parent-issuer must match the IUI of the potential child for this to be considered a match -direct_verify (bool: &quot;true&quot;) - determines whether it is required for this to be a match that someone trusting the parent certificate would trust the potential-child certificate (without any more information) -indirect-sign (bool: &quot;true&quot;) - determines whether it is required for this to be a match that if someone trusted the first certificate, they would trust the potential-child certificate (using the certificate chains available) -path_contains (bool: &quot;false&quot;) - determines whether it is required for this to be a match for the ca_chain of the potential child certificate to contain the parent certificate  ","version":"Next","tagName":"h3"},{"title":"Accessed APIs​","type":1,"pageTitle":"pki list-intermediates","url":"/openbao/docs/commands/pki/list-intermediates/#accessed-apis","content":" Note that the OpenBao user running this command will need to have access to the following API endpoints, each representing a step in the process:  READ /:parentLIST /sys/mounts - when no [child] argument is provided, this is used to find a list of pki mountsLIST /:child_mount/issuers/ - when no [child] argument is provided, or the[child] argument is a mount rather than an issuer, this is used to find a list of pki issuers on the mountREAD /:child - each potential child issuer is read for comparison against the parent  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"pki list-intermediates","url":"/openbao/docs/commands/pki/list-intermediates/#examples","content":" $ bao pki list-intermediates /pki_root/issuer/default intermediate match? ------------ ------ pki_int_2/issuer/d4404ccc-3ad4-83a9-f5df-398637654b3b true pki_int_2/issuer/db0b0a6c-6641-ac15-363a-4e5261315581 true pki_root/issuer/9464c4fe-e8a6-d96a-0566-021575e7382c true pki_int/issuer/2f958ec5-1838-336e-331b-07032379b958 true pki_int/issuer/b8cc0b41-e0e9-1a92-12c4-6849c9d6f837 true  ","version":"Next","tagName":"h2"},{"title":"pki health-check","type":0,"sectionRef":"#","url":"/openbao/docs/commands/pki/health-check/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#examples","content":" Performs a basic health check against the pki-root mount:  $ bao pki health-check pki-root/   Configuration can be specified using the -health-config flag:  $ bao pki health-check -health-config=mycorp-root.json pki-root/   Using the -list flag will show the list of health checks and any known configuration values (with their defaults) that will be run against this mount:  $ bao pki health-check -list pki-root/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#usage","content":" The following flags are unique to this command:  -default-disabled - When specified, results in all health checks being disabled by default unless enabled by the configuration file explicitly. The default is false, meaning all default-enabled health checks will run. -health-config (string: &quot;&quot;) - Path to JSON configuration file to modify health check execution and parameters. -list - When specified, no health checks are run, but all known health checks are printed. Still requires a positional mount argument. The default is false, meaning no listing is printed and health checks will execute. -return-indicator (string: &quot;default&quot;) - Behavior of the return value (exit code) of this command: permission, for exiting with a non-zero code when the tool lacks permissions or has a version mismatch with the server;critical, for exiting with a non-zero code when a check returns a critical status in addition to the above;warning, for exiting with a non-zero status when a check returns a warning status in addition to the above;informational, for exiting with a non-zero status when a check returns an informational status in addition to the above;default, for the default behavior based on severity of message and only returning a zero exit status when all checks have passed and no execution errors have occurred.  This command respects the -format parameter to control the presentation of output sent to stdout. Fatal errors that prevent health checks from executing may not follow this formatting.  ","version":"Next","tagName":"h2"},{"title":"Return status and output​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#return-status-and-output","content":" This command returns the following exit codes:  0 - Everything is good.1 - Usage error (check CLI parameters).2 - Informational message from a health check.3 - Warning message from a health check.4 - Critical message from a health check.5 - A version mismatch between health check and OpenBao Server occurred, preventing one or more health checks from being fully run.6 - A permission denied message was returned from OpenBao Server for one or more health checks.  Note that an exit code of 5 (due to a version mismatch) is not necessarily fatal to the health check.  Each health check outputs one or results in a list. This list contains a mapping of keys (status, status_code, endpoint, and message) to values returned by the health check. An endpoint may occur in more than one health check and is not necessarily guaranteed to exist on the server (e.g., using wildcards to indicate all matching paths have the same result). Tabular form elides the status code, as this is meant to be consumed programatically.  These correspond to the following health check status values:  status not_applicable / status code 0: exit code 0.status ok / status code 1: exit code 0status informational / status code 2: exit code 2.status warning / status code 3: exit code 3.status critical / status code 4: exit code 4.status invalid_version / status code 5: exit code 5.status insufficient_permissions / status code 6: exit code 6.  ","version":"Next","tagName":"h2"},{"title":"Health checks​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#health-checks","content":" The following health checks are currently implemented. More health checks may be added in future releases and may default to being enabled.  ","version":"Next","tagName":"h2"},{"title":"CA validity period​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#ca-validity-period","content":" Name: ca_validity_period  Accessed APIs:  LIST /issuers (unauthenticated)READ /issuer/:issuer_ref/json (unauthenticated)  Config Parameters:  root_expiry_critical (duration: 182d) - for a duration within which the root's lifetime is considered criticalintermediate_expiry_critical (duration: 30d) - for a duration within which the intermediate's lifetime is considered criticalroot_expiry_warning (duration: 365d) - for a duration within which the root's lifetime is considered warningintermediate_expiry_warning (duration: 60d) - for a duration within which the intermediate's lifetime is considered warningroot_expiry_informational (duration: 730d) - for a duration within which the root's lifetime is considered informationalintermediate_expiry_informational (duration: 180d) - for a duration within which the intermediate's lifetime is considered informational  This health check will check each issuer in the mount for validity status, returning a list. If a CA expires within the next 30 days, the result will be critical. If a root CA expires within the next 12 months or an intermediate CA within the next 2 months, the result will be a warning. If a root CA expires within 24 months or an intermediate CA within 6 months, the result will be informational.  Remediation steps:  Perform a CA rotation operationto check for CAs that are about to expire.Migrate from expiring CAs to new CAs.Delete any expired CAs with one of the following options:  Run tidy manually with bao write &lt;mount&gt;/tidy tidy_expired_issuers=true.Use the OpenBao API to call delete issuer.  ","version":"Next","tagName":"h3"},{"title":"CRL validity period​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#crl-validity-period","content":" Name: crl_validity_period  Accessed APIs:  LIST /issuers (unauthenticated)READ /config/crl (optional)READ /issuer/:issuer_ref/crl (unauthenticated)READ /issuer/:issuer_ref/crl/delta (unauthenticated)  Config Parameters:  crl_expiry_pct_critical (int: 95) - the percentage of validity period after which a CRL should be considered critically close to expirydelta_crl_expiry_pct_critical (int: 95) - the percentage of validity period after which a Delta CRL should be considered critically close to expiry  This health check checks each issuer's CRL for validity status, returning a list. Unlike CAs, where a date-based duration makes sense due to effort required to successfully rotate, rotating CRLs are much easier, so a percentage based approach makes sense. If the chosen percentage exceeds that of the grace_period from the CRL configuration, an informational message will be issued rather than OK.  For informational purposes, it reads the CRL config and suggests enabling auto-rebuild CRLs if not enabled.  Remediation steps:  Use bao write to enable CRL auto-rebuild:  $ bao write &lt;mount&gt;/config/crl auto_rebuild=true   ","version":"Next","tagName":"h3"},{"title":"Root certificate issued Non-CA leaves​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#root-certificate-issued-non-ca-leaves","content":" Name: root_issued_leaves  APIs:  LIST /issuers (unauthenticated)READ /issuer/:issuer_ref/pem (unauthenticated)LIST /certsREAD /certs/:serial (unauthenticated)  Config Parameters:  certs_to_fetch (int: 100) - a quantity of leaf certificates to fetch to see if any leaves have been issued by a root directly.  This health check verifies whether a proper CA hierarchy is in use. We do this by fetching certs_to_fetch leaf certificates (configurable) and seeing if they are a non-issuer leaf and if they were signed by a root issuer in this mount. If one is found, we'll issue a warning about this, and recommend setting up an intermediate CA.  Remediation steps:  Restrict the use of sign, sign-verbatim, issue, and ACME APIs against the root issuer.Create an intermediary issuer in a different mount.Have the root issuer sign the new intermediary issuer.Issue new leaf certificates using the intermediary issuer.  ","version":"Next","tagName":"h3"},{"title":"Role allows implicit localhost issuance​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#role-allows-implicit-localhost-issuance","content":" Name: role_allows_localhost  APIs:  LIST /rolesREAD /roles/:name  Config Parameters: (none)  Checks whether any roles exist that allow implicit localhost based issuance (allow_localhost=true) with a non-empty allowed_domains value.  Remediation steps:  Set allow_localhost to false for all roles.Update the allowed_domains field with an explicit list of allowed localhost-like domains.  ","version":"Next","tagName":"h3"},{"title":"Role allows Glob-Based wildcard issuance​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#role-allows-glob-based-wildcard-issuance","content":" Name: role_allows_glob_wildcards  APIs:  LIST /rolesREAD /roles/:name  Config Parameters:  allowed_roles (list: nil) - an allow-list of roles to ignore.  Check each role to see whether or not it allows wildcard issuance and glob domains. Wildcards and globs can interact and result in nested wildcards among other (potentially dangerous) quirks.  Remediation steps:  Split any role that need both of allow_glob_domains and allow_wildcard_certificates to be true into two roles.Continue splitting roles until both of the following are true for all roles: The role has allow_glob_domains or allow_wildcard_certificates, but not both.Roles with allow_glob_domains and allow_wildcard_certificates are the only roles required for all SANs on the certificate. Add the roles that allow glob domains and wildcards to allowed_roles so OpenBao ignores them in future checks.  ","version":"Next","tagName":"h3"},{"title":"Role sets no_store=false and performance​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#role-sets-no_storefalse-and-performance","content":" Name: role_no_store_false  APIs:  LIST /rolesREAD /roles/:nameLIST /certsREAD /config/crl  Config Parameters:  allowed_roles (list: nil) - an allow-list of roles to ignore.  Checks each role to see whether no_store is set to false.  warning OpenBao will provide warnings and performance will suffer if you have a large number of certificates without temporal CRL auto-rebuilding and set no_storeto true.  Remediation steps:  Update none-ACME roles with no_store=false. NOTE: Roles used for ACME issuance must have no_store set to true.Set your certificate lifetimes as short as possible.Use BYOC revocations to revoke certificates as needed.  ","version":"Next","tagName":"h3"},{"title":"Accessibility of audit information​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#accessibility-of-audit-information","content":" Name: audit_visibility  APIs:  READ /sys/mounts/:mount/tune  Config Parameters:  ignored_parameters (list: nil) - a list of parameters to ignore their HMAC status.  This health check checks whether audit information is accessible to log consumers, validating whether our list of safe and unsafe audit parameters are generally followed. These are informational responses, if any are present.  Remediation steps:  Use bao secrets tune to set the desired audit parameters:  $ bao secrets tune \\ -audit-non-hmac-response-keys=certificate \\ -audit-non-hmac-response-keys=issuing_ca \\ -audit-non-hmac-response-keys=serial_number \\ -audit-non-hmac-response-keys=error \\ -audit-non-hmac-response-keys=ca_chain \\ -audit-non-hmac-request-keys=certificate \\ -audit-non-hmac-request-keys=issuer_ref \\ -audit-non-hmac-request-keys=common_name \\ -audit-non-hmac-request-keys=alt_names \\ -audit-non-hmac-request-keys=other_sans \\ -audit-non-hmac-request-keys=ip_sans \\ -audit-non-hmac-request-keys=uri_sans \\ -audit-non-hmac-request-keys=ttl \\ -audit-non-hmac-request-keys=not_after \\ -audit-non-hmac-request-keys=serial_number \\ -audit-non-hmac-request-keys=key_type \\ -audit-non-hmac-request-keys=private_key_format \\ -audit-non-hmac-request-keys=managed_key_name \\ -audit-non-hmac-request-keys=managed_key_id \\ -audit-non-hmac-request-keys=ou \\ -audit-non-hmac-request-keys=organization \\ -audit-non-hmac-request-keys=country \\ -audit-non-hmac-request-keys=locality \\ -audit-non-hmac-request-keys=province \\ -audit-non-hmac-request-keys=street_address \\ -audit-non-hmac-request-keys=postal_code \\ -audit-non-hmac-request-keys=permitted_dns_domains \\ -audit-non-hmac-request-keys=policy_identifiers \\ -audit-non-hmac-request-keys=ext_key_usage_oids \\ -audit-non-hmac-request-keys=csr \\ &lt;mount&gt;   ","version":"Next","tagName":"h3"},{"title":"ACL policies allow problematic endpoints​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#acl-policies-allow-problematic-endpoints","content":" Name: policy_allow_endpoints  APIs:  LIST /sys/policyREAD /sys/policy/:name  Config Parameters:  allowed_policies (list: nil) - a list of policies to allow-list for access to insecure APIs.  This health check checks whether unsafe access to APIs (such as sign-intermediate, sign-verbatim, and sign-self-issued) are allowed. Any findings are a critical result and should be rectified by the administrator or explicitly allowed.  ","version":"Next","tagName":"h3"},{"title":"Allow If-Modified-Since requests​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#allow-if-modified-since-requests","content":" Name: allow_if_modified_since  APIs:  READ /sys/internal/ui/mounts  Config Parameters: (none)  This health check verifies if the If-Modified-Since header has been added to passthrough_request_headers and if Last-Modified header has been added to allowed_response_headers. This is an informational message if both haven't been configured, or a warning if only one has been configured.  Remediation steps:  Update allowed_response_headers and passthrough_request_headers for all policies with bao secrets tune:  $ bao secrets tune \\ -passthrough-request-headers=&quot;If-Modified-Since&quot; \\ -allowed-response-headers=&quot;Last-Modified&quot; \\ &lt;mount&gt;   Update ACME-specific headers with bao secrets tune (if you are using ACME):  $ bao secrets tune \\ -passthrough-request-headers=&quot;If-Modified-Since&quot; \\ -allowed-response-headers=&quot;Last-Modified&quot; \\ -allowed-response-headers=&quot;Replay-Nonce&quot; \\ -allowed-response-headers=&quot;Link&quot; \\ -allowed-response-headers=&quot;Location&quot; \\ &lt;mount&gt;   ","version":"Next","tagName":"h3"},{"title":"Auto-Tidy disabled​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#auto-tidy-disabled","content":" Name: enable_auto_tidy  APIs:  READ /config/auto-tidy  Config Parameters:  interval_duration_critical (duration: 7d) - the maximum allowed interval_duration to hit critical threshold.interval_duration_warning (duration: 2d) - the maximum allowed interval_duration to hit a warning threshold.pause_duration_critical (duration: 1s) - the maximum allowed pause_duration to hit a critical threshold.pause_duration_warning (duration: 200ms) - the maximum allowed pause_duration to hit a warning threshold.  This health check verifies that auto-tidy is enabled, with sane defaults for interval_duration and pause_duration. Any disabled findings will be informational, as this is a best-practice but not strictly required, but other findings w.r.t. interval_duration or pause_duration will be critical/warnings.  Remediation steps  Use bao write to enable auto-tidy with the recommended defaults:  $ bao write &lt;mount&gt;/config/auto-tidy \\ enabled=true \\ tidy_cert_store=true \\ tidy_revoked_certs=true \\ tidy_acme=true \\ tidy_revocation_queue=true \\ tidy_cross_cluster_revoked_certs=true \\ tidy_revoked_cert_issuer_associations=true   ","version":"Next","tagName":"h3"},{"title":"Tidy hasn't run​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#tidy-hasnt-run","content":" Name: tidy_last_run  APIs:  READ /tidy-status  Config Parameters:  last_run_critical (duration: 7d) - the critical delay threshold between when tidy should have last run.last_run_warning (duration: 2d) - the warning delay threshold between when tidy should have last run.  This health check verifies that tidy has run within the last run window. This can be critical/warning alerts as this can start to seriously impact OpenBao's performance.  Remediation steps:  Schedule a manual run of tidy with bao write:  $ bao write &lt;mount&gt;/tidy \\ tidy_cert_store=true \\ tidy_revoked_certs=true \\ tidy_acme=true \\ tidy_revocation_queue=true \\ tidy_cross_cluster_revoked_certs=true \\ tidy_revoked_cert_issuer_associations=true   Review the tidy status endpoint, bao read &lt;mount&gt;/tidy-status for additional information.Re-configure auto-tidy based on the log information and results of your manual run.  ","version":"Next","tagName":"h3"},{"title":"Too many certificates​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#too-many-certificates","content":" Name: too_many_certs  APIs:  READ /tidy-statusLIST /certs  Config Parameters:  count_critical (int: 250000) - the critical threshold at which there are too many certs.count_warning (int: 50000) - the warning threshold at which there are too many certs.  This health check verifies that this cluster has a reasonable number of certificates. Ideally this would be fetched from tidy's status or a new metric reporting format, but as a fallback when tidy hasn't run, a list operation will be performed instead.  Remediation steps:  Verify that tidy ran recently with bao read: $ bao read &lt;mount&gt;/tidy-status Schedule a manual run of tidy with bao write: $ bao write &lt;mount&gt;/tidy \\ tidy_cert_store=true \\ tidy_revoked_certs=true \\ tidy_acme=true \\ tidy_revocation_queue=true \\ tidy_cross_cluster_revoked_certs=true \\ tidy_revoked_cert_issuer_associations=true Enable auto-tidy.Make sure that you are not renewing certificates too soon. Certificate lifetimes should reflect the expected usage of the certificate. If the TTL is set appropriately, most certificates renew at approximately 2/3 of their lifespan.Consider setting the no_store field for all roles to true and use BYOC revocations to avoid storage.  ","version":"Next","tagName":"h3"},{"title":"Enable ACME issuance​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#enable-acme-issuance","content":" Name: enable_acme_issuance  APIs:  READ /config/acmeREAD /config/clusterLIST /issuers (unauthenticated)READ /issuer/:issuer_ref/json (unauthenticated)  Config Parameters: (none)  This health check verifies that ACME is enabled within a mount that contains an intermediary issuer, as this is considered a best-practice to support a self-rotating PKI infrastructure.  Review the ACME Certificate IssuanceAPI documentation to learn about enabling ACME support in OpenBao.  ","version":"Next","tagName":"h3"},{"title":"ACME response headers​","type":1,"pageTitle":"pki health-check","url":"/openbao/docs/commands/pki/health-check/#acme-response-headers","content":" Name: allow_acme_headers  APIs:  READ /sys/internal/ui/mounts  Config Parameters: (none)  This health check verifies if the &quot;Replay-Nonce, Link, and Location headers have been added to allowed_response_headers, when the ACME feature is enabled. The ACME protocol will not work if these headers are not added to the mount.  Remediation steps:  Use bao secrets tune to add the missing headers to allowed_response_headers:  $ bao secrets tune \\ -allowed-response-headers=&quot;Last-Modified&quot; \\ -allowed-response-headers=&quot;Replay-Nonce&quot; \\ -allowed-response-headers=&quot;Link&quot; \\ -allowed-response-headers=&quot;Location&quot; \\ &lt;mount&gt;  ","version":"Next","tagName":"h3"},{"title":"pki verify-sign","type":0,"sectionRef":"#","url":"/openbao/docs/commands/pki/verify-sign/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"pki verify-sign","url":"/openbao/docs/commands/pki/verify-sign/#usage","content":" Usage: bao pki verify-sign &lt;parent&gt; &lt;child&gt;  &lt;parent&gt; is the fully name-spaced path to the issuer certificate which will be used to verify the &lt;child&gt; certificate &lt;child&gt; is the fully name-spaced path to the potential child-certificate to be verified  A fully namespaced path looks like, for instance, 'ns1/mount1/issuer/issuerName/json'.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"pki verify-sign","url":"/openbao/docs/commands/pki/verify-sign/#example","content":" $ bao pki verify-sign pki_root/issuer/root pki_int/issuer/FirstDepartment issuer:pki_root/issuer/root issued:pki_int/issuer/FirstDepartment field value ----- ----- subject_match true path_match true trust_match true key_id_match true signature_match true  ","version":"Next","tagName":"h2"},{"title":"plugin","type":0,"sectionRef":"#","url":"/openbao/docs/commands/plugin/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"plugin","url":"/openbao/docs/commands/plugin/#examples","content":" List all available secret plugins in the catalog:  $ bao plugin list secret Name Version ---- ------- kubernetes v0.5.0+builtin kv v0.15.0+builtin ...   Register a new secret plugin to the catalog:  $ bao plugin register \\ -sha256=d3f0a8be02f6c074cf38c9c99d4d04c9c6466249 \\ secret my-custom-plugin Success! Registered plugin: my-custom-plugin   Get information about a plugin in the catalog:  $ bao plugin info secret my-custom-plugin Key Value --- ----- args [] builtin false command my-custom-plugin deprecation_status n/a name my-custom-plugin sha256 33e72f3d30ff2acdbf3cf3c8fa1c8945b60dab876c4226ab25617a63c9f16cc5 version n/a   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"plugin","url":"/openbao/docs/commands/plugin/#usage","content":" Usage: bao plugin &lt;subcommand&gt; [options] [args] # ... Subcommands: deregister Deregister an existing plugin in the catalog info Read information about a plugin in the catalog list Lists available plugins register Registers a new plugin in the catalog reload Reload mounted plugin backend reload-status Get the status of an active or recently completed global plugin reload   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"pki reissue","type":0,"sectionRef":"#","url":"/openbao/docs/commands/pki/reissue/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"pki reissue","url":"/openbao/docs/commands/pki/reissue/#usage","content":" Usage: bao pki reissue [flags] &lt;parent&gt; &lt;template&gt; &lt;child_mount&gt; [options]  [flags] are optional arguments described below. &lt;parent&gt; is the fully qualified path of the Certificate Authority in OpenBao which will issue the new intermediate certificate. &lt;template&gt; is the fully qualified path of an intermediate certificate in OpenBao which will be used to populate certificate fields not overridden by [options].  warning Note: not all possible certificate fields are supported by OpenBao, and this template reader covers only those OpenBao generates as a best effort. If unknown fields are set, such as when an external CA was imported into OpenBao, there may not be a warning that those are missing from the new issuer.  &lt;child_mount&gt; is the path of the mount in OpenBao where the new issuer is saved. [options] are the superset of the k=v options passed to generate/intermediate and sign-intermediate commands. See below.  The output of this command when it is successful is to read the resulting new issuer entry.  ","version":"Next","tagName":"h2"},{"title":"Flags​","type":1,"pageTitle":"pki reissue","url":"/openbao/docs/commands/pki/reissue/#flags","content":" -type (string: &quot;internal&quot;) - This determines the type of key use for the newly created certificate. Valid types are &quot;existing&quot; - where we link to a key already present in the OpenBao-backend to be used - &quot;internal&quot; - to generate a new key for this certificate - or &quot;kms&quot; - to link to an external key. Exported keys are not available through this API.  warning Note: It is only possible to generate a new certificate with an existing key that exists in the same mount where that key-material exists. This command is expected to fail should the template exist on a different mount,existing is the selected type, and no key_ref for a key in the new issuer mount is provided.  -issuer_name (string: &quot;&quot;) - If present, the newly created issuer will be given this name.  ","version":"Next","tagName":"h3"},{"title":"Options​","type":1,"pageTitle":"pki reissue","url":"/openbao/docs/commands/pki/reissue/#options","content":" Other than type (which is passed as a flag, see above), this command accepts all options provided to theGenerate CSR andSign Intermediate endpoints.  ","version":"Next","tagName":"h3"},{"title":"Accessed APIs​","type":1,"pageTitle":"pki reissue","url":"/openbao/docs/commands/pki/reissue/#accessed-apis","content":" Note that the OpenBao user running this command will need to have access to the following API endpoints, each representing a step in the process:  READ /:parent - used to check validityREAD /:template - used to generate the options for the new certificateWRITE /:child_mount/intermediate/generate/:type - used to generate the csrWRITE /:parent/sign-intermediate - used to sign the csrWRITE /:child_mount/issuers/import/cert - used to import the new issuer, and the issuer chainUPDATE /:child_mount/issuer/:issuer_refs - used to both name the new issuer, and also set the name of the parent in the issuer chainREAD /:child_mount/issuer/:new_issuer_ref - used to verify completion, generate the output  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"pki reissue","url":"/openbao/docs/commands/pki/reissue/#examples","content":" $ bao pki reissue -issuer_name=&quot;SecondDepartment&quot; /pki_root/issuer/default /pki_int/issuer/FirstDepartment /pki_int_2/ common_name=&quot;second-department.example.com&quot; Key Value --- ----- ca_chain [-----BEGIN CERTIFICATE----- MIID0DCCArigAwIBAgIUdfRe05B5eRXsg3pvsJ/g94eYuWkwDQYJKoZIhvcNAQEL```  ","version":"Next","tagName":"h2"},{"title":"plugin info","type":0,"sectionRef":"#","url":"/openbao/docs/commands/plugin/info/","content":"","keywords":"","version":"Next"},{"title":"deprecation_status field​","type":1,"pageTitle":"plugin info","url":"/openbao/docs/commands/plugin/info/#deprecation_status-field","content":" As of 1.12, all builtin plugins will have an associated Deprecation Status. This status will be reflected in the deprecation_status key/value pair, seen below.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"plugin info","url":"/openbao/docs/commands/plugin/info/#examples","content":" Display information about a plugin  $ bao plugin info -version=v1.0.0 auth my-custom-plugin Key Value --- ----- args [] builtin false command my-custom-plugin deprecation_status n/a name my-custom-plugin sha256 04ce575260fa3a2cfc477d13ac327108c50838a03917ec4d6df38ecdc64452d1 version v1.0.0   $ bao plugin info database postgresql-database-plugin Key Value --- ----- args [] builtin true command n/a deprecation_status supported name postgresql-database-plugin sha256 n/a version n/a   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"plugin info","url":"/openbao/docs/commands/plugin/info/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"plugin info","url":"/openbao/docs/commands/plugin/info/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"plugin info","url":"/openbao/docs/commands/plugin/info/#command-options","content":" -plugin-version (string: &quot;&quot;) - Semantic version of the plugin to read from the catalog. If unspecified, refers to the unversioned plugin registered with the same name and type, or the built-in plugin, in that order of precedence. ","version":"Next","tagName":"h3"},{"title":"plugin list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/plugin/list/","content":"","keywords":"","version":"Next"},{"title":"Deprecation status column​","type":1,"pageTitle":"plugin list","url":"/openbao/docs/commands/plugin/list/#deprecation-status-column","content":" As of 1.12, all builtin plugins will have an associated Deprecation Status. This status will be reflected in the Deprecation Status column, seen below. All non-builtin plugins will show a Deprecation Status of &quot;n/a&quot;.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"plugin list","url":"/openbao/docs/commands/plugin/list/#examples","content":" List all available plugins in the catalog.  $ bao plugin list Name Type Version ---- ---- ------- approle auth v1.14.8+builtin.bao # ... $ bao plugin list database Name Version ---- ------- cassandra-database-plugin v1.13.0+builtin.bao # ...   List detailed plugin information:  $ bao plugin list -detailed Name Type Version Deprecation Status ---- ---- ------- ------------------ approle auth v1.14.8+builtin.bao supported # ...   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"plugin list","url":"/openbao/docs/commands/plugin/list/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"plugin list","url":"/openbao/docs/commands/plugin/list/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"plugin list","url":"/openbao/docs/commands/plugin/list/#command-options","content":" -detailed (bool: false) - Print detailed information such as version and deprecation status about each plugin. ","version":"Next","tagName":"h3"},{"title":"plugin deregister","type":0,"sectionRef":"#","url":"/openbao/docs/commands/plugin/deregister/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"plugin deregister","url":"/openbao/docs/commands/plugin/deregister/#examples","content":" Deregister a plugin:  $ bao plugin deregister auth my-custom-plugin Success! Deregistered plugin (if it was registered): my-custom-plugin   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"plugin deregister","url":"/openbao/docs/commands/plugin/deregister/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -version (string: &quot;&quot;) - Semantic version of the plugin to deregister. If unset, only an unversioned plugin may be deregistered. ","version":"Next","tagName":"h2"},{"title":"plugin reload","type":0,"sectionRef":"#","url":"/openbao/docs/commands/plugin/reload/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"plugin reload","url":"/openbao/docs/commands/plugin/reload/#examples","content":" Reload a plugin by name:  $ bao plugin reload -plugin my-custom-plugin Success! Reloaded plugin: my-custom-plugin   Reload an auth plugin by mount:  $ bao plugin reload \\ -mounts auth/my-custom-plugin-1 \\ -mounts auth/my-custom-plugin-2 Success! Reloaded mounts: [auth/my-custom-plugin-1/ auth/my-custom-plugin-2/]   Reload a secrets plugin by mount:  $ bao plugin reload \\ -mounts my-custom-plugin-1 \\ -mounts my-custom-plugin-2 Success! Reloaded mounts: [my-custom-plugin-1/ my-custom-plugin-2/]   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"plugin reload","url":"/openbao/docs/commands/plugin/reload/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Command options​","type":1,"pageTitle":"plugin reload","url":"/openbao/docs/commands/plugin/reload/#command-options","content":" -plugin (string: &quot;&quot;) - The name of the plugin to reload, as registered in the plugin catalog. -mounts (array: []) - Array or comma-separated string mount paths of the plugin backends to reload. -scope (string: &quot;&quot;) - The scope of the reload. For local reloads, omit this flag. For reloads that span multiple OpenBao clusters, use global. ","version":"Next","tagName":"h3"},{"title":"plugin register","type":0,"sectionRef":"#","url":"/openbao/docs/commands/plugin/register/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"plugin register","url":"/openbao/docs/commands/plugin/register/#examples","content":" Register a plugin:  $ bao plugin register \\ -sha256=d3f0a8be02f6c074cf38c9c99d4d04c9c6466249 \\ auth my-custom-plugin Success! Registered plugin: my-custom-plugin   Register a plugin with custom args:  $ bao plugin register \\ -sha256=d3f0a8be02f6c074cf38c9c99d4d04c9c6466249 \\ -args=--with-glibc,--with-curl-bindings \\ auth my-custom-plugin   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"plugin register","url":"/openbao/docs/commands/plugin/register/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"plugin register","url":"/openbao/docs/commands/plugin/register/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"plugin register","url":"/openbao/docs/commands/plugin/register/#command-options","content":" -sha256 (string: &lt;required&gt;) - Checksum (SHA256) of the plugin binary. -args (string: &quot;&quot;) - List of arguments to pass to the binary plugin during each invocation. Specify multiple arguments with commas. -command (string: &quot;&quot;) - Name of the command to run to invoke the binary. By default, this is the name of the plugin. -plugin-version (string: &quot;&quot;) - Semantic version of the plugin to run from the catalog. If unspecified, refers to the unversioned plugin registered with the same name and type, or the built-in plugin, in that order of precedence. ","version":"Next","tagName":"h3"},{"title":"policy","type":0,"sectionRef":"#","url":"/openbao/docs/commands/policy/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"policy","url":"/openbao/docs/commands/policy/#examples","content":" List all enabled policies:  $ bao policy list   Create a policy named &quot;my-policy&quot; from contents on local disk:  $ bao policy write my-policy ./my-policy.hcl   Delete the policy named my-policy:  $ bao policy delete my-policy   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"policy","url":"/openbao/docs/commands/policy/#usage","content":" Usage: bao policy &lt;subcommand&gt; [options] [args] # ... Subcommands: delete Deletes a policy by name list Lists the installed policies read Prints the contents of a policy write Uploads a named policy from a file   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"policy delete","type":0,"sectionRef":"#","url":"/openbao/docs/commands/policy/delete/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"policy delete","url":"/openbao/docs/commands/policy/delete/#examples","content":" Delete the policy named &quot;my-policy&quot;:  $ bao policy delete my-policy   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"policy delete","url":"/openbao/docs/commands/policy/delete/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"policy fmt","type":0,"sectionRef":"#","url":"/openbao/docs/commands/policy/fmt/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"policy fmt","url":"/openbao/docs/commands/policy/fmt/#examples","content":" Format the local file &quot;my-policy.hcl&quot;:  $ bao policy fmt my-policy.hcl   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"policy fmt","url":"/openbao/docs/commands/policy/fmt/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"policy read","type":0,"sectionRef":"#","url":"/openbao/docs/commands/policy/read/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"policy read","url":"/openbao/docs/commands/policy/read/#examples","content":" Read the policy named &quot;my-policy&quot;:  $ bao policy read my-policy   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"policy read","url":"/openbao/docs/commands/policy/read/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"policy read","url":"/openbao/docs/commands/policy/read/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"policy list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/policy/list/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"policy list","url":"/openbao/docs/commands/policy/list/#examples","content":" List the available policies:  $ bao policy list default root   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"policy list","url":"/openbao/docs/commands/policy/list/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"policy list","url":"/openbao/docs/commands/policy/list/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"proxy","type":0,"sectionRef":"#","url":"/openbao/docs/commands/proxy/","content":"proxy Please see the OpenBao Proxy documentation page.","keywords":"","version":"Next"},{"title":"read","type":0,"sectionRef":"#","url":"/openbao/docs/commands/read/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"read","url":"/openbao/docs/commands/read/#examples","content":" Read entity details of a given ID:  $ bao read identity/entity/id/2f09126d-d161-abb8-2241-555886491d97   ","version":"Next","tagName":"h2"},{"title":"API versus CLI​","type":1,"pageTitle":"read","url":"/openbao/docs/commands/read/#api-versus-cli","content":" Assuming that you have K/V version 2 (kv-v2) secrets engine enabled atsecret/, the following command reads secrets at the secret/data/customersAPI path:  $ bao read secret/data/customers   This is equivalent to:  $ curl --request GET --header &quot;X-Vault-Token: $OPENBAO_TOKEN&quot; \\ $OPENBAO_ADDR/v1/secret/data/customers   Since K/V secrets engine is a commonly used feature, OpenBao CLI provides thekv command. Read secrets from the secret/data/customerspath using the kv CLI command:  $ bao kv get -mount=secret customers   info Comparison: All three commands retrieve the same data, but display the output in a different format. By default, bao read prints output in key-value format. The curl command prints the response in JSON. Since thekv command is designed to handle operations associated with K/V secrets engine, it prints the output in more structured format that is easy to read.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"read","url":"/openbao/docs/commands/read/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"read","url":"/openbao/docs/commands/read/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, &quot;yaml&quot;, or &quot;raw&quot;. This can also be specified via the VAULT_FORMAT environment variable.  For a full list of examples and paths, please see the documentation that corresponds to the secrets engine in use. ","version":"Next","tagName":"h3"},{"title":"policy write","type":0,"sectionRef":"#","url":"/openbao/docs/commands/policy/write/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"policy write","url":"/openbao/docs/commands/policy/write/#examples","content":" Upload a policy named &quot;my-policy&quot; from &quot;/tmp/policy.hcl&quot; on the local disk:  $ bao policy write my-policy /tmp/policy.hcl   Upload a policy from stdin:  $ cat my-policy.hcl | bao policy write my-policy -   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"policy write","url":"/openbao/docs/commands/policy/write/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"print","type":0,"sectionRef":"#","url":"/openbao/docs/commands/print/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"print","url":"/openbao/docs/commands/print/#examples","content":" Print the current token.  $ bao print token hvs.CAESICaie3Dm0_Hx001QuMabo1IXnyKkx_FuE14MH7zir_bqGh4KHGh2cy5wQnJsZzZ6WG82b29HUlI3eFdEQ0NPQzQ  ","version":"Next","tagName":"h2"},{"title":"secrets enable","type":0,"sectionRef":"#","url":"/openbao/docs/commands/secrets/enable/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"secrets enable","url":"/openbao/docs/commands/secrets/enable/#examples","content":" Enable the KV secrets engine at &quot;kv/&quot;:  $ bao secrets enable kv Success! Enabled the kv secrets engine at: kv/   Enable the SSH secrets engine at ssh-prod/:  $ bao secrets enable -path=ssh-prod ssh   Enable the database secrets engine with an explicit maximum TTL of 30m:  $ bao secrets enable -max-lease-ttl=30m database   Enable a custom plugin (after it is registered in the plugin registry):  $ bao secrets enable -path=my-secrets my-plugin   For more information on the specific configuration options and paths, please see the secrets engine documentation.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"secrets enable","url":"/openbao/docs/commands/secrets/enable/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -audit-non-hmac-request-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the request data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. An example of this is provided in the tune section. -audit-non-hmac-response-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the response data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -default-lease-ttl (duration: &quot;&quot;) - The default lease TTL for this secrets engine. If unspecified, this defaults to the OpenBao server's globally configured default lease TTL. -description (string: &quot;&quot;) - Human-friendly description for the purpose of this engine. -force-no-cache (bool: false) - Force the secrets engine to disable caching. If unspecified, this defaults to the OpenBao server's globally configured cache settings. This does not affect caching of the underlying encrypted data storage. -local (bool: false) - Mark the secrets engine as local-only. Local engines are not replicated or removed by replication. -max-lease-ttl (duration: &quot;&quot;) The maximum lease TTL for this secrets engine. If unspecified, this defaults to the OpenBao server's globally configured maximum lease TTL. -path (string: &quot;&quot;) Place where the secrets engine will be accessible. This must be unique cross all secrets engines. This defaults to the &quot;type&quot; of the secrets engine.  danger Case-sensitive: The path where you enable secrets engines is case-sensitive. For example, the KV secrets engine enabled at kv/ and KV/ are treated as two distinct instances of KV secrets engine.  -passthrough-request-headers (string: &quot;&quot;) - request header values that will be sent to the secrets engine. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -allowed-response-headers (string: &quot;&quot;) - response header values that the secrets engine will be allowed to set. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -plugin-version (string: &quot;&quot;) - Configures the semantic version of the plugin to use. If unspecified, implies the built-in or any matching unversioned plugin that may have been registered. ","version":"Next","tagName":"h2"},{"title":"secrets list","type":0,"sectionRef":"#","url":"/openbao/docs/commands/secrets/list/","content":"","keywords":"","version":"Next"},{"title":"Deprecation status column​","type":1,"pageTitle":"secrets list","url":"/openbao/docs/commands/secrets/list/#deprecation-status-column","content":" As of 1.12, all built-in secrets engines will have an associated Deprecation Status. This status will be reflected in the Deprecation Status column, seen below. All secrets engines which are not provided by built-in plugins will show aDeprecation Status of &quot;n/a&quot;.  ","version":"Next","tagName":"h2"},{"title":"Version columns​","type":1,"pageTitle":"secrets list","url":"/openbao/docs/commands/secrets/list/#version-columns","content":" The -detailed view displays some version information for each mount.  The Version field indicates the configured version for the plugin. Empty, or &quot;n/a&quot;, indicates the built-in or any matching unversioned plugin that may have been registered.  Running Version indicates the actual plugin version running, which may differ from Version if the plugin hasn't been reloaded since the configured version was updated using the secrets tune command. Finally, the Running SHA256 field indicates the SHA256 sum of the running plugin's binary. This may be different from the SHA256 registered in the catalog if the plugin hasn't been reloaded since the plugin version was overwritten in the catalog.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"secrets list","url":"/openbao/docs/commands/secrets/list/#examples","content":" List all enabled secrets engines:  $ bao secrets list Path Type Accessor Description ---- ---- -------- ----------- cubbyhole/ cubbyhole cubbyhole_548b4dc5 per-token private secret storage secret/ kv identity_aa00c06d key/value secret storage sys/ system system_547412e3 system endpoints used for control, policy and debugging   List all enabled secrets engines with detailed output:  $ bao secrets list -detailed Path Plugin Accessor Default TTL Max TTL Force No Cache Replication Seal Wrap External Entropy Access Options Description UUID Version Running Version Running SHA256 Deprecation Status ---- ------ -------- ----------- ------- -------------- ----------- --------- ----------------------- ------- ----------- ---- ------- --------------- -------------- ------------------ cubbyhole/ cubbyhole cubbyhole_b16d1bc0 n/a n/a false local false false map[] per-token private secret storage 8c64d56b-9d46-d667-1155-a8c1a83a5d01 n/a v1.12.0+builtin.bao n/a n/a identity/ identity identity_3d67c936 system system false replicated false false map[] identity store 5aa1e59c-33b5-9dec-05d6-c80c9a800557 n/a v1.12.0+builtin.bao n/a n/a postgresql/ postgresql postgresql_f0a54308 system system false replicated false false map[] n/a 8cdc1d2d-0713-eaa6-17e3-49790a60650b n/a v1.12.0+builtin.bao n/a deprecated sys/ system system_c86bd362 n/a n/a false replicated true false map[] system endpoints used for control, policy and debugging e3193999-0875-d38d-3458-21d9f2762c80 n/a v1.12.0+builtin.bao n/a n/a   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"secrets list","url":"/openbao/docs/commands/secrets/list/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"secrets list","url":"/openbao/docs/commands/secrets/list/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"secrets list","url":"/openbao/docs/commands/secrets/list/#command-options","content":" -detailed (bool: false) - Print detailed information such as configuration and replication status about each secrets engine. ","version":"Next","tagName":"h3"},{"title":"secrets","type":0,"sectionRef":"#","url":"/openbao/docs/commands/secrets/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"secrets","url":"/openbao/docs/commands/secrets/#examples","content":" Enable a secrets engine:  $ bao secrets enable database Success! Enabled the database secrets engine at: database/   List all secrets engines:  $ bao secrets list Path Type Description ---- ---- ----------- cubbyhole/ cubbyhole per-token private secret storage database/ database n/a secret/ kv key/value secret storage sys/ system system endpoints used for control, policy and debugging   Move a secrets engine to a new path:  $ bao secrets move database/ db-prod/ Success! Moved secrets engine database/ to: db-prod/   Tune a secrets engine:  $ bao secrets tune -max-lease-ttl=30m db-prod/ Success! Tuned the secrets engine at: db-prod/   Disable a secrets engine:  $ bao secrets disable db-prod/ Success! Disabled the secrets engine (if it existed) at: db-prod/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"secrets","url":"/openbao/docs/commands/secrets/#usage","content":" Usage: bao secrets &lt;subcommand&gt; [options] [args] # ... Subcommands: disable Disable a secrets engine enable Enable a secrets engine list List enabled secrets engines move Move a secrets engine to a new path tune Tune a secrets engine configuration   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"secrets disable","type":0,"sectionRef":"#","url":"/openbao/docs/commands/secrets/disable/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"secrets disable","url":"/openbao/docs/commands/secrets/disable/#examples","content":" Disable the secrets engine enabled at kv/:  $ bao secrets disable kv/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"secrets disable","url":"/openbao/docs/commands/secrets/disable/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands.  ","version":"Next","tagName":"h2"},{"title":"Force disable​","type":1,"pageTitle":"secrets disable","url":"/openbao/docs/commands/secrets/disable/#force-disable","content":" Because secrets disable revokes secrets associated with this mount, possible errors can prevent the secrets engine from being disabled if the revocation fails.  The best way to resolve this is to figure out the underlying issue and then disable the secrets engine once the underlying issue is resolved. Often, this can be as simple as increasing the timeout (in the event of timeout errors).  For recovery situations where the secret was manually removed from the secrets backing service, one can force a secrets engine disable in OpenBao by performing a prefix force revoke on the mount prefix, followed by a secrets disable when that completes. If the underlying secrets were not manually cleaned up, this method might result in dangling credentials. This is meant for extreme circumstances. ","version":"Next","tagName":"h2"},{"title":"secrets move","type":0,"sectionRef":"#","url":"/openbao/docs/commands/secrets/move/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"secrets move","url":"/openbao/docs/commands/secrets/move/#examples","content":" Move the existing secrets engine at ns1/secret/ to ns2/kv/:  $ bao secrets move ns1/secret/ ns2/kv/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"secrets move","url":"/openbao/docs/commands/secrets/move/#usage","content":" There are no flags beyond the standard set of flagsincluded on all commands. ","version":"Next","tagName":"h2"},{"title":"ssh","type":0,"sectionRef":"#","url":"/openbao/docs/commands/ssh/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"ssh","url":"/openbao/docs/commands/ssh/#examples","content":" SSH using the OTP mode (requires sshpassfor full automation):  $ bao ssh -mode=otp -role=my-role user@1.2.3.4   SSH using the CA mode:  $ bao ssh -mode=ca -role=my-role user@1.2.3.4   SSH using CA mode with host key verification:  $ bao ssh \\ -mode=ca \\ -role=my-role \\ -host-key-mount-point=host-signer \\ -host-key-hostnames=example.com \\ user@example.com   For step-by-step guides and instructions for each of the available SSH auth methods, please see the corresponding SSH secrets engine.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"ssh","url":"/openbao/docs/commands/ssh/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"ssh","url":"/openbao/docs/commands/ssh/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"SSH options​","type":1,"pageTitle":"ssh","url":"/openbao/docs/commands/ssh/#ssh-options","content":" -mode (string: &quot;&quot;) - Name of the authentication mode (ca, dynamic, otp).&quot; -mount-point (string: &quot;ssh/&quot;) - Mount point to the SSH secrets engine. -no-exec (bool: false) - Print the generated credentials, but do not establish a connection. -role (string: &quot;&quot;) - Name of the role to use to generate the key. -strict-host-key-checking (string: &quot;&quot;) - Value to use for the SSH configuration option &quot;StrictHostKeyChecking&quot;. The default is ask. This can also be specified via the VAULT_SSH_STRICT_HOST_KEY_CHECKING environment variable. -user-known-hosts-file (string: &quot;~/.ssh/known_hosts&quot;) - Value to use for the SSH configuration option &quot;UserKnownHostsFile&quot;. This can also be specified via the VAULT_SSH_USER_KNOWN_HOSTS_FILE environment variable.  ","version":"Next","tagName":"h3"},{"title":"CA mode options​","type":1,"pageTitle":"ssh","url":"/openbao/docs/commands/ssh/#ca-mode-options","content":" -host-key-hostnames (string: &quot;*&quot;) - List of hostnames to delegate for the CA. The default value allows all domains and IPs. This is specified as a comma-separated list of values. This can also be specified via theVAULT_SSH_HOST_KEY_HOSTNAMES environment variable. -host-key-mount-point (string: &quot;&quot;) - Mount point to the SSH secrets engine where host keys are signed. When given a value, OpenBao will generate a custom &quot;known_hosts&quot; file with delegation to the CA at the provided mount point to verify the SSH connection's host keys against the provided CA. By default, host keys are validated against the user's local &quot;known_hosts&quot; file. This flag forces strict key host checking and ignores a custom user known hosts file. This can also be specified via theVAULT_SSH_HOST_KEY_MOUNT_POINT environment variable. -private-key-path (string: &quot;~/.ssh/id_rsa&quot;) - Path to the SSH private key to use for authentication. This must be the corresponding private key to-public-key-path. -public-key-path (string: &quot;~/.ssh/id_rsa.pub&quot;) - Path to the SSH public key to send to OpenBao for signing. ","version":"Next","tagName":"h3"},{"title":"status","type":0,"sectionRef":"#","url":"/openbao/docs/commands/status/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"status","url":"/openbao/docs/commands/status/#examples","content":" Check the status:  $ bao status Sealed: false Key Shares: 5 Key Threshold: 3 Unseal Progress: 0 Unseal Nonce: Version: x.y.z Build Date: 2022-05-03T08:34:11Z Cluster Name: openbao-cluster-49ffd45f Cluster ID: d2dad792-fb99-1c8d-452e-528d073ba205 High-Availability Enabled: false   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"status","url":"/openbao/docs/commands/status/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"status","url":"/openbao/docs/commands/status/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  By default, the output is displayed in &quot;table&quot; format.  Output fields​  The field for total shares is displayed as &quot;n&quot; instead of n in yaml outputs.The following fields in &quot;table&quot; format are displayed only when relevant:  &quot;Unseal Progress&quot; and &quot;Unseal Nonce&quot; are displayed when OpenBao is sealed.&quot;Seal Migration in Progress&quot; is displayed when it is in progress.&quot;Cluster Name&quot; and &quot;Cluster ID&quot; are displayed if they have a value.&quot;Raft Committed Index&quot;, &quot;Raft Applied Index&quot;, &quot;Last WAL&quot; are diplayed if they are non-zero.&quot;Warnings&quot; are displayed if the warnings apply.The following fields are displayed only when HA mode is enabled and is unsealed: &quot;HA Cluster&quot;.&quot;HA Mode&quot;.&quot;Active Since&quot; is displayed if the node is active and has a valid active time. ","version":"Next","tagName":"h3"},{"title":"secrets tune","type":0,"sectionRef":"#","url":"/openbao/docs/commands/secrets/tune/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"secrets tune","url":"/openbao/docs/commands/secrets/tune/#examples","content":" Before tuning the secret mount, view the current configuration of the mount enabled at &quot;pki/&quot;:  $ bao read sys/mounts/pki/tune Key Value --- ----- default_lease_ttl 12h description Example PKI mount force_no_cache false max_lease_ttl 24h   Tune the default lease, exclude common_name and serial_number from being HMAC'd in the audit log for the PKI secrets engine:  $ bao secrets tune -default-lease-ttl=18h -audit-non-hmac-request-keys=common_name -audit-non-hmac-response-keys=serial_number pki/ Success! Tuned the secrets engine at: pki/ $ bao read sys/mounts/pki/tune Key Value --- ----- audit_non_hmac_request_keys [common_name] audit_non_hmac_response_keys [serial_number] default_lease_ttl 18h description Example PKI mount force_no_cache false max_lease_ttl 24h   Specify multiple audit non-hmac request keys:  $ bao secrets tune -audit-non-hmac-request-keys=common_name -audit-non-hmac-request-keys=ttl pki/   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"secrets tune","url":"/openbao/docs/commands/secrets/tune/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -allowed-response-headers (string: &quot;&quot;) - response header values that the secrets engine will be allowed to set. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -audit-non-hmac-request-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the request data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -audit-non-hmac-response-keys (string: &quot;&quot;) - Key that will not be HMAC'd by audit devices in the response data object. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -default-lease-ttl (duration: &quot;&quot;) - The default lease TTL for this secrets engine. If unspecified, this defaults to the OpenBao server's globally configured default lease TTL, or a previously configured value for the secrets engine. Uses duration format strings. -description (string: &quot;&quot;) - Specifies the description of the mount. This overrides the current stored value, if any. -listing-visibility (string: &quot;&quot;) - The flag to toggle whether to show the mount in the UI-specific listing endpoint. Valid values are &quot;unauth&quot; or &quot;hidden&quot;. Passing empty string leaves the current setting unchanged. -max-lease-ttl (duration: &quot;&quot;) - The maximum lease TTL for this secrets engine. If unspecified, this defaults to the OpenBao server's globally configured maximum lease TTL, or a previously configured value for the secrets engine. This value is allowed to override the server's global max TTL; it can be longer or shorter. Uses duration format strings. -passthrough-request-headers (string: &quot;&quot;) - request header values that will be sent to the secrets engine. Note that multiple keys may be specified by providing this option multiple times, each time with 1 key. -plugin-version (string: &quot;&quot;) - Configures the semantic version of the plugin to use. The new version will not start running until the mount isreloaded. ","version":"Next","tagName":"h2"},{"title":"server","type":0,"sectionRef":"#","url":"/openbao/docs/commands/server/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"server","url":"/openbao/docs/commands/server/#examples","content":" Start a server with a configuration file:  $ bao server -config=/etc/openbao/config.hcl   Run in &quot;dev&quot; mode with a custom initial root token:  $ bao server -dev -dev-root-token-id=&quot;root&quot;   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"server","url":"/openbao/docs/commands/server/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Command options​","type":1,"pageTitle":"server","url":"/openbao/docs/commands/server/#command-options","content":" -config (string: &quot;&quot;) - Path to a configuration file or directory of configuration files. This flag can be specified multiple times to load multiple configurations. If the path is a directory, all files which end in .hcl or .json are loaded. -log-level (string: &quot;info&quot;) - Log verbosity level. Supported values (in order of descending detail) are trace, debug, info, warn, and error. This can also be specified via the VAULT_LOG_LEVEL environment variable. -log-format (string: &quot;standard&quot;) - Log format. Supported values are standard and json. This can also be specified via theVAULT_LOG_FORMAT environment variable. -log-file - the absolute path where OpenBao should save log messages in addition to other, existing outputs like journald / stdout. Paths that end with a path separator use the default file name, openbao.log. Paths that do not end with a file extension use the default .log extension. If the log file rotates, OpenBao appends the current timestamp to the file name at the time of rotation. For example: log-file\tFull log file\tRotated log file/var/log\t/var/log/openbao.log\t/var/log/openbao-{timestamp}.log /var/log/my-diary\t/var/log/my-diary.log\t/var/log/my-diary-{timestamp}.log /var/log/my-diary.txt\t/var/log/my-diary.txt\t/var/log/my-diary-{timestamp}.txt -log-rotate-bytes - to specify the number of bytes that should be written to a log before it needs to be rotated. Unless specified, there is no limit to the number of bytes that can be written to a log file. -log-rotate-duration - to specify the maximum duration a log should be written to before it needs to be rotated. Must be a duration value such as 30s. Defaults to 24h. -log-rotate-max-files - to specify the maximum number of older log file archives to keep. Defaults to 0 (no files are ever deleted). Set to -1 to discard old log files when a new one is created. -experiment (string array: []) - The name of an experiment to enable for this node. This flag can be specified multiple times to enable multiple experiments. Experiments should NOT be used in production, and the associated APIs may have backwards incompatible changes between releases. Additional experiments can also be specified via theVAULT_EXPERIMENTS environment variable as a comma-separated list, or via theexperiments config key. VAULT_ALLOW_PENDING_REMOVAL_MOUNTS (bool: false) - (environment variable) Allow OpenBao to be started with builtin engines which have the Pending Removaldeprecation state. This is a temporary stopgap in place in order to perform an upgrade and disable these engines. Once these engines are marked Removed (in the next major release of OpenBao), the environment variable will no longer work and a downgrade must be performed in order to remove the offending engines. For more information, see the deprecation faq.  ","version":"Next","tagName":"h3"},{"title":"Dev options​","type":1,"pageTitle":"server","url":"/openbao/docs/commands/server/#dev-options","content":" -dev (bool: false) - Enable development mode. In this mode, OpenBao runs in-memory and starts unsealed. As the name implies, do not run &quot;dev&quot; mode in production. -dev-tls (bool: false) - Enable TLS development mode. In this mode, OpenBao runs in-memory and starts unsealed with a generated TLS CA, certificate and key. As the name implies, do not run &quot;dev&quot; mode in production. -dev-tls-cert-dir (string: &quot;&quot;) - Directory where generated TLS files are created if -dev-tls is specified. If left unset, files are generated in a temporary directory. -dev-listen-address (string: &quot;127.0.0.1:8200&quot;) - Address to bind to in &quot;dev&quot; mode. This can also be specified via the VAULT_DEV_LISTEN_ADDRESSenvironment variable. -dev-root-token-id (string: &quot;&quot;) - Initial root token. This only applies when running in &quot;dev&quot; mode. This can also be specified via theVAULT_DEV_ROOT_TOKEN_ID environment variable. Note: The token ID should not start with the s. prefix. -dev-no-store-token (string: &quot;&quot;) - Do not persist the dev root token to the token helper (usually the local filesystem) for use in future requests. The token will only be displayed in the command output. -dev-plugin-dir (string: &quot;&quot;) - Directory from which plugins are allowed to be loaded. Only applies in &quot;dev&quot; mode, it will automatically register all the plugins in the provided directory. ","version":"Next","tagName":"h3"},{"title":"Token helpers","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token-helper/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Token helpers","url":"/openbao/docs/commands/token-helper/#configuration","content":" To configure a token helper, edit (or create) the file ~/.openbao and add a line similar to:  token_helper = &quot;/path/to/token/helper.sh&quot;   You will need to use the fully qualified path to the token helper script. The script should be executable.  ","version":"Next","tagName":"h2"},{"title":"Developing a token helper​","type":1,"pageTitle":"Token helpers","url":"/openbao/docs/commands/token-helper/#developing-a-token-helper","content":" The interface to a token helper is extremely simple: the script is passed with one argument that could be get, store or erase. If the argument is get, the script should do whatever work it needs to do to retrieve the stored token and then print the token to STDOUT. If the argument is store, OpenBao is asking you to store the token. Finally, if the argument is erase, your program should erase the stored token.  If your program succeeds, it should exit with status code 0. If it encounters an issue that prevents it from working, it should exit with some other status code. You should write a user-friendly error message to STDERR. You should never write anything other than the token to STDOUT, as OpenBao assumes whatever it gets on STDOUT is the token.  ","version":"Next","tagName":"h2"},{"title":"Example token helper​","type":1,"pageTitle":"Token helpers","url":"/openbao/docs/commands/token-helper/#example-token-helper","content":" This is an example token helper written in Ruby that stores and retrieves tokens in a json file called ~/.openbao_tokens. The key is the environment variable $VAULT_ADDR, this allows the OpenBao user to easily store and retrieve tokens from a number of different OpenBao servers.  #!/usr/bin/env ruby require 'json' unless ENV['VAULT_ADDR'] STDERR.puts &quot;No VAULT_ADDR environment variable set. Set it and run me again!&quot; exit 100 end begin tokens = JSON.parse(File.read(&quot;#{ENV['HOME']}/.openbao_tokens&quot;)) rescue Errno::ENOENT =&gt; e # file doesn't exist so create a blank hash for it tokens = {} end case ARGV.first when 'get' print tokens[ENV['VAULT_ADDR']] if tokens[ENV['VAULT_ADDR']] exit 0 when 'store' tokens[ENV['VAULT_ADDR']] = STDIN.read when 'erase' tokens.delete!(ENV['VAULT_ADDR']) end File.open(&quot;#{ENV['HOME']}/.openbao_tokens&quot;, 'w') { |file| file.write(tokens.to_json) }  ","version":"Next","tagName":"h3"},{"title":"token","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"token","url":"/openbao/docs/commands/token/#examples","content":" Create a new token:  $ bao token create   Revoke a token:  $ bao token revoke 96ddf4bc-d217-f3ba-f9bd-017055595017   Renew a token:  $ bao token renew 96ddf4bc-d217-f3ba-f9bd-017055595017   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"token","url":"/openbao/docs/commands/token/#usage","content":" Usage: bao token &lt;subcommand&gt; [options] [args] # ... Subcommands: capabilities Print capabilities of a token on a path create Create a new token lookup Display information about a token renew Renew a token lease revoke Revoke a token and its children   For more information, examples, and usage about a subcommand, click on the name of the subcommand in the sidebar. ","version":"Next","tagName":"h2"},{"title":"token capabilities","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token/capabilities/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"token capabilities","url":"/openbao/docs/commands/token/capabilities/#examples","content":" List capabilities for the local token on the &quot;secret/foo&quot; path:  $ bao token capabilities secret/foo read   List capabilities for a token on the &quot;cubbyhole/foo&quot; path:  $ bao token capabilities 96ddf4bc-d217-f3ba-f9bd-017055595017 database/creds/readonly deny   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"token capabilities","url":"/openbao/docs/commands/token/capabilities/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"token capabilities","url":"/openbao/docs/commands/token/capabilities/#output-options","content":" -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"token create","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token/create/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"token create","url":"/openbao/docs/commands/token/create/#examples","content":" Create a token attached to specific policies:  $ bao token create -policy=my-policy -policy=other-policy Key Value --- ----- token 95eba8ed-f6fc-958a-f490-c7fd0eda5e9e token_accessor 882d4a40-3796-d06e-c4f0-604e8503750b token_duration 768h token_renewable true token_policies [default my-policy other-policy]   Create a periodic token:  $ bao token create -period=30m Key Value --- ----- token fdb90d58-af87-024f-fdcd-9f95039e353a token_accessor 4cd9177c-034b-a004-c62d-54bc56c0e9bd token_duration 30m token_renewable true token_policies [my-policy]   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"token create","url":"/openbao/docs/commands/token/create/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"token create","url":"/openbao/docs/commands/token/create/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"token create","url":"/openbao/docs/commands/token/create/#command-options","content":" -display-name (string: &quot;&quot;) - Name to associate with this token. This is a non-sensitive value that can be used to help identify created secrets (e.g. prefixes). -entity-alias (string: &quot;&quot;) - Name of the entity alias to associate with during token creation. Only works in combination with -role argument and used entity alias must be listed in allowed_entity_aliases. If this has been specified, the entity will not be inherited from the parent. -explicit-max-ttl (duration: &quot;&quot;) - Explicit maximum lifetime for the token. Unlike normal TTLs, the maximum TTL is a hard limit and cannot be exceeded. Uses duration format strings. -id (string: &quot;&quot;) - Value for the token. By default, this is an auto-generated value. Specifying this value requires sudo permissions. -metadata (k=v: &quot;&quot;) - Arbitrary key=value metadata to associate with the token. This metadata will show in the audit log when the token is used. This can be specified multiple times to add multiple pieces of metadata. -no-default-policy (bool: false) - Detach the &quot;default&quot; policy from the policy set for this token. -orphan (bool: false) - Create the token with no parent. This prevents the token from being revoked when the token which created it expires. Setting this value requires sudo permissions. -period (duration: &quot;&quot;) - If specified, every renewal will use the given period. Periodic tokens do not expire as long as they are actively being renewed (unless -explicit-max-ttl is also provided). Setting this value requires sudo permissions. Uses duration format strings. -policy (string: &quot;&quot;) - Name of a policy to associate with this token. This can be specified multiple times to attach multiple policies. -renewable (bool: true) - Allow the token to be renewed up to it's maximum TTL. -role (string: &quot;&quot;) - Name of the role to create the token against. Specifying -role may override other arguments. The locally authenticated OpenBao token must have permission for auth/token/create/&lt;role&gt;. -ttl (duration: &quot;&quot;) - Initial TTL to associate with the token. Token renewals may be able to extend beyond this value, depending on the configured maximumTTLs. Uses duration format strings. -type (string: &quot;service&quot;) - The type of token to create. Can be &quot;service&quot; or &quot;batch&quot;. -use-limit (int: 0) - Number of times this token can be used. After the last use, the token is automatically revoked. By default, tokens can be used an unlimited number of times until their expiration. -wrap-ttl (duration: &quot;&quot;) - Wraps the response in a cubbyhole token with the requested TTL. The response is available via the &quot;bao unwrap&quot; command. The TTL is specified as a numeric string with suffix like &quot;30s&quot; or &quot;5m&quot;. This can also be specified via the VAULT_WRAP_TTL environment variable. ","version":"Next","tagName":"h3"},{"title":"token lookup","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token/lookup/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"token lookup","url":"/openbao/docs/commands/token/lookup/#examples","content":" Get information about the locally authenticated token (this uses the/auth/token/lookup-self endpoint and permission):  $ bao token lookup   Get information about a particular token (this uses the /auth/token/lookupendpoint and permission):  $ bao token lookup 96ddf4bc-d217-f3ba-f9bd-017055595017   Get information about a token via its accessor:  $ bao token lookup -accessor 9793c9b3-e04a-46f3-e7b8-748d7da248da   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"token lookup","url":"/openbao/docs/commands/token/lookup/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"token lookup","url":"/openbao/docs/commands/token/lookup/#output-options","content":" -format (default: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"token lookup","url":"/openbao/docs/commands/token/lookup/#command-options","content":" -accessor (bool: false) - Treat the argument as an accessor instead of a token. When this option is selected, the output will NOT include the token. ","version":"Next","tagName":"h3"},{"title":"token revoke","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token/revoke/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"token revoke","url":"/openbao/docs/commands/token/revoke/#examples","content":" Revoke a token and all the token's children:  $ bao token revoke 96ddf4bc-d217-f3ba-f9bd-017055595017 Success! Revoked token (if it existed)   Revoke a token leaving the token's children:  $ bao token revoke -mode=orphan 96ddf4bc-d217-f3ba-f9bd-017055595017 Success! Revoked token (if it existed)   Revoke a token by accessor:  $ bao token revoke -accessor 9793c9b3-e04a-46f3-e7b8-748d7da248da Success! Revoked token (if it existed)   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"token revoke","url":"/openbao/docs/commands/token/revoke/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  -accessor (bool: false) - Treat the argument as an accessor instead of a token. -mode (string: &quot;&quot;) - Type of revocation to perform. If unspecified, OpenBao will revoke the token and all of the token's children. If &quot;orphan&quot;, OpenBao will revoke only the token, leaving the children as orphans. If &quot;path&quot;, tokens created from the given authentication path prefix are deleted along with their children. -self - Perform the revocation on the currently authenticated token. ","version":"Next","tagName":"h2"},{"title":"transit","type":0,"sectionRef":"#","url":"/openbao/docs/commands/transit/","content":"","keywords":"","version":"Next"},{"title":"Syntax​","type":1,"pageTitle":"transit","url":"/openbao/docs/commands/transit/#syntax","content":" Option flags for a given subcommand are provided after the subcommand, but before the arguments.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"transit","url":"/openbao/docs/commands/transit/#examples","content":" To import keys into a mount via theTransit BYOKmechanism, use the bao transit import &lt;path&gt; &lt;key&gt; orbao transit import-version &lt;path&gt; &lt;key&gt; commands:  $ bao transit import transit/keys/test-key @test-key type=rsa-2048 Retrieving transit wrapping key. Wrapping source key with ephemeral key. Encrypting ephemeral key with transit wrapping key. Submitting wrapped key to OpenBao transit. Success!  ","version":"Next","tagName":"h2"},{"title":"transit import and transit import-version","type":0,"sectionRef":"#","url":"/openbao/docs/commands/transit/import/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"transit import and transit import-version","url":"/openbao/docs/commands/transit/import/#examples","content":" Imports a 2048-bit RSA key as a new key:  $ bao transit import transit/keys/test-key @test-key type=rsa-2048 Retrieving transit wrapping key. Wrapping source key with ephemeral key. Encrypting ephemeral key with transit wrapping key. Submitting wrapped key to OpenBao transit. Success!   Imports a new version of an existing key:  $ bao transit import-version transit/keys/test-key @test-key-updated Retrieving transit wrapping key. Wrapping source key with ephemeral key. Encrypting ephemeral key with transit wrapping key. Submitting wrapped key to OpenBao transit. Success!   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"transit import and transit import-version","url":"/openbao/docs/commands/transit/import/#usage","content":" This command does not have any unique flags and respects core OpenBao CLI commands. See bao transit import -help for more information.  This command requires two positional arguments:  PATH, the path to the transit key to import in the format of&lt;mount&gt;/keys/&lt;key-name&gt;, where &lt;mount&gt; is the path to the mount (using -namespace=&lt;ns&gt; to specify any namespaces), and &lt;key-name&gt;is the desired name of the key.KEY, the key material to import in Standard Base64 encoding (either of a raw key in the case of symmetric keys such as AES, or of the DER encoded format for asymmetric keys such as RSA). If the value for KEYbegins with an @, the CLI argument is assumed to be a path to a file on disk to be read. ","version":"Next","tagName":"h2"},{"title":"token renew","type":0,"sectionRef":"#","url":"/openbao/docs/commands/token/renew/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"token renew","url":"/openbao/docs/commands/token/renew/#examples","content":" Renew a token (this uses the /auth/token/renew endpoint and permission):  $ bao token renew 96ddf4bc-d217-f3ba-f9bd-017055595017   Renew the currently authenticated token (this uses the /auth/token/renew-selfendpoint and permission):  $ bao token renew   Renew a token requesting a specific increment value:  $ bao token renew -increment=30m 96ddf4bc-d217-f3ba-f9bd-017055595017   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"token renew","url":"/openbao/docs/commands/token/renew/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"token renew","url":"/openbao/docs/commands/token/renew/#output-options","content":" -format (default: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"token renew","url":"/openbao/docs/commands/token/renew/#command-options","content":" -increment (duration: &quot;&quot;) - Request a specific increment for renewal. OpenBao will not honor this request for periodic tokens. If not supplied, OpenBao will use the default TTL. This is specified as a numeric string with suffix like &quot;30s&quot; or &quot;5m&quot;. This is aliased as &quot;-i&quot;. ","version":"Next","tagName":"h3"},{"title":"unwrap","type":0,"sectionRef":"#","url":"/openbao/docs/commands/unwrap/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"unwrap","url":"/openbao/docs/commands/unwrap/#examples","content":" Unwrap the data in the cubbyhole secrets engine for a token:  $ bao unwrap 3de9ece1-b347-e143-29b0-dc2dc31caafd   Unwrap the data in the active token:  $ bao login 848f9ccf-7176-098c-5e2b-75a0689d41cd $ bao unwrap # unwraps 848f9ccf...   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"unwrap","url":"/openbao/docs/commands/unwrap/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"unwrap","url":"/openbao/docs/commands/unwrap/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable. ","version":"Next","tagName":"h3"},{"title":"Concepts","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/","content":"Concepts This section covers some concepts that are important to understand for day to day OpenBao usage and operation. Every page in this section is recommended reading for anyone consuming or operating OpenBao. Please use the navigation to the left to learn more about a topic.","keywords":"","version":"Next"},{"title":"version","type":0,"sectionRef":"#","url":"/openbao/docs/commands/version/","content":"version The version command prints the OpenBao version: $ bao version OpenBao v1.2.3 It can also be printed by adding the flags --version or -v to the bao command: $ bao -v OpenBao v1.2.3, built 2022-05-03T08:34:11Z ","keywords":"","version":"Next"},{"title":"version-history","type":0,"sectionRef":"#","url":"/openbao/docs/commands/version-history/","content":"version-history The version-history command prints the historical list of installed OpenBao versions in chronological order. Note: Version tracking was added in 1.9.0. Earlier versions have not been tracked. The Build Date will only be available for versions 1.11.0 or greater. Version Installation Time Build Date ------- ----------------- ---------- 1.9.0 2021-11-18T10:23:16Z 1.9.1 2022-12-13T11:09:52Z 1.9.2 2021-12-23T10:56:37Z 1.11.0 2022-05-03T13:16:04Z 2022-05-03T08:34:11Z ## Usage The following flags are available in addition to the [standard set of flags](/docs/commands) included on all commands. ### Output options - `-format` `(string: &quot;table&quot;)` - Print the output in the given format. Valid formats are &quot;table&quot; or json&quot;. This can also be specified via the `VAULT_FORMAT` environment variable. ","keywords":"","version":"Next"},{"title":"write","type":0,"sectionRef":"#","url":"/openbao/docs/commands/write/","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"write","url":"/openbao/docs/commands/write/#examples","content":" Store an arbitrary secrets in the token's cubbyhole.  $ bao write cubbyhole/git-credentials username=&quot;student01&quot; password=&quot;p@$$w0rd&quot;   Create a new encryption key in the transit secrets engine:  $ bao write -force transit/keys/my-key   The -force flag allows the write operation without input data. (See command options.)  ","version":"Next","tagName":"h2"},{"title":"API versus CLI​","type":1,"pageTitle":"write","url":"/openbao/docs/commands/write/#api-versus-cli","content":" Create a token with TTL set to 8 hours, limited to 3 uses, and attach adminand secops policies.  $ bao write auth/token/create policies=&quot;admin&quot; policies=&quot;secops&quot; ttl=8h num_uses=3   Equivalent cURL command for this operation:  $ tee request_payload.json -&lt;&lt;EOF { &quot;policies&quot;: [&quot;admin&quot;, &quot;secops&quot;], &quot;ttl&quot;: &quot;8h&quot;, &quot;num_uses&quot;: 3 } EOF $ curl --header &quot;X-Vault-Token: $OPENBAO_TOKEN&quot; \\ --request POST \\ --data @request_payload.json \\ $OPENBAO_ADDR/v1/auth/token/create   The bao write command simplifies the API call.  Since token management is a common task, OpenBao CLI provides atoken command withcreate subcommand. The CLI command simplifies the token creation. Use the bao create command with options to set the token TTL, policies, and use limit.  $ bao token create -policy=admin -policy=secops -ttl=8h -use-limit=3   info Syntax: The command options start with - (e.g. -ttl) while API path parameters do not (e.g. ttl). You always set the API parameters after the path you are invoking.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"write","url":"/openbao/docs/commands/write/#usage","content":" The following flags are available in addition to the standard set of flags included on all commands.  ","version":"Next","tagName":"h2"},{"title":"Output options​","type":1,"pageTitle":"write","url":"/openbao/docs/commands/write/#output-options","content":" -field (string: &quot;&quot;) - Print only the field with the given name. Specifying this option will take precedence over other formatting directives. The result will not have a trailing newline making it ideal for piping to other processes. -format (string: &quot;table&quot;) - Print the output in the given format. Valid formats are &quot;table&quot;, &quot;json&quot;, or &quot;yaml&quot;. This can also be specified via theVAULT_FORMAT environment variable.  ","version":"Next","tagName":"h3"},{"title":"Command options​","type":1,"pageTitle":"write","url":"/openbao/docs/commands/write/#command-options","content":" -force (bool: false) - Allow the operation to continue with no key=value pairs. This allows writing to keys that do not need or expect data. This is aliased as -f. ","version":"Next","tagName":"h3"},{"title":"Client count FAQ","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/client-count/faq/","content":"","keywords":"","version":"Next"},{"title":"Definitions​","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/#definitions","content":" ","version":"Next","tagName":"h2"},{"title":"What is a client? {#what-is-a-client}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Any unique application, service, or user that authenticates to an OpenBao cluster. The client count metric is a combination of entity clients and non-entity clients.  Consult the clients and entities overview for more information on client definitions.  ","version":"Next","tagName":"h3"},{"title":"What is the difference between an entity client, non-entity client, and certificate client? {#eclient-vs-neclient}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Entity clients map to an active identity.Non-entity clients map to an active non-entity token.Certificate clients map to an active ACME PKI certificate.  Consult the clients and entities overview for more information about how OpenBao determines entity assignments.  ","version":"Next","tagName":"h3"},{"title":"Computing client count​","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/#computing-clients","content":" ","version":"Next","tagName":"h2"},{"title":"Does the Nomad-Openbao integration affect client counts? {#nomad}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Maybe.  Nomad Openbao integrationuses token roles where a single token role creates tokens for many Nomad jobs. Unless you have configured explicit identity aliases for your Nomad tokens, Openbao will record every running instance of a Nomad job as a unique client.  ","version":"Next","tagName":"h3"},{"title":"Are batch tokens counted differently than service tokens? {#batch-tokens}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" No.  Batch token clients are counted like service token clients. The batch token is mapped to either to the associated active entity or an artificial entity that Openbao creates by combining the assigned namespace and policy. See theclients and entities overview for more details.  ","version":"Next","tagName":"h3"},{"title":"Do custom user filters affect client counts? {#custom-filters}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes.  Custom user filters can change the way that entity aliases are mapped, which can affect the client count computation.  Consult the clients and entities overview for more information about how Openbao determines entity assignments.  ","version":"Next","tagName":"h3"},{"title":"Does mount migration affect client counts? {#mount-migration}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Maybe.  Migrating mounts across namespace will create duplication in the client count.Migrating mounts within a namespace will not affect client count.  ","version":"Next","tagName":"h3"},{"title":"Upgrading and migration​","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/#upgrading","content":" ","version":"Next","tagName":"h2"},{"title":"What happens to client count when I upgrade? {#what-happens-at-upgrade}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" OpenBao will only reflect the number of active unique clients since the upgrade.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/#usage","content":" ","version":"Next","tagName":"h2"},{"title":"Can I view the list of unique client IDs that contributed to my client count aggregate? {#view-data}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes.  You can export the list of unique clients that contributed to your client count for a given period with theactivity export API endpoint.  ","version":"Next","tagName":"h3"},{"title":"Is clientID viewable in the audit logs for non-entity tokens? {#clientid-in-logs}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes.  Audit logs include a field called clientID that records the active or computed entity ID of the associated token.  ","version":"Next","tagName":"h3"},{"title":"Can I skip client computation for a period of time during the period? {#skip-computation}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes, but the data may be inaccurate.  Breaking up the data will likely result in client duplication. For example, assume your period runs from January 1st to December 31st, and you break the computation into two periods to exclude the month of April:  Period&lt;sub&gt;1&lt;/sub&gt; runs from January 1st to March 31stPeriod&lt;sub&gt;2&lt;/sub&gt; runs from June 1st to December 31st  OpenBao treats the two requests independently so January 1st and June 1st are both used as a fresh start to re-count unique clients. Any client that was active during both periods will appear in both result sets, even though OpenBao will only counted that client once for the actual period.  ","version":"Next","tagName":"h3"},{"title":"Are there conditions that will cause me to lose client data? {#lost-data}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes.  The OpenBao activity log handles client computation. The standby nodes track and accumulate activity log data then transmit updates to the active node over gRPC whenever the log grows by 8KB or 10 minutes has elapsed, whichever happens first.  If a node goes down during the accumulation phase you will lose the untransmitted data in addition to any client count data that would have been collected during the outage.  ","version":"Next","tagName":"h3"},{"title":"What happens if a portion of the data is missing for my period? {#missing-data}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" OpenBao only returns the most recent contiguous set of data.  For example, assume your period runs from January 1st to December 31st but you disabled tracking for the month of April. OpenBao will look for the largest, contiguous window of time where data is available, May through December, and compute results for that period of time. May 2021 through December 2021.  ","version":"Next","tagName":"h3"},{"title":"Can I disable client counting? {#disable-client-count}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes.  You can use the OpenBao API toupdate the client count configurationand disable the tracking parameter. If you disable client counting in the middle of a month, OpenBao will discard any data currently recorded for the month. Data for previous months is preserved.  ","version":"Next","tagName":"h3"},{"title":"Can I configure OpenBao to log the client count data? {#log-client-count}","type":1,"pageTitle":"Client count FAQ","url":"/openbao/docs/concepts/client-count/faq/##","content":" Yes.  You can use the OpenBao API toupdate the client count configurationand specify your preferred retention period. ","version":"Next","tagName":"h3"},{"title":"Authentication","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/auth/","content":"","keywords":"","version":"Next"},{"title":"auth methods​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#auth-methods","content":" OpenBao supports a number of auth methods. Some backends are targeted toward users while others are targeted toward machines. Most authentication backends must be enabled before use. To enable an auth method:  $ bao write sys/auth/my-auth type=userpass   This enables the &quot;userpass&quot; auth method at the path &quot;my-auth&quot;. This authentication will be accessible at the path &quot;my-auth&quot;. Often you will see authentications at the same path as their name, but this is not a requirement.  To learn more about this authentication, use the built-in path-help command:  $ bao path-help auth/my-auth # ...   OpenBao supports multiple auth methods simultaneously, and you can even mount the same type of auth method at different paths. Only one authentication is required to gain access to OpenBao, and it is not currently possible to force a user through multiple auth methods to gain access, although some backends do support MFA.  ","version":"Next","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#tokens","content":" There is an entire page dedicated to tokens, but it is important to understand that authentication works by verifying your identity and then generating a token to associate with that identity.  For example, even though you may authenticate using something like GitHub, OpenBao generates a unique access token for you to use for future requests. The CLI automatically attaches this token to requests, but if you're using the API you'll have to do this manually.  This token given for authentication with any backend can also be used with the full set of token commands, such as creating new sub-tokens, revoking tokens, and renewing tokens. This is all covered on thetoken concepts page.  ","version":"Next","tagName":"h2"},{"title":"Authenticating​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#authenticating","content":" ","version":"Next","tagName":"h2"},{"title":"Via the CLI​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#via-the-cli","content":" To authenticate with the CLI, bao login is used. This supports many of the built-in auth methods. For example, with GitHub:  $ bao login -method=github token=&lt;token&gt; ...   After authenticating, you will be logged in. The CLI command will also output your raw token. This token is used for revocation and renewal. As the user logging in, the primary use case of the token is renewal, covered below in the &quot;Auth Leases&quot; section.  To determine what variables are needed for an auth method, supply the -method flag without any additional arguments and help will be shown.  If you're using a method that isn't supported via the CLI, then the API must be used.  ","version":"Next","tagName":"h3"},{"title":"Via the API​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#via-the-api","content":" API authentication is generally used for machine authentication. Each auth method implements its own login endpoint. Use the bao path-helpmechanism to find the proper endpoint.  For example, the GitHub login endpoint is located at auth/github/login. And to determine the arguments needed, bao path-help auth/github/login can be used.  ","version":"Next","tagName":"h3"},{"title":"Auth leases​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#auth-leases","content":" Just like secrets, identities haveleases associated with them. This means that you must reauthenticate after the given lease period to continue accessing OpenBao.  To set the lease associated with an identity, reference the help for the specific auth method in use. It is specific to each backend how leasing is implemented.  And just like secrets, identities can be renewed without having to completely reauthenticate. Just use bao token renew &lt;token&gt; with the leased token associated with your identity to renew it.  ","version":"Next","tagName":"h2"},{"title":"Code example​","type":1,"pageTitle":"Authentication","url":"/openbao/docs/concepts/auth/#code-example","content":" The following code snippet demonstrates how to renew auth tokens.  Go package main import ( &quot;context&quot; &quot;fmt&quot; &quot;log&quot; openbao &quot;github.com/openbao/openbao/api&quot; auth &quot;github.com/openbao/openbao/api/auth/userpass&quot; ) // Once you've set the token for your OpenBao client, you will need to // periodically renew its lease. // // A function like this should be run as a goroutine to avoid blocking. // // Production applications may also wish to be more tolerant of failures and // retry rather than exiting. func renewToken(client *openbao.Client) { for { openbaoLoginResp, err := login(client) if err != nil { log.Fatalf(&quot;unable to authenticate to OpenBao: %v&quot;, err) } tokenErr := manageTokenLifecycle(client, openbaoLoginResp) if tokenErr != nil { log.Fatalf(&quot;unable to start managing token lifecycle: %v&quot;, tokenErr) } } } // Starts token lifecycle management. Returns only fatal errors as errors, // otherwise returns nil so we can attempt login again. func manageTokenLifecycle(client *openbao.Client, token *openbao.Secret) error { renew := token.Auth.Renewable // You may notice a different top-level field called Renewable. That one is used for dynamic secrets renewal, not token renewal. if !renew { log.Printf(&quot;Token is not configured to be renewable. Re-attempting login.&quot;) return nil } watcher, err := client.NewLifetimeWatcher(&amp;openbao.LifetimeWatcherInput{ Secret: token, Increment: 3600, // Learn more about this optional value in https://www.vaultproject.io/docs/concepts/lease#lease-durations-and-renewal }) if err != nil { return fmt.Errorf(&quot;unable to initialize new lifetime watcher for renewing auth token: %w&quot;, err) } go watcher.Start() defer watcher.Stop() for { select { // `DoneCh` will return if renewal fails, or if the remaining lease // duration is under a built-in threshold and either renewing is not // extending it or renewing is disabled. In any case, the caller // needs to attempt to log in again. case err := &lt;-watcher.DoneCh(): if err != nil { log.Printf(&quot;Failed to renew token: %v. Re-attempting login.&quot;, err) return nil } // This occurs once the token has reached max TTL. log.Printf(&quot;Token can no longer be renewed. Re-attempting login.&quot;) return nil // Successfully completed renewal case renewal := &lt;-watcher.RenewCh(): log.Printf(&quot;Successfully renewed: %#v&quot;, renewal) } } } func login(client *openbao.Client) (*openbao.Secret, error) { // WARNING: A plaintext password like this is obviously insecure. // See the hashicorp/vault-examples repo for full examples of how to securely // log in to OpenBao using various auth methods. This function is just // demonstrating the basic idea that a *openbao.Secret is returned by // the login call. userpassAuth, err := auth.NewUserpassAuth(&quot;my-user&quot;, &amp;auth.Password{FromString: &quot;my-password&quot;}) if err != nil { return nil, fmt.Errorf(&quot;unable to initialize userpass auth method: %w&quot;, err) } authInfo, err := client.Auth().Login(context.TODO(), userpassAuth) if err != nil { return nil, fmt.Errorf(&quot;unable to login to userpass auth method: %w&quot;, err) } if authInfo == nil { return nil, fmt.Errorf(&quot;no auth info was returned after login&quot;) } return authInfo, nil }  ","version":"Next","tagName":"h2"},{"title":"Client count calculation","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/client-count/counting/","content":"","keywords":"","version":"Next"},{"title":"How OpenBao tracks clients​","type":1,"pageTitle":"Client count calculation","url":"/openbao/docs/concepts/client-count/counting/#how-openbao-tracks-clients","content":" Each time a client authenticates, OpenBao checks whether the corresponding entity ID has already been recorded in the client log as active for the current month:  If no record exists, OpenBao adds an entry for the entity ID.If a record exists but the entity was last active prior to the current month, OpenBao adds a new entry to the client record for the entity ID.If a record exists and the entity was last active within the current month, OpenBao does not add a new entry to the client record for the entity ID.  For example:  Two non-entity tokens under the same namespace, with the same alias name and policy assignment receive the same entity assignment and are only countedonce.Two authentication requests from a single ACME client for the same certificate identifiers from different mounts receive the same entity assignments and are counted once.An application authenticating with AppRole receive the same entity assignment every time and only counted once.  At the end of each month, OpenBao pre-computes reports for each cluster on the number of active entities, per namespace, for each time period within the configured retention period. By de-duplicating records from the current month against records for the previous month, OpenBao ensures entities that remain active within every calendar month are only counted once for the year.  The deduplication process has two additional consequences:  Detailed reporting lags by 1 month at the start of the billing period.Billing period reports that include the current month must use an approximation for the number of new clients in the current month.  ","version":"Next","tagName":"h2"},{"title":"How OpenBao approximates current-month client count​","type":1,"pageTitle":"Client count calculation","url":"/openbao/docs/concepts/client-count/counting/#how-openbao-approximates-current-month-client-count","content":" OpenBao approximates client count for the current month using ahyperloglog algorithm that looks at the difference between the cardinalities of:  the number of clients across the entire billing period, andthe number of clients across the billing period excluding clients from the current month.  The approximation algorithm uses theaxiomhq library with fourteen registers and sparse representations (when applicable). The multiset for the calculation is the total number of clients within a billing period, and the accuracy estimate for the approximation decreases as the difference between the number of clients in the current month and the number of clients in the billing period increases.  ","version":"Next","tagName":"h2"},{"title":"Testing verification for client count approximations​","type":1,"pageTitle":"Client count calculation","url":"/openbao/docs/concepts/client-count/counting/#testing-verification-for-client-count-approximations","content":" Given CM as the number of clients for the current month and BP as the number of clients in the billing period, we found that the approximation becomes increasingly imprecise as:  the difference between BC and CM increasesthe value of CM approaches zero.the number of months in the billing period increase.  The maximum observed error rate (ER = (FOUND_NEW_CLIENTS / EXPECTED_NEW_CLIENTS)) was 30% for 10,000 clients or less, with an error rate of 5 – 10% in the average case.  For the purposes of predictive analysis, the following tables list a random sample the values we found during testing for CM, BP, and ER.  Single-month testsMulti-month / multi-segment tests Current month (CM)\tBilling period (BP)\tError rate (ER)7\t10\t0% 20\t600\t0% 20\t1000\t0% 20\t6000\t10% 20\t10000\t10% 200\t600\t0% 200\t10000\t7% 400\t6000\t5% 2000\t10000\t4%  ","version":"Next","tagName":"h3"},{"title":"Resource costs for client computation​","type":1,"pageTitle":"Client count calculation","url":"/openbao/docs/concepts/client-count/counting/#resource-costs-for-client-computation","content":" In addition to the storage used for storing the pre-computed reports, each active entity in the client log consumes a few bytes of storage. As a safety measure against runaway storage growth, OpenBao limits the number of entity records to 656,000 per month, but typical storage costs are much less.  On average, 1000 monthly active entities requires 1.5 MiB of storage capacity over the default 24-month retention period.  Related conceptsRelated API docsRelated tutorialsOther resources Clients and entitiesClient count FAQ ","version":"Next","tagName":"h2"},{"title":"Clients and entities","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/client-count/","content":"","keywords":"","version":"Next"},{"title":"Identity and entity assignment​","type":1,"pageTitle":"Clients and entities","url":"/openbao/docs/concepts/client-count/#identity-and-entity-assignment","content":" Authorized clients can connect to OpenBao with a variety of authentication methods.  Authorization source\tAuthN methodExternally managed or SSO\tActive Directory, LDAP, OIDC, JWT, GitHub, username+password Platform- or server-based\tKubernetes, Cert Self\tAppRole, tokens with no associated authN path or role    When a client authenticates, OpenBao assigns a unique identifier (client entity) in the OpenBao identity systembased on the authentication method used or a previously assigned alias.Entity aliases let clients authenticate with multiple methods but still be associated with a single policy, share resources, and count as the same entity, regardless of the authentication method used for a particular session.  ","version":"Next","tagName":"h2"},{"title":"Standard entity assignments​","type":1,"pageTitle":"Clients and entities","url":"/openbao/docs/concepts/client-count/#standard-entity-assignments","content":" In addition to custom authentication methods configured with secure plugins, OpenBao supports many standardized authentication methods by default.  AuthN method\tUnique ID\tConfigured withAppRole\tRole ID\tNot configurable JWT/OIDC\tThe presented claims (no default value)\tuser_claim Kerberos\tUsername\tNot configurable Kubernetes\tService account UID\tNot configurable LDAP\tUsername\tNot configurable RADIUS\tUsername\tNot configurable TLS Certificate\tSubject CommonName\tNot configurable Token\tentity_alias\tNot configurable Username/Password\tUsername\tNot configurable  Each authentication method has a unique ID string that corresponds to a client entity used for telemetry. For example, a microservice authenticating with AppRole takes the associated role ID as the entity. If you are running at scale and have multiple copies of the microservices using the same role id, the full set of instances will share the same identifier.  As a result, it is critical that you configure different clients (microservices, humans, applications, services, platforms, servers, or pipelines) in a way that results in distinct clients having unique identifiers. For example, the role IDs should be different between two microservices, MicroserviceA and MicroServiceB, even if the specific instances of MicroServiceA and MicroServiceB share a common role ID.  ","version":"Next","tagName":"h2"},{"title":"Entity assignment with ACME​","type":1,"pageTitle":"Clients and entities","url":"/openbao/docs/concepts/client-count/#entity-assignment-with-acme","content":" OpenBao treats all ACME connections that authenticate under the same certificate identifier (domain) as the same certificate entity for client count calculations.  For example:  ACME client requests (from the same server or separate servers) for the same certificate identifier (a unique combination of CN,DNS, SANS and IP SANS) are treated as the same entities.If an ACME client makes a request for a.test.com, and subsequently makes a new request for b.test.com and *.test.com then two distinct entities will be created, one for a.test.com and another for the combination of b.test.com and *.test.com.Overlap of certificate identifiers from different ACME clients will be treated as the same entity e.g. if client 1 requests a.test.com and client 2 requestsa.test.com a single entity is created for both requests.  ","version":"Next","tagName":"h2"},{"title":"Entity assignment with namespaces​","type":1,"pageTitle":"Clients and entities","url":"/openbao/docs/concepts/client-count/#entity-assignment-with-namespaces","content":" A namespace represents a isolated, logical space within a single OpenBao cluster and is typically used for administrative purposes.  When a client authenticates within a given namespace, OpenBao assigns the same client entity to activities within any child namespaces because the namespaces exist within the same larger scope.  When a client authenticates across namespace boundaries, OpenBao treats the single client as two distinct entities because the client is operating across different scopes with different policy assignments and resources.  For example:  Different requests under parent and child namespaces from a single client authenticated under the parent namespace are assigned the same entity ID. All the client activities occur within the boundaries of the namespace referenced in the original authentication request.Different requests under parent and child namespaces from a single client authenticated under the child namespace are assigned different entity IDs. Some of the client activities occur outside the boundaries of the namespace referenced in the original authentication request.Requests by the same client to two different namespaces, NAMESPACEAand NAMESPACEB are assigned different entity IDs.  ","version":"Next","tagName":"h2"},{"title":"Entity assignment with non-entity tokens​","type":1,"pageTitle":"Clients and entities","url":"/openbao/docs/concepts/client-count/#entity-assignment-with-non-entity-tokens","content":" OpenBao uses tokens as the core method for authentication. You can use tokens to authenticate directly, or use token auth methodsto dynamically generate tokens based on external identities.  When clients authenticate with the token auth methodwithout a client identity, the result is a non-entity token. For example, a service might use the token authentication method to create a token for a user whose explicit identity is unknown.  Ultimately, non-entity tokens trace back to a particular client or purpose so OpenBao assigns unique entity IDs to non-entity tokens based on a combination of the:  assigned entity alias name (if present),associated policies, andnamespace under which the token was created.  In rare cases, tokens may be created outside of the OpenBao identity systemwithout an associated entity or identity. OpenBao treats every unaffiliated token as a unique client for production usage. We strongly discourage the use of unaffiliated tokens and recommend that you always associate a token with an entity alias and token role.  Behavior of non-entity tokens All non-entity tokens with the same namespace and policy assignments are treated as the same client entity.  Related conceptsRelated tutorialsOther resources Client count calculationClient count FAQ ","version":"Next","tagName":"h2"},{"title":"\"Dev\" server mode","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/dev-server/","content":"","keywords":"","version":"Next"},{"title":"Properties​","type":1,"pageTitle":"\"Dev\" server mode","url":"/openbao/docs/concepts/dev-server/#properties","content":" The properties of the dev server (some can be overridden with command line flags or by specifying a configuration file):  Initialized and unsealed - The server will be automatically initialized and unsealed. You don't need to use bao operator unseal. It is ready for use immediately. In-memory storage - All data is stored (encrypted) in-memory. OpenBao server doesn't require any file permissions. Bound to local address without TLS - The server is listening on127.0.0.1:8200 (the default server address) without TLS. Automatically Authenticated - The server stores your root access token so bao CLI access is ready to go. If you are accessing OpenBao via the API, you'll need to authenticate using the token printed out. Single unseal key - The server is initialized with a single unseal key. The OpenBao is already unsealed, but if you want to experiment with seal/unseal, then only the single outputted key is required. Key Value store mounted - A v2 KV secret engine is mounted atsecret/. Please be aware that there are differences with v1 KV. If you want to use v1, use this flag -dev-kv-v1.  ","version":"Next","tagName":"h2"},{"title":"Use case​","type":1,"pageTitle":"\"Dev\" server mode","url":"/openbao/docs/concepts/dev-server/#use-case","content":" The dev server should be used for experimentation with OpenBao features, such as different auth methods, secrets engines, audit devices, etc. If you're new to OpenBao, you may want to pick up with Your First Secret in our getting started guide.  In addition to experimentation, the dev server is very easy to automate for development environments. ","version":"Next","tagName":"h2"},{"title":"Duration string format","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/duration-format/","content":"","keywords":"","version":"Next"},{"title":"How it works​","type":1,"pageTitle":"Duration string format","url":"/openbao/docs/concepts/duration-format/#how-it-works","content":" A duration string is a possibly signed sequence of decimal numbers, each with an optional fraction and an optional unit suffix. If no unit is given, we interpret the numbers as seconds.  Valid time units are:  ns Nanosecondsus (or µs): Microsecondsms: Millisecondss: Secondsm: Minutesh: Hoursd: Days  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Duration string format","url":"/openbao/docs/concepts/duration-format/#examples","content":" Example values could be:  100 (One hundred seconds, equivalent to 100s)60h (Sixty hours)1.5h (One and a half hours)50d (Fifty days)100ms (One hundred milliseconds)50ns (Fifty nanoseconds) ","version":"Next","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/events/","content":"","keywords":"","version":"Next"},{"title":"Event types​","type":1,"pageTitle":"Events","url":"/openbao/docs/concepts/events/#event-types","content":" Internal components of OpenBao as well as external plugins can generate events. These are published to &quot;event types&quot;, sometimes called &quot;topics&quot; in some event systems. All events of a specific event type will have the same format for their additional metadata field.  The following events are currently generated by OpenBao and its builtin plugins automatically:  Plugin\tEvent Typekv\tkv-v1/delete kv\tkv-v1/write kv\tkv-v2/config-write kv\tkv-v2/data-delete kv\tkv-v2/data-patch kv\tkv-v2/data-write kv\tkv-v2/delete kv\tkv-v2/destroy kv\tkv-v2/metadata-delete kv\tkv-v2/metadata-patch kv\tkv-v2/metadata-write kv\tkv-v2/undelete  ","version":"Next","tagName":"h2"},{"title":"Event format​","type":1,"pageTitle":"Events","url":"/openbao/docs/concepts/events/#event-format","content":" Events may be formatted in protobuf binary format or as JSON. See EventReceived in sdk/logical/event.proto in the relevant OpenBao version for the protobuf schema.  When formatted as JSON, the event conforms to the CloudEvents specification.  id (string) - CloudEvents unique identifier for the event. The id is unique for each event, and events with the same id represent the same event. source (string) - CloudEvents source, which is currently https://vaultproject.io. specversion (string) - The CloudEvents specification version this conforms to. type (string) - CloudEvents type this event corresponds to, which is currently always *. datacontenttype (string) - CloudEvents content type of the event, which is currently always application/json. time (string) - ISO 8601-formatted timestamp for when the event was generated. data (object) - OpenBao-specific data. event (Event) - contains the event that happened. id (string) - (repeat of the id parameter) metadata (object) - arbitrary extra data customized for the event type. eventType (string) - the event type that was published. pluginInfo (PluginInfo) - information about the plugin that generated the event, if applicable. mountClass (string) - the class of plugin, e.g., secret, auth. mountAccessor (string) - the unique ID of the mounted plugin. mountPath (string) - the path that the plugin is mounted at. plugin (string) - the name of the plugin, e.g., kv.  Here is an example event in JSON format:  { &quot;id&quot;: &quot;901f2388-aabb-a385-7bc0-0b09d5fa060b&quot;, &quot;source&quot;: &quot;https://vaultproject.io/&quot;, &quot;specversion&quot;: &quot;1.0&quot;, &quot;type&quot;: &quot;*&quot;, &quot;data&quot;: { &quot;event&quot;: { &quot;id&quot;: &quot;901f2388-aabb-a385-7bc0-0b09d5fa060b&quot;, &quot;metadata&quot;: { &quot;current_version&quot;: &quot;1&quot;, &quot;oldest_version&quot;: &quot;0&quot;, &quot;path&quot;: &quot;data/foo&quot; } }, &quot;event_type&quot;: &quot;kv-v2/data-write&quot;, &quot;plugin_info&quot;: { &quot;mount_class&quot;: &quot;secret&quot;, &quot;mount_accessor&quot;: &quot;kv_a6081d01&quot;, &quot;mount_path&quot;: &quot;secret/&quot;, &quot;plugin&quot;: &quot;kv&quot; } }, &quot;datacontentype&quot;: &quot;application/cloudevents&quot;, &quot;time&quot;: &quot;2023-02-17T13:11:39.227341-08:00&quot; }   ","version":"Next","tagName":"h2"},{"title":"Subscribing to events​","type":1,"pageTitle":"Events","url":"/openbao/docs/concepts/events/#subscribing-to-events","content":" OpenBao has an API endpoint, /v1/sys/events/subscribe/{eventType}, that allows users to subscribe to events via a WebSocket stream. This endpoint supports the standard authentication and authorization workflows used by other OpenBao endpoints. The {eventType} parameter is a non-empty string of what event type to subscribe to, which may contain wildcards (*) to subscribe to multiple events, e.g., kv-v2/data-*.  By default, the events are delivered in protobuf binary format. The endpoint can also format the data as JSON if the json query parameter is set to true:  $ wscat -H &quot;X-Vault-Token: $(bao print token)&quot; --connect 'ws://127.0.0.1:8200/v1/sys/events/subscribe/kv-v2/data-write?json=true {&quot;id&quot;:&quot;901f2388-aabb-a385-7bc0-0b09d5fa060b&quot;,&quot;source&quot;:&quot;https://vaultproject.io/&quot;,&quot;specversion&quot;:&quot;1.0&quot;,&quot;type&quot;:&quot;*&quot;,&quot;data&quot;:{&quot;event&quot;:{&quot;id&quot;:&quot;901f2388-aabb-a385-7bc0-0b09d5fa060b&quot;,&quot;metadata&quot;:{&quot;current_version&quot;:&quot;1&quot;,&quot;oldest_version&quot;:&quot;0&quot;,&quot;path&quot;:&quot;data/foo&quot;}},&quot;event_type&quot;:&quot;kv-v2/data-write&quot;,&quot;plugin_info&quot;:{&quot;mount_class&quot;:&quot;secret&quot;,&quot;mount_accessor&quot;:&quot;kv_a6081d01&quot;,&quot;mount_path&quot;:&quot;secret/&quot;,&quot;plugin&quot;:&quot;kv&quot;}},&quot;datacontentype&quot;:&quot;application/cloudevents&quot;,&quot;time&quot;:&quot;2023-02-17T13:11:39.227341-08:00&quot;} ...   The OpenBao CLI support this endpoint via the events subscribe command, which will output a stream of JSON for the requested events (one line per event):  $ bao events subscribe kv-v2/data-write {&quot;id&quot;:&quot;901f2388-aabb-a385-7bc0-0b09d5fa060b&quot;,&quot;source&quot;:&quot;https://vaultproject.io/&quot;,&quot;specversion&quot;:&quot;1.0&quot;,&quot;type&quot;:&quot;*&quot;,&quot;data&quot;:{&quot;event&quot;:{&quot;id&quot;:&quot;901f2388-aabb-a385-7bc0-0b09d5fa060b&quot;,&quot;metadata&quot;:{&quot;current_version&quot;:&quot;1&quot;,&quot;oldest_version&quot;:&quot;0&quot;,&quot;path&quot;:&quot;data/foo&quot;}},&quot;event_type&quot;:&quot;kv-v2/data-write&quot;,&quot;plugin_info&quot;:{&quot;mount_class&quot;:&quot;secret&quot;,&quot;mount_accessor&quot;:&quot;kv_a6081d01&quot;,&quot;mount_path&quot;:&quot;secret/&quot;,&quot;plugin&quot;:&quot;kv&quot;}},&quot;datacontentype&quot;:&quot;application/cloudevents&quot;,&quot;time&quot;:&quot;2023-02-17T13:11:39.227341-08:00&quot;} ...   ","version":"Next","tagName":"h2"},{"title":"Policies​","type":1,"pageTitle":"Events","url":"/openbao/docs/concepts/events/#policies","content":" To subscribe, the read capability must be granted by a policyon the /v1/sys/events/subscribe/{eventType} path, where {eventType} is the event type that will be subscribed to. The path may contain wildcards.  An example blanket policy is:  path &quot;sys/events/subscribe/*&quot; { capabilities = [&quot;read&quot;] }  ","version":"Next","tagName":"h2"},{"title":"High availability mode (HA)","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/ha/","content":"","keywords":"","version":"Next"},{"title":"Server-to-Server communication​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#server-to-server-communication","content":" Both methods of request handling rely on the active node advertising information about itself to the other nodes. Rather than over the network, this communication takes place within OpenBao's encrypted storage; the active node writes this information and unsealed standby OpenBao nodes can read it.  For the client redirection method, this is the extent of server-to-server communication -- no direct communication with only encrypted entries in the data store used to transfer state.  For the request forwarding method, the servers need direct communication with each other. In order to perform this securely, the active node also advertises, via the encrypted data store entry, a newly-generated private key (ECDSA-P521) and a newly-generated self-signed certificate designated for client and server authentication. Each standby uses the private key and certificate to open a mutually-authenticated TLS 1.2 connection to the active node via the advertised cluster address. When client requests come in, the requests are serialized, sent over this TLS-protected communication channel, and acted upon by the active node. The active node then returns a response to the standby, which sends the response back to the requesting client.  ","version":"Next","tagName":"h2"},{"title":"Request forwarding​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#request-forwarding","content":" If request forwarding is enabled (turned on by default in 0.6.2), clients can still force the older/fallback redirection behavior (see below) if desired by setting the X-Vault-No-Request-Forwarding header to any non-empty value.  Successful cluster setup requires a few configuration parameters, although some can be automatically determined.  ","version":"Next","tagName":"h2"},{"title":"Client redirection​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#client-redirection","content":" If X-Vault-No-Request-Forwarding header in the request is set to a non-empty value, the standby nodes will redirect the client using a 307 status code to the active node's redirect address.  This is also the fallback method used when request forwarding is turned off or there is an error performing the forwarding. As such, a redirect address is always required for all HA setups.  Some HA data store drivers can autodetect the redirect address, but it is often necessary to configure it manually via a top-level value in the configuration file. The key for this value is api_addr and the value can also be specified by the VAULT_API_ADDR environment variable, which takes precedence.  What the api_addr value should be set to depends on how OpenBao is set up. There are two common scenarios: OpenBao servers accessed directly by clients, and OpenBao servers accessed via a load balancer.  In both cases, the api_addr should be a full URL including scheme (http/https), not simply an IP address and port.  ","version":"Next","tagName":"h2"},{"title":"Direct access​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#direct-access","content":" When clients are able to access OpenBao directly, theapi_addr for each node should be that node's address. For instance, if there are two OpenBao nodes:  A, accessed via https://a.openbao.mycompany.com:8200B, accessed via https://b.openbao.mycompany.com:8200  Then node A would set itsapi_addr tohttps://a.openbao.mycompany.com:8200 and node B would set itsapi_addr tohttps://b.openbao.mycompany.com:8200.  This way, when A is the active node, any requests received by node B will cause it to redirect the client to node A'sapi_addr at https://a.openbao.mycompany.com, and vice-versa.  ","version":"Next","tagName":"h3"},{"title":"Behind load balancers​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#behind-load-balancers","content":" Sometimes clients use load balancers as an initial method to access one of the OpenBao servers, but actually have direct access to each OpenBao node. In this case, the OpenBao servers should actually be set up as described in the above section, since for redirection purposes the clients have direct access.  However, if the only access to the OpenBao servers is via the load balancer, theapi_addr on each node should be the same: the address of the load balancer. Clients that reach a standby node will be redirected back to the load balancer; at that point hopefully the load balancer's configuration will have been updated to know the address of the current leader. This can cause a redirect loop and as such is not a recommended setup when it can be avoided.  ","version":"Next","tagName":"h3"},{"title":"Per-Node cluster listener addresses​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#per-node-cluster-listener-addresses","content":" Each listener block in OpenBao's configuration file contains an address value on which OpenBao listens for requests. Similarly, eachlistener block can contain acluster_address on which OpenBao listens for server-to-server cluster requests. If this value is not set, its IP address will be automatically set to same as theaddress value, and its port will be automatically set to the same as theaddress value plus one (so by default, port 8201).  Note that only active nodes have active listeners. When a node becomes active it will start cluster listeners, and when it becomes standby it will stop them.  ","version":"Next","tagName":"h3"},{"title":"Per-Node cluster address​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#per-node-cluster-address","content":" Similar to the api_addr,cluster_addr is the value that each node, if active, should advertise to the standbys to use for server-to-server communications, and lives as a top-level value in the configuration file. On each node, this should be set to a host name or IP address that a standby can use to reach one of that node'scluster_address values set in thelistener blocks, including port. (Note that this will always be forced to https since only TLS connections are used between servers.)  This value can also be specified by the VAULT_CLUSTER_ADDR environment variable, which takes precedence.  ","version":"Next","tagName":"h3"},{"title":"Storage support​","type":1,"pageTitle":"High availability mode (HA)","url":"/openbao/docs/concepts/ha/#storage-support","content":" Currently the only officially supported storage backend that supports high availability is the Integrated Storage backend. In addition to that, some community suppThese may change over time, and the configuration page should be referenced. orted storage backends implement hight availability as well.  The OpenBao Integrated Storage is recommended as the default HA backend for new deployments of OpenBao. See thecomparison chartfor help deciding which option is best for you.  If you're interested in implementing another backend or adding HA support to another backend, we'd love your contributions. Adding HA support requires implementing thephysical.HABackendinterface for the storage backend. ","version":"Next","tagName":"h2"},{"title":"Autopilot","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/integrated-storage/autopilot/","content":"","keywords":"","version":"Next"},{"title":"Server stabilization​","type":1,"pageTitle":"Autopilot","url":"/openbao/docs/concepts/integrated-storage/autopilot/#server-stabilization","content":" Server stabilization helps to retain the stability of the Raft cluster by safely joining new voting nodes to the cluster. When a new voter node is joined to an existing cluster, autopilot adds it as a non-voter instead, and waits for a pre-configured amount of time to monitor it's health. If the node remains to be healthy for the entire duration of stabilization, then that node will be promoted as a voter. The server stabilization period can be tuned usingserver_stabilization_time (see below).  ","version":"Next","tagName":"h2"},{"title":"Dead server cleanup​","type":1,"pageTitle":"Autopilot","url":"/openbao/docs/concepts/integrated-storage/autopilot/#dead-server-cleanup","content":" Dead server cleanup automatically removes nodes deemed unhealthy from the Raft cluster, avoiding the manual operator intervention. This feature can be tuned using the cleanup_dead_servers, dead_server_last_contact_threshold, and min_quorum (see below).  ","version":"Next","tagName":"h2"},{"title":"State API​","type":1,"pageTitle":"Autopilot","url":"/openbao/docs/concepts/integrated-storage/autopilot/#state-api","content":" State API provides detailed information about all the nodes in the Raft cluster in a single call. This API can be used for monitoring for cluster health.  ","version":"Next","tagName":"h2"},{"title":"Follower health​","type":1,"pageTitle":"Autopilot","url":"/openbao/docs/concepts/integrated-storage/autopilot/#follower-health","content":" Follower node health is determined by 2 factors.  Its ability to heartbeat to leader node at regular intervals. Tuned usinglast_contact_threshold (see below).Its ability to keep up with data replication from the leader node. Tuned usingmax_trailing_logs (see below).  ","version":"Next","tagName":"h3"},{"title":"Default configuration​","type":1,"pageTitle":"Autopilot","url":"/openbao/docs/concepts/integrated-storage/autopilot/#default-configuration","content":" By default, Autopilot is enabled in OpenBao, although dead server cleanup is not enabled by default.  Autopilot exposes a configuration API to manage its behavior. Autopilot gets initialized with the following default values. If these default values do not meet your expected autopilot behavior, don't forget to set them to your desired values.  cleanup_dead_servers - false This controls whether to remove dead servers from the Raft peer list periodically or when a new server joins. This requires thatmin-quorum is also set. dead_server_last_contact_threshold - 24h Limit on the amount of time a server can go without leader contact before being considered failed. This takes effect only when cleanup_dead_servers is set. min_quorum - This doesn't default to anything and should be set to the expected number of voters in your cluster when cleanup_dead_servers is set as true. Minimum number of servers that should always be present in a cluster. Autopilot will not prune servers below this number. max_trailing_logs - 1000 Amount of entries in the Raft Log that a server can be behind before being considered unhealthy. last_contact_threshold - 10s Limit on the amount of time a server can go without leader contact before being considered unhealthy. server_stabilization_time - 10s Minimum amount of time a server must be in a healthy state before it can become a voter. Until that happens, it will be visible as a peer in the cluster, but as a non-voter, meaning it won't contribute to quorum.  warning Note: Autopilot in OpenBao does similar things to what autopilot does inConsul. However, the configuration in these 2 systems differ in terms of default values and thresholds; some additional parameters might also show up in OpenBao in comparison to Consul as well. Autopilot in OpenBao and Consul use different technical underpinnings requiring these differences, to provide the autopilot functionality.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Autopilot","url":"/openbao/docs/concepts/integrated-storage/autopilot/#tutorial","content":" Refer to the following tutorials to learn more.  Integrated Storage AutopilotFault Tolerance with Redundancy Zones ","version":"Next","tagName":"h2"},{"title":"Lease, renew, and revoke","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/lease/","content":"","keywords":"","version":"Next"},{"title":"Lease IDs​","type":1,"pageTitle":"Lease, renew, and revoke","url":"/openbao/docs/concepts/lease/#lease-ids","content":" When reading a dynamic secret, such as via bao read, OpenBao always returns alease_id. This is the ID used with commands such as bao lease renew and bao lease revoke to manage the lease of the secret.  ","version":"Next","tagName":"h2"},{"title":"Lease durations and renewal​","type":1,"pageTitle":"Lease, renew, and revoke","url":"/openbao/docs/concepts/lease/#lease-durations-and-renewal","content":" Along with the lease ID, a lease duration can be read. The lease duration is a Time To Live value: the time in seconds for which the lease is valid. A consumer of this secret must renew the lease within that time.  When renewing the lease, the user can request a specific amount of time they want remaining on the lease, termed the increment. This is not an increment at the end of the current TTL; it is an increment from the current time. For example, bao lease renew -increment=3600 my-lease-id would request that the TTL of the lease be adjusted to 1 hour (3600 seconds). Having the increment be rooted at the current time instead of the end of the lease makes it easy for users to reduce the length of leases if they don't actually need credentials for the full possible lease period, allowing those credentials to expire sooner and resources to be cleaned up earlier.  The requested increment is completely advisory. The backend in charge of the secret can choose to completely ignore it. For most secrets, the backend does its best to respect the increment, but often limits it to ensure renewals every so often.  As a result, the return value of renewals should be carefully inspected to determine what the new lease is.  info To implement token renewal logic in your application code, refer to the code example in the Authentication doc.  ","version":"Next","tagName":"h2"},{"title":"Prefix-based revocation​","type":1,"pageTitle":"Lease, renew, and revoke","url":"/openbao/docs/concepts/lease/#prefix-based-revocation","content":" In addition to revoking a single secret, operators with proper access control can revoke multiple secrets based on their lease ID prefix.  Lease IDs are structured in a way that their prefix is always the path where the secret was requested from. This lets you revoke trees of secrets. For example, to revoke all Userpass logins, you can do bao lease revoke -prefix auth/userpass/. For more information about revoke command please checkcli's lease revokecommand docs.  This is very useful if there is an intrusion within a specific system: all secrets of a specific backend or a certain configured backend can be revoked quickly and easily. ","version":"Next","tagName":"h2"},{"title":"Identity","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/identity/","content":"","keywords":"","version":"Next"},{"title":"Entities and aliases​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#entities-and-aliases","content":" Each user may have multiple accounts with various identity providers, and OpenBao supports many of those providers to authenticate with OpenBao. OpenBao Identity can tie authentications from various auth methods to a single representation. This representation of a consolidated identity is called an Entity and their corresponding accounts with authentication providers can be mapped asAliases. In essence, each entity is made up of zero or more aliases. An entity cannot have more than one alias for a particular authentication backend.  For example, a user with accounts in both GitHub and LDAP can be mapped to a single entity in OpenBao with two aliases, one of type GitHub and one of type LDAP.    However, if both aliases are created on the same auth mount, such as a Github mount, both aliases cannot be mapped to the same entity. The aliases can have the same auth type, as long as the auth mounts are different, and still be associated to the same entity. The diagrams below illustrate both valid and invalid scenarios.    When a client authenticates via any credential backend (except the Token backend), OpenBao creates a new entity. It attaches a new alias to it if a corresponding entity does not already exist. The entity identifier will be tied to the authenticated token. When such tokens are used, their entity identifiers are audit logged, marking a trail of actions performed by specific users.  warning OpenBao Entity is used to count the number of OpenBao clients. To learn more about client count, refer to the Client Countdocumentation.  ","version":"Next","tagName":"h2"},{"title":"Entity management​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#entity-management","content":" Entities in OpenBao do not automatically pull identity information from anywhere. It needs to be explicitly managed by operators. This way, it is flexible in terms of administratively controlling the number of entities to be synced against OpenBao. In some sense, OpenBao will serve as a cache of identities and not as a source of identities.  ","version":"Next","tagName":"h2"},{"title":"Entity policies​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#entity-policies","content":" OpenBao policies can be assigned to entities which will grant additionalpermissions to the token on top of the existing policies on the token. If the token presented on the API request contains an identifier for the entity and if that entity has a set of policies on it, then the token will be capable of performing actions allowed by the policies on the entity as well.    This is a paradigm shift in terms of when the policies of the token get evaluated. Before identity, the policy names on the token were immutable (not the contents of those policies though). But with entity policies, along with the immutable set of policy names on the token, the evaluation of policies applicable to the token through its identity will happen at request time. This also adds enormous flexibility to control the behavior of already issued tokens.  It is important to note that the policies on the entity are only a means to grantadditional capabilities and not a replacement for the policies on the token. To know the full set of capabilities of the token with an associated entity identifier, the policies on the token should be taken into account.  warning NOTE: Be careful in granting permissions to non-readonly identity endpoints. If a user can modify an entity, they can grant it additional privileges through policies. If a user can modify an alias they can login with, they can bind it to an entity with higher privileges. If a user can modify group membership, they can add their entity to a group with higher privileges.  ","version":"Next","tagName":"h2"},{"title":"Mount bound aliases​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#mount-bound-aliases","content":" OpenBao supports multiple authentication backends and also allows enabling the same type of authentication backend on different mount paths. The alias name of the user will be unique within the backend's mount. But identity store needs to uniquely distinguish between conflicting alias names across different mounts of these identity providers. Hence, the alias name in combination with the authentication backend mount's accessor, serve as the unique identifier of an alias.  The table below shows what information each of the supported auth methods uses to form the alias name. This is the identifying information that is used to match or create an entity. If no entities are explicitly created or merged, then one entity will be implicitly createdfor each object on the right-hand side of the table, when it is used to authenticate on a particular auth mount point.  Auth method\tName reported by auth methodAppRole\tRole ID JWT/OIDC\tConfigurable via user_claim to one of the presented claims (no default value) Kerberos\tUsername Kubernetes\tConfigurable via alias_name_source to one of: Service account UID (default), Service account name LDAP\tUsername RADIUS\tUsername TLS Certificate\tSubject CommonName Token\tentity_alias, if provided Username (userpass)\tUsername  ","version":"Next","tagName":"h2"},{"title":"Implicit entities​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#implicit-entities","content":" Operators can create entities for all the users of an auth mount beforehand and assign policies to them, so that when users login, the desired capabilities to the tokens via entities are already assigned. But if that's not done, upon a successful user login from any of the authentication backends, OpenBao will create a new entity and assign an alias against the login that was successful.  Note that the tokens created using the token authentication backend will not normally have any associated identity information. An existing or new implicit entity can be assigned by using the entity_alias parameter, when creating a token using a token role with a configured list of allowed_entity_aliases.  ","version":"Next","tagName":"h2"},{"title":"Identity auditing​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#identity-auditing","content":" If the token used to make API calls has an associated entity identifier, it will be audit logged as well. This leaves a trail of actions performed by specific users.  ","version":"Next","tagName":"h2"},{"title":"Identity groups​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#identity-groups","content":" OpenBao identity has support for groups. A group can contain multiple entities as its members. A group can also have subgroups. Policies set on the group are granted to all members of the group. During request time, when the token's entity ID is being evaluated for the policies that it has access to, policies that are inherited due to group memberships are granted along with the policies on the entity itself.    ","version":"Next","tagName":"h2"},{"title":"Group hierarchical permissions​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#group-hierarchical-permissions","content":" Entities can be direct members of groups, in which case they inherit the policies of the groups they belong to. Entities can also be indirect members of groups. For example, if a GroupA has GroupB as subgroup, then members of GroupB are indirect members of GroupA. Hence, the members of GroupB will have access to policies on both GroupA and GroupB.  ","version":"Next","tagName":"h2"},{"title":"External vs internal groups​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#external-vs-internal-groups","content":" By default, the groups created in identity store are called the internal groups. The membership management of these groups should be carried out manually. A group can also be created as an external group. In this case, the entity membership in the group is managed semi-automatically. An external group serves as a mapping to a group that is outside of the identity store. External groups can have one (and only one) alias. This alias should map to a notion of a group that is outside of the identity store. For example, groups in LDAP and teams in GitHub. A username in LDAP belonging to a group in LDAP can get its entity ID added as a member of a group in OpenBao automatically during loginsand token renewals. This works only if the group in OpenBao is an external group and has an alias that maps to the group in LDAP. If the user is removed from the group in LDAP, that change gets reflected in OpenBao only upon the subsequent login or renewal operation.  For information about Identity Secrets Engine, refer to Identity Secrets Engine.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Identity","url":"/openbao/docs/concepts/identity/#tutorial","content":" Refer to the Identity: Entities and Groups tutorial to learn how OpenBao supports mutliple authentication methods and enables the same authentication method to be used with different mount paths. ","version":"Next","tagName":"h2"},{"title":"Integrated storage","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/integrated-storage/","content":"","keywords":"","version":"Next"},{"title":"Server-to-Server communication​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#server-to-server-communication","content":" Once nodes are joined to one another they begin to communicate using mTLS over OpenBao's cluster port. The cluster port defaults to 8201. The TLS information is exchanged at join time and is rotated on a cadence.  A requirement for Integrated Storage is that thecluster_addr configuration option is set. This allows OpenBao to assign an address to the node ID at join time.  ","version":"Next","tagName":"h2"},{"title":"Cluster membership​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#cluster-membership","content":" This section will outline how to bootstrap and manage a cluster of OpenBao nodes running Integrated Storage.  Integrated Storage is bootstrapped during the initialization process, and results in a cluster of size 1. Depending on the desired deployment size, nodes can be joined to the active OpenBao node.  ","version":"Next","tagName":"h2"},{"title":"Joining nodes​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#joining-nodes","content":" Joining is the process of taking an uninitialized OpenBao node and making it a member of an existing cluster. In order to authenticate the new node to the cluster it must use the same seal mechanism. If using a Auto Unseal the node must be configured to use the same KMS provider and Key as the cluster it's attempting to join. If using a Shamir seal the unseal keys must be provided to the new node before the join process can complete. Once a node has successfully joined, data from the active node can begin to replicate to it. Once a node has been joined it cannot be re-joined to a different cluster.  You can either join the node automatically via the config file or manually through the API (both methods described below). When joining a node, the API address of the leader node must be used. We recommend setting the api_addr configuration option on all nodes to make joining simpler.  retry_join configuration​  This method enables setting one, or more, target leader nodes in the config file. When an uninitialized OpenBao server starts up it will attempt to join each potential leader that is defined, retrying until successful. When one of the specified leaders become active this node will successfully join. When using Shamir seal, the joined nodes will still need to be unsealed manually. When using Auto Unseal the node will be able to join and unseal automatically.  An example retry_joinconfig can be seen below:  storage &quot;raft&quot; { path = &quot;/var/raft/&quot; node_id = &quot;node3&quot; retry_join { leader_api_addr = &quot;https://node1.openbao.local:8200&quot; } retry_join { leader_api_addr = &quot;https://node2.openbao.local:8200&quot; } }   Note, in each retry_joinstanza, you may provide a singleleader_api_addr orauto_join value. When a cloudauto_join configuration value is provided, OpenBao will use go-discoverto automatically attempt to discover and resolve potential Raft leader addresses.  See the go-discoverREADME for details on the format of the auto_join value.  storage &quot;raft&quot; { path = &quot;/var/raft/&quot; node_id = &quot;node3&quot; retry_join { auto_join = &quot;provider=aws region=eu-west-1 tag_key=openbao tag_value=... access_key_id=... secret_access_key=...&quot; } }   By default, OpenBao will attempt to reach discovered peers using HTTPS and port 8200. Operators may override these through theauto_join_scheme andauto_join_port fields respectively.  storage &quot;raft&quot; { path = &quot;/var/raft/&quot; node_id = &quot;node3&quot; retry_join { auto_join = &quot;provider=aws region=eu-west-1 tag_key=openbao tag_value=... access_key_id=... secret_access_key=...&quot; auto_join_scheme = &quot;http&quot; auto_join_port = 8201 } }   Join from the CLI​  Alternatively you can use the join CLI command or the API to join a node. The active node's API address will need to be specified:  $ bao operator raft join https://node1.openbao.local:8200   ","version":"Next","tagName":"h3"},{"title":"Removing peers​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#removing-peers","content":" Removing a peer node is a necessary step when you no longer want the node in the cluster. This could happen if the node is rotated for a new one, the hostname permanently changes and can no longer be accessed, you're attempting to shrink the size of the cluster, or for many other reasons. Removing the peer will ensure the cluster stays at the desired size, and that quorum is maintained.  To remove the peer you can issue aremove-peer command and provide the node ID you wish to remove:  $ bao operator raft remove-peer node1 Peer removed successfully!   ","version":"Next","tagName":"h3"},{"title":"Listing peers​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#listing-peers","content":" To see the current peer set for the cluster you can issue alist-peers command. All the voting nodes that are listed here contribute to the quorum and a majority must be alive for Integrated Storage to continue to operate.  $ bao operator raft list-peers Node Address State Voter ---- ------- ----- ----- node1 node1.openbao.local:8201 follower true node2 node2.openbao.local:8201 follower true node3 node3.openbao.local:8201 leader true   ","version":"Next","tagName":"h3"},{"title":"Integrated storage and TLS​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#integrated-storage-and-tls","content":" We've glossed over some details in the above sections on bootstrapping clusters. The instructions are sufficient for most cases, but some users have run into problems when using auto-join and TLS in conjunction with things like auto-scaling. The issue is that go-discover on most platforms returns IPs (not hostnames), and because the IPs aren't knowable in advance, the TLS certificates used to secure the OpenBao API port don't contain these IPs in their IP SANs.  ","version":"Next","tagName":"h2"},{"title":"OpenBao networking recap​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#openbao-networking-recap","content":" Before we explore solutions to this problem, let's recapitulate how OpenBao nodes speak to one another.  OpenBao exposes two TCP ports: the API port andthe cluster port.  The API port is where clients send their OpenBao HTTP requests.  For a single-node OpenBao cluster you don't worry about a cluster port as it won't be used.  When you have multiple nodes, you also need a cluster port. This is used by OpenBao nodes to issue RPCs to one another, e.g. to forward requests from a standby node to the active node, or when Raft is in use, to handle leader election and replication of stored data.  The cluster port is secured using a TLS certificate that the OpenBao active node generates internally. It's clear how this can work when not using integrated storage: every node has at least read access to storage, so once the active node has persisted the certificate, the standby nodes can fetch it, and all agree on how cluster traffic should be encrypted.  It's less clear how this works with Integrated Storage, as there is a chicken and egg problem. Nodes don't have a shared view of storage until the raft cluster has been formed, but we're trying to form the raft cluster! To solve this problem, an OpenBao node must speak to another OpenBao node using the API port instead of the cluster port. This is currently the only situation in which OpenBao does this.  node2 wants to join the cluster, so issues challenge API request to existing member node1node1 replies to challenge request with (1) an encrypted random UUID and (2) seal confignode2 must decrypt UUID using seal; if using auto-unseal can do it directly, if using Shamir must wait for user to provide enough unseal keys to perform decryptionnode2 sends decrypted UUID back to node1 using answer APInode1 sees node2 can be trusted (since it has seal access) and replies with a bootstrap package which includes the cluster TLS certificate and private keynode2 gets sent a raft snapshot over the cluster port  After this procedure the new node will never again send traffic to the API port. All subsequent inter-node communication will use the cluster port.    ","version":"Next","tagName":"h3"},{"title":"Assisted raft join techniques​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#assisted-raft-join-techniques","content":" The simplest option is to do it by hand: issue raft join commands specifying the explicit names or IPs of the nodes to join to. In this section we look at other TLS-compatible options that lend themselves more to automation.  Autojoin with TLS servername​  The simplest option might be to specify aleader_tls_servernamein the retry_joinstanza which matches a DNS SAN in the certificate.  Note that names in a certificate's DNS SAN don't actually have to be registered in a DNS server. Your nodes may have no names found in DNS, while still using certificate(s) that contain this shared servername in their DNS SANs.  Autojoin but constrain CIDR, list all possible IPs in certificate​  If all the OpenBao node IPs are assigned from a small subnet, e.g. a /28, it becomes practical to put all the IPs that exist in that subnet into the IP SANs of the TLS certificate the nodes will share.  The drawback here is that the cluster may someday outgrow the CIDR and changing it may be a pain. For similar reasons this solution may be impractical when using non-voting nodes and dynamically scaling clusters.  Load balancer instead of autojoin​  Most OpenBao instances are going to have a load balancer (LB) between clients and the OpenBao nodes. In that case, the LB knows how to route traffic to working OpenBao nodes, and there's no need for auto-join: we can just useretry_join with the LB address as the target.  One potential issue here: some users want a public facing LB for clients to connect to OpenBao, but aren't comfortable with OpenBao internal traffic egressing from the internal network it normally runs on.  ","version":"Next","tagName":"h3"},{"title":"Outage recovery​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#outage-recovery","content":" ","version":"Next","tagName":"h2"},{"title":"Quorum maintained​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#quorum-maintained","content":" This section outlines the steps to take when a single server or multiple servers are in a failed state but quorum is still maintained. This means the remaining alive servers are still operational, can elect a leader, and are able to process write requests.  If the failed server is recoverable, the best option is to bring it back online and have it reconnect to the cluster with the same host address. This will return the cluster to a fully healthy state.  If this is impractical, you need to remove the failed server. Usually, you can issue a remove-peer command to remove the failed server if it's still a member of the cluster.  If the remove-peer command isn't possible or you'd rather manually re-write the cluster membership araft/peers.json file can be written to the configured data directory.  ","version":"Next","tagName":"h3"},{"title":"Quorum lost​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#quorum-lost","content":" In the event that multiple servers are lost, causing a loss of quorum and a complete outage, partial recovery is still possible.  If the failed servers are recoverable, the best option is to bring them back online and have them reconnect to the cluster using the same host addresses. This will return the cluster to a fully healthy state.  If the failed servers are not recoverable, partial recovery is possible using data on the remaining servers in the cluster. There may be data loss in this situation because multiple servers were lost, so information about what's committed could be incomplete. The recovery process implicitly commits all outstanding Raft log entries, so it's also possible to commit data that was uncommitted before the failure.  See the section below on manual recovery usingpeers.json for details of the recovery procedure. You include only the remaining servers in thepeers.json recovery file. The cluster should be able to elect a leader once the remaining servers are all restarted with an identicalpeers.json configuration.  Any servers you introduce later can be fresh with totally clean data directories and joined using OpenBao's join command.  In extreme cases, it should be possible to recover with just a single remaining server by starting that single server with itself as the only peer in thepeers.json recovery file.  ","version":"Next","tagName":"h3"},{"title":"Manual recovery using peers.json​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#manual-recovery-using-peersjson","content":" Using raft/peers.json for recovery can cause uncommitted Raft log entries to be implicitly committed, so this should only be used after an outage where no other option is available to recover a lost server. Make sure you don't have any automated processes that will put the peers file in place on a periodic basis.  To begin, stop all remaining servers.  The next step is to go to the configured data path of each OpenBao server. Inside that directory, there will be a raft/ sub-directory. We need to create araft/peers.json file. The file should be formatted as a JSON array containing the node ID, address:port, and suffrage information of each OpenBao server you wish to be in the cluster:  [ { &quot;id&quot;: &quot;node1&quot;, &quot;address&quot;: &quot;node1.openbao.local:8201&quot;, &quot;non_voter&quot;: false }, { &quot;id&quot;: &quot;node2&quot;, &quot;address&quot;: &quot;node2.openbao.local:8201&quot;, &quot;non_voter&quot;: false }, { &quot;id&quot;: &quot;node3&quot;, &quot;address&quot;: &quot;node3.openbao.local:8201&quot;, &quot;non_voter&quot;: false } ]   id (string: &lt;required&gt;) - Specifies the node ID of the server. This can be found in the config file, or inside the node-id file in the server's data directory if it was auto-generated.address (string: &lt;required&gt;) - Specifies the host and port of the server. The port is the server's cluster port.  Create entries for all servers. You must confirm that servers you do not include here have indeed failed and will not later rejoin the cluster. Ensure that this file is the same across all remaining server nodes.  At this point, you can restart all the remaining servers. The cluster should be in an operable state again. One of the nodes should claim leadership and become active.  ","version":"Next","tagName":"h3"},{"title":"Other recovery methods​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/concepts/integrated-storage/#other-recovery-methods","content":" For other, non-quorum related recovery OpenBao's recovery mode can be used. ","version":"Next","tagName":"h3"},{"title":"Mount migration","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/mount-migration/","content":"","keywords":"","version":"Next"},{"title":"Why​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#why","content":" There can be several reasons for wanting to migrate mounts. In OpenBao, the use cases could be for renaming mounts to align with org standards.  ","version":"Next","tagName":"h2"},{"title":"Async behavior​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#async-behavior","content":" The first thing to note about the sys/remount endpoint is that it is an asynchronous endpoint. An invocation will start the migration process, and the API will return a migration ID. This ID, in turn, be used to monitor the migration status using the sys/remount/status endpoint.  ","version":"Next","tagName":"h2"},{"title":"Namespaces​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#namespaces","content":" The sys/remount endpoint can move mounts across namespaces with the namespaces supplied as prefixes on the path arguments. In this case, namespaces, for both the source and destination mounts, must be either the namespace in which the /sys/remount endpoint is called or the children of that namespace. Let us assume that we have three namespaces ns1/, ns1/ns2/, and ns1/ns3. We want to move the mount my-secret from ns1/ns2/my-secret to ns1/ns3/my-secret. Moving the mount can be accomplished in two ways. The first way is to invoke /sys/remount from the root namespace with the from argument as ns1/ns2/my-secret and to argument as ns1/ns3/my-secret. The second way is to invoke /sys/remount from the namespace ns1/, with from as ns2/my-secret and toas ns3/my-secret.  ","version":"Next","tagName":"h2"},{"title":"Leases​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#leases","content":" The remount operation will result in existing leases on a mount being revoked. On mounts with a large number of leases, the revocation process and hence remounting as a whole may be a time consuming process. Any dynamic secrets for a secrets mount and any tokens associated with an auth mount, will be revoked during the remount process.  ","version":"Next","tagName":"h2"},{"title":"Configurations​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#configurations","content":" The remount operation will retain all the configurations of the mount. For example, if you create a read-only role on a database mount or a user on a userpass mount, those will be available at the new location after remounting.  ","version":"Next","tagName":"h2"},{"title":"Cleanup operations​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#cleanup-operations","content":" There are two primary cleanup operations that OpenBao operators will need to keep in mind after performing a remount.  ","version":"Next","tagName":"h2"},{"title":"Entities and aliases​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#entities-and-aliases","content":" Any aliases that refer to users on the auth mount could now point to an invalid mount when an auth mount is moved. Pointing to an invalid mount may not be the case for every instance; a remount within a namespace will end in the aliases pointing to a valid mount. Still, a remount across namespaces will always result in the aliases pointing to an invalid mount. In the latter case, the OpenBao operator should find and remove those aliases from the source namespace, and create equivalent aliases and entities for the new mount in the target namespace. If new entities and aliases aren't created in the target namespace, OpenBao will dynamically generate them upon login operations.  ","version":"Next","tagName":"h3"},{"title":"Policies​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#policies","content":" Remounting can also result in policies referring to invalid paths. Any policy that refers to a moved secrets engine would need to be updated to point to the new location of the engine, assuming that the policy is in the target namespace or a parent of the target namespace, or updated to remove the original mount path if not. Any policies associated with roles on a moved auth mount need to be inspected to see if they still refer to valid paths after the remount operation. Say in namespace ns1/, a child of the root namespace, a role on the mount approle/ has policies granting access to /my-secret. If the mount is moved to another child of the root namespace, say ns2/, which does not have a secrets engine called my-secret/, the OpenBao operator would either create an equivalent my-secret/ mount in ns2/, or update the policy to refer to paths valid from the ns2/ namespace.  ","version":"Next","tagName":"h3"},{"title":"Quotas​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#quotas","content":" The mount being moved may have rate limit or lease count quotas.. The remount process will update these quotas to refer to the new path of the mount.  ","version":"Next","tagName":"h2"},{"title":"Path filters​","type":1,"pageTitle":"Mount migration","url":"/openbao/docs/concepts/mount-migration/#path-filters","content":" The remount operation will respect any existing path filters. Three uses cases, in particular, are shown below. here.  If a mount is moved into a namespace denylisted on a secondary cluster, it will not be available on that cluster.If a mount is moved from a namespace denylisted on a secondary cluster to one that is not, it will now be available on the cluster.If a mount is specifically denylisted on a secondary cluster and is moved, it will now be available on the cluster. ","version":"Next","tagName":"h2"},{"title":"OIDC provider","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/oidc-provider/","content":"","keywords":"","version":"Next"},{"title":"Configuration options​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#configuration-options","content":" The next few sections of the document provide implementation details for each resource that permits OpenBao configuration as an OIDC identity provider.  ","version":"Next","tagName":"h2"},{"title":"OIDC providers​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#oidc-providers","content":" Each OpenBao namespace will contain a built-in provider resource named default. The defaultprovider will allow all client applications within the namespace to use it for OIDC flows. The default provider can be modified but not deleted.  Additionally, an OpenBao namespace may contain several provider resources. Each configured provider will publish the APIs listed within the OIDC flow section. The APIs will be served via backend path-based routing on OpenBao's listen address.  A provider has the following configuration parameters:  Issuer URL: used in the iss claim of ID tokensAllowed client IDs: limits which clients can access the providerScopes supported: limits what identity information is available as claims  The issuer URL parameter is necessary for the validation of ID tokens by clients. If an URL parameter is not provided explicitly, it will default to a URL with OpenBao's api_addr as the scheme://host:port component and /v1/:namespace/identity/oidc/provider/:name as the path component. This means tokens issued by a provider in a specified OpenBao cluster must be validated within that same cluster. If the issuer URL is provided explicitly, it must point to an OpenBao instance that is network-reachable by clients for ID token validation.  The allowed client IDs parameter utilizes the list of client IDs that have been generated by OpenBao as a part of client registration. By default, all clients will be disallowed. Providing * as the parameter value will allow all clients to use the provider.  The scopes parameter employs a list of references to named scope resources. The values provided are discoverable by the scopes_supported key in the OIDC discovery document of the provider. By default, a provider will have the openid scope available. See the scopes section below for more details on the openid scope.  ","version":"Next","tagName":"h3"},{"title":"Scopes​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#scopes","content":" Providers may reference scope resources via the scopes_supported parameter to make specific identity information available as claims.  A scope will have the following configuration parameters:  Description: identity information captured by the scopeTemplate: maps individual claims to OpenBao identity information  The template parameter takes advantage of the JSON-based templating used by identity tokens for claims mapping. This means the parameter will take a JSON string of arbitrary structure where the values may be replaced with specific identity information. Template parameters that are not present for an OpenBao identity are omitted from the resulting claims without an error.  Example of a JSON template for a scope:  { &quot;username&quot;: {{identity.entity.aliases.$MOUNT_ACCESSOR.name}}, &quot;contact&quot;: { &quot;email&quot;: {{identity.entity.metadata.email}}, &quot;phone_number&quot;: {{identity.entity.metadata.phone_number}} }, &quot;groups&quot;: {{identity.entity.groups.names}} }   The full list of template parameters are included in the following table:  Name\tDescriptionidentity.entity.id\tThe entity's ID identity.entity.name\tThe entity's name identity.entity.groups.ids\tThe IDs of the groups the entity is a member of identity.entity.groups.names\tThe names of the groups the entity is a member of identity.entity.metadata\tMetadata associated with the entity identity.entity.metadata.&lt;metadata key&gt;\tMetadata associated with the entity for the given key identity.entity.aliases.&lt;mount accessor&gt;.id\tEntity alias ID for the given mount identity.entity.aliases.&lt;mount accessor&gt;.name\tEntity alias name for the given mount identity.entity.aliases.&lt;mount accessor&gt;.metadata\tMetadata associated with the alias for the given mount identity.entity.aliases.&lt;mount accessor&gt;.metadata.&lt;metadata key&gt;\tMetadata associated with the alias for the given mount and metadata key identity.entity.aliases.&lt;mount accessor&gt;.custom_metadata\tCustom metadata associated with the alias for the given mount identity.entity.aliases.&lt;mount accessor&gt;.custom_metadata.&lt;custom_metadata key&gt;\tCustom metadata associated with the alias for the given mount and custom metadata key time.now\tCurrent time as integral seconds since the Epoch time.now.plus.&lt;duration&gt;\tCurrent time plus a duration format string time.now.minus.&lt;duration&gt;\tCurrent time minus a duration format string  Several named scopes can be made available on an individual provider. Note that the top-level keys in a JSON template may conflict with those in another scope. When scopes are made available on a provider, their templates are checked for top-level conflicts. A warning will be issued to the OpenBao operator if any conflicts are found. This may result in an error if the scopes are requested in an OIDC Authentication Request.  The openid scope is a unique case scope that may not be modified or deleted. The scope will exist in OpenBao and supported by each provider by default. The scope represents the minimum set of claims required by the OIDC specification for inclusion in ID tokens. As such, templates may not contain top-level keys that overwrite the claims populated by the openid scope.  The following defines the claims key and value mapping for the openid scope:  iss- configured issuer of the providersub- unique entity ID of the OpenBao useraud- ID of the clientiat- time of token issueexp- time of token issue + ID token TTL  ","version":"Next","tagName":"h3"},{"title":"Client applications​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#client-applications","content":" A client resource represents an application that wants to delegate end-user authentication to OpenBao using the OIDC protocol. The information provided by a client resource can be used to configure an OIDC relying party.  A client has the following configuration parameters:  Redirect URIs: limits the valid redirect URIs in an authentication requestAssignments: determine who can authenticate with the clientKey: used to sign the ID tokensID token TTL: specifies the time-to-live for ID tokensAccess token TTL: specifies the time-to-live for access tokensClient type: determines the client's ability to maintain confidentiality of credentials  The key parameter is optional. The key will be used to sign ID tokens for the client. It cannot be modified after creation. If not supplied, defaults to the built-indefault key.  A client_id is generated and returned after a successful client registration. Theclient_id uniquely identifies the client. Its value will be a string with 32 random characters from the base62 character set.  warning Note: At least one of the redirect URIs of a client must exactly match the redirect_uri parameter used in an authentication request initiated by the client.  Client types​  A client resource has a client_type parameter which specifies the OAuth 2.0client type based on its ability to maintain confidentiality of credentials. The following sections detail the differences between confidential and public clients in OpenBao.  Confidential​  Confidential clients are capable of maintaining the confidentiality of their credentials. Confidential clients have a client_secret. The client_secret will have a prefix ofhvo_secret followed by 64 random characters in the base62 character set.  Confidential clients may use Proof Key for Code Exchange (PKCE) during the authorization code flow.  Confidential clients must authenticate to the token endpoint using theclient_secret_basic or client_secret_post client authentication method.  Public​  Public clients are not capable of maintaining the confidentiality of their credentials. As such, public clients do not have a client_secret.  Public clients must use Proof Key for Code Exchange (PKCE) during the authorization code flow.  Public clients use the none client authentication method.  ","version":"Next","tagName":"h3"},{"title":"Assignments​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#assignments","content":" Assignment resources are referenced by clients via the assignments parameter. This parameter limits the set of OpenBao users allowed to authenticate. The assignments of an associated client are validated during the authentication request, ensuring that the OpenBao identity associated with the request is a member of the assignment's entities or groups.  Each OpenBao namespace will contain a built-in assignment resource named allow_all. Theallow_all assignment allows all OpenBao entities to authenticate through a client. Theallow_all assignment cannot be modified or deleted.  ","version":"Next","tagName":"h3"},{"title":"Keys​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#keys","content":" Key resources are referenced by clients via the key parameter. This parameter specifies the key that will be used to sign ID tokens for the client. See existingdocumentation for details on keyring management, supported signing algorithms, rotation periods, and verification TTLs. Currently, a key referenced by a client cannot be changed.  Each OpenBao namespace will contain a built-in key resource named default. The defaultkey can be modified but not deleted. Clients that don't specify the key parameter at creation time will use the default key.  The default key will have the following configuration:  algorithm - RS256allowed_client_ids - *rotation_period - 24hverification_ttl - 24h  ","version":"Next","tagName":"h3"},{"title":"OIDC flow​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#oidc-flow","content":" warning Note: The OpenBao OIDC Provider feature currently only supports the authorization code flow.  The following sections provide implementation details for the OIDC compliant APIs provided by OpenBao OIDC providers.  OpenBao OIDC providers enable registered clients to authenticate and obtain identity information (or &quot;claims&quot;) for their end-users. They do this by providing the APIs and behavior required to satisfy the OIDC specification for the authorization code flow. All clients are treated as first-party. This means that end-users will not be required to provide consent to the provider as detailed in section 3.1.2.4 of the OIDC specification. The provider will release information to clients as long as the end-user has ACL access to the provider and their identity has been authorized via an assignment.  OpenBao OIDC providers implement Proof Key for Code Exchange (PKCE) to mitigate authorization code interception attacks. PKCE is required for public client types and optional for confidential client types.  ","version":"Next","tagName":"h2"},{"title":"OpenID configuration​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#openid-configuration","content":" Each provider offers an unauthenticated endpoint that facilitates OIDC Discovery. All required metadata listed in OpenID Provider Metadata is included in the discovery document. Additionally, the recommended userinfo_endpoint and scopes_supported metadata are included.  ","version":"Next","tagName":"h3"},{"title":"Keys​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#keys-1","content":" Each provider offers an unauthenticated endpoint that provides the public portion of keys used to sign ID tokens. The keys are published in a JSON Web Key Set (JWKS) format. The keyset for an individual provider contains the keys referenced by all clients via the allowed_client_ids configuration parameter. A Cache-Control header to set based on responses, allowing clients to refresh their keys upon rotation. The max-age of the header is set based on the earliest rotation time of any of the keys in the keyset.  ","version":"Next","tagName":"h3"},{"title":"Authorization endpoint​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#authorization-endpoint","content":" Each provider offers an authenticated authorization endpoint. The authorization endpoint for each provider is added to OpenBao's default policy using the identity/oidc/provider/+/authorize path. The endpoint incorporates all required authentication request parameters as input.  The endpoint validates client requests and ensures that all required parameters are present and valid. The redirect_uri of the request is validated against the client's redirect_uris. The requesting OpenBao entity will be validated against the client's assignments. An appropriate error code is returned for invalid requests.  An authorization code is generated with a successful validation of the request. The authorization code is single-use and cached with a lifetime of approximately 5 minutes, which mitigates the risk of leaks. A response including the original state presented by the client and code will be returned to the OpenBao UI which initiated the request. OpenBao will issue an HTTP 302 redirect to the redirect_uri of the request, which includes the code and state as query parameters.  ","version":"Next","tagName":"h3"},{"title":"Token endpoint​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#token-endpoint","content":" Each provider will offer a token endpoint. The endpoint may be unauthenticated in OpenBao but is authenticated by requiring a client_secret as described in client authentication. The endpoint ingests all required token request parameters as input. The endpoint validates the client requests and exchanges an authorization code for the ID token and access token. The cache of authorization codes will be verified against the code presented in the exchange. The appropriate error codes are returned for all invalid requests.  The ID token is generated and returned upon successful client authentication and request validation. The ID token will contain a combination of required and configurable claims. The required claims are enumerated in the scopes section above for the openid scope. The configurable claims are populated by templates associated with the scopes provided in the authentication request that generated the authorization code.  An access token is also generated and returned upon successful client authentication and request validation. The access token is an OpenBao batch token with a policy that only provides read access to the issuing provider's userinfo endpoint. The access token is also a TTL as defined by the access_token_ttl of the requesting client.  ","version":"Next","tagName":"h3"},{"title":"UserInfo endpoint​","type":1,"pageTitle":"OIDC provider","url":"/openbao/docs/concepts/oidc-provider/#userinfo-endpoint","content":" Each provider provides an authenticated userinfo endpoint. The endpoint accepts the access token obtained from the token endpoint as a bearer token. The userinfo response is a JSON object with the application/json content type. The JSON object contains claims for the OpenBao entity associated with the access token. The claims returned are determined by the scopes requested in the authentication request that produced the access token. The sub claim is always returned as the entity ID in the userinfo response. ","version":"Next","tagName":"h3"},{"title":"Password policies","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/password-policies/","content":"","keywords":"","version":"Next"},{"title":"Design​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#design","content":" Password policies fundamentally have two parts: a length, and a set of rules that a password must adhere to. Passwords are randomly generated from the de-duplicated union of charsets found in all rules and then checked against each of the rules to determine if the candidate password is valid according to the policy. See Candidate Password Generation for details on how passwords are generated prior to being checked against the rule set.  A rule is an assertion upon a candidate password string that indicates whether or not the password is acceptable. For example: a &quot;charset&quot; rule states that a password must have at least one lowercase letter in it. This rule will reject any passwords that do not have any lowercase letters in it.  Multiple rules may be specified within a policy to create more complex rules, such as requiring at least one lowercase letter, at least one uppercase letter, and at least one number.  The flow looks like:    ","version":"Next","tagName":"h2"},{"title":"Candidate password generation​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#candidate-password-generation","content":" How a candidate password is generated is extremely important. Great care must be placed to ensure that passwords aren't created in a way that can be exploited by threat actors. This section describes how we generate passwords within password policies to ensure that passwords are generated as securely as possible.  To generate a candidate password, three things are needed:  A cryptographically secure random number generator (RNG).A character set (charset) to select characters from.The length of the password.  At a high level, we use our RNG to generate N numbers that correspond to indices into the charset array where N is the length of the password we wish to create. Each value returned from the RNG is then used to extract a character from the charset into the password.  For example, let's generate a password of length 8 from the charset abcdefghij:  The RNG is used to generate 8 random values. For our example let's say those values are:  [3, 2, 0, 8, 7, 3, 5, 1]  Each of these values is an index into the charset array:  [3, 2, 0, 8, 7, 3, 5, 1] =&gt; [d, c, a, i, h, d, f, b]  This gives us our candidate password: dcaihdfb which can then be run through the rules of the policy.  In a real world scenario, the values in the random array will be between [0-255] as that is the range of values that a single byte can be. The value is restricted to the size of the charset array by using themodulo operation to prevent referencing a character outside the bounds of the charset. However this can introduce a problem with bias.  ","version":"Next","tagName":"h2"},{"title":"Preventing bias​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#preventing-bias","content":" When using the modulo operation to generate a password, you must be very careful to prevent the introduction of bias. When generating a random number between [0-255] for a charset that has a length that isn't evenly divisible into 256, some of the first characters in the charset may be selected more frequently than the remaining characters.  To demonstrate this, let's simplify the math. Assume that we have a charset of length 10: abcdefghij. Let's also assume that our RNG generates values [0-25]. The first 10 values 0-9 correspond to each character in our charset. The next 10 values 10-19 also correspond to each character in our charset. However, the next 6 values 20-25 correspond to only the first 6 characters in the charset. This means that those 6 characters abcdef can be selected more often than the last 4 characters ghij.  In order to prevent this from happening, we calculate the maximum value that we can allow an index to be. This is based on the length of the charset we are selecting from. In the example above, the maximum index value we should allow is 19 as that represents the largest integer multiple of the length of the charset array that is less than the maximum value that our RNG can generate. When our RNG generates any values larger than our maximum allowed value, that number is ignored and we continue to the next number. Passwords do not lose any length because we continue generating numbers until the password is fully filled in to the length requested.  ","version":"Next","tagName":"h3"},{"title":"Performance characteristics​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#performance-characteristics","content":" Characterizing password generation performance with this model is heavily dependent on the policy configuration. In short, the more restrictive the policy, the longer it will take to generate a password. This generalization isn't always true, but is a general guideline. The performance curve can be generalized:  (time to generate a candidate password) * (number of candidate passwords generated)  Where the number of times a candidate password needs to be generated is a function of how likely a given candidate password does not pass all of the rules.  Here are some example policy configurations with their performance characteristics below. Each of these policies have the same charset that candidate passwords are generated from (94 characters). The only difference is the minimum number of characters for various character subsets.  No Minimum Characters rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; } rule &quot;charset&quot; { charset = &quot;0123456789&quot; } rule &quot;charset&quot; { charset = &quot;!\\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~&quot; }   1 uppercase, 1 lowercase, 1 numeric rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;!\\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~&quot; }   1 uppercase, 1 lowercase, 1 numeric, 1 from all ASCII characters rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;!\\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~&quot; min-chars = 1 }   1 uppercase, 1 lowercase, 1 numeric, 1 from !@#$ rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;!@#$&quot; min-chars = 1 } # Fleshes out the rest of the symbols but doesn't add any required characters rule &quot;charset&quot; { charset = &quot;!\\&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~&quot; }     As more characters are generated, the amount of time increases (as seen in No Minimum Characters). This upward trend can be dwarfed by restricting charsets. When a password is short, the chances of a character being selected from a subset is smaller. For instance, if you have a 1 character password from the charsetabcde the chances of selecting c from it is 1/5. However if you have a 2 character password, the chances of selecting c at least once are greater than 1/5 because you have a second chance to select c from the charset.  In these examples, as the length of the password increases, the amount of time to generate a password trends down, levels off, and then slowly increases. This is a combination of the two effects listed above: increasing time to generate more characters vs the chances of the character subsets being selected. When a single subset is very small (such as !@#$) the chances of it being selected are much smaller (4/94) than if the subset is larger (26/94 for lowercase characters). This can result in a dramatic loss of performance.  Click here for more details on password generation probabilities In the examples above, the charset being used to generate candidate passwords is 94 characters long. Randomly choosing a given character from the 94 character charset has a 1/94 chance. Choosing a single character from it after N tries (where N is the length of the password) is 1-(1-1/94)^N. If we expand this to look at a subset of characters (such as lowercase characters) the chances of selecting a character from that subset is 1-(1-L/94)^N where L is the length of the subset. For lowercase characters, we get a probability of 1-(1-26/94)^N. If we do this for uppercase letters as well as numbers, then we get a combined probability curve: p = (1-(1-26/94)^N) * (1-(1-26/94)^N) * (1-(1-10/94)^N) It should be noted that this probability curve only applies to this specific policy. To understand the performance characteristics of a given policy, you should run your policy with thegenerate endpoint to see how much time the policy takes to produce passwords.  ","version":"Next","tagName":"h2"},{"title":"Password policy syntax​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#password-policy-syntax","content":" Password policies are defined in HCL or JSON which defines the length of the password and a set of rules a password must adhere to.  See the API docs for examples of the commands to save/read/etc. password policies  Here is a very simple policy which generates 20 character passwords from lowercase characters:  length = 20 rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; }   Multiple rules may be specified, including multiple rules of the same type. For instance, the following policy will generate a 20 character password with at least one lowercase letter, at least one uppercase letter, at least one number, and at least one symbol from the set !@#$%^&amp;*:  length = 20 rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;!@#$%^&amp;*&quot; min-chars = 1 }   At least one charset must be specified for a policy to be valid. In order to generate a password, a charset must be available to select characters from and password policies do not have a default charset. The following policy is NOT valid and will be rejected:  length = 20   ","version":"Next","tagName":"h2"},{"title":"Configuration & available rules​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#configuration--available-rules","content":" ","version":"Next","tagName":"h2"},{"title":"length parameter​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#length-parameter","content":" length (int: &lt;required&gt;) - Specifies how long the generated password will be. Must be &gt;= 4.  Length is not a rule. It is the only part of the configuration that does not adhere to the guess- and-check approach of rules.  ","version":"Next","tagName":"h3"},{"title":"Rule charset​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#rule-charset","content":" Allows you to specify a minimum number of characters from a given charset. For instance: a password must have at least one lowercase letter. This rule also helps construct the charset that the password generation utilizes. In order to generate a password, a charset must be specified.  If multiple charsets are specified, all of the charsets will be combined and de-duplicated prior to generating any candidate passwords. Each individual charset rule will still need to be adhered to in order to successfully generate passwords.  warning After combining and de-duplicating charsets, the length of the charset that candidate passwords are generated from must be no longer than 256 characters.  Parameters​  charset (string: &lt;required&gt;) – A string representation of the character set that this rule observes. Accepts UTF-8 compatible strings. All characters within the string must be printable. Please note that the JSON output returned may be escaped for the special and control characters such as &lt;,&gt;,&amp; etc as per the JSON specification.min-chars (int: 0) - Specifies a minimum number of characters required from the charset specified in this rule. For example: if min-chars = 2, the password must have at least 2 characters from charset.  Example​  length = 20 rule &quot;charset&quot; { charset = &quot;abcde&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;01234&quot; min-chars = 1 }   This policy will generate passwords from the charset abcde01234. However, the password must have at least one character that is from abcde and at least one character from 01234. If charsets overlap between rules, the charsets will be de-duplicated to prevent bias towards the overlapping set. For instance: if you have two charset rules: abcde &amp; cdefg, the charset abcdefg will be used to generate candidate passwords, but a least one character from each abcde &amp; cdefg must still appear in the password.  If min-chars is not specified (or set to 0) then this charset will not have a minimum required number of characters, but it will be used to select characters from. Example:  length = 8 rule &quot;charset&quot; { charset = &quot;abcde&quot; } rule &quot;charset&quot; { charset = &quot;01234&quot; min-chars = 1 }   This policy generates 8 character passwords from the charset abcde01234 and requires at least one character from 01234 to be in it, but does not require any characters from abcde. The password04031945 may result from this policy, even though no alphabetical characters are in it.  ","version":"Next","tagName":"h3"},{"title":"Default password policy​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#default-password-policy","content":" OpenBao ships with a default password policy that applies to any password generated by OpenBao without an explicit policy assignment. The default policy requires passwords include:  20 characters total1 uppercase character1 lowercase character1 number1 special character  length = 20 rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;-&quot; min-chars = 1 }   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Password policies","url":"/openbao/docs/concepts/password-policies/#tutorial","content":" Refer to User Configurable Password Generation for Secret Enginesfor a step-by-step tutorial. ","version":"Next","tagName":"h2"},{"title":"Using PGP, GnuPG, and keybase","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/pgp-gpg-keybase/","content":"","keywords":"","version":"Next"},{"title":"Initializing with PGP​","type":1,"pageTitle":"Using PGP, GnuPG, and keybase","url":"/openbao/docs/concepts/pgp-gpg-keybase/#initializing-with-pgp","content":" One of the early fundamental problems when bootstrapping and initializing OpenBao was that the first user (the initializer) received a plain-text copy of all of the unseal keys. This defeats the promises of OpenBao's security model, and it also makes the distribution of those keys more difficult. OpenBao can optionally be initialized using PGP keys. In this mode, OpenBao will generate the unseal keys and then immediately encrypt them using the given users' public PGP keys. Only the owner of the corresponding private key is then able to decrypt the value, revealing the plain-text unseal key.  First, you must create, acquire, or import the appropriate key(s) onto the local machine from which you are initializing OpenBao. This guide will not attempt to cover all aspects of PGP keys but give examples using two popular programs: Keybase and GnuPG.  For beginners, we suggest using Keybase.io (&quot;Keybase&quot;) as it can be both simpler and has a number of useful behaviors and properties around key management, such as verification of users' identities using a number of public online sources. It also exposes the ability for users to have PGP keys generated, stored, and managed securely on their servers. Using OpenBao with Keybase will be discussed first as it is simpler.  ","version":"Next","tagName":"h2"},{"title":"Initializing with keybase​","type":1,"pageTitle":"Using PGP, GnuPG, and keybase","url":"/openbao/docs/concepts/pgp-gpg-keybase/#initializing-with-keybase","content":" To generate unseal keys for Keybase users, OpenBao accepts the keybase: prefix to the -pgp-keys argument:  $ bao operator init -key-shares=3 -key-threshold=2 \\ -pgp-keys=&quot;keybase:jefferai,keybase:vishalnayak,keybase:sethvargo&quot;   This requires far fewer steps than traditional PGP (e.g. with gpg) because Keybase handles a few of the tedious steps. The output will be the similar to the following:  Key 1: wcBMA37rwGt6FS1VAQgAk1q8XQh6yc... Key 2: wcBMA0wwnMXgRzYYAQgAavqbTCxZGD... Key 3: wcFMA2DjqDb4YhTAARAAeTFyYxPmUd... ...   The output should be rather long in comparison to a regular unseal key. These keys are encrypted, and only the user holding the corresponding private key can decrypt the value. The keys are encrypted in the order in which specified in the -pgp-keys attribute. As such, the keys belong to respective Keybase accounts of jefferai, vishalnayak, and sethvargo. These keys can be distributed over almost any medium, although common sense and judgement are best advised. The encrypted keys are base64 encoded before returning.  ","version":"Next","tagName":"h2"},{"title":"Unsealing with keybase​","type":1,"pageTitle":"Using PGP, GnuPG, and keybase","url":"/openbao/docs/concepts/pgp-gpg-keybase/#unsealing-with-keybase","content":" As a user, the easiest way to decrypt your unseal key is with the Keybase CLI tool. You can download it from Keybase.io download page. After you have downloaded and configured the Keybase CLI, you are now tasked with entering your unseal key. To get the plain-text unseal key, you must decrypt the value given to you by the initializer. To get the plain-text value, run the following command:  $ echo &quot;wcBMA37...&quot; | base64 --decode | keybase pgp decrypt   And replace wcBMA37... with the encrypted key.  You will be prompted to enter your Keybase passphrase. The output will be the plain-text unseal key.  6ecb46277133e04b29bd0b1b05e60722dab7cdc684a0d3ee2de50ce4c38a357101   This is your unseal key in plain-text and should be guarded the same way you guard a password. Now you can enter your key to the unseal command:  $ bao operator unseal Key (will be hidden): ...     ","version":"Next","tagName":"h3"},{"title":"Initializing with GnuPG​","type":1,"pageTitle":"Using PGP, GnuPG, and keybase","url":"/openbao/docs/concepts/pgp-gpg-keybase/#initializing-with-gnupg","content":" GnuPG is an open-source implementation of the OpenPGP standard and is available on nearly every platform. For more information, please see the GnuPG manual.  To create a new PGP key, run, following the prompts:  $ gpg --gen-key   To import an existing key, download the public key onto disk and run:  $ gpg --import key.asc   Once you have imported the users' public keys, you need to save their values to disk as either base64 or binary key files. For example:  $ gpg --export 348FFC4C | base64 &gt; seth.asc   These key files must exist on disk in base64 (the &quot;standard&quot; base64 character set, without ASCII armoring) or binary. Once saved to disk, the path to these files can be specified as an argument to the -pgp-keys flag.  $ bao operator init -key-shares=3 -key-threshold=2 \\ -pgp-keys=&quot;jeff.asc,vishal.asc,seth.asc&quot;   The result should look something like this:  Key 1: wcBMA37rwGt6FS1VAQgAk1q8XQh6yc... Key 2: wcBMA0wwnMXgRzYYAQgAavqbTCxZGD... Key 3: wcFMA2DjqDb4YhTAARAAeTFyYxPmUd... ...   The output should be rather long in comparison to a regular unseal key. These keys are encrypted, and only the user holding the corresponding private key can decrypt the value. The keys are encrypted in the order in which specified in the -pgp-keys attribute. As such, the first key belongs to Jeff, the second to Vishal, and the third to Seth. These keys can be distributed over almost any medium, although common sense and judgement are best advised. The encrypted keys are base64 encoded before returning.  ","version":"Next","tagName":"h2"},{"title":"Unsealing with GnuPG​","type":1,"pageTitle":"Using PGP, GnuPG, and keybase","url":"/openbao/docs/concepts/pgp-gpg-keybase/#unsealing-with-gnupg","content":" Assuming you have been given an unseal key that was encrypted using your public PGP key, you are now tasked with entering your unseal key. To get the plain-text unseal key, you must decrypt the value given to you by the initializer. To get the plain-text value, run the following command:  $ echo &quot;wcBMA37...&quot; | base64 --decode | gpg -dq   And replace wcBMA37... with the encrypted key.  If you encrypted your private PGP key with a passphrase, you may be prompted to enter it. After you enter your password, the output will be the plain-text key:  6ecb46277133e04b29bd0b1b05e60722dab7cdc684a0d3ee2de50ce4c38a357101   This is your unseal key in plain-text and should be guarded the same way you guard a password. Now you can enter your key to the unseal command:  $ bao operator unseal Key (will be hidden): ...  ","version":"Next","tagName":"h3"},{"title":"Recovery mode","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/recovery-mode/","content":"","keywords":"","version":"Next"},{"title":"Recovery process​","type":1,"pageTitle":"Recovery mode","url":"/openbao/docs/concepts/recovery-mode/#recovery-process","content":" The usual way recovery mode is used is:  seal or stop all nodes in the clusterif using Integrated Storage, run bao status on each node to find the highest-index ones (this will require they be running and sealed, as if unsealed a new leader might be elected and writes could happen, confusing the issue)restart the target node in recovery modegenerate a recovery token on that nodeuse the recovery token to perform sys/raw requests to repair the nodeif using Integrated Storage, reform the raft cluster as described below  ","version":"Next","tagName":"h2"},{"title":"Integrated storage for HA only (ha_storage)​","type":1,"pageTitle":"Recovery mode","url":"/openbao/docs/concepts/recovery-mode/#integrated-storage-for-ha-only-ha_storage","content":" If Integrated Storage is used in hybrid mode (i.e. for ha_storage), recovery mode will not allow for changes to the Raft data but instead allow for modification of the underlying physical data that is associated with OpenBao's storage backend. This means that the notes regarding Integrated Storage in this doc do not apply.  ","version":"Next","tagName":"h2"},{"title":"Integrated storage​","type":1,"pageTitle":"Recovery mode","url":"/openbao/docs/concepts/recovery-mode/#integrated-storage","content":" With Integrated Storage, not all nodes are equal. It's possible that some nodes are further behind - i.e. haven't applied as many Raft logs. It is important when choosing a node to use for recovery that it has the highest AppliedIndex found in the cluster.  Each node's AppliedIndex value can be obtained by running bao status against the node sealed nodes of the cluster after bringing it down.  ","version":"Next","tagName":"h2"},{"title":"Recovery tokens​","type":1,"pageTitle":"Recovery mode","url":"/openbao/docs/concepts/recovery-mode/#recovery-tokens","content":" Recovery tokens are issued in much the same way as root tokens are generated, only using a different endpoint, and the OpenBao node must be sealed first. Unlike root tokens, the recovery token is not persisted, so if OpenBao is restarted into recovery mode a new one must be generated.  Only a single recovery token can be generated. If lost, restart OpenBao and generate a new one.  ","version":"Next","tagName":"h2"},{"title":"Raw requests​","type":1,"pageTitle":"Recovery mode","url":"/openbao/docs/concepts/recovery-mode/#raw-requests","content":" Requests can be issued to sys/raw in just the same way as in regular OpenBao server mode. The only difference is that in recovery mode, X-Vault-Tokenmust contain a recovery token instead of a service or batch token.  ","version":"Next","tagName":"h2"},{"title":"Reform the raft cluster​","type":1,"pageTitle":"Recovery mode","url":"/openbao/docs/concepts/recovery-mode/#reform-the-raft-cluster","content":" Recovery mode OpenBao automatically resizes the cluster to size 1. This is necessary because the Raft protocol won't allow changes to be made without a quorum, and in recovery mode we wish to make changes using a single node.  This means that after having used recovery mode, part of the procedure for returning to active service must include re-forming the raft cluster. There are two ways to do so: either delete the OpenBao data directory on the other nodes and re-join them to the recovered node, or use theManual Recovery Using peers.jsonapproach to get all nodes to agree on what nodes are part of the cluster. ","version":"Next","tagName":"h2"},{"title":"Resource quotas","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/resource-quotas/","content":"","keywords":"","version":"Next"},{"title":"Rate limit quotas​","type":1,"pageTitle":"Resource quotas","url":"/openbao/docs/concepts/resource-quotas/#rate-limit-quotas","content":" OpenBao allows operators to create rate limit quotas which enforce API rate limiting using a token bucket algorithm. A rate limit quota can be created at the root level or defined on a namespace, mount, or full API path by specifying a path when creating the quota. The rate limiter is applied to each unique client IP address on a per-node basis (i.e. rate limit quotas are not replicated). A client may invoke rate requests at any given second, after which they may invoke additional requests at rate per-second.  A rate limit quota defined at the root level (i.e. empty path) is inherited by all namespaces and mounts. It acts as a single rate limiter for the entire OpenBao API. A rate limit quota defined on a namespace takes precedence over the global rate limit quota, a rate limit quota defined for a mount takes precedence over the global and namespace rate limit quotas, and a rate limit quota defined for a specific path will take precedence over global, namespace, and mount quotas. Additionally, quotas defined with a role to limit login requests made using that role on the specified auth mount will take precedence over all other quotas. In other words, the most specific quota rule will be applied.  A rate limit can be created with an optional block_interval, such that when set to a non-zero value, any client that hits a rate limit threshold will be blocked from all subsequent requests for a duration of block_interval seconds.  OpenBao also allows the inspection of the state of rate limiting in an OpenBao node through various metrics exposed and through enabling optional audit logging.  ","version":"Next","tagName":"h2"},{"title":"Exempt routes​","type":1,"pageTitle":"Resource quotas","url":"/openbao/docs/concepts/resource-quotas/#exempt-routes","content":" By default, the following paths are exempt from rate limiting. However, OpenBao operators can override the set of paths that are exempt from all rate limit resource quotas by updating the rate_limit_exempt_paths configuration field.  sys/generate-recovery-token/attemptsys/generate-recovery-token/updatesys/generate-root/attemptsys/generate-root/updatesys/healthsys/seal-statussys/unseal  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Resource quotas","url":"/openbao/docs/concepts/resource-quotas/#tutorial","content":" Refer to Protecting OpenBao with Resource Quotas for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Resource quotas","url":"/openbao/docs/concepts/resource-quotas/#api","content":" Rate limit quotas can be managed over the HTTP API. Please seeRate Limit Quotas API for more details. ","version":"Next","tagName":"h2"},{"title":"Response wrapping","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/response-wrapping/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Response wrapping","url":"/openbao/docs/concepts/response-wrapping/#overview","content":" In many OpenBao deployments, clients can access OpenBao directly and consume returned secrets. In other situations, it may make sense to or be desired to separate privileges such that one trusted entity is responsible for interacting with most of the OpenBao API and passing secrets to the end consumer.  However, the more relays a secret travels through, the more possibilities for accidental disclosure, especially if the secret is being transmitted in plaintext. For instance, you may wish to get a TLS private key to a machine that has been cold-booted, but since you do not want to store a decryption key in persistent storage, you cannot encrypt this key in transit.  To help address this problem, OpenBao includes a feature called response wrapping. When requested, OpenBao can take the response it would have sent to an HTTP client and instead insert it into thecubbyhole of a single-use token, returning that single-use token instead.  Logically speaking, the response is wrapped by the token, and retrieving it requires an unwrap operation against this token. Functionally speaking, the token provides authorization to use an encryption key from OpenBao's keyring to decrypt the data.  This provides a powerful mechanism for information sharing in many environments. In the types of scenarios, described above, often the best practical option is to provide cover for the secret information, be able todetect malfeasance (interception, tampering), and limit lifetime of the secret's exposure. Response wrapping performs all three of these duties:  It provides cover by ensuring that the value being transmitted across the wire is not the actual secret but a reference to such a secret, namely the response-wrapping token. Information stored in logs or captured along the way do not directly see the sensitive information.It provides malfeasance detection by ensuring that only a single party can ever unwrap the token and see what's inside. A client receiving a token that cannot be unwrapped can trigger an immediate security incident. In addition, a client can inspect a given token before unwrapping to ensure that its origin is from the expected location in OpenBao.It limits the lifetime of secret exposure because the response-wrapping token has a lifetime that is separate from the wrapped secret (and often can be much shorter), so if a client fails to come up and unwrap the token, the token can expire very quickly.  ","version":"Next","tagName":"h2"},{"title":"Response-Wrapping tokens​","type":1,"pageTitle":"Response wrapping","url":"/openbao/docs/concepts/response-wrapping/#response-wrapping-tokens","content":" When a response is wrapped, the normal API response from OpenBao does not contain the original secret, but rather contains a set of information related to the response-wrapping token:  TTL: The TTL of the response-wrapping token itselfToken: The actual token valueCreation Time: The time that the response-wrapping token was createdCreation Path: The API path that was called in the original requestWrapped Accessor: If the wrapped response is an authentication response containing an OpenBao token, this is the value of the wrapped token's accessor. This is useful for orchestration systems (such as Nomad) to be able to control the lifetime of secrets based on their knowledge of the lifetime of jobs, without having to actually unwrap the response-wrapping token or gain knowledge of the token ID inside.  OpenBao currently does not provide signed response-wrapping tokens, as it provides little extra protection. If you are being pointed to the correct OpenBao server, token validation is performed by interacting with the server itself; a signed token does not remove the need to validate the token with the server, since the token is not carrying data but merely an access mechanism and the server will not release data without validating it. If you are being attacked and pointed to the wrong OpenBao server, the same attacker could trivially give you the wrong signing public key that corresponds to the wrong OpenBao server. You could cache a previously valid key, but could also cache a previously valid address (and in most cases the OpenBao address will not change or will be set via a service discovery mechanism). As such, we rely on the fact that the token itself is not carrying authoritative data and do not sign it.  ","version":"Next","tagName":"h2"},{"title":"Response-Wrapping token operations​","type":1,"pageTitle":"Response wrapping","url":"/openbao/docs/concepts/response-wrapping/#response-wrapping-token-operations","content":" Via the sys/wrapping path, several operations can be run against wrapping tokens:  Lookup (sys/wrapping/lookup): This allows fetching the response-wrapping token's creation time, creation path, and TTL. This path is unauthenticated and available to response-wrapping tokens themselves. In other words, a response-wrapping token holder wishing to perform validation is always allowed to look up the properties of the token.Unwrap (sys/wrapping/unwrap): Unwrap the token, returning the response inside. The response that is returned will be the original wire-format response; it can be used directly with API clients.Rewrap (sys/wrapping/rewrap): Allows migrating the wrapped data to a new response-wrapping token. This can be useful for long-lived secrets. For example, an organization may wish (or be required in a compliance scenario) to have the pki backend's root CA key be returned in a long-lived response-wrapping token to ensure that nobody has seen the key (easily verified by performing lookups on the response-wrapping token) but available for signing CRLs in case they ever accidentally change or lose the pkimount. Often, compliance schemes require periodic rotation of secrets, so this helps achieve that compliance goal without actually exposing what's inside.Wrap (sys/wrapping/wrap): A helper endpoint that echoes back the data sent to it in a response-wrapping token. Note that blocking access to this endpoint does not remove the ability for arbitrary data to be wrapped, as it can be done elsewhere in OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Response-Wrapping token creation​","type":1,"pageTitle":"Response wrapping","url":"/openbao/docs/concepts/response-wrapping/#response-wrapping-token-creation","content":" Response wrapping is per-request and is triggered by providing to OpenBao the desired TTL for a response-wrapping token for that request. This is set by the client using the X-Vault-Wrap-TTL header and can be either an integer number of seconds or a string duration of seconds (15s), minutes (20m), or hours (25h). When using the OpenBao CLI, you can set this via the -wrap-ttlparameter. When using the Go API, wrapping is triggered by setting a helper functionthat tells the API the conditions under which to request wrapping, by mapping an operation and path to a desired TTL.  If a client requests wrapping:  The original HTTP response is serializedA new single-use token is generated with the TTL supplied by the clientInternally, the original serialized response is stored in the single-use token's cubbyholeA new response is generated, with the token ID, TTL, and path stored in the new response's wrap information objectThe new response is returned to the caller  Note that policies can control minimum/maximum wrapping TTLs; see the policies concepts page for more information.  ","version":"Next","tagName":"h2"},{"title":"Response-Wrapping token validation​","type":1,"pageTitle":"Response wrapping","url":"/openbao/docs/concepts/response-wrapping/#response-wrapping-token-validation","content":" Proper validation of response-wrapping tokens is essential to ensure that any malfeasance is detected. It's also pretty straightforward.  Validation is best performed by the following steps:  If a client has been expecting delivery of a response-wrapping token and none arrives, this may be due to an attacker intercepting the token and then preventing it from traveling further. This should cause an alert to trigger an immediate investigation.Perform a lookup on the response-wrapping token. This immediately tells you if the token has already been unwrapped or is expired (or otherwise revoked). If the lookup indicates that a token is invalid, it does not necessarily mean that the data was intercepted (for instance, perhaps the client took a long time to start up and the TTL expired) but should trigger an alert for immediate investigation, likely with the assistance of OpenBao's audit logs to see if the token really was unwrapped.With the token information in hand, validate that the creation path matches expectations. If you expect to find a TLS key/certificate inside, chances are the path should be something like pki/issue/.... If the path is not what you expect, it is possible that the data contained inside was read and then put into a new response-wrapping token. (This is especially likely if the path starts with cubbyhole or sys/wrapping/wrap.) Particular care should be taken with kv secrets engine: exact matches on the path are best there. For example, if you expect a secret to come from secret/foo and the interceptor provides a token with secret/bar as the path, simply checking for a prefix of secret/ is not enough.After prefix validation, unwrap the token. If the unwrap fails, the response is similar to if the initial lookup fails: trigger an alert for immediate investigation.  Following those steps provides very strong assurance that the data contained within the response-wrapping token has never been seen by anyone other than the intended client and that any interception or tampering has resulted in a security alert. ","version":"Next","tagName":"h2"},{"title":"Policies","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/policies/","content":"","keywords":"","version":"Next"},{"title":"Policy-authorization workflow​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#policy-authorization-workflow","content":" Before a human or machine can gain access, an administrator must configure OpenBao with an auth method. Authentication is the process by which human or machine-supplied information is verified against an internal or external system.  Consider the following diagram, which illustrates the steps a security team would take to configure OpenBao to authenticate using a corporate LDAP or ActiveDirectory installation. Even though this example uses LDAP, the concept applies to all auth methods.    The security team configures OpenBao to connect to an auth method. This configuration varies by auth method. In the case of LDAP, OpenBao needs to know the address of the LDAP server and whether to connect using TLS. It is important to note that OpenBao does not store a copy of the LDAP database - OpenBao will delegate the authentication to the auth method. The security team authors a policy (or uses an existing policy) which grants access to paths in OpenBao. Policies are written in HCL in your editor of preference and saved to disk. The policy's contents are uploaded and stored in OpenBao and referenced by name. You can think of the policy's name as a pointer or symlink to its set of rules. Most importantly, the security team maps data in the auth method to a policy. For example, the security team might create mappings like: Members of the OU group &quot;dev&quot; map to the OpenBao policy named &quot;readonly-dev&quot;. or Members of the OU group &quot;ops&quot; map to the OpenBao policies &quot;admin&quot; and &quot;auditor&quot;.  Now OpenBao has an internal mapping between a backend authentication system and internal policy. When a user authenticates to OpenBao, the actual authentication is delegated to the auth method. As a user, the flow looks like:    A user attempts to authenticate to OpenBao using their LDAP credentials, providing OpenBao with their LDAP username and password. OpenBao establishes a connection to LDAP and asks the LDAP server to verify the given credentials. Assuming this is successful, the LDAP server returns the information about the user, including the OU groups. OpenBao maps the result from the LDAP server to policies inside OpenBao using the mapping configured by the security team in the previous section. OpenBao then generates a token and attaches the matching policies. OpenBao returns the token to the user. This token has the correct policies assigned, as dictated by the mapping configuration that was setup by the security team in advance.  The user then uses this OpenBao token for future operations. If the user performs the authentication steps again, they will get a new token. The token will have the same permissions, but the actual token will be different. Authenticating a second time does not invalidate the original token.  ","version":"Next","tagName":"h2"},{"title":"Policy syntax​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#policy-syntax","content":" Policies are written in HCL or JSON and describe which paths in OpenBao a user or machine is allowed to access.  Here is a very simple policy which grants read capabilities to the KVv1 path&quot;secret/foo&quot;:  path &quot;secret/foo&quot; { capabilities = [&quot;read&quot;] }   When this policy is assigned to a token, the token can read from &quot;secret/foo&quot;. However, the token cannot update or delete &quot;secret/foo&quot;, since the capabilities do not allow it. Because policies are deny by default, the token would have no other access in OpenBao.  Here is a more detailed policy, and it is documented inline:  # This section grants all access on &quot;secret/*&quot;. further restrictions can be # applied to this broad policy, as shown below. path &quot;secret/*&quot; { capabilities = [&quot;create&quot;, &quot;read&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;list&quot;] } # Even though we allowed secret/*, this line explicitly denies # secret/super-secret. this takes precedence. path &quot;secret/super-secret&quot; { capabilities = [&quot;deny&quot;] } # Policies can also specify allowed, disallowed, and required parameters. here # the key &quot;secret/restricted&quot; can only contain &quot;foo&quot; (any value) and &quot;bar&quot; (one # of &quot;zip&quot; or &quot;zap&quot;). path &quot;secret/restricted&quot; { capabilities = [&quot;create&quot;] allowed_parameters = { &quot;foo&quot; = [] &quot;bar&quot; = [&quot;zip&quot;, &quot;zap&quot;] } }   Policies use path-based matching to test the set of capabilities against a request. A policy path may specify an exact path to match, or it could specify a glob pattern which instructs OpenBao to use a prefix match:  # Permit reading only &quot;secret/foo&quot;. an attached token cannot read &quot;secret/food&quot; # or &quot;secret/foo/bar&quot;. path &quot;secret/foo&quot; { capabilities = [&quot;read&quot;] } # Permit reading everything under &quot;secret/bar&quot;. an attached token could read # &quot;secret/bar/zip&quot;, &quot;secret/bar/zip/zap&quot;, but not &quot;secret/bars/zip&quot;. path &quot;secret/bar/*&quot; { capabilities = [&quot;read&quot;] } # Permit reading everything prefixed with &quot;zip-&quot;. an attached token could read # &quot;secret/zip-zap&quot; or &quot;secret/zip-zap/zong&quot;, but not &quot;secret/zip/zap path &quot;secret/zip-*&quot; { capabilities = [&quot;read&quot;] }   In addition, a + can be used to denote any number of characters bounded within a single path segment:  # Permit reading the &quot;teamb&quot; path under any top-level path under secret/ path &quot;secret/+/teamb&quot; { capabilities = [&quot;read&quot;] } # Permit reading secret/foo/bar/teamb, secret/bar/foo/teamb, etc. path &quot;secret/+/+/teamb&quot; { capabilities = [&quot;read&quot;] }   OpenBao's architecture is similar to a filesystem. Every action in OpenBao has a corresponding path and capability - even OpenBao's internal core configuration endpoints live under the &quot;sys/&quot; path. Policies define access to these paths and capabilities, which controls a token's access to credentials in OpenBao.  warning Note: The policy rules that OpenBao applies are determined by the most-specific match available, using the priority rules described below. This may be an exact match or the longest-prefix match of a glob. If the same pattern appears in multiple policies, we take the union of the capabilities. If different patterns appear in the applicable policies, we take only the highest-priority match from those policies.  This means if you define a policy for &quot;secret/foo*&quot;, the policy would also match &quot;secret/foobar&quot;. Specifically, when there are potentially multiple matching policy paths, P1 and P2, the following matching criteria is applied:  If the first wildcard (+) or glob (*) occurs earlier in P1, P1 is lower priorityIf P1 ends in * and P2 doesn't, P1 is lower priorityIf P1 has more + (wildcard) segments, P1 is lower priorityIf P1 is shorter, it is lower priorityIf P1 is smaller lexicographically, it is lower priority  For example, given the two paths, &quot;secret/*&quot; and &quot;secret/+/+/foo/*&quot;, the first wildcard appears in the same place, both end in * and the latter has two wildcard segments while the former has zero. So we end at rule (3), and give &quot;secret/+/+/foo/*&quot;lower priority.  danger **Informational:**The glob character referred to in this documentation is the asterisk (*). It is not a regular expression and is only supported as the last character of the path!  When providing list capability, it is important to note that since listing always operates on a prefix, policies must operate on a prefix because OpenBao will sanitize request paths to be prefixes.  ","version":"Next","tagName":"h2"},{"title":"Capabilities​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#capabilities","content":" Each path must define one or more capabilities which provide fine-grained control over permitted (or denied) operations. As shown in the examples above, capabilities are always specified as a list of strings, even if there is only one capability.  To determine the capabilities needed to perform a specific operation, the -output-policy flag can be added to the CLI subcommand. For an example, refer to the Print Policy Requirements document section.  The list of capabilities include the following:  create (POST/PUT) - Allows creating data at the given path. Very few parts of OpenBao distinguish between create and update, so most operations require both create and update capabilities. Parts of OpenBao that provide such a distinction are noted in documentation. read (GET) - Allows reading the data at the given path. update (POST/PUT) - Allows changing the data at the given path. In most parts of OpenBao, this implicitly includes the ability to create the initial value at the path. patch (PATCH) - Allows partial updates to the data at a given path. delete (DELETE) - Allows deleting the data at the given path. list (LIST) - Allows listing values at the given path. Note that the keys returned by a list operation are not filtered by policies. Do not encode sensitive information in key names. Not all backends support listing.  In the list above, the associated HTTP verbs are shown in parenthesis next to the capability. When authoring policy, it is usually helpful to look at the HTTP API documentation for the paths and HTTP verbs and map them back onto capabilities. While the mapping is not strictly 1:1, they are often very similarly matched.  In addition to the standard set, there are some capabilities that do not map to HTTP verbs.  sudo - Allows access to paths that are root-protected. Tokens are not permitted to interact with these paths unless they have the sudocapability (in addition to the other necessary capabilities for performing an operation against that path, such as read or delete). For example, modifying the audit log backends requires a token with sudoprivileges. deny - Disallows access. This always takes precedence regardless of any other defined capabilities, including sudo.  warning Note: Capabilities usually map to the HTTP verb, and not the underlying action taken. This can be a common source of confusion. Generating database credentials creates database credentials, but the HTTP request is a GET which corresponds to a read capability. Thus, to grant access to generate database credentials, the policy would grant read access on the appropriate path.  ","version":"Next","tagName":"h3"},{"title":"Templated policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#templated-policies","content":" The policy syntax allows for doing variable replacement in some policy strings with values available to the token. Currently identity information can be injected, and currently the path keys in policies allow injection.  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#parameters","content":" Name\tDescriptionidentity.entity.id\tThe entity's ID identity.entity.name\tThe entity's name identity.entity.metadata.&lt;metadata key&gt;\tMetadata associated with the entity for the given key identity.entity.aliases.&lt;mount accessor&gt;.id\tEntity alias ID for the given mount identity.entity.aliases.&lt;mount accessor&gt;.name\tEntity alias name for the given mount identity.entity.aliases.&lt;mount accessor&gt;.metadata.&lt;metadata key&gt;\tMetadata associated with the alias for the given mount and metadata key identity.entity.aliases.&lt;mount accessor&gt;.custom_metadata.&lt;custom_metadata key&gt;\tCustom metadata associated with the alias for the given mount and custom metadata key identity.groups.ids.&lt;group id&gt;.name\tThe group name for the given group ID identity.groups.names.&lt;group name&gt;.id\tThe group ID for the given group name identity.groups.ids.&lt;group id&gt;.metadata.&lt;metadata key&gt;\tMetadata associated with the group for the given key identity.groups.names.&lt;group name&gt;.metadata.&lt;metadata key&gt;\tMetadata associated with the group for the given key  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#examples","content":" The following policy creates a section of the KVv2 Secret Engine to a specific user  path &quot;secret/data/{{identity.entity.id}}/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;read&quot;, &quot;delete&quot;] } path &quot;secret/metadata/{{identity.entity.id}}/*&quot; { capabilities = [&quot;list&quot;] }   If you wanted to create a shared section of KV that is associated with entities that are in a group.  # In the example below, the group ID maps a group and the path path &quot;secret/data/groups/{{identity.groups.ids.fb036ebc-2f62-4124-9503-42aa7A869741.name}}/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;read&quot;, &quot;delete&quot;] } path &quot;secret/metadata/groups/{{identity.groups.ids.fb036ebc-2f62-4124-9503-42aa7A869741.name}}/*&quot; { capabilities = [&quot;list&quot;] }   warning Note: When developing templated policies, use IDs wherever possible. Each ID is unique to the user, whereas names can change over time and can be reused. This ensures that if a given user or group name is changed, the policy will be mapped to the intended entity or group.  If you want to use the metadata associated with an authentication plugin in your templates, you will need to get its mount accessor and access it via thealiases key.  You can get the mount accessor value using the following command:  $&gt; bao auth list Path Type Accessor Description ---- ---- -------- ----------- kubernetes/ kubernetes auth_kubernetes_xxxx n/a token/ token auth_token_yyyy token based credentials   The following templated policy allow to read the path associated with the Kubernetes service account namespace of the identity:  path &quot;secret/data/{{identity.entity.aliases.auth_kubernetes_xxxx.metadata.service_account_namespace}}/*&quot; { capabilities = [&quot;read&quot;] }   ","version":"Next","tagName":"h3"},{"title":"Fine-grained control​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#fine-grained-control","content":" In addition to the standard set of capabilities, OpenBao offers finer-grained control over permissions at a given path. The capabilities associated with a path take precedence over permissions on parameters.  ","version":"Next","tagName":"h2"},{"title":"Parameter constraints​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#parameter-constraints","content":" danger Note: The use of globs (*) may result in surprising or unexpected behavior.  warning Note: The allowed_parameters, denied_parameters, and required_parameters fields are not supported for policies used with the version 2 kv secrets engine.  See the API Specification for more information.  Policies can take into account HTTP request parameters to further constrain requests, using the following options:  required_parameters - A list of parameters that must be specified. # This requires the user to create &quot;secret/profile&quot; with a parameter/key named # &quot;name&quot; and &quot;id&quot; where kv v1 is enabled at &quot;secret/&quot;. path &quot;secret/profile&quot; { capabilities = [&quot;create&quot;] required_parameters = [&quot;name&quot;, &quot;id&quot;] } allowed_parameters - A list of keys and values that are permitted on the given path. Setting a parameter with a value of the empty list allows the parameter to contain any value. # This allows the user to update the password parameter value set on any # users configured for userpass auth method. The password value can be # anything. However, the user cannot update other parameter values such as # token_ttl. path &quot;auth/userpass/users/*&quot; { capabilities = [&quot;update&quot;] allowed_parameters = { &quot;password&quot; = [] } }   info Usage example: The ACL Policy Path Templatingtutorial demonstrates the use of allowed_parameters to permit a user to update the user's password when using the userpass auth method to log in with OpenBao.  Setting a parameter with a value of a populated list allows the parameter to contain only those values. # This allows the user to create or update an encryption key for transit # secrets engine enabled at &quot;transit/&quot;. When you do, you can set the # &quot;auto_rotate_period&quot; parameter value so that the key gets rotated. # However, the rotation period must be &quot;8h&quot;, &quot;24h&quot;, or &quot;5d&quot;. Any other value # will result in an error. path &quot;transit/keys/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;] allowed_parameters = { &quot;auto_rotate_period&quot; = [&quot;8h&quot;, &quot;24h&quot;, &quot;5d&quot;] } } If any keys are specified, all non-specified parameters will be denied unless the parameter &quot;*&quot; is set to an empty array, which will allow all other parameters to be modified. Parameters with specific values will still be restricted to those values. # When kv v1 secrets engine is enabled at &quot;secret/&quot;, this allows the user to # create &quot;secret/foo&quot; with a parameter named &quot;bar&quot;. The parameter &quot;bar&quot; can # only contain the values &quot;zip&quot; or &quot;zap&quot;, but any other parameters may be # created with any value. path &quot;secret/foo&quot; { capabilities = [&quot;create&quot;] allowed_parameters = { &quot;bar&quot; = [&quot;zip&quot;, &quot;zap&quot;] &quot;*&quot; = [] } } denied_parameters - A list of keys and values that are not permitted on the given path. Any values specified here take precedence over allowed_parameters. Setting a parameter with a value of the empty list denies any changes to that parameter. # This allows the user to update the userpass auth method's user # configurations (e.g., &quot;password&quot;) but cannot update the &quot;token_policies&quot; # and &quot;policies&quot; parameter values. path &quot;auth/userpass/users/*&quot; { capabilities = [&quot;update&quot;] denied_parameters = { &quot;token_policies&quot; = [] &quot;policies&quot; = [] } } Setting a parameter with a value of a populated list denies any parameter containing those values. # This allows the user to create or update token roles. However, the # &quot;allowed_policies&quot; parameter value cannot be &quot;admin&quot;, but the user can # assign any other policies to the parameter. path &quot;auth/token/roles/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;] denied_parameters = { &quot;allowed_policies&quot; = [&quot;admin&quot;] } } Setting to &quot;*&quot; will deny any parameter. # This allows the user to create or update an encryption key for transit # secrets engine enabled at &quot;transit/&quot;. However, the user cannot set any of # the configuration parameters. As a result, the created key will have all # parameters set to default values. path &quot;transit/keys/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;] denied_parameters = { &quot;*&quot; = [] } } If any parameters are specified, all non-specified parameters are allowed, unless allowed_parameters is also set, in which case normal rules apply.  Parameter values also support prefix/suffix globbing. Globbing is enabled by prepending or appending or prepending a splat (*) to the value:  # Only allow a parameter named &quot;bar&quot; with a value starting with &quot;foo-*&quot;. path &quot;secret/foo&quot; { capabilities = [&quot;create&quot;] allowed_parameters = { &quot;bar&quot; = [&quot;foo-*&quot;] } }   warning Note: the only value that can be used with the * parameter is [].  Parameter constraints limitations​  Default values​  Evaluation of policies with allowed_parameters, denied_parameters, and required_parameters happens without consideration of parameters' default values.  Given the following policy:  # The &quot;no_store&quot; parameter cannot be false path &quot;secret/foo&quot; { capabilities = [&quot;create&quot;] denied_parameters = { &quot;no_store&quot; = [false, &quot;false&quot;] } }   The following operation will error, because &quot;no_store&quot; is set to false:  $ bao write secret/foo no_store=false value=bar   Whereas the following operation will succeed, even if the &quot;no_store&quot; parameter must be a boolean, and it defaults to false:  # Succeeds because &quot;no_store=false&quot; isn't present in the parameters $ bao write secret/foo value=bar   This is because the policy evaluator does not know what the default value is for the &quot;no_store&quot; parameter. All it sees is that the denied parameter isn't present in the command.  This can be resolved by requiring the &quot;no_store&quot; parameter in your policy:  path &quot;secret/foo&quot; { capabilities = [&quot;create&quot;] required_parameters = [&quot;no_store&quot;] denied_parameters = { &quot;no_store&quot; = [false, &quot;false&quot;] } }   The following command, which previously succeeded, will now fail under the new policy because there is no &quot;no_store&quot; parameter:  $ bao write secret/foo value=bar   Globbing​  It's also important to note that the use of globbing may result in surprising or unexpected behavior:  # This allows the user to create, update, or patch &quot;secret/foo&quot; with a parameter # named &quot;bar&quot;. the values passed to parameter &quot;bar&quot; must start with &quot;baz/&quot; # so values like &quot;baz/quux&quot; are fine. however, values like # &quot;baz/quux,wibble,wobble,wubble&quot; would also be accepted. the API that # underlies &quot;secret/foo&quot; might allow comma delimited values for the &quot;bar&quot; # parameter, and if it did, specifying a value like # &quot;baz/quux,wibble,wobble,wubble&quot; would result in 4 different values getting # passed along. seeing values like &quot;wibble&quot; or &quot;wobble&quot; getting passed to # &quot;secret/foo&quot; might surprise someone that expected the allowed_parameters # constraint to only allow values starting with &quot;baz/&quot;. path &quot;secret/foo&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;, &quot;patch&quot;] allowed_parameters = { &quot;bar&quot; = [&quot;baz/*&quot;] } }   ","version":"Next","tagName":"h3"},{"title":"Required response wrapping TTLs​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#required-response-wrapping-ttls","content":" These parameters can be used to set minimums/maximums on TTLs set by clients when requesting that a response bewrapped, with a granularity of a second. These use duration format strings.  In practice, setting a minimum TTL of one second effectively makes response wrapping mandatory for a particular path.  min_wrapping_ttl - The minimum allowed TTL that clients can specify for a wrapped response. In practice, setting a minimum TTL of one second effectively makes response wrapping mandatory for a particular path. It can also be used to ensure that the TTL is not too low, leading to end targets being unable to unwrap before the token expires. max_wrapping_ttl - The maximum allowed TTL that clients can specify for a wrapped response.  # This effectively makes response wrapping mandatory for this path by setting min_wrapping_ttl to 1 second. # This also sets this path's wrapped response maximum allowed TTL to 90 seconds. path &quot;auth/approle/role/my-role/secret-id&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;] min_wrapping_ttl = &quot;1s&quot; max_wrapping_ttl = &quot;90s&quot; }   If both are specified, the minimum value must be less than the maximum. In addition, if paths are merged from different stanzas, the lowest value specified for each is the value that will result, in line with the idea of keeping token lifetimes as short as possible.  ","version":"Next","tagName":"h3"},{"title":"Built-in policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#built-in-policies","content":" OpenBao has two built-in policies: default and root. This section describes the two built-in policies.  ","version":"Next","tagName":"h2"},{"title":"Default policy​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#default-policy","content":" The default policy is a built-in OpenBao policy that cannot be removed. By default, it is attached to all tokens, but may be explicitly excluded at token creation time by supporting authentication methods.  The policy contains basic functionality such as the ability for the token to look up data about itself and to use its cubbyhole data. However, OpenBao is not prescriptive about its contents. It can be modified to suit your needs; OpenBao will never overwrite your modifications. If you want to stay up-to-date with the latest upstream version of the default policy, simply read the contents of the policy from an up-to-date dev server, and write those contents into your OpenBao's default policy.  To view all permissions granted by the default policy on your OpenBao installation, run:  $ bao read sys/policy/default   To disable attachment of the default policy:  $ bao token create -no-default-policy   or via the API:  $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data '{&quot;no_default_policy&quot;: &quot;true&quot;}' \\ https://openbao.hashicorp.rocks/v1/auth/token/create   ","version":"Next","tagName":"h3"},{"title":"Root policy​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#root-policy","content":" The root policy is a built-in OpenBao policy that cannot be modified or removed. Any user associated with this policy becomes a root user. A root user can doanything within OpenBao. As such, it is highly recommended that you revoke any root tokens before running OpenBao in production.  When an OpenBao server is first initialized, there always exists one root user. This user is used to do the initial configuration and setup of OpenBao. After configured, the initial root token should be revoked and more strictly controlled users and authentication should be used.  To revoke a root token, run:  $ bao token revoke &quot;&lt;token&gt;&quot;   or via the API:  $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data '{&quot;token&quot;: &quot;&lt;token&gt;&quot;}' \\ https://openbao.hashicorp.rocks/v1/auth/token/revoke   For more information, please read:  Production HardeningGenerating a Root Token  ","version":"Next","tagName":"h3"},{"title":"Managing policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#managing-policies","content":" Policies are authored (written) in your editor of choice. They can be authored in HCL or JSON, and the syntax is described in detail above. Once saved, policies must be uploaded to OpenBao before they can be used.  ","version":"Next","tagName":"h2"},{"title":"Listing policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#listing-policies","content":" To list all registered policies in OpenBao:  $ bao read sys/policy   or via the API:  $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ https://openbao.hashicorp.rocks/v1/sys/policy   warning Note: You may also see the CLI command bao policies. This is a convenience wrapper around reading the sys endpoint directly. It provides the same functionality but formats the output in a special manner.  ","version":"Next","tagName":"h3"},{"title":"Creating policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#creating-policies","content":" Policies may be created (uploaded) via the CLI or via the API. To create a new policy in OpenBao:  $ bao policy write policy-name policy-file.hcl   or via the API:  $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data '{&quot;policy&quot;:&quot;path \\&quot;...\\&quot; {...} &quot;}' \\ https://openbao.hashicorp.rocks/v1/sys/policy/policy-name   In both examples, the name of the policy is &quot;policy-name&quot;. You can think of this name as a pointer or symlink to the policy ACLs. Tokens are attached policies by name, which are then mapped to the set of rules corresponding to that name.  ","version":"Next","tagName":"h3"},{"title":"Updating policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#updating-policies","content":" Existing policies may be updated to change permissions via the CLI or via the API. To update an existing policy in OpenBao, follow the same steps as creating a policy, but use an existing policy name:  $ bao write sys/policy/my-existing-policy policy=@updated-policy.json   or via the API:  $ curl \\ --request POST \\ --header &quot;X-Vault-Token: ...&quot; \\ --data '{&quot;policy&quot;:&quot;path \\&quot;...\\&quot; {...} &quot;}' \\ https://openbao.hashicorp.rocks/v1/sys/policy/my-existing-policy   ","version":"Next","tagName":"h3"},{"title":"Deleting policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#deleting-policies","content":" Existing policies may be deleted via the CLI or API. To delete a policy:  $ bao delete sys/policy/policy-name   or via the API:  $ curl \\ --request DELETE \\ --header &quot;X-Vault-Token: ...&quot; \\ https://openbao.hashicorp.rocks/v1/sys/policy/policy-name   This is an idempotent operation. OpenBao will not return an error when deleting a policy that does not exist.  ","version":"Next","tagName":"h3"},{"title":"Associating policies​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#associating-policies","content":" OpenBao can automatically associate a set of policies to a token based on an authorization. This configuration varies significantly between authentication backends. For simplicity, this example will use OpenBao's built-in userpass auth method.  An OpenBao administrator or someone from the security team would create the user in OpenBao with a list of associated policies:  $ bao write auth/userpass/users/sethvargo \\ password=&quot;s3cr3t!&quot; \\ policies=&quot;dev-readonly,logs&quot;   This creates an authentication mapping to the policy such that, when the user authenticates successfully to OpenBao, they will be given a token which has the list of policies attached.  The user wishing to authenticate would run  $ bao login -method=&quot;userpass&quot; username=&quot;sethvargo&quot; Password (will be hidden): ...   If the provided information is correct, OpenBao will generate a token, assign the list of configured policies to the token, and return that token to the authenticated user.  ","version":"Next","tagName":"h2"},{"title":"Root protected API endpoints​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#root-protected-api-endpoints","content":" warning Note: OpenBao treats the HTTP POST and PUT verbs as equivalent, so for each mention of POST in the table above, PUT may also be used. OpenBao uses the non-standard LIST HTTP verb, but also allows list requests to be made using the GET verb along with ?list=trueas a query parameter, so for each mention of LIST in the table above, GET with ?list=truemay also be used.  The following paths requires a root token or sudo capability in the policy:  Path\tHTTP verb\tDescriptionauth/token/accessors\tLIST\tList token accessors for all current OpenBao service tokens auth/token/create\tPOST\tCreate a periodic or an orphan token (period or no_parent) option pki/root\tDELETE\tDelete the current CA key (pki secrets engine) pki/root/sign-self-issued\tPOST\tUse the configured CA certificate to sign a self-issued certificate (pki secrets engine) sys/audit\tGET\tList enabled audit devices sys/audit/:path\tPOST, DELETE\tEnable or remove an audit device sys/auth/:path\tGET, POST, DELETE\tManage the auth methods (enable, read, and delete) sys/auth/:path/tune\tGET, POST\tManage the auth methods (enable, read, delete, and tune) sys/config/auditing/request-headers\tGET\tList the request headers that are configured to be audited sys/config/auditing/request-headers/:name\tGET, POST, DELETE\tManage the auditing headers (create, update, read and delete) sys/config/cors\tGET, POST, DELETE\tConfigure CORS setting sys/config/ui/headers\tGET, LIST\tConfigure the UI settings sys/config/ui/headers/:name\tPOST, DELETE\tConfigure custom HTTP headers to be served with the UI sys/internal/inspect/router/:tag\tGET\tInspect the internal components of OpenBao's router. tag must be one of root, uuid, accessor, or storage sys/leases/lookup/:prefix\tLIST\tList lease IDs sys/leases/revoke-force/:prefix\tPOST\tRevoke all secrets or tokens ignoring backend errors sys/leases/revoke-prefix/:prefix\tPOST\tRevoke all secrets generated under a given prefix sys/plugins/catalog/:type/:name\tGET, POST, DELETE\tRegister a new plugin, or read/remove an existing plugin sys/raw:path\tGET, POST, DELETE\tUsed to access the raw underlying store in OpenBao sys/raw:prefix\tGET, LIST\tReturns a list keys for a given path prefix sys/remount\tPOST\tMoves an already-mounted backend to a new mount point sys/rotate\tPOST\tTrigger a rotation of the backend encryption key sys/seal\tPOST\tSeals the OpenBao sys/step-down\tPOST\tForces a node to give up active status  ","version":"Next","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#tokens","content":" Tokens have two sets of policies: identity policies, which are computed based on the entity and its groups, and token policies, which are either defined based on the login method or, in the case of explicit token creates via the API, are an input to the token creation. What follows concerns token policies exclusively: a token's identity policies cannot be controlled except by modifying the underlying entities, groups, and group memberships.  Tokens are associated with their policies at creation time. For example:  $ bao token create -policy=dev-readonly -policy=logs   Normally the only policies that may be specified are those which are present in the current token's (i.e. the new token's parent's) token policies. However, root users can assign any policies.  There is no way to modify the policies associated with a token once the token has been issued. The token must be revoked and a new one acquired to receive a new set of policies.  However, the contents of policies are parsed in real-time whenever the token is used. As a result, if a policy is modified, the modified rules will be in force the next time a token, with that policy attached, is used to make a call to OpenBao.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Policies","url":"/openbao/docs/concepts/policies/#tutorial","content":" Refer to the following tutorials for further learning:  OpenBao PoliciesACL Policy Path Templating ","version":"Next","tagName":"h2"},{"title":"Seal/Unseal","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/seal/","content":"","keywords":"","version":"Next"},{"title":"Why?​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#why","content":" The data stored by OpenBao is encrypted. OpenBao needs the encryption key in order to decrypt the data. The encryption key is also stored with the data (in the keyring), but encrypted with another encryption key known as the root key.  Therefore, to decrypt the data, OpenBao must decrypt the encryption key which requires the root key. Unsealing is the process of getting access to this root key. The root key is stored alongside all other OpenBao data, but is encrypted by yet another mechanism: the unseal key.  To recap: most OpenBao data is encrypted using the encryption key in the keyring; the keyring is encrypted by the root key; and the root key is encrypted by the unseal key.  ","version":"Next","tagName":"h2"},{"title":"Shamir seals​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#shamir-seals","content":"   The default OpenBao config uses a Shamir seal. Instead of distributing the unseal key as a single key to an operator, OpenBao uses an algorithm known asShamir's Secret Sharingto split the key into shares. A certain threshold of shares is required to reconstruct the unseal key, which is then used to decrypt the root key.  This is the unseal process: the shares are added one at a time (in any order) until enough shares are present to reconstruct the key and decrypt the root key.  ","version":"Next","tagName":"h2"},{"title":"Unsealing​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#unsealing","content":" The unseal process is done by running bao operator unseal or via the API. This process is stateful: each key can be entered via multiple mechanisms from multiple client machines and it will work. This allows each shares of the root key to be on a distinct client machine for better security.  Note that when using the Shamir seal with multiple nodes, each node must be unsealed with the required threshold of shares. Partial unsealing of each node is not distributed across the cluster.  Once an OpenBao node is unsealed, it remains unsealed until one of these things happens:  It is resealed via the API (see below). The server is restarted. OpenBao's storage layer encounters an unrecoverable error.  info Note: Unsealing makes the process of automating an OpenBao install difficult. Automated tools can easily install, configure, and start OpenBao, but unsealing it using Shamir is a very manual process. For most users Auto Unseal will provide a better experience.  ","version":"Next","tagName":"h2"},{"title":"Sealing​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#sealing","content":" There is also an API to seal the OpenBao. This will throw away the root key in memory and require another unseal process to restore it. Sealing only requires a single operator with root privileges.  This way, if there is a detected intrusion, the OpenBao data can be locked quickly to try to minimize damages. It can't be accessed again without access to the root key shares.  ","version":"Next","tagName":"h2"},{"title":"Auto unseal​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#auto-unseal","content":" Auto Unseal was developed to aid in reducing the operational complexity of keeping the unseal key secure. This feature delegates the responsibility of securing the unseal key from users to a trusted device or service. At startup OpenBao will connect to the device or service implementing the seal and ask it to decrypt the root key OpenBao read from storage.    There are certain operations in OpenBao besides unsealing that require a quorum of users to perform, e.g. generating a root token. When using a Shamir seal the unseal keys must be provided to authorize these operations. When using Auto Unseal these operations require recovery keys instead.  Just as the initialization process with a Shamir seal yields unseal keys, initializing with an Auto Unseal yields recovery keys.  It is still possible to seal an OpenBao node using the API. In this case OpenBao will remain sealed until restarted, or the unseal API is used, which with Auto Unseal requires the recovery key fragments instead of the unseal key fragments that would be provided with Shamir. The process remains the same.  For a list of examples and supported providers, please see theseal documentation.  info Warning: Recovery keys cannot decrypt the root key, and thus are not sufficient to unseal OpenBao if the Auto Unseal mechanism isn't working. They are purely an authorization mechanism. Using Auto Unseal creates a strict OpenBao lifecycle dependency on the underlying seal mechanism. This means that if the seal mechanism (such as the Cloud KMS key) becomes unavailable, or deleted before the seal is migrated, then there is no ability to recover access to the OpenBao cluster until the mechanism is available again. If the seal mechanism or its keys are permanently deleted, then the OpenBao cluster cannot be recovered, even from backups.To mitigate this risk, we recommend careful controls around management of the seal mechanism, for example usingAWS Service Control Policiesor similar.  ","version":"Next","tagName":"h2"},{"title":"Recovery key​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#recovery-key","content":" When OpenBao is initialized while using an HSM or KMS, rather than unseal keys being returned to the operator, recovery keys are returned. These are generated from an internal recovery key that is split via Shamir's Secret Sharing, similar to OpenBao's treatment of unseal keys when running without an HSM or KMS.  Details about initialization and rekeying follow. When performing an operation that uses recovery keys, such as generate-root, selection of the recovery keys for this purpose, rather than the barrier unseal keys, is automatic.  ","version":"Next","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#initialization","content":" When initializing, the split is performed according to the following CLI flags and their API equivalents in the /sys/init endpoint:  recovery-shares: The number of shares into which to split the recovery key. This value is equivalent to the recovery_shares value in the API endpoint.recovery-threshold: The threshold of shares required to reconstruct the recovery key. This value is equivalent to the recovery_threshold value in the API endpoint.recovery-pgp-keys: The PGP keys to use to encrypt the returned recovery key shares. This value is equivalent to the recovery_pgp_keys value in the API endpoint, although as with pgp_keys the object in the API endpoint is an array, not a string.  Additionally, OpenBao will refuse to initialize if the option has not been set to generate a key, and no key is found. SeeConfiguration for more details.  ","version":"Next","tagName":"h3"},{"title":"Rekeying​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#rekeying","content":" Unseal key​  OpenBao's unseal key can be rekeyed using a normal bao operator rekeyoperation from the CLI or the matching API calls. The rekey operation is authorized by meeting the threshold of recovery keys. After rekeying, the new barrier key is wrapped by the HSM or KMS and stored like the previous key; it is not returned to the users that submitted their recovery keys.  Recovery key​  The recovery key can be rekeyed to change the number of shares/threshold or to target different key holders via different PGP keys. When using the OpenBao CLI, this is performed by using the -target=recovery flag to bao operator rekey.  Via the API, the rekey operation is performed with the same parameters as thenormal /sys/rekeyendpoint; however, the API prefix for this operation is at /sys/rekey-recovery-key rather than/sys/rekey.  ","version":"Next","tagName":"h3"},{"title":"Seal migration​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#seal-migration","content":" The Seal migration process cannot be performed without downtime, and due to the technical underpinnings of the seal implementations, the process requires that you briefly take the whole cluster down. While experiencing some downtime may be unavoidable, we believe that switching seals is a rare event and that the inconvenience of the downtime is an acceptable trade-off.  warning NOTE: A backup should be taken before starting seal migration in case something goes wrong.  warning NOTE: Seal migration operation will require both old and new seals to be available during the migration. For example, migration from Auto Unseal to Shamir seal will require that the service backing the Auto Unseal is accessible during the migration.  warning NOTE: Seal migration from Auto Unseal to Auto Unseal of the same type is supported in OpenBao. However, there is a current limitation that prevents migrating from AWSKMS to AWSKMS; all other seal migrations of the same type are supported. Seal migration from One Auto Unseal type (AWS KMS) to different Auto Unseal type (HSM, Azure KMS, etc.) is also supported on older versions as well.  ","version":"Next","tagName":"h2"},{"title":"Migration steps​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#migration-steps","content":" These steps are common for seal migrations between any supported kinds and for any storage backend.  Take a standby node down and update the seal configuration. If the migration is from Shamir seal to Auto seal, add the desired new Auto seal block to the configuration.If the migration is from Auto seal to Shamir seal, add disabled = &quot;true&quot;to the old seal block.If the migration is from Auto seal to another Auto seal, add disabled = &quot;true&quot; to the old seal block and add the desired new Auto seal block. Now, bring the standby node back up and run the unseal command on each key, by supplying the -migrate flag. Supply Shamir unseal keys if the old seal was Shamir, which will be migrated as the recovery keys for the Auto seal.Supply recovery keys if the old seal is one of Auto seals, which will be migrated as the recovery keys of the new Auto seal, or as Shamir unseal keys if the new seal is Shamir. Perform step 1 for all the standby nodes, one at a time. It is necessary to bring back the downed standby node before moving on to the other standby nodes, specifically when Integrated Storage is in use for it helps to retain the quorum. Step down the active node. One of the standby nodes will become the new active node. When using Integrated Storage, ensure that quorum is reached and a leader is elected. The new active node will perform the migration. Monitor the server log in the active node to witness the completion of the seal migration process. Wait for a little while for the migration information to replicate to all the nodes in case of Integrated Storage. Seal migration is now completed. Take down the old active node, update its configuration to use the new seal blocks (completely unaware of the old seal type) ,and bring it back up. It will be auto-unsealed if the new seal is one of the Auto seals, or will require unseal keys if the new seal is Shamir. At this point, configuration files of all the nodes can be updated to only have the new seal information. Standby nodes can be restarted right away and the active node can be restarted upon a leadership change.  ","version":"Next","tagName":"h3"},{"title":"Migration pre 1.5.1​","type":1,"pageTitle":"Seal/Unseal","url":"/openbao/docs/concepts/seal/#migration-pre-151","content":" Migration from shamir to auto unseal​  To migrate from Shamir keys to Auto Unseal, take your server cluster offline and update the seal configuration with the appropriate seal configuration. Bring your server back up and leave the rest of the nodes offline if using multi-server mode, then run the unseal process with the-migrate flag and bring the rest of the cluster online.  All unseal commands must specify the -migrate flag. Once the required threshold of unseal keys are entered, unseal keys will be migrated to recovery keys.  $ bao operator unseal -migrate  Migration from auto unseal to shamir​  To migrate from Auto Unseal to Shamir keys, take your server cluster offline and update the seal configuration and add disabled = &quot;true&quot; to the seal block. This allows the migration to use this information to decrypt the key but will not unseal OpenBao. When you bring your server back up, run the unseal process with the -migrate flag and use the Recovery Keys to perform the migration. All unseal commands must specify the -migrate flag. Once the required threshold of recovery keys are entered, the recovery keys will be migrated to be used as unseal keys.  Migration from auto unseal to auto unseal​  To migrate from Auto Unseal to a different Auto Unseal configuration, take your server cluster offline and update the existing seal configuration and add disabled = &quot;true&quot; to the seal block. Then add another seal block to describe the new seal.  When you bring your server back up, run the unseal process with the -migrateflag and use the Recovery Keys to perform the migration. All unseal commands must specify the -migrate flag. Once the required threshold of recovery keys are entered, the recovery keys will be kept and used as recovery keys in the new seal.  Migration with integrated storage​  Integrated Storage uses the Raft protocol underneath, which requires a quorum of servers to be online before the cluster is functional. Therefore, bringing the cluster back up one node at a time with the seal configuration updated, will not work in this case. Follow the same steps for each kind of migration described above with the exception that after the cluster is taken offline, update the seal configurations of all the nodes appropriately and bring them all back up. When the quorum of nodes are back up, Raft will elect a leader and the leader node that will perform the migration. The migrated information will be replicated to all other cluster peers and when the peers eventually become the leader, migration will not happen again on the peer nodes. ","version":"Next","tagName":"h3"},{"title":"Storage","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/storage/","content":"","keywords":"","version":"Next"},{"title":"Supported storage backends​","type":1,"pageTitle":"Storage","url":"/openbao/docs/concepts/storage/#supported-storage-backends","content":" Many other options for storage are available for OpenBao - see ourStorage Configuration section for more information.  info Choosing a storage backend: Refer to the integrated storage vs. external storagesection of the storage configuration page to help make a decision about which storage backend to use.  ","version":"Next","tagName":"h2"},{"title":"Backups​","type":1,"pageTitle":"Storage","url":"/openbao/docs/concepts/storage/#backups","content":" Due to the highly flexible nature of OpenBao's potential storage configurations, providing exact guidance on backing up OpenBao is challenging.  When backing up OpenBao, there are two pieces to consider:  OpenBao's encrypted data in the storage backendConfiguration files and management scripts for running the OpenBao server  There's also a big question - what is the error case you're trying to guard against by saving a backup?  ","version":"Next","tagName":"h2"},{"title":"The big question - why take backups?​","type":1,"pageTitle":"Storage","url":"/openbao/docs/concepts/storage/#the-big-question---why-take-backups","content":" It's important to consider the question of &quot;why take a backup&quot; while developing your ongoing backup and disaster recovery strategy.  Taking a backup is recommended prior to upgrades, as downgrading OpenBao storage is not always possible. Generally, a backup is recommended any time a major change is planned for a cluster.  More specifically, we recommend taking backups before, but not during, write operations to the /sys API (excluding the /sys/leases, /sys/namespaces,/sys/tools, /sys/wrapping, /sys/policies, and /sys/pprof endpoints). Some examples of workflows that write to the /sys API are upgrades and rekeys. In the future, this guidance may change for the Integrated Storage backend.  Backups can also help with accidental data deletions or modifications. In this case, the story can get a little tricky. If you simply recover a backup from 5AM with the correct data, but the current time is 10AM, you will lose data written between 5 and 10AM. Lucy Davinhart gave a HashiConf talk that serves as an interesting case study.  We do not recommend backups as protection against the failure of an individual machine. OpenBao servers can run in clusters, so to protect against server failure, we recommend running OpenBao in HA mode. An OpenBao cluster can extend across multiple availability zones within a region.  When using OpenBao in HA Mode, a backup can help guard against the failure of a data center.  Ultimately, backups are not a replacement for running in HA. As you develop a plan for recovering from or guarding against failure, you should consider both backups and HA as critical components of that plan.  ","version":"Next","tagName":"h3"},{"title":"Backing up OpenBao's persisted data​","type":1,"pageTitle":"Storage","url":"/openbao/docs/concepts/storage/#backing-up-openbaos-persisted-data","content":" Backups and restores are ideally performed while OpenBao is offline. If offline backups are not feasible, we recommend using a storage backend that supports atomic snapshots (such as Integrated Storage).  warning If your storage backend does not support atomic snapshots, we recommend only taking offline backups.  To perform a backup or restore of OpenBao's encrypted data when using an officially supported storage backend, see the instructions linked below. For other storage backends, follow the documentation of that backend for taking and restoring backups.  Integrated Storage snapshots  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Storage","url":"/openbao/docs/concepts/storage/#configuration","content":" In addition to backing up OpenBao's encrypted data via the storage backend, you may also wish to save the server configuration files, any scripts for managing the OpenBao service, and ensure you can reinstall any user-installed plugins. The location of these files will be specific to your installation of OpenBao.  NOTE: Although a backup or snapshot of OpenBao's data from the storage backend is encrypted, some of your configuration may be sensitive (an OpenBao token for Transit Autounseal or a TLS private key in your configuration, for example). The presence of this information in your backups will mean that they may need to be carefully protected. ","version":"Next","tagName":"h3"},{"title":"Tokens","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/tokens/","content":"","keywords":"","version":"Next"},{"title":"Token types​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#token-types","content":" There are two types of tokens: service tokens and batch tokens. A section near the bottom of this page contains detailed information about their differences, but it is useful to understand other token concepts first. The features in the following sections all apply to service tokens, and their applicability to batch tokens is discussed later.  ","version":"Next","tagName":"h2"},{"title":"The token store​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#the-token-store","content":" Often in documentation or in help channels, the &quot;token store&quot; is referenced. This is the same as the token authentication backend. This is a special backend in that it is responsible for creating and storing tokens, and cannot be disabled. It is also the only auth method that has no login capability -- all actions require existing authenticated tokens.  ","version":"Next","tagName":"h2"},{"title":"Root tokens​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#root-tokens","content":" Root tokens are tokens that have the root policy attached to them. Root tokens can do anything in OpenBao. Anything. In addition, they are the only type of token within OpenBao that can be set to never expire without any renewal needed. As a result, it is purposefully hard to create root tokens; in fact there are only three ways to create root tokens:  The initial root token generated at bao operator init time -- this token has no expirationBy using another root token; a root token with an expiration cannot create a root token that never expiresBy using bao operator generate-root (example) with the permission of a quorum of unseal key holders  Root tokens are useful in development but should be extremely carefully guarded in production. In fact, the OpenBao team recommends that root tokens are only used for just enough initial setup (usually, setting up auth methods and policies necessary to allow administrators to acquire more limited tokens) or in emergencies, and are revoked immediately after they are no longer needed. If a new root token is needed, the operator generate-root command and associatedAPI endpoint can be used to generate one on-the-fly.  It is also good security practice for there to be multiple eyes on a terminal whenever a root token is live. This way multiple people can verify as to the tasks performed with the root token, and that the token was revoked immediately after these tasks were completed.  ","version":"Next","tagName":"h2"},{"title":"Token hierarchies and orphan tokens​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#token-hierarchies-and-orphan-tokens","content":" Normally, when a token holder creates new tokens, these tokens will be created as children of the original token; tokens they create will be children of them; and so on. When a parent token is revoked, all of its child tokens -- and all of their leases -- are revoked as well. This ensures that a user cannot escape revocation by simply generating a never-ending tree of child tokens.  Often this behavior is not desired, so users with appropriate access can createorphan tokens. These tokens have no parent -- they are the root of their own token tree. These orphan tokens can be created:  Via write access to the auth/token/create-orphan endpointBy having sudo or root access to the auth/token/createand setting the no_parent parameter to trueVia token store rolesBy logging in with any other (non-token) auth method  Users with appropriate permissions can also use the auth/token/revoke-orphanendpoint, which revokes the given token but rather than revoke the rest of the tree, it instead sets the tokens' immediate children to be orphans. Use with caution!  ","version":"Next","tagName":"h2"},{"title":"Token accessors​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#token-accessors","content":" When tokens are created, a token accessor is also created and returned. This accessor is a value that acts as a reference to a token and can only be used to perform limited actions:  Look up a token's properties (not including the actual token ID)Look up a token's capabilities on a pathRenew the tokenRevoke the token  The token making the call, not the token associated with the accessor, must have appropriate permissions for these functions.  There are many useful workflows around token accessors. As an example, a service that creates tokens on behalf of another service (such as theNomad scheduler) can store the accessor correlated with a particular job ID. When the job is complete, the accessor can be used to instantly revoke the token given to the job and all of its leased credentials, limiting the chance that a bad actor will discover and use them.  Audit devices can optionally be set to not obfuscate token accessors in audit logs. This provides a way to quickly revoke tokens in case of an emergency. However, it also means that the audit logs can be used to perform a larger-scale denial of service attack.  Finally, the only way to &quot;list tokens&quot; is via the auth/token/accessorscommand, which actually gives a list of token accessors. While this is still a dangerous endpoint (since listing all of the accessors means that they can then be used to revoke all tokens), it also provides a way to audit and revoke the currently-active set of tokens.  ","version":"Next","tagName":"h2"},{"title":"Token Time-To-Live, periodic tokens, and explicit max TTLs​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#token-time-to-live-periodic-tokens-and-explicit-max-ttls","content":" Every non-root token has a time-to-live (TTL) associated with it, which is a current period of validity since either the token's creation time or last renewal time, whichever is more recent. (Root tokens may have a TTL associated, but the TTL may also be 0, indicating a token that never expires). After the current TTL is up, the token will no longer function -- it, and its associated leases, are revoked.  If the token is renewable, OpenBao can be asked to extend the token validity period using bao token renew or the appropriate renewal endpoint. At this time, various factors come into play. What happens depends upon whether the token is a periodic token (available for creation by root/sudo users, token store roles, or some auth methods), has an explicit maximum TTL attached, or neither.  ","version":"Next","tagName":"h2"},{"title":"The general case​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#the-general-case","content":" In the general case, where there is neither a period nor explicit maximum TTL value set on the token, the token's lifetime since it was created will be compared to the maximum TTL. This maximum TTL value is dynamically generated and can change from renewal to renewal, so the value cannot be displayed when a token's information is looked up. It is based on a combination of factors:  The system max TTL, which is 32 days but can be changed in OpenBao's configuration file.The max TTL set on a mount using mount tuning. This value is allowed to override the system max TTL -- it can be longer or shorter, and if set this value will be respected.A value suggested by the auth method that issued the token. This might be configured on a per-role, per-group, or per-user basis. This value is allowed to be less than the mount max TTL (or, if not set, the system max TTL), but it is not allowed to be longer.  Note that the values in (2) and (3) may change at any given time, which is why a final determination about the current allowed max TTL is made at renewal time using the current values. It is also why it is important to always ensure that the TTL returned from a renewal operation is within an allowed range; if this value is not extending, likely the TTL of the token cannot be extended past its current value and the client may want to reauthenticate and acquire a new token. However, outside of direct operator interaction, OpenBao will never revoke a token before the returned TTL has expired.  ","version":"Next","tagName":"h3"},{"title":"Explicit max TTLs​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#explicit-max-ttls","content":" Tokens can have an explicit max TTL set on them. This value becomes a hard limit on the token's lifetime -- no matter what the values in (1), (2), and (3) from the general case are, the token cannot live past this explicitly-set value. This has an effect even when using periodic tokens to escape the normal TTL mechanism.  ","version":"Next","tagName":"h3"},{"title":"Periodic tokens​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#periodic-tokens","content":" In some cases, having a token be revoked would be problematic -- for instance, if a long-running service needs to maintain its SQL connection pool over a long period of time. In this scenario, a periodic token can be used. Periodic tokens can be created in a few ways:  By having sudo capability or a root token with the auth/token/createendpointBy using token store rolesBy using an auth method that supports issuing these, such as AppRole  At issue time, the TTL of a periodic token will be equal to the configured period. At every renewal time, the TTL will be reset back to this configured period, and as long as the token is successfully renewed within each of these periods of time, it will never expire. Outside of root tokens, it is currently the only way for a token in OpenBao to have an unlimited lifetime.  The idea behind periodic tokens is that it is easy for systems and services to perform an action relatively frequently -- for instance, every two hours, or even every five minutes. Therefore, as long as a system is actively renewing this token -- in other words, as long as the system is alive -- the system is allowed to keep using the token and any associated leases. However, if the system stops renewing within this period (for instance, if it was shut down), the token will expire relatively quickly. It is good practice to keep this period as short as possible, and generally speaking it is not useful for humans to be given periodic tokens.  There are a few important things to know when using periodic tokens:  When a periodic token is created via a token store role, the current value of the role's period setting will be used at renewal timeA token with both a period and an explicit max TTL will act like a periodic token but will be revoked when the explicit max TTL is reached  ","version":"Next","tagName":"h3"},{"title":"CIDR-Bound tokens​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#cidr-bound-tokens","content":" Some tokens are able to be bound to CIDR(s) that restrict the range of client IPs allowed to use them. These affect all tokens except for non-expiring root tokens (those with a TTL of zero). If a root token has an expiration, it also is affected by CIDR-binding.  ","version":"Next","tagName":"h2"},{"title":"Token types in detail​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#token-types-in-detail","content":" There are currently two types of tokens.  ","version":"Next","tagName":"h2"},{"title":"Service tokens​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#service-tokens","content":" Service tokens are what users will generally think of as &quot;normal&quot; OpenBao tokens. They support all features, such as renewal, revocation, creating child tokens, and more. They are correspondingly heavyweight to create and track.  ","version":"Next","tagName":"h3"},{"title":"Batch tokens​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#batch-tokens","content":" Batch tokens are encrypted blobs that carry enough information for them to be used for OpenBao actions, but they require no storage on disk to track them. As a result they are extremely lightweight and scalable, but lack most of the flexibility and features of service tokens.  ","version":"Next","tagName":"h3"},{"title":"Token type comparison​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#token-type-comparison","content":" This reference chart describes the difference in behavior between service and batch tokens.  \tService Tokens\tBatch TokensCan Be Root Tokens\tYes\tNo Can Create Child Tokens\tYes\tNo Can be Renewable\tYes\tNo Manually Revocable\tYes\tNo Can be Periodic\tYes\tNo Can have Explicit Max TTL\tYes\tNo (always uses a fixed TTL) Has Accessors\tYes\tNo Has Cubbyhole\tYes\tNo Revoked with Parent (if not orphan)\tYes\tStops Working Dynamic Secrets Lease Assignment\tSelf\tParent (if not orphan) Cost\tHeavyweight; multiple storage writes per token creation\tLightweight; no storage cost for token creation  ","version":"Next","tagName":"h3"},{"title":"Service vs. batch token lease handling​","type":1,"pageTitle":"Tokens","url":"/openbao/docs/concepts/tokens/#service-vs-batch-token-lease-handling","content":" Service tokens​  Leases created by service tokens (including child tokens' leases) are tracked along with the service token and revoked when the token expires.  Batch tokens​  Leases created by batch tokens are constrained to the remaining TTL of the batch tokens and, if the batch token is not an orphan, are tracked by the parent. They are revoked when the batch token's TTL expires, or when the batch token's parent is revoked (at which point the batch token is also denied access to OpenBao). ","version":"Next","tagName":"h3"},{"title":"Transform secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/transform/","content":"","keywords":"","version":"Next"},{"title":"Comparison to transit​","type":1,"pageTitle":"Transform secrets engine","url":"/openbao/docs/concepts/transform/#comparison-to-transit","content":" Transit implements many traditional cryptographic primitives, such as AES encryption and RSA signatures (among others). Transform implements solutions to protect sensitive values in more narrow, but still critical use cases.  ","version":"Next","tagName":"h2"},{"title":"What solution when?​","type":1,"pageTitle":"Transform secrets engine","url":"/openbao/docs/concepts/transform/#what-solution-when","content":" When should one use a particular transform or transit encryption? Based on your use case and its requirements, this flowchart can help you choose the right solution.    Keep in mind that unlike all other solutions, Tokenization is stateful, and all values must be stored either within OpenBao or a supported external store. As such all other solutions will outperform and outscale tokenization. ","version":"Next","tagName":"h2"},{"title":"User lockout","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/user-lockout/","content":"","keywords":"","version":"Next"},{"title":"Precendence​","type":1,"pageTitle":"User lockout","url":"/openbao/docs/concepts/user-lockout/#precendence","content":" The precedence for user lockout configuration is as follows:  Configuration for an auth mount using tune &gt;&gt; Configuration for an auth method in config file &gt;&gt; Configuration for &quot;all&quot; auth methods in config file &gt;&gt; Default values.  The precedence for user lockout disable is as follows:  Disable using environment variable VAULT_DISABLE_USER_LOCKOUT &gt;&gt; Configuration for an auth mount using tune &gt;&gt; Configuration for an auth method in config file &gt;&gt; Configuration for &quot;all&quot; auth methods in config file &gt;&gt; Default values.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"User lockout","url":"/openbao/docs/concepts/user-lockout/#configuration","content":" User lockout parameters can be configured using config file for &quot;all&quot; auth methods or a specific auth method (userpass, ldap, or approle). Please see user lockout configuration for more details.  The user lockout configuration for the auth method at a given path can be tuned using auth tune. Please see auth tune commandor auth tune api for more details.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"User lockout","url":"/openbao/docs/concepts/user-lockout/#api","content":" Please see sys/locked-users API for more details. ","version":"Next","tagName":"h2"},{"title":"Username templating","type":0,"sectionRef":"#","url":"/openbao/docs/concepts/username-templating/","content":"","keywords":"","version":"Next"},{"title":"Available functions​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#available-functions","content":" ","version":"Next","tagName":"h2"},{"title":"String/Character manipulation​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#stringcharacter-manipulation","content":" lowercase - Lowercases the input value. Example: {{.FieldName | lowercase}}  replace - Find/replace on the input value. Example: {{.FieldName | replace - _}}  truncate - truncates the input value to the specified number of characters. Example: {{.FieldName | truncate 10}}  truncate_sha256 - Truncates the input value to the specified number of characters. The last 8 characters of the new value will be replace by the first 8 characters of the SHA256 hash of the truncated characters. Example: {{.FieldName | truncate_sha256 20}}. If FieldName is abcdefghijklmnopqrstuvwxyz, all characters after the 12th (l) are removed and SHA256 hashed (872808ffbf...1886ca6f20). The first 8 characters of the hash (872808ff) are then appended to the end of the first 12 characters from the original value: abcdefghijkl872808ff.  uppercase - Uppercases the input value. Example: {{.FieldName | uppercase}}  ","version":"Next","tagName":"h3"},{"title":"Generating values​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#generating-values","content":" random - Generates a random string from lowercase letters, uppercase letters, and numbers. Must include a number indicating how many characters to generate. Example: {{random 20}} generates 20 random characters  timestamp - The current time. Must provide a formatting string based on Go’s time package. Example: {{timestamp &quot;2006-01-02T15:04:05Z&quot;}}  unix_time - The current unix timestamp (number of seconds since Jan 1 1970). Example: {{unix_time}}  unix_time_millis - The current unix timestamp in milliseconds. Example: {{unix_time_millis}}  uuid - Generates a random UUID. Example: {{uuid}}  ","version":"Next","tagName":"h3"},{"title":"Hashing​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#hashing","content":" base64 - Base64 encodes the input value. Example: {{.FieldName | base64}}  sha256 - SHA256 hashes the input value. Example: {{.FieldName | sha256}}  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#examples","content":" Each secret engine provides a different set of data to the template. Please see the associated secret engine's documentation for details on what values are provided to the template. The examples below are modeled after theDatabase engine's data, however the specific fields that are provided from a given engine may differ from these examples. Additionally, the time is assumed to be 2009-02-13 11:31:30PM GMT (unix timestamp: 1234567890) and random characters are the ordered english alphabet: abcdefghijklmnopqrstuvwxyz.  info Note: The space between {{/}} and the values/functions are optional. For instance: {{.DisplayName}} is equivalent to {{ .DisplayName }}  Field name\tValueDisplayName\ttoken-with-display-name RoleName\tmy_custom_database_role  To reference either of these fields, a . must be put in front of the field name: {{.DisplayName}}. Custom functions do not include a . in front of them: {{random 20}}.  ","version":"Next","tagName":"h2"},{"title":"Basic example​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#basic-example","content":" Template:  {{.DisplayName}}_{{.RoleName}}   Username:  token-with-display-name_my_custom_database_role   This is a basic example that references the two fields that are provided to the template. In simplest terms, this is a simple string substitution.  warning This example does not have any randomness and should not be used when generating dynamic usernames. The purpose is to demonstrate referencing data within the Go template language.  ","version":"Next","tagName":"h3"},{"title":"Custom functions​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#custom-functions","content":" Template:  FOO_{{.DisplayName | replace &quot;-&quot; &quot;_&quot; | uppercase}}_{{.RoleName | replace &quot;-&quot; &quot;_&quot; | uppercase}}_{{timestamp &quot;2006_01_02T15_04_05Z&quot; | replace &quot;-&quot; &quot;_&quot;}}   Username:  FOO_TOKEN_WITH_DISPLAY_NAME_MY_CUSTOM_DATABASE_ROLE_2009_02_13T11_31_30Z_0700   {{.DisplayName | replace &quot;-&quot; &quot;_&quot; | uppercase}} - Replaces all dashes with underscores and then uppercases the display name. {{.RoleName | replace &quot;-&quot; &quot;_&quot; | uppercase}} - Replaces all dashes with underscores and then uppercases the role name. {{timestamp &quot;2006_01_02T15_04_05Z&quot; | replace &quot;-&quot; &quot;_&quot;}} - Generates the current timestamp using the provided format and replaces all dashes with underscores.  ","version":"Next","tagName":"h3"},{"title":"Truncating to maximum length​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#truncating-to-maximum-length","content":" Template:  {{printf &quot;v_%s_%s_%s_%s&quot; (.DisplayName | truncate 8) (.RoleName | truncate 8) (random 20) (unix_time) | truncate 45}}   Username:  v_token-wi_my_custo_abcdefghijklmnopqrst_1234   .DisplayName | truncate 8 truncates the display name to 8 characters (token-wi). .RoleName | truncate 8 truncates the role name to 8 characters (my_custo). random 20 generates 20 random characters abcdefghijklmnopqrst. unix_time generates the current timestamp as the number of seconds since January 1, 1970 (1234567890).   Each of these values are passed to printf &quot;v_%s_%s_%s_%s&quot; which prepends them with v_ and puts an underscore between each field. This results in v_token-wi_my_custo_abcdefghijklmnopqrst_1234567890. This value is then passed totruncate 45 where the last 6 characters are removed which results in v_token-wi_my_custo_abcdefghijklmnopqrst_1234.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Username templating","url":"/openbao/docs/concepts/username-templating/#tutorial","content":" Refer to the following tutorials for step-by-step instructions.  Dynamic Secrets: Database Secrets Engine ","version":"Next","tagName":"h2"},{"title":"listener stanza","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/listener/","content":"listener stanza The listener stanza configures the addresses and ports on which OpenBao will respond to requests. At this time, there are two listeners: TCPUnix Domain Socket","keywords":"","version":"Next"},{"title":"unix listener","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/listener/unix/","content":"","keywords":"","version":"Next"},{"title":"unix listener parameters​","type":1,"pageTitle":"unix listener","url":"/openbao/docs/configuration/listener/unix/#unix-listener-parameters","content":" address (string: &quot;/run/openbao.sock&quot;, &lt;required&gt;) – Specifies the address to bind the Unix socket. socket_mode (string: &quot;&quot;, &lt;optional&gt;) – Changes the access permissions and the special mode flags of the Unix socket. socket_user (string: &quot;&quot;, &lt;optional&gt;) – Changes the user owner of the Unix socket. socket_group (string: &quot;&quot;, &lt;optional&gt;) – Changes the group owner of the Unix socket.  ","version":"Next","tagName":"h2"},{"title":"unix listener examples​","type":1,"pageTitle":"unix listener","url":"/openbao/docs/configuration/listener/unix/#unix-listener-examples","content":" ","version":"Next","tagName":"h2"},{"title":"Listening on multiple sockets​","type":1,"pageTitle":"unix listener","url":"/openbao/docs/configuration/listener/unix/#listening-on-multiple-sockets","content":" This example shows OpenBao listening on a specified socket, as well as the default.  listener &quot;unix&quot; {} listener &quot;unix&quot; { address = &quot;/var/run/openbao.sock&quot; }   ","version":"Next","tagName":"h3"},{"title":"Listening on multiple interfaces​","type":1,"pageTitle":"unix listener","url":"/openbao/docs/configuration/listener/unix/#listening-on-multiple-interfaces","content":" This example shows OpenBao listening on TCP localhost, as well as Unix socket.  listener &quot;unix&quot; { address = &quot;/var/run/openbao.sock&quot; } listener &quot;tcp&quot; { address = &quot;127.0.0.1:8200&quot; }   ","version":"Next","tagName":"h3"},{"title":"Configuring permissions​","type":1,"pageTitle":"unix listener","url":"/openbao/docs/configuration/listener/unix/#configuring-permissions","content":" This example shows changing access permissions and ownership of the Unix socket.  listener &quot;unix&quot; { address = &quot;/var/run/openbao.sock&quot; socket_mode = &quot;644&quot; socket_user = &quot;1000&quot; socket_group = &quot;1000&quot; }  ","version":"Next","tagName":"h3"},{"title":"OpenBao configuration","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Parameters​","type":1,"pageTitle":"OpenBao configuration","url":"/openbao/docs/configuration/#parameters","content":" storage ([StorageBackend][storage-backend]: &lt;required&gt;) – Configures the storage backend where OpenBao data is stored. Please see thestorage backends documentation for the full list of available storage backends. Running OpenBao in HA mode would require coordination semantics to be supported by the backend. If the storage backend supports HA coordination, HA backend options can also be specified in this parameter block. If not, a separate ha_storage parameter should be configured with a backend that supports HA, along with corresponding HA options. ha_storage ([StorageBackend][storage-backend]: nil) – Configures the storage backend where OpenBao HA coordination will take place. This must be an HA-supporting backend. If not set, HA will be attempted on the backend given in the storage parameter. This parameter is not required if the storage backend supports HA coordination and if HA specific options are already specified with storage parameter. (Refer to Use Integrated Storage for HA Coordinationfor a usage example.) listener ([Listener][listener]: &lt;required&gt;) – Configures how OpenBao is listening for API requests. user_lockout ([UserLockout][user-lockout]: nil) – Configures the user-lockout behaviour for failed logins. For more information, please see theuser lockout configuration documentation. seal ([Seal][seal]: nil) – Configures the seal type to use for auto-unsealing, as well as for [seal wrapping][sealwrap] as an additional layer of data protection. cluster_name (string: &lt;generated&gt;) – Specifies the identifier for the OpenBao cluster. If omitted, OpenBao will generate a value. cache_size (string: &quot;131072&quot;) – Specifies the size of the read cache used by the physical storage subsystem. The value is in number of entries, so the total cache size depends on the size of stored entries. disable_cache (bool: false) – Disables all caches within OpenBao, including the read cache used by the physical storage subsystem. This will very significantly impact performance. disable_mlock (bool: false) – Disables the server from executing themlock syscall. mlock prevents memory from being swapped to disk. Disablingmlock is not recommended unless using integrated storage. Follow the additional security precautions outlined below when disabling mlock. This can also be provided via the environment variable VAULT_DISABLE_MLOCK. Disabling mlock is not recommended unless the systems running OpenBao only use encrypted swap or do not use swap at all. OpenBao only supports memory locking on UNIX-like systems that support the mlock() syscall (Linux, FreeBSD, etc). Non UNIX-like systems (e.g. Windows, NaCL, Android) lack the primitives to keep a process's entire memory address space from spilling to disk and is therefore automatically disabled on unsupported platforms. Disabling mlock is strongly recommended if using integrated storage due to the fact that mlock does not interact well with memory mapped files such as those created by BoltDB, which is used by Raft to track state. When usingmlock, memory-mapped files get loaded into resident memory which causes OpenBao's entire dataset to be loaded in-memory and cause out-of-memory issues if OpenBao's data becomes larger than the available RAM. In this case, even though the data within BoltDB remains encrypted at rest, swap should be disabled to prevent OpenBao's other in-memory sensitive data from being dumped into disk. On Linux, to give the OpenBao executable the ability to use the mlocksyscall without running the process as root, run: sudo setcap cap_ipc_lock=+ep $(readlink -f $(which bao))   warning Note: Since each plugin runs as a separate process, you need to do the same for each plugin in your plugins directory.  If you use a Linux distribution with a modern version of systemd, you can add the following directive to the &quot;[Service]&quot; configuration section:  LimitMEMLOCK=infinity   plugin_directory (string: &quot;&quot;) – A directory from which plugins are allowed to be loaded. OpenBao must have permission to read files in this directory to successfully load plugins, and the value cannot be a symbolic link. Enabling the file permissions check via the environment variable VAULT_ENABLE_FILE_PERMISSIONS_CHECKallows OpenBao to check if the config directory and files are owned by the user running OpenBao. It also checks if there are no write or execute permissions for group or others. OpenBao allows operators to specify the user and permissions of the plugin directory and binaries using parameters plugin_file_uid and plugin_file_permissions in config if an operator needs those to be different. This check is disabled by default. plugin_file_uid (integer: 0) – Uid of the plugin directories and plugin binaries if they are owned by an user other than the user running OpenBao. This only needs to be set if the file permissions check is enabled via the environment variable VAULT_ENABLE_FILE_PERMISSIONS_CHECK. plugin_file_permissions (string: &quot;&quot;) – Octal permission string of the plugin directories and plugin binaries if they have write or execute permissions for group or others. This only needs to be set if the file permissions check is enabled via the environment variableVAULT_ENABLE_FILE_PERMISSIONS_CHECK. telemetry ([Telemetry][telemetry]: &lt;none&gt;) – Specifies the telemetry reporting system. default_lease_ttl (string: &quot;768h&quot;) – Specifies the default lease duration for tokens and secrets. This is specified using a label suffix like &quot;30s&quot; or&quot;1h&quot;. This value cannot be larger than max_lease_ttl. max_lease_ttl (string: &quot;768h&quot;) – Specifies the maximum possible lease duration for tokens and secrets. This is specified using a label suffix like &quot;30s&quot; or &quot;1h&quot;. Individual mounts can override this value by tuning the mount with the max-lease-ttl flag of theauth orsecret commands. default_max_request_duration (string: &quot;90s&quot;) – Specifies the default maximum request duration allowed before OpenBao cancels the request. This can be overridden per listener via the max_request_duration value. detect_deadlocks (string: &quot;&quot;) - A comma separated string that specifies the internal mutex locks that should be monitored for potential deadlocks. Currently supported values include statelock, quotas and expiration which will cause &quot;POTENTIAL DEADLOCK:&quot; to be logged when an attempt at a core state lock appears to be deadlocked. Enabling this can have a negative effect on performance due to the tracking of each lock attempt. raw_storage_endpoint (bool: false) – Enables the sys/raw endpoint which allows the decryption/encryption of raw data into and out of the security barrier. This is a highly privileged endpoint. introspection_endpoint (bool: false) - Enables the sys/internal/inspect endpoint which allows users with a root token or sudo privileges to inspect certain subsystems inside OpenBao. ui (bool: false) – Enables the built-in web UI, which is available on all listeners (address + port) at the /ui path. Browsers accessing the standard OpenBao API address will automatically redirect there. This can also be provided via the environment variable VAULT_UI. For more information, please see theui configuration documentation. pid_file (string: &quot;&quot;) - Path to the file in which the OpenBao server's Process ID (PID) should be stored. enable_response_header_hostname (bool: false) - Enables the addition of an HTTP header in all of OpenBao's HTTP responses: X-Vault-Hostname. This will contain the host name of the OpenBao node that serviced the HTTP request. This information is best effort and is not guaranteed to be present. If this configuration option is enabled and the X-Vault-Hostname header is not present in a response, it means there was some kind of error retrieving the host name from the operating system. enable_response_header_raft_node_id (bool: false) - Enables the addition of an HTTP header in all of OpenBao's HTTP responses: X-Vault-Raft-Node-ID. If OpenBao is participating in a Raft cluster (i.e. using integrated storage), this header will contain the Raft node ID of the OpenBao node that serviced the HTTP request. If OpenBao is not participating in a Raft cluster, this header will be omitted, whether this configuration option is enabled or not. log_level (string: &quot;info&quot;) - Log verbosity level. Supported values (in order of descending detail) are trace, debug, info, warn, and error. This can also be specified via the VAULT_LOG_LEVEL environment variable.  warning Note: On SIGHUP (sudo kill -s HUP pid of bao), if a valid value is specified, OpenBao will update the existing log level, overriding (even if specified) both the CLI flag and environment variable.  warning Note: Not all parts of OpenBao's logging can have its log level be changed dynamically this way; in particular, secrets/auth plugins are currently not updated dynamically.  log_format - Equivalent to the -log-format command-line flag. log_file - Equivalent to the -log-file command-line flag. log_rotate_duration - Equivalent to the -log-rotate-duration command-line flag. log_rotate_bytes - Equivalent to the -log-rotate-bytes command-line flag. log_rotate_max_files - Equivalent to the -log-rotate-max-files command-line flag. experiments (string array: []) - The list of experiments to enable for this node. Experiments should NOT be used in production, and the associated APIs may have backwards incompatible changes between releases. Additional experiments can also be specified via the VAULT_EXPERIMENTS environment variable as a comma-separated list, or via the-experiment flag. imprecise_lease_role_tracking (bool: &quot;false&quot;) - Skip lease counting by role if there are no role based quotas enabled. When imprecise_lease_role_tracking is set to true and a new role-based quota is enabled, subsequent lease counts start from 0.imprecise_lease_role_tracking affects role-based lease count quotas, but reduces latencies when not using role based quotas.  ","version":"Next","tagName":"h2"},{"title":"High availability parameters​","type":1,"pageTitle":"OpenBao configuration","url":"/openbao/docs/configuration/#high-availability-parameters","content":" The following parameters are used on backends that support high availability.  api_addr (string: &quot;&quot;) – Specifies the address (full URL) to advertise to other OpenBao servers in the cluster for client redirection. This value is also used for plugin backends. This can also be provided via the environment variable VAULT_API_ADDR. In general this should be set as a full URL that points to the value of the listener address. This can be dynamically defined with ago-sockaddr templatethat is resolved at runtime. cluster_addr (string: &quot;&quot;) – Specifies the address to advertise to other OpenBao servers in the cluster for request forwarding. This can also be provided via the environment variable VAULT_CLUSTER_ADDR. This is a full URL, likeapi_addr, but OpenBao will ignore the scheme (all cluster members always use TLS with a private key/certificate). This can be dynamically defined with ago-sockaddr templatethat is resolved at runtime. disable_clustering (bool: false) – Specifies whether clustering features such as request forwarding are enabled. Setting this to true on one OpenBao node will disable these features only when that node is the active node. This parameter cannot be set to true if raft is the storage type. ","version":"Next","tagName":"h3"},{"title":"Log completed requests","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/log-requests-level/","content":"","keywords":"","version":"Next"},{"title":"seal stanza","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"seal stanza","url":"/openbao/docs/configuration/seal/#configuration","content":" Seal configuration can be done through the OpenBao configuration file using theseal stanza:  seal [NAME] { # ... }   For example:  seal &quot;pkcs11&quot; { # ... }   For configuration options which also read an environment variable, the environment variable will take precedence over values in the configuration file. ","version":"Next","tagName":"h2"},{"title":"Activating logging completed requests​","type":1,"pageTitle":"Log completed requests","url":"/openbao/docs/configuration/log-requests-level/#activating-logging-completed-requests","content":" By default, logging completed requests is disabled. To activate request logging, set the log_requests_levelconfiguration option in the OpenBao server configuration to the desired logging level. The acceptable logging levels areerror, warn, info, debug, trace, and off, which is the default.  Completed requests will be logged at the configured level, if OpenBao's log level includes this level of logs. For example, if log_level is set to debug, but log_requests_level is set to trace, completed requests will not be logged.  If the OpenBao server is already running, you can still configure the parameter in the OpenBao server configuration, and then send a SIGHUP signal to the OpenBao process.  log_requests_level = &quot;debug&quot; log_level = &quot;debug&quot; listener &quot;tcp&quot; { # ... }   ","version":"Next","tagName":"h2"},{"title":"Deactivating logging completed requests​","type":1,"pageTitle":"Log completed requests","url":"/openbao/docs/configuration/log-requests-level/#deactivating-logging-completed-requests","content":" To deactivate logging completed requests, simply remove the log_requests_level configuration parameter from the OpenBao server configuration, or set it to off, and send a SIGHUP signal to the OpenBao process.  log_requests_level = &quot;off&quot; log_level = &quot;debug&quot; listener &quot;tcp&quot; { # ... }  ","version":"Next","tagName":"h2"},{"title":"tcp listener","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/listener/tcp/","content":"","keywords":"","version":"Next"},{"title":"Listener's custom response headers​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#listeners-custom-response-headers","content":" OpenBao supports defining custom HTTP response headers for the root path (/) and also on API endpoints (/v1/*). The headers are defined based on the returned status code. For example, a user can define a list of custom response headers for the 200 status code, and another list of custom response headers for the 307 status code. There is a &quot;/sys/config/ui&quot; API endpoint which allows users to set UI specific custom headers. If a header is configured in a configuration file, it is not allowed to be reconfigured through the &quot;/sys/config/ui&quot; API endpoint. In cases where a custom header value needs to be modified or the custom header needs to be removed, the OpenBao's configuration file needs to be modified accordingly, and a SIGHUP signal needs to be sent to the OpenBao process.  If a header is defined in the configuration file and the same header is used by the internal processes of OpenBao, the configured header is not accepted. For example, a custom header which has the X-Vault- prefix will not be accepted. A message will be logged in the OpenBao's logs upon start up indicating the header with X-Vault- prefix is not accepted.  ","version":"Next","tagName":"h2"},{"title":"Order of precedence​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#order-of-precedence","content":" If the same header is configured in both the configuration file and in the &quot;/sys/config/ui&quot; API endpoint, the header in the configuration file takes precedence. For example, the &quot;Content-Security-Policy&quot; header is defined by default in the&quot;/sys/config/ui&quot; API endpoint. If that header is also defined in the configuration file, the value in the configuration file is set in the response headers instead of the default value in the &quot;/sys/config/ui&quot; API endpoint.  ","version":"Next","tagName":"h3"},{"title":"tcp listener parameters​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#tcp-listener-parameters","content":" address (string: &quot;127.0.0.1:8200&quot;) – Specifies the address to bind to for listening. This can be dynamically defined with ago-sockaddr templatethat is resolved at runtime. cluster_address (string: &quot;127.0.0.1:8201&quot;) – Specifies the address to bind to for cluster server-to-server requests. This defaults to one port higher than the value of address. This does not usually need to be set, but can be useful in case OpenBao servers are isolated from each other in such a way that they need to hop through a TCP load balancer or some other scheme in order to talk. This can be dynamically defined with ago-sockaddr templatethat is resolved at runtime. http_idle_timeout (string: &quot;5m&quot;) - Specifies the maximum amount of time to wait for the next request when keep-alives are enabled. If http_idle_timeoutis zero, the value of http_read_timeout is used. If both are zero, the value of http_read_header_timeout is used. This is specified using a label suffix like &quot;30s&quot; or &quot;1h&quot;. http_read_header_timeout (string: &quot;10s&quot;) - Specifies the amount of time allowed to read request headers. This is specified using a label suffix like&quot;30s&quot; or &quot;1h&quot;. http_read_timeout (string: &quot;30s&quot;) - Specifies the maximum duration for reading the entire request, including the body. This is specified using a label suffix like &quot;30s&quot; or &quot;1h&quot;. http_write_timeout string: &quot;0&quot;) - Specifies the maximum duration before timing out writes of the response and is reset whenever a new request's header is read. The default value of &quot;0&quot; means infinity. This is specified using a label suffix like &quot;30s&quot; or &quot;1h&quot;. max_request_size (int: 33554432) – Specifies a hard maximum allowed request size, in bytes. Defaults to 32 MB if not set or set to 0. Specifying a number less than 0 turns off limiting altogether. max_request_duration (string: &quot;90s&quot;) – Specifies the maximum request duration allowed before OpenBao cancels the request. This overridesdefault_max_request_duration for this listener. proxy_protocol_behavior (string: &quot;&quot;) – When specified, enables a PROXY protocol version 1 behavior for the listener. Accepted Values: use_always - The client's IP address will always be used.allow_authorized - If the source IP address is in theproxy_protocol_authorized_addrs list, the client's IP address will be used. If the source IP is not in the list, the source IP address will be used.deny_unauthorized - The traffic will be rejected if the source IP address is not in the proxy_protocol_authorized_addrs list. proxy_protocol_authorized_addrs (string: &lt;required-if-enabled&gt; or array: &lt;required-if-enabled&gt; ) – Specifies the list of allowed source IP addresses to be used with the PROXY protocol. Not required if proxy_protocol_behavior is set to use_always. Source IPs should be comma-delimited if provided as a string. At least one source IP must be provided,proxy_protocol_authorized_addrs cannot be an empty array or string. tls_disable (string: &quot;false&quot;) – Specifies if TLS will be disabled. OpenBao assumes TLS by default, so you must explicitly disable TLS to opt-in to insecure communication. tls_cert_file (string: &lt;required-if-enabled&gt;, reloads-on-SIGHUP) – Specifies the path to the certificate for TLS. It requires a PEM-encoded file. To configure the listener to use a CA certificate, concatenate the primary certificate and the CA certificate together. The primary certificate should appear first in the combined file. On SIGHUP, the path set here at OpenBao startup will be used for reloading the certificate; modifying this value while OpenBao is running will have no effect for SIGHUPs. tls_key_file (string: &lt;required-if-enabled&gt;, reloads-on-SIGHUP) – Specifies the path to the private key for the certificate. It requires a PEM-encoded file. If the key file is encrypted, you will be prompted to enter the passphrase on server startup. The passphrase must stay the same between key files when reloading your configuration using SIGHUP. On SIGHUP, the path set here at OpenBao startup will be used for reloading the certificate; modifying this value while OpenBao is running will have no effect for SIGHUPs. tls_min_version (string: &quot;tls12&quot;) – Specifies the minimum supported version of TLS. Accepted values are &quot;tls10&quot;, &quot;tls11&quot;, &quot;tls12&quot; or &quot;tls13&quot;.  warning Warning: TLS 1.1 and lower (tls10 and tls11 values for thetls_min_version and tls_max_version parameters) are widely considered insecure.  tls_max_version (string: &quot;tls13&quot;) – Specifies the maximum supported version of TLS. Accepted values are &quot;tls10&quot;, &quot;tls11&quot;, &quot;tls12&quot; or &quot;tls13&quot;.  warning Warning: TLS 1.1 and lower (tls10 and tls11 values for thetls_min_version and tls_max_version parameters) are widely considered insecure.  tls_cipher_suites (string: &quot;&quot;) – Specifies the list of supported ciphersuites as a comma-separated-list. The list of all available ciphersuites is available in the Golang TLS documentation.  warning Note: Go only consults the tls_cipher_suites list for TLSv1.2 and earlier; the order of ciphers is not important. For this parameter to be effective, the tls_max_version property must be set to tls12 to prevent negotiation of TLSv1.3, which is not recommended. For more information about this and other TLS related changes, see the Go TLS blog post.  tls_prefer_server_cipher_suites (string: &quot;false&quot;) – Specifies to prefer the server's ciphersuite over the client ciphersuites.  warning Warning: The tls_prefer_server_cipher_suites parameter is deprecated. Setting it has no effect. See the aboveGo blog post for more information about this change.  tls_require_and_verify_client_cert (string: &quot;false&quot;) – Turns on client authentication for this listener; the listener will require a presented client cert that successfully validates against system CAs. tls_client_ca_file (string: &quot;&quot;) – PEM-encoded Certificate Authority file used for checking the authenticity of client. tls_disable_client_certs (string: &quot;false&quot;) – Turns off client authentication for this listener. The default behavior (when this is false) is for OpenBao to request client certificates when available.  warning Warning: The tls_disable_client_certs and tls_require_and_verify_client_cert fields in the listener stanza of the OpenBao server configuration are mutually exclusive fields. Please ensure they are not both set to true. TLS client verification remains optional with default settings and is not enforced.  x_forwarded_for_authorized_addrs (string: &lt;required-to-enable&gt;) – Specifies the list of source IP CIDRs for which an X-Forwarded-For header will be trusted. Comma-separated list or JSON array. This turns on X-Forwarded-For support. If for example OpenBao receives connections from the load balancer's IP of 1.2.3.4, adding 1.2.3.4 to x_forwarded_for_authorized_addrswill result in the remote_address field in the audit log being populated with the connecting client's IP, for example 3.4.5.6. Note this requires the load balancer to send the connecting client's IP in the X-Forwarded-For header. x_forwarded_for_hop_skips (string: &quot;0&quot;) – The number of addresses that will be skipped from the rear of the set of hops. For instance, for a header value of 1.2.3.4, 2.3.4.5, 3.4.5.6, 4.5.6.7, if this value is set to &quot;1&quot;, the address that will be used as the originating client IP is 3.4.5.6. x_forwarded_for_reject_not_authorized (string: &quot;true&quot;) – If set false, if there is an X-Forwarded-For header in a connection from an unauthorized address, the header will be ignored and the client connection used as-is, rather than the client connection rejected. x_forwarded_for_reject_not_present (string: &quot;true&quot;) – If set false, if there is no X-Forwarded-For header or it is empty, the client address will be used as-is, rather than the client connection rejected.  ","version":"Next","tagName":"h2"},{"title":"telemetry parameters​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#telemetry-parameters","content":" unauthenticated_metrics_access (bool: false) - If set to true, allows unauthenticated access to the /v1/sys/metrics endpoint.  ","version":"Next","tagName":"h3"},{"title":"profiling parameters​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#profiling-parameters","content":" unauthenticated_pprof_access (bool: false) - If set to true, allows unauthenticated access to the /v1/sys/pprof endpoint.  ","version":"Next","tagName":"h3"},{"title":"inflight_requests_logging parameters​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#inflight_requests_logging-parameters","content":" unauthenticated_in_flight_requests_access (bool: false) - If set to true, allows unauthenticated access to the /v1/sys/in-flight-req endpoint.  ","version":"Next","tagName":"h3"},{"title":"custom_response_headers parameters​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#custom_response_headers-parameters","content":" default (key-value-map: {}) - A map of string header names to an array of string values. The default headers are set on all endpoints regardless of the status code value. For an example, please refer to the &quot;Configuring custom http response headers&quot; section. &lt;specific status code&gt; (key-value-map: {}) - A map of string header names to an array of string values. These headers are set only when the specific status code is returned. For example, &quot;200&quot; = {&quot;Header-A&quot;: [&quot;Value1&quot;, &quot;Value2&quot;]}, &quot;Header-A&quot;is set when the http response status code is &quot;200&quot;. &lt;collective status code&gt; (key-value-map: {}) - A map of string header names to an array of string values. These headers are set only when the response status code falls under the collective status code. For example, &quot;2xx&quot; = {&quot;Header-A&quot;: [&quot;Value1&quot;, &quot;Value2&quot;]}, &quot;Header-A&quot;is set when the http response status code is &quot;200&quot;, &quot;204&quot;, etc.  ","version":"Next","tagName":"h3"},{"title":"tcp listener examples​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#tcp-listener-examples","content":" ","version":"Next","tagName":"h2"},{"title":"Configuring TLS​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#configuring-tls","content":" This example shows enabling a TLS listener.  listener &quot;tcp&quot; { tls_cert_file = &quot;/etc/certs/openbao.crt&quot; tls_key_file = &quot;/etc/certs/openbao.key&quot; }   ","version":"Next","tagName":"h3"},{"title":"Listening on multiple interfaces​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#listening-on-multiple-interfaces","content":" This example shows OpenBao listening on a private interface, as well as localhost.  listener &quot;tcp&quot; { address = &quot;127.0.0.1:8200&quot; } listener &quot;tcp&quot; { address = &quot;10.0.0.5:8200&quot; } # Advertise the non-loopback interface api_addr = &quot;https://10.0.0.5:8200&quot; cluster_addr = &quot;https://10.0.0.5:8201&quot;   ","version":"Next","tagName":"h3"},{"title":"Configuring unauthenticated metrics access​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#configuring-unauthenticated-metrics-access","content":" This example shows enabling unauthenticated metrics access.  listener &quot;tcp&quot; { telemetry { unauthenticated_metrics_access = true } }   ","version":"Next","tagName":"h3"},{"title":"Configuring unauthenticated profiling access​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#configuring-unauthenticated-profiling-access","content":" This example shows enabling unauthenticated profiling access.  listener &quot;tcp&quot; { profiling { unauthenticated_pprof_access = true unauthenticated_in_flight_request_access = true } }   ","version":"Next","tagName":"h3"},{"title":"Configuring custom http response headers​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#configuring-custom-http-response-headers","content":" This example shows configuring custom http response headers. Operators can configure &quot;custom_response_headers&quot; sub-stanza in the listener stanza to set custom http headers appropriate to their applications. Examples of such headers are &quot;Strict-Transport-Security&quot;and &quot;Content-Security-Policy&quot; which are known HTTP headers, and could be configured to harden the security of an application communicating with the OpenBao endpoints. Note that vulnerability scans often examine such security related HTTP headers. In addition, application specific custom headers can also be configured. For example, &quot;X-Custom-Header&quot; has been configured in the example below.  listener &quot;tcp&quot; { custom_response_headers { &quot;default&quot; = { &quot;Strict-Transport-Security&quot; = [&quot;max-age=31536000&quot;,&quot;includeSubDomains&quot;], &quot;Content-Security-Policy&quot; = [&quot;connect-src https://clusterA.openbao.external/&quot;], &quot;X-Custom-Header&quot; = [&quot;Custom Header Default Value&quot;], }, &quot;2xx&quot; = { &quot;Content-Security-Policy&quot; = [&quot;connect-src https://clusterB.openbao.external/&quot;], &quot;X-Custom-Header&quot; = [&quot;Custom Header Value 1&quot;, &quot;Custom Header Value 2&quot;], }, &quot;301&quot; = { &quot;Strict-Transport-Security&quot; = [&quot;max-age=31536000&quot;], &quot;Content-Security-Policy&quot; = [&quot;connect-src https://clusterC.openbao.external/&quot;], }, } }   In situations where a header is defined under several status code subsections, the header matching the most specific response code will be returned. For example, with the config example below, a 307 response would return 307 Custom header value, while a 306 would return 3xx Custom header value.  listener &quot;tcp&quot; { custom_response_headers { &quot;default&quot; = { &quot;X-Custom-Header&quot; = [&quot;default Custom header value&quot;] }, &quot;3xx&quot; = { &quot;X-Custom-Header&quot; = [&quot;3xx Custom header value&quot;] }, &quot;307&quot; = { &quot;X-Custom-Header&quot; = [&quot;307 Custom header value&quot;] } } }   ","version":"Next","tagName":"h3"},{"title":"Listening on all IPv6 & IPv4 interfaces​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#listening-on-all-ipv6--ipv4-interfaces","content":" This example shows OpenBao listening on all IPv4 &amp; IPv6 interfaces including localhost.  listener &quot;tcp&quot; { address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; }   ","version":"Next","tagName":"h3"},{"title":"Listening to specific IPv6 address​","type":1,"pageTitle":"tcp listener","url":"/openbao/docs/configuration/listener/tcp/#listening-to-specific-ipv6-address","content":" This example shows OpenBao only using IPv6 and binding to the interface with the IP address: 2001:1c04:90d:1c00:a00:27ff:fefa:58ec  listener &quot;tcp&quot; { address = &quot;[2001:1c04:90d:1c00:a00:27ff:fefa:58ec]:8200&quot; cluster_address = &quot;[2001:1c04:90d:1c00:a00:27ff:fefa:58ec]:8201&quot; } # Advertise the non-loopback interface api_addr = &quot;https://[2001:1c04:90d:1c00:a00:27ff:fefa:58ec]:8200&quot; cluster_addr = &quot;https://[2001:1c04:90d:1c00:a00:27ff:fefa:58ec]:8201&quot;  ","version":"Next","tagName":"h3"},{"title":"awskms seal","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/awskms/","content":"","keywords":"","version":"Next"},{"title":"awskms example​","type":1,"pageTitle":"awskms seal","url":"/openbao/docs/configuration/seal/awskms/#awskms-example","content":" This example shows configuring AWS KMS seal through the OpenBao configuration file by providing all the required values:  seal &quot;awskms&quot; { region = &quot;us-east-1&quot; access_key = &quot;AKIAIOSFODNN7EXAMPLE&quot; secret_key = &quot;wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; kms_key_id = &quot;19ec80b0-dfdd-4d97-8164-c6examplekey&quot; endpoint = &quot;https://vpce-0e1bb1852241f8cc6-pzi0do8n.kms.us-east-1.vpce.amazonaws.com&quot; }   ","version":"Next","tagName":"h2"},{"title":"awskms parameters​","type":1,"pageTitle":"awskms seal","url":"/openbao/docs/configuration/seal/awskms/#awskms-parameters","content":" These parameters apply to the seal stanza in the OpenBao configuration file:  region (string: &quot;us-east-1&quot;): The AWS region where the encryption key lives. If not provided, may be populated from the AWS_REGION orAWS_DEFAULT_REGION environment variables, from your ~/.aws/config file, or from instance metadata. access_key (string: &lt;required&gt;): The AWS access key ID to use. May also be specified by the AWS_ACCESS_KEY_ID environment variable or as part of the AWS profile from the AWS CLI or instance profile. session_token (string: &quot;&quot;): Specifies the AWS session token. This can also be provided via the environment variable AWS_SESSION_TOKEN. secret_key (string: &lt;required&gt;): The AWS secret access key to use. May also be specified by the AWS_SECRET_ACCESS_KEY environment variable or as part of the AWS profile from the AWS CLI or instance profile. kms_key_id (string: &lt;required&gt;): The AWS KMS key ID or ARN to use for encryption and decryption. May also be specified by the VAULT_AWSKMS_SEAL_KEY_IDenvironment variable. An alias in the format alias/key-alias-name may also be used here. disabled (string: &quot;&quot;): Set this to true if OpenBao is migrating from an auto seal configuration. Otherwise, set to false. endpoint (string: &quot;&quot;): The KMS API endpoint to be used to make AWS KMS requests. May also be specified by the AWS_KMS_ENDPOINT environment variable. This is useful, for example, when connecting to KMS over a VPC Endpoint. If not set, OpenBao will use the default API endpoint for your region.  Refer to the Seal Migration documentation for more information about the seal migration process.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"awskms seal","url":"/openbao/docs/configuration/seal/awskms/#authentication","content":" Authentication-related values must be provided, either as environment variables or as configuration parameters.  warning Note: Although the configuration file allows you to pass inAWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY as part of the seal's parameters, it is strongly recommended to set these values via environment variables.  AWS authentication values:  AWS_REGION or AWS_DEFAULT_REGIONAWS_ACCESS_KEY_IDAWS_SECRET_ACCESS_KEY  Note: The client uses the official AWS SDK and will use the specified credentials, environment credentials, shared file credentials, or IAM role/ECS task credentials in that order, if the above AWS specific values are not provided.  OpenBao needs the following permissions on the KMS key:  kms:Encryptkms:Decryptkms:DescribeKey  These can be granted via IAM permissions on the principal that OpenBao uses, on the KMS key policy for the KMS key, or via KMS Grants on the key.  ","version":"Next","tagName":"h2"},{"title":"awskms environment variables​","type":1,"pageTitle":"awskms seal","url":"/openbao/docs/configuration/seal/awskms/#awskms-environment-variables","content":" Alternatively, the AWS KMS seal can be activated by providing the following environment variables.  OpenBao Seal specific values:  VAULT_SEAL_TYPEVAULT_AWSKMS_SEAL_KEY_ID  ","version":"Next","tagName":"h2"},{"title":"Key rotation​","type":1,"pageTitle":"awskms seal","url":"/openbao/docs/configuration/seal/awskms/#key-rotation","content":" This seal supports rotating the root keys defined in AWS KMSdoc. Both automatic rotation and manual rotation is supported for KMS since the key information is stored with the encrypted data. Old keys must not be disabled or deleted and are used to decrypt older data. Any new or updated data will be encrypted with the current key defined in the seal configuration or set to current under a key alias.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"awskms seal","url":"/openbao/docs/configuration/seal/awskms/#tutorial","content":" Refer to the Auto-unseal using AWS KMStutorial to learn how to auto-unseal OpenBao using AWS KMS. ","version":"Next","tagName":"h2"},{"title":"alicloudkms seal","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/alicloudkms/","content":"","keywords":"","version":"Next"},{"title":"alicloudkms example​","type":1,"pageTitle":"alicloudkms seal","url":"/openbao/docs/configuration/seal/alicloudkms/#alicloudkms-example","content":" This example shows configuring AliCloud KMS seal through the OpenBao configuration file by providing all the required values:  seal &quot;alicloudkms&quot; { region = &quot;us-east-1&quot; access_key = &quot;0wNEpMMlzy7szvai&quot; secret_key = &quot;PupkTg8jdmau1cXxYacgE736PJj4cA&quot; kms_key_id = &quot;08c33a6f-4e0a-4a1b-a3fa-7ddfa1d4fb73&quot; }   ","version":"Next","tagName":"h2"},{"title":"alicloudkms parameters​","type":1,"pageTitle":"alicloudkms seal","url":"/openbao/docs/configuration/seal/alicloudkms/#alicloudkms-parameters","content":" These parameters apply to the seal stanza in the OpenBao configuration file:  region (string: &lt;required&gt; &quot;us-east-1&quot;): The AliCloud region where the encryption key lives. May also be specified by the ALICLOUD_REGIONenvironment variable. domain (string: &quot;kms.us-east-1.aliyuncs.com&quot;): If set, overrides the endpoint AliCloud would normally use for KMS for a particular region. May also be specified by the ALICLOUD_DOMAIN environment variable. access_key (string: &lt;required&gt;): The AliCloud access key ID to use. May also be specified by the ALICLOUD_ACCESS_KEY environment variable or as part of the AliCloud profile from the AliCloud CLI or instance profile. secret_key (string: &lt;required&gt;): The AliCloud secret access key to use. May also be specified by the ALICLOUD_SECRET_KEY environment variable or as part of the AliCloud profile from the AliCloud CLI or instance profile. kms_key_id (string: &lt;required&gt;): The AliCloud KMS key ID to use for encryption and decryption. May also be specified by the VAULT_ALICLOUDKMS_SEAL_KEY_IDenvironment variable. disabled (string: &quot;&quot;): Set this to true if OpenBao is migrating from an auto seal configuration. Otherwise, set to false.  Refer to the Seal Migration documentation for more information about the seal migration process.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"alicloudkms seal","url":"/openbao/docs/configuration/seal/alicloudkms/#authentication","content":" Authentication-related values must be provided, either as environment variables or as configuration parameters.  warning Note: Although the configuration file allows you to pass inALICLOUD_ACCESS_KEY and ALICLOUD_SECRET_KEY as part of the seal's parameters, it is strongly recommended to set these values via environment variables.  AliCloud authentication values: * `ALICLOUD_REGION` * `ALICLOUD_ACCESS_KEY` * `ALICLOUD_SECRET_KEY`   Note: The client uses the official AliCloud SDK and will use environment credentials, the specified credentials, or RAM role credentials in that order.  ","version":"Next","tagName":"h2"},{"title":"alicloudkms environment variables​","type":1,"pageTitle":"alicloudkms seal","url":"/openbao/docs/configuration/seal/alicloudkms/#alicloudkms-environment-variables","content":" Alternatively, the AliCloud KMS seal can be activated by providing the following environment variables:  OpenBao Seal specific values: * `VAULT_SEAL_TYPE` * `VAULT_ALICLOUDKMS_SEAL_KEY_ID`  ","version":"Next","tagName":"h2"},{"title":"azurekeyvault seal","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/azurekeyvault/","content":"","keywords":"","version":"Next"},{"title":"azurekeyvault example​","type":1,"pageTitle":"azurekeyvault seal","url":"/openbao/docs/configuration/seal/azurekeyvault/#azurekeyvault-example","content":" This example shows configuring Azure Key Vault seal through the OpenBao configuration file by providing all the required values:  seal &quot;azurekeyvault&quot; { tenant_id = &quot;46646709-b63e-4747-be42-516edeaf1e14&quot; client_id = &quot;03dc33fc-16d9-4b77-8152-3ec568f8af6e&quot; client_secret = &quot;DUJDS3...&quot; vault_name = &quot;hc-openbao&quot; key_name = &quot;openbao_key&quot; }   ","version":"Next","tagName":"h2"},{"title":"azurekeyvault parameters​","type":1,"pageTitle":"azurekeyvault seal","url":"/openbao/docs/configuration/seal/azurekeyvault/#azurekeyvault-parameters","content":" These parameters apply to the seal stanza in the OpenBao configuration file:  tenant_id (string: &lt;required&gt;): The tenant id for the Azure Active Directory organization. May also be specified by the AZURE_TENANT_ID environment variable. client_id (string: &lt;required or MSI&gt;): The client id for credentials to query the Azure APIs. May also be specified by the AZURE_CLIENT_ID environment variable. client_secret (string: &lt;required or MSI&gt;): The client secret for credentials to query the Azure APIs. May also be specified by the AZURE_CLIENT_SECRET environment variable. environment (string: &quot;AZUREPUBLICCLOUD&quot;): The Azure Cloud environment API endpoints to use. May also be specified by the AZURE_ENVIRONMENT environment variable. vault_name (string: &lt;required&gt;): The Key Vault vault to use the encryption keys for encryption and decryption. May also be specified by the VAULT_AZUREKEYVAULT_VAULT_NAME environment variable. key_name (string: &lt;required&gt;): The Key Vault key to use for encryption and decryption. May also be specified by theVAULT_AZUREKEYVAULT_KEY_NAME environment variable. resource (string: &quot;vault.azure.net&quot;): The AZ KeyVault resource's DNS Suffix to connect to. May also be specified in the AZURE_AD_RESOURCE environment variable. Needs to be changed to connect to Azure's Managed HSM KeyVault instance type. disabled (string: &quot;&quot;): Set this to true if OpenBao is migrating from an auto seal configuration. Otherwise, set to false.  Refer to the Seal Migration documentation for more information about the seal migration process.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"azurekeyvault seal","url":"/openbao/docs/configuration/seal/azurekeyvault/#authentication","content":" Authentication-related values must be provided, either as environment variables or as configuration parameters.  Azure authentication values:  AZURE_TENANT_IDAZURE_CLIENT_IDAZURE_CLIENT_SECRETAZURE_ENVIRONMENTAZURE_AD_RESOURCE  warning Note: If OpenBao is hosted on Azure, OpenBao can use Managed Service Identities (MSI) to access Azure instead of an environment and shared client id and secret. MSI must beenabledon the VMs hosting OpenBao, and it is the preferred configuration since MSI prevents your Azure credentials from being stored as clear text. Refer to theProduction Hardening tutorial for more best practices.  info Note: If you are using a Managed HSM KeyVault, AZURE_AD_RESOURCE or the resourceconfiguration parameter must be specified; usually this should point to managedhsm.azure.net, but could point to other suffixes depending on Azure environment.  ","version":"Next","tagName":"h2"},{"title":"azurekeyvault environment variables​","type":1,"pageTitle":"azurekeyvault seal","url":"/openbao/docs/configuration/seal/azurekeyvault/#azurekeyvault-environment-variables","content":" Alternatively, the Azure Key Vault seal can be activated by providing the following environment variables:  VAULT_AZUREKEYVAULT_VAULT_NAMEVAULT_AZUREKEYVAULT_KEY_NAME  ","version":"Next","tagName":"h2"},{"title":"Key rotation​","type":1,"pageTitle":"azurekeyvault seal","url":"/openbao/docs/configuration/seal/azurekeyvault/#key-rotation","content":" This seal supports rotating keys defined in Azure Key Vault. Key metadata is stored with the encrypted data to ensure the correct key is used during decryption operations. Simply set up Azure Key Vault with key rotationusing Azure Automation Account and OpenBao will recognize newly rotated keys.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"azurekeyvault seal","url":"/openbao/docs/configuration/seal/azurekeyvault/#tutorial","content":" Refer to the Auto-unseal using Azure Key Vaulttutorial to learn how to use the Azure Key Vault to auto-unseal an OpenBao server. ","version":"Next","tagName":"h2"},{"title":"ocikms seal","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/ocikms/","content":"","keywords":"","version":"Next"},{"title":"ocikms example​","type":1,"pageTitle":"ocikms seal","url":"/openbao/docs/configuration/seal/ocikms/#ocikms-example","content":" This example shows configuring the OCI KMS seal through the OpenBao configuration file by providing all the required values:  seal &quot;ocikms&quot; { key_id = &quot;ocid1.key.oc1.iad.afnxza26aag4s.abzwkljsbapzb2nrha5nt3s7s7p42ctcrcj72vn3kq5qx&quot; crypto_endpoint = &quot;https://afnxza26aag4s-crypto.kms.us-ashburn-1.oraclecloud.com&quot; management_endpoint = &quot;https://afnxza26aag4s-management.kms.us-ashburn-1.oraclecloud.com&quot; auth_type_api_key = &quot;true&quot; }   ","version":"Next","tagName":"h2"},{"title":"ocikms parameters​","type":1,"pageTitle":"ocikms seal","url":"/openbao/docs/configuration/seal/ocikms/#ocikms-parameters","content":" These parameters apply to the seal stanza in the OpenBao configuration file:  key_id (string: &lt;required&gt;): The OCI KMS key ID to use. May also be specified by the VAULT_OCIKMS_SEAL_KEY_ID environment variable. crypto_endpoint (string: &lt;required&gt;): The OCI KMS cryptographic endpoint (or data plane endpoint) to be used to make OCI KMS encryption/decryption requests. May also be specified by the VAULT_OCIKMS_CRYPTO_ENDPOINT environment variable. management_endpoint (string: &lt;required&gt;): The OCI KMS management endpoint (or control plane endpoint) to be used to make OCI KMS key management requests. May also be specified by the VAULT_OCIKMS_MANAGEMENT_ENDPOINT environment variable. auth_type_api_key (boolean: false): Specifies if using API key to authenticate to OCI KMS service. If it is false, OpenBao authenticates using the instance principal from the compute instance. See Authentication section for details. Default is false. disabled (string: &quot;&quot;): Set this to true if OpenBao is migrating from an auto seal configuration. Otherwise, set to false.  Refer to the Seal Migration documentation for more information about the seal migration process.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"ocikms seal","url":"/openbao/docs/configuration/seal/ocikms/#authentication","content":" Authentication-related values must be provided, either as environment variables or as configuration parameters.  If you want to use Instance Principal, add section configuration below and add further configuration settings as detailed in the configuration docs.  seal &quot;ocikms&quot; { crypto_endpoint = &quot;&lt;kms-crypto-endpoint&gt;&quot; management_endpoint = &quot;&lt;kms-management-endpoint&gt;&quot; key_id = &quot;&lt;kms-key-id&gt;&quot; } # Notes: # crypto_endpoint can be replaced by VAULT_OCIKMS_CRYPTO_ENDPOINT environment var # management_endpoint can be replaced by VAULT_OCIKMS_MANAGEMENT_ENDPOINT environment var # key_id can be replaced by VAULT_OCIKMS_SEAL_KEY_ID environment var   If you want to use User Principal, the plugin will take the API key you defined for OCI SDK, often under ~/.oci/config.  seal &quot;ocikms&quot; { auth_type_api_key = true crypto_endpoint = &quot;&lt;kms-crypto-endpoint&gt;&quot; management_endpoint = &quot;&lt;kms-management-endpoint&gt;&quot; key_id = &quot;&lt;kms-key-id&gt;&quot; }   To grant permission for a compute instance to use OCI KMS service, write policies for KMS access.  Create a Dynamic Group in your OCI tenancy.Create a policy that allows the Dynamic Group to use or manage keys from OCI KMS. There are multiple ways to write these policies. The OCI Identity Policy can be used as a reference or starting point.  The most common policy allows a dynamic group of tenant A to use KMS's keys in tenant B:  define tenancy tenantB as &lt;tenantB-ocid&gt; endorse dynamic-group &lt;dynamic-group-name&gt; to use keys in tenancy tenantB   define tenancy tenantA as &lt;tenantA-ocid&gt; define dynamic-group &lt;dynamic-group-name&gt; as &lt;dynamic-group-ocid&gt; admit dynamic-group &lt;dynamic-group-name&gt; of tenancy tenantA to use keys in compartment &lt;key-compartment&gt;   ","version":"Next","tagName":"h2"},{"title":"ocikms rotate OCI KMS master key​","type":1,"pageTitle":"ocikms seal","url":"/openbao/docs/configuration/seal/ocikms/#ocikms-rotate-oci-kms-master-key","content":" For the OCI KMS key rotation feature, OCI KMS will create a new version of key internally. This process is independent from OpenBao, and OpenBao still uses the same key_id without any interruption.  If you want to change the key_id: migrate to Shamir, change key_id, and then migrate to OCI KMS with the new key_id. ","version":"Next","tagName":"h2"},{"title":"gcpckms seal","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/gcpckms/","content":"","keywords":"","version":"Next"},{"title":"gcpckms example​","type":1,"pageTitle":"gcpckms seal","url":"/openbao/docs/configuration/seal/gcpckms/#gcpckms-example","content":" This example shows configuring GCP Cloud KMS seal through the OpenBao configuration file by providing all the required values:  seal &quot;gcpckms&quot; { credentials = &quot;/usr/openbao/openbao-project-user-creds.json&quot; project = &quot;openbao-project&quot; region = &quot;global&quot; key_ring = &quot;openbao-keyring&quot; crypto_key = &quot;openbao-key&quot; }   ","version":"Next","tagName":"h2"},{"title":"gcpckms parameters​","type":1,"pageTitle":"gcpckms seal","url":"/openbao/docs/configuration/seal/gcpckms/#gcpckms-parameters","content":" These parameters apply to the seal stanza in the OpenBao configuration file:  credentials (string: &lt;required&gt;): The path to the credentials JSON file to use. May be also specified by the GOOGLE_CREDENTIALS orGOOGLE_APPLICATION_CREDENTIALS environment variable or set automatically if running under Google App Engine, Google Compute Engine or Google Kubernetes Engine. project (string: &lt;required&gt;): The GCP project ID to use. May also be specified by the GOOGLE_PROJECT environment variable. region (string: &quot;us-east-1&quot;): The GCP region/location where the key ring lives. May also be specified by the GOOGLE_REGION environment variable. key_ring (string: &lt;required&gt;): The GCP CKMS key ring to use. May also be specified by the VAULT_GCPCKMS_SEAL_KEY_RING environment variable. crypto_key (string: &lt;required&gt;): The GCP CKMS crypto key to use for encryption and decryption. May also be specified by theVAULT_GCPCKMS_SEAL_CRYPTO_KEY environment variable. disabled (string: &quot;&quot;): Set this to true if OpenBao is migrating from an auto seal configuration. Otherwise, set to false.  Refer to the Seal Migration documentation for more information about the seal migration process.  ","version":"Next","tagName":"h2"},{"title":"Authentication & permissions​","type":1,"pageTitle":"gcpckms seal","url":"/openbao/docs/configuration/seal/gcpckms/#authentication--permissions","content":" Authentication-related values must be provided, either as environment variables or as configuration parameters.  GCP authentication values:  GOOGLE_CREDENTIALS or GOOGLE_APPLICATION_CREDENTIALSGOOGLE_PROJECTGOOGLE_REGION  Note: The client uses the official Google SDK and will use the specified credentials, environment credentials, or application default credentialsin that order, if the above GCP specific values are not provided.  The service account needs the following minimum permissions on the crypto key:  cloudkms.cryptoKeyVersions.useToEncrypt cloudkms.cryptoKeyVersions.useToDecrypt cloudkms.cryptoKeys.get   These permissions can be described with the following role:  roles/cloudkms.cryptoKeyEncrypterDecrypter cloudkms.cryptoKeys.get   cloudkms.cryptoKeys.get permission is used for retrieving metadata information of keys from CloudKMS within this engine initialization process.  ","version":"Next","tagName":"h2"},{"title":"gcpckms environment variables​","type":1,"pageTitle":"gcpckms seal","url":"/openbao/docs/configuration/seal/gcpckms/#gcpckms-environment-variables","content":" Alternatively, the GCP Cloud KMS seal can be activated by providing the following environment variables:  VAULT_SEAL_TYPEVAULT_GCPCKMS_SEAL_KEY_RINGVAULT_GCPCKMS_SEAL_CRYPTO_KEY  ","version":"Next","tagName":"h2"},{"title":"Key rotation​","type":1,"pageTitle":"gcpckms seal","url":"/openbao/docs/configuration/seal/gcpckms/#key-rotation","content":" This seal supports rotating keys defined in Google Cloud KMSdoc. Both scheduled rotation and manual rotation is supported for CKMS since the key information. Old keys version must not be disabled or deleted and are used to decrypt older data. Any new or updated data will be encrypted with the primary key version.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"gcpckms seal","url":"/openbao/docs/configuration/seal/gcpckms/#tutorial","content":" Refer to the Auto-unseal using GCP Cloud KMSguide for a step-by-step tutorial. ","version":"Next","tagName":"h2"},{"title":"transit seal","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/seal/transit/","content":"","keywords":"","version":"Next"},{"title":"transit example​","type":1,"pageTitle":"transit seal","url":"/openbao/docs/configuration/seal/transit/#transit-example","content":" This example shows configuring Transit seal through the OpenBao configuration file by providing all the required values:  seal &quot;transit&quot; { address = &quot;https://openbao:8200&quot; token = &quot;s.Qf1s5zigZ4OX6akYjQXJC1jY&quot; disable_renewal = &quot;false&quot; // Key configuration key_name = &quot;transit_key_name&quot; mount_path = &quot;transit/&quot; namespace = &quot;ns1/&quot; // TLS Configuration tls_ca_cert = &quot;/etc/openbao/ca_cert.pem&quot; tls_client_cert = &quot;/etc/openbao/client_cert.pem&quot; tls_client_key = &quot;/etc/openbao/ca_cert.pem&quot; tls_server_name = &quot;openbao&quot; tls_skip_verify = &quot;false&quot; }   ","version":"Next","tagName":"h2"},{"title":"transit parameters​","type":1,"pageTitle":"transit seal","url":"/openbao/docs/configuration/seal/transit/#transit-parameters","content":" These parameters apply to the seal stanza in the OpenBao configuration file:  address (string: &lt;required&gt;): The full address to the OpenBao cluster. This may also be specified by the VAULT_ADDR environment variable. token (string: &lt;required&gt;): The OpenBao token to use. This may also be specified by the VAULT_TOKEN environment variable. key_name (string: &lt;required&gt;): The transit key to use for encryption and decryption. This may also be supplied using the VAULT_TRANSIT_SEAL_KEY_NAMEenvironment variable. mount_path (string: &lt;required&gt;): The mount path to the transit secret engine. This may also be supplied using the VAULT_TRANSIT_SEAL_MOUNT_PATH environment variable. namespace (string: &quot;&quot;): The namespace path to the transit secret engine. This may also be supplied using the VAULT_NAMESPACE environment variable. disable_renewal (string: &quot;false&quot;): Disables the automatic renewal of the token in case the lifecycle of the token is managed with some other mechanism outside of OpenBao, such as OpenBao Agent. This may also be specified using theVAULT_TRANSIT_SEAL_DISABLE_RENEWAL environment variable. tls_ca_cert (string: &quot;&quot;): Specifies the path to the CA certificate file used for communication with the OpenBao server. This may also be specified using theVAULT_CACERT environment variable. tls_client_cert (string: &quot;&quot;): Specifies the path to the client certificate for communication with the OpenBao server. This may also be specified using theVAULT_CLIENT_CERT environment variable. tls_client_key (string: &quot;&quot;): Specifies the path to the private key for communication with the OpenBao server. This may also be specified using theVAULT_CLIENT_KEY environment variable. tls_server_name (string: &quot;&quot;): Name to use as the SNI host when connecting to the OpenBao server via TLS. This may also be specified via theVAULT_TLS_SERVER_NAME environment variable. tls_skip_verify (bool: &quot;false&quot;): Disable verification of TLS certificates. Using this option is highly discouraged and decreases the security of data transmissions to and from the OpenBao server. This may also be specified using theVAULT_SKIP_VERIFY environment variable. disabled (string: &quot;&quot;): Set this to true if OpenBao is migrating from an auto seal configuration. Otherwise, set to false.  Refer to the Seal Migration documentation for more information about the seal migration process.  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"transit seal","url":"/openbao/docs/configuration/seal/transit/#authentication","content":" Authentication-related values must be provided, either as environment variables or as configuration parameters.  warning Note: Although the configuration file allows you to pass inVAULT_TOKEN as part of the seal's parameters, it is strongly recommended to set these values via environment variables.  The OpenBao token used to authenticate needs the following permissions on the transit key:  path &quot;&lt;mount path&gt;/encrypt/&lt;key name&gt;&quot; { capabilities = [&quot;update&quot;] } path &quot;&lt;mount path&gt;/decrypt/&lt;key name&gt;&quot; { capabilities = [&quot;update&quot;] }   Other considerations for the token used:  it should probably be an orphan token, otherwise when the parent token expires or gets revoked the seal will break.consider making it a periodic tokenand not setting an explicit max TTL, otherwise at some point it will cease to be renewable.  ","version":"Next","tagName":"h2"},{"title":"Key rotation​","type":1,"pageTitle":"transit seal","url":"/openbao/docs/configuration/seal/transit/#key-rotation","content":" This seal supports key rotation using the Transit Secret Engine's key rotation endpoints. Seedoc. Old keys must not be disabled or deleted and are used to decrypt older data.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"transit seal","url":"/openbao/docs/configuration/seal/transit/#tutorial","content":" Refer to the Auto-unseal using Transit Secrets Enginetutorial to learn how use the transit secrets engine to automatically unseal OpenBao. ","version":"Next","tagName":"h2"},{"title":"service_registration stanza","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/service-registration/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"service_registration stanza","url":"/openbao/docs/configuration/service-registration/#configuration","content":" Service registration configuration is done through the OpenBao configuration file using the service_registration stanza:  service_registration [NAME] { [PARAMETERS...] }   For example:  service_registration &quot;consul&quot; { address = &quot;127.0.0.1:8500&quot; }   For configuration options which also read an environment variable, the environment variable will take precedence over values in the configuration file. ","version":"Next","tagName":"h2"},{"title":"Consul service registration","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/service-registration/consul/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#configuration","content":" service_registration &quot;consul&quot; { address = &quot;127.0.0.1:8500&quot; }   If OpenBao is running in HA mode, include the transfer protocol (http:// orhttps://) in the address:  service_registration &quot;consul&quot; { address = &quot;http://127.0.0.1:8500&quot; }   Once properly configured, an unsealed OpenBao installation should be available and accessible at:  active.openbao.service.consul   Unsealed OpenBao instances in standby mode are available at:  standby.openbao.service.consul   All unsealed OpenBao instances are available as healthy at:  openbao.service.consul   Sealed OpenBao instances will mark themselves as unhealthy to avoid being returned at Consul's service discovery layer.  ","version":"Next","tagName":"h2"},{"title":"consul parameters​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#consul-parameters","content":" address (string: &quot;127.0.0.1:8500&quot;) – Specifies the address of the Consul agent to communicate with. This can be an IP address, DNS record, or unix socket. It is recommended that you communicate with a local Consul agent; do not communicate directly with a server. check_timeout (string: &quot;5s&quot;) – Specifies the check interval used to send health check information back to Consul. This is specified using a label suffix like &quot;30s&quot; or &quot;1h&quot;. disable_registration (string: &quot;false&quot;) – Specifies whether OpenBao should register itself with Consul. scheme (string: &quot;http&quot;) – Specifies the scheme to use when communicating with Consul. This can be set to &quot;http&quot; or &quot;https&quot;. It is highly recommended you communicate with Consul over https over non-local connections. When communicating over a unix socket, this option is ignored. service (string: &quot;openbao&quot;) – Specifies the name of the service to register in Consul. service_tags (string: &quot;&quot;) – Specifies a comma-separated list of tags to attach to the service registration in Consul. service_address (string: nil) – Specifies a service-specific address to set on the service registration in Consul. If unset, OpenBao will use what it knows to be the HA redirect address - which is usually desirable. Setting this parameter to &quot;&quot; will tell Consul to leverage the configuration of the node the service is registered on dynamically. This could be beneficial if you intend to leverage Consul'stranslate_wan_addrs parameter. token (string: &quot;&quot;) – Specifies the Consul ACL token with permission to register the OpenBao service into Consul's service catalog. This is not an OpenBao token. See the ACL section below for help.  The following settings apply when communicating with Consul via an encrypted connection. You can read more about encrypting Consul connections on theConsul encryption page.  tls_ca_file (string: &quot;&quot;) – Specifies the path to the CA certificate used for Consul communication. This defaults to system bundle if not specified. This should be set according to theca_file setting in Consul. tls_cert_file (string: &quot;&quot;) (optional) – Specifies the path to the certificate for Consul communication. This should be set according to thecert_file setting in Consul. tls_key_file (string: &quot;&quot;) – Specifies the path to the private key for Consul communication. This should be set according to thekey_file setting in Consul. tls_min_version (string: &quot;tls12&quot;) – Specifies the minimum TLS version to use. Accepted values are &quot;tls10&quot;, &quot;tls11&quot;, &quot;tls12&quot; or &quot;tls13&quot;. tls_skip_verify (string: &quot;false&quot;) – Disable verification of TLS certificates. Using this option is highly discouraged.  ","version":"Next","tagName":"h2"},{"title":"ACLs​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#acls","content":" If using ACLs in Consul, you'll need appropriate permissions to register the OpenBao service. The following ACL policy will work for most use-cases, assuming that your service name is openbao:  { &quot;service&quot;: { &quot;openbao&quot;: { &quot;policy&quot;: &quot;write&quot; } } }   ","version":"Next","tagName":"h2"},{"title":"consul examples​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#consul-examples","content":" ","version":"Next","tagName":"h2"},{"title":"Local agent​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#local-agent","content":" This example shows a sample configuration which communicates with a local Consul agent running on 127.0.0.1:8500.  service_registration &quot;consul&quot; {}   ","version":"Next","tagName":"h3"},{"title":"Detailed customization​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#detailed-customization","content":" This example shows communicating with Consul on a custom address with an ACL token.  service_registration &quot;consul&quot; { address = &quot;10.5.7.92:8194&quot; token = &quot;abcd1234&quot; }   ","version":"Next","tagName":"h3"},{"title":"Consul via unix socket​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#consul-via-unix-socket","content":" This example shows communicating with Consul over a local unix socket.  service_registration &quot;consul&quot; { address = &quot;unix:///tmp/.consul.http.sock&quot; }   ","version":"Next","tagName":"h3"},{"title":"Custom TLS​","type":1,"pageTitle":"Consul service registration","url":"/openbao/docs/configuration/service-registration/consul/#custom-tls","content":" This example shows using a custom CA, certificate, and key file to securely communicate with Consul over TLS.  service_registration &quot;consul&quot; { scheme = &quot;https&quot; tls_ca_file = &quot;/etc/pem/openbao.ca&quot; tls_cert_file = &quot;/etc/pem/openbao.cert&quot; tls_key_file = &quot;/etc/pem/openbao.key&quot; }  ","version":"Next","tagName":"h3"},{"title":"storage stanza","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/storage/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"storage stanza","url":"/openbao/docs/configuration/storage/#configuration","content":" Storage backend configuration is done through the OpenBao configuration file using the storage stanza:  storage [NAME] { [PARAMETERS...] }   For example:  storage &quot;file&quot; { path = &quot;/mnt/openbao/data&quot; }   For configuration options which also read an environment variable, the environment variable will take precedence over values in the configuration file.  ","version":"Next","tagName":"h2"},{"title":"Integrated storage vs. external storage​","type":1,"pageTitle":"storage stanza","url":"/openbao/docs/configuration/storage/#integrated-storage-vs-external-storage","content":" It is recommended to use OpenBao's integrated storage for most use cases rather than configuring another system to store OpenBao data externally. (Integrated Storage is an embedded OpenBao data storage.  The table below compares the characteristics of Integrated Storage and External Storage. Suppose you decide that the additional operational complexity of external storage is worth it for your use case. In that case, there are several community supported external storage options to choose from.  \tIntegrated Storage\tExternal StorageOpenBao Supported\tYes\tLimited support Operation\tOperationally simpler with no additional software installation required.\tMust install and configure the external storage environment outside of OpenBao. For high availability, the external storage should be clustered. Networking\tOne less network hop.\tExtra network hop between OpenBao and the external storage system. Troubleshooting and monitoring\tIntegrated Storage is a part of OpenBao; therefore, OpenBao is the only system you need to monitor and troubleshoot.\tThe source of failure could be the external storage; therefore, you need to check the health of both OpenBao and the external storage. This requires expertise in the chosen storage backend and additional monitoring of that storage. Data location\tThe encrypted OpenBao data is stored on the same host where the OpenBao server process runs.\tThe encrypted OpenBao data is stored where the external storage is located. Therefore, the OpenBao server and the data storage are hosted on physically separate hosts. System requirements\tAvoid &quot;burstable&quot; CPU and storage options. SSDs should be used for the hard drive. See the Reference Architecture guide.\tFollow the system requirements given by your chosen storage backend.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"storage stanza","url":"/openbao/docs/configuration/storage/#tutorial","content":" Refer to the Integrated Storage tutorials to learn more about Integrated Storage. ","version":"Next","tagName":"h2"},{"title":"Filesystem storage backend","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/storage/filesystem/","content":"","keywords":"","version":"Next"},{"title":"file parameters​","type":1,"pageTitle":"Filesystem storage backend","url":"/openbao/docs/configuration/storage/filesystem/#file-parameters","content":" path (string: &lt;required&gt;) – The absolute path on disk to the directory where the data will be stored. If the directory does not exist, OpenBao will create it.  ","version":"Next","tagName":"h2"},{"title":"file examples​","type":1,"pageTitle":"Filesystem storage backend","url":"/openbao/docs/configuration/storage/filesystem/#file-examples","content":" This example shows the Filesystem storage backend being mounted at/mnt/openbao/data.  storage &quot;file&quot; { path = &quot;/mnt/openbao/data&quot; }  ","version":"Next","tagName":"h2"},{"title":"Kubernetes service registration","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/service-registration/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Kubernetes service registration","url":"/openbao/docs/configuration/service-registration/kubernetes/#configuration","content":" service_registration &quot;kubernetes&quot; { namespace = &quot;my-namespace&quot; pod_name = &quot;my-pod-name&quot; }   Alternatively, the namespace and pod name can be set through the following environment variables:  VAULT_K8S_NAMESPACEVAULT_K8S_POD_NAME  This allows you to set these parameters usingthe Downward API.  If using only environment variables, the service registration stanza declaring you're using Kubernetes must still exist to indicate your intentions:  service_registration &quot;kubernetes&quot; {}   For service registration to succeed, OpenBao must be able to apply labels to pods in Kubernetes. The following RBAC rules are required to allow the service account associated with the OpenBao pods to update its own pod specification:  kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: namespace: mynamespace name: openbao-service-account rules: - apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;] verbs: [&quot;get&quot;, &quot;update&quot;, &quot;patch&quot;]   ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Kubernetes service registration","url":"/openbao/docs/configuration/service-registration/kubernetes/#examples","content":" Once properly configured, enabling service registration will cause Kubernetes pods to come up with the following labels:  apiVersion: v1 kind: Pod metadata: name: openbao labels: vault-active: &quot;false&quot; vault-initialized: &quot;true&quot; vault-perf-standby: &quot;false&quot; vault-sealed: &quot;false&quot; vault-version: 1.14.0   After shutdowns, OpenBao pods will bear the following labels:  apiVersion: v1 kind: Pod metadata: name: openbao labels: vault-active: &quot;false&quot; vault-initialized: &quot;false&quot; vault-perf-standby: &quot;false&quot; vault-sealed: &quot;true&quot; vault-version: 1.14.0   ","version":"Next","tagName":"h2"},{"title":"Label definitions​","type":1,"pageTitle":"Kubernetes service registration","url":"/openbao/docs/configuration/service-registration/kubernetes/#label-definitions","content":" vault-active (string: &quot;true&quot;/&quot;false&quot;) – Vault active is updated dynamically each time OpenBao's active status changes. True indicates that this OpenBao pod is currently the leader. False indicates that this OpenBao pod is currently a standby.vault-initialized (string: &quot;true&quot;/&quot;false&quot;) – Vault initialized is updated dynamically each time OpenBao's initialization status changes. True indicates that OpenBao is currently initialized. False indicates the OpenBao is currently uninitialized.vault-sealed (string: &quot;true&quot;/&quot;false&quot;) – Vault sealed is updated dynamically each time OpenBao's sealed/unsealed status changes. True indicates that OpenBao is currently sealed. False indicates that OpenBao is currently unsealed.vault-version (string: &quot;1.14.0&quot;) – Vault version is a string that will not change during a pod's lifecycle.  ","version":"Next","tagName":"h2"},{"title":"Working with OpenBao's service discovery labels​","type":1,"pageTitle":"Kubernetes service registration","url":"/openbao/docs/configuration/service-registration/kubernetes/#working-with-openbaos-service-discovery-labels","content":" ","version":"Next","tagName":"h2"},{"title":"Example service​","type":1,"pageTitle":"Kubernetes service registration","url":"/openbao/docs/configuration/service-registration/kubernetes/#example-service","content":" With labels applied to the pod, services can be created using selectors to filter pods with specific OpenBao HA roles, effectively allowing direct communication with subsets of OpenBao pods. Note the vault-active: &quot;true&quot; line below.  apiVersion: v1 kind: Service metadata: labels: app.kubernetes.io/instance: openbao app.kubernetes.io/name: openbao helm.sh/chart: openbao-0.1.2 name: openbao-active-us-east namespace: default spec: clusterIP: 10.7.254.51 ports: - name: http port: 8200 protocol: TCP targetPort: 8200 - name: internal port: 8201 protocol: TCP targetPort: 8201 publishNotReadyAddresses: false selector: app.kubernetes.io/instance: openbao app.kubernetes.io/name: openbao component: server vault-active: &quot;true&quot; type: ClusterIP   Also, by setting publishNotReadyAddresses: false above, pods that have failed will be removed from the service pool.  With this active service in place, we now have a dedicated endpoint that will always reach the active node.  ","version":"Next","tagName":"h3"},{"title":"Example upgrades​","type":1,"pageTitle":"Kubernetes service registration","url":"/openbao/docs/configuration/service-registration/kubernetes/#example-upgrades","content":" In conjunction with the pod labels and the OnDelete upgrade strategy, upgrades are much easier to orchestrate:  $ helm upgrade openbao --set='server.image.tag=1.14.0' $ kubectl delete pod --selector=vault-active=false \\ --selector=vault-version=1.2.3 $ kubectl delete pod --selector=vault-active=true \\ --selector=vault-version=1.2.3   When deleting an instance of a pod, the Statefulset defining the desired state of the cluster will reschedule the deleted pods with the newest image. ","version":"Next","tagName":"h3"},{"title":"In-Memory storage backend","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/storage/in-memory/","content":"","keywords":"","version":"Next"},{"title":"inmem parameters​","type":1,"pageTitle":"In-Memory storage backend","url":"/openbao/docs/configuration/storage/in-memory/#inmem-parameters","content":" The In-Memory storage backend has no configuration parameters.  ","version":"Next","tagName":"h2"},{"title":"inmem examples​","type":1,"pageTitle":"In-Memory storage backend","url":"/openbao/docs/configuration/storage/in-memory/#inmem-examples","content":" This example shows activating the In-Memory storage backend.  storage &quot;inmem&quot; {}  ","version":"Next","tagName":"h2"},{"title":"User lockout","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/user-lockout/","content":"","keywords":"","version":"Next"},{"title":"user_lockout stanza​","type":1,"pageTitle":"User lockout","url":"/openbao/docs/configuration/user-lockout/#user_lockout-stanza","content":" The user_lockout stanza specifies various configurations for user lockout behaviour for failed logins in OpenBao. They can be configured for all supported auth methods (userpass, ldap and approle) using &quot;all&quot; user_lockout stanza name or for a specific auth method using the auth method name in stanza.  Supported user_lockout stanza names are all, userpass, ldap and approle.  The configurations for a specific auth method takes precedence over the configurations specified for all auth methods using &quot;all&quot; user_lockout stanza name in the config file.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"User lockout","url":"/openbao/docs/configuration/user-lockout/#configuration","content":" User lockouts configuration is done through the OpenBao configuration file using the user_lockout stanza:  user_lockout [NAME] { [PARAMETERS...] }   For example:  user_lockout &quot;all&quot; { lockout_duration = &quot;10m&quot; lockout_counter_reset = &quot;10m&quot; } user_lockout &quot;userpass&quot; { lockout_threshold = &quot;25&quot; lockout_duration = &quot;5m&quot; } user_lockout &quot;ldap&quot; { disable_lockout = &quot;true&quot; }   Here, user lockout feature will be disabled for ldap auth methods. Userpass auth methods will have lockout threshold of 25, lockout duration of 5 minutes, lockout counter reset of 10 minutes. Approle auth methods will have a lockout threshold of 5 (considers default as this value is not configured), lockout duration of 10 minutes and lockout counter reset of 10 minutes.  The user lockout configuration for the auth method at a given path can be tuned using auth tune. Please see auth tune commandor auth tune api for more details.  ","version":"Next","tagName":"h2"},{"title":"user_lockout parameters​","type":1,"pageTitle":"User lockout","url":"/openbao/docs/configuration/user-lockout/#user_lockout-parameters","content":" The following options are available on all user_lockout configurations.  lockout_threshold (string: &quot;&quot;) - Specifies the number of failed login attempts after which the user is locked out.lockout_duration (string: &quot;&quot;) - Specifies the duration for which an user will be locked out.lockout_counter_reset (string: &quot;&quot;) - Specifies the duration after which the lockout counter is reset with no failed login attempts.disable_lockout (bool: false) - Disables the user lockout feature if set to true. ","version":"Next","tagName":"h2"},{"title":"telemetry stanza","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/telemetry/","content":"","keywords":"","version":"Next"},{"title":"telemetry parameters​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#telemetry-parameters","content":" Due to the number of configurable parameters to the telemetry stanza, parameters on this page are grouped by the telemetry provider.  ","version":"Next","tagName":"h2"},{"title":"Common​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#common","content":" The following options are available on all telemetry configurations.  usage_gauge_period (string: &quot;10m&quot;) - Specifies the interval at which high-cardinality usage data is collected, such as token counts, entity counts, and secret counts. A value of &quot;none&quot; disables the collection. Uses duration format strings.maximum_gauge_cardinality (int: 500) - The maximum cardinality of gauge labels.disable_hostname (bool: false) - Specifies if gauge values should be prefixed with the local hostname.enable_hostname_label (bool: false) - Specifies if all metric values should contain the host label with the local hostname. It is recommended to enabledisable_hostname if this option is used.lease_metrics_epsilon (string: &quot;1h&quot;) - Specifies the size of the bucket used to measure future lease expiration. For example, for the default value of 1 hour, the vault.expire.leases.by_expirationmetric will aggregate the total number of expiring leases for 1 hour buckets, starting from the current time. Note that leases are put into buckets by rounding. For example, if lease_metrics_epsilon is set to 1h and lease A expires 25 minutes from now, and lease B expires 35 minutes from now, then lease A will be in the first bucket, which corresponds to 0-30 minutes, and lease B will be in the second bucket, which corresponds to 31-90 minutes. Uses duration format strings.num_lease_metrics_buckets (int: 168) - The number of expiry buckets for leases. For the default value, for example, 168 value labels for the vault.expire.leases.by_expiration metric will be reported, where each value each bucket is separated in time by the lease_metrics_epsilon parameter. For the default 1 hour value oflease_metrics_epsilon and the default value of num_lease_metrics_buckets, vault.expire.leases.by_expirationwill report the total number of leases expiring within each hour from the current time to one week from the current time.add_lease_metrics_namespace_labels (bool: false) - If this value is set to true, then vault.expire.leases.by_expirationwill break down expiring leases by both time and namespace. This parameter is disabled by default because enabling it can lead to a large-cardinality metric.filter_default (bool: true) - This controls whether to allow metrics that have not been specified by the filter. Defaults to true, which will allow all metrics when no filters are provided. When set to false with no filters, no metrics will be sent.prefix_filter (string array: []) - This is a list of filter rules to apply for allowing/blocking metrics by prefix in the following format: [&quot;+vault.token&quot;, &quot;-vault.expire&quot;, &quot;+vault.expire.num_leases&quot;] A leading &quot;+&quot; will enable any metrics with the given prefix, and a leading &quot;-&quot; will block them. If there is overlap between two rules, the more specific rule will take precedence. Blocking will take priority if the same prefix is listed multiple times.  ","version":"Next","tagName":"h3"},{"title":"statsite​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#statsite","content":" These telemetry parameters apply tostatsite.  statsite_address (string: &quot;&quot;) - Specifies the address of a statsite server to forward metrics data to.  telemetry { statsite_address = &quot;statsite.company.local:8125&quot; }   ","version":"Next","tagName":"h3"},{"title":"statsd​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#statsd","content":" These telemetry parameters apply tostatsd.  statsd_address (string: &quot;&quot;) - Specifies the address of a statsd server to forward metrics to.  telemetry { statsd_address = &quot;statsd.company.local:8125&quot; }   ","version":"Next","tagName":"h3"},{"title":"circonus​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#circonus","content":" These telemetry parameters apply to Circonus.  circonus_api_token (string: &quot;&quot;) - Specifies a valid Circonus API Token used to create/manage check. If provided, metric management is enabled. circonus_api_app (string: &quot;nomad&quot;) - Specifies a valid app name associated with the API token. circonus_api_url (string: &quot;https://api.circonus.com/v2&quot;) - Specifies the base URL to use for contacting the Circonus API. circonus_submission_interval (string: &quot;10s&quot;) - Specifies the interval at which metrics are submitted to Circonus. circonus_submission_url (string: &quot;&quot;) - Specifies thecheck.config.submission_url field, of a Check API object, from a previously created HTTPTRAP check. circonus_check_id (string: &quot;&quot;) - Specifies the Check ID (not check bundle) from a previously created HTTPTRAP check. The numeric portion of thecheck._cid field in the Check API object. circonus_check_force_metric_activation (bool: false) - Specifies if force activation of metrics which already exist and are not currently active. If check management is enabled, the default behavior is to add new metrics as they are encountered. If the metric already exists in the check, it will not be activated. This setting overrides that behavior. circonus_check_instance_id (string: &quot;&lt;hostname&gt;:&lt;application&gt;&quot;) - Serves to uniquely identify the metrics coming from this instance. It can be used to maintain metric continuity with transient or ephemeral instances as they move around within an infrastructure. By default, this is set to hostname:application name (e.g. &quot;host123:nomad&quot;). circonus_check_search_tag (string: &lt;service&gt;:&lt;application&gt;) - Specifies a special tag which, when coupled with the instance id, helps to narrow down the search results when neither a Submission URL or Check ID is provided. By default, this is set to service:app (e.g. &quot;service:nomad&quot;). circonus_check_display_name (string: &quot;&quot;) - Specifies a name to give a check when it is created. This name is displayed in the Circonus UI Checks list. circonus_check_tags (string: &quot;&quot;) - Comma separated list of additional tags to add to a check when it is created. circonus_broker_id (string: &quot;&quot;) - Specifies the ID of a specific Circonus Broker to use when creating a new check. The numeric portion of broker._cidfield in a Broker API object. If metric management is enabled and neither a Submission URL nor Check ID is provided, an attempt will be made to search for an existing check using Instance ID and Search Tag. If one is not found, a new HTTPTRAP check will be created. By default, this is a random Enterprise Broker is selected, or, the default Circonus Public Broker. circonus_broker_select_tag (string: &quot;&quot;) - Specifies a special tag which will be used to select a Circonus Broker when a Broker ID is not provided. The best use of this is to as a hint for which broker should be used based onwhere this particular instance is running (e.g. a specific geo location or datacenter, dc:sfo).  ","version":"Next","tagName":"h3"},{"title":"dogstatsd​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#dogstatsd","content":" These telemetry parameters apply toDogStatsD.  dogstatsd_addr (string: &quot;&quot;) - This provides the address of a DogStatsD instance. DogStatsD is a protocol-compatible flavor of statsd, with the added ability to decorate metrics with tags and event information. If provided, OpenBao will send various telemetry information to that instance for aggregation. This can be used to capture runtime information.  dogstatsd_tags (string array: []) - This provides a list of global tags that will be added to all telemetry packets sent to DogStatsD. It is a list of strings, where each string looks like &quot;my_tag_name:my_tag_value&quot;.  ","version":"Next","tagName":"h3"},{"title":"prometheus​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#prometheus","content":" These telemetry parameters apply toprometheus.  prometheus_retention_time (string: &quot;24h&quot;) - Specifies the amount of time that Prometheus metrics are retained in memory. Setting this to 0 will disable Prometheus telemetry.disable_hostname (bool: false) - It is recommended to also enable the optiondisable_hostname to avoid having prefixed metrics with hostname.  The /v1/sys/metrics endpoint is only accessible on active nodes and automatically disabled on standby nodes. You can enable the /v1/sys/metricsendpoint on standby nodes by enabling unauthenticated metrics access.  OpenBao does not use the default Prometheus path, so Prometheus must be configured with the path below. Note that using ?format=prometheus in the path won't work as &quot;?&quot; will be escaped, so it must be specified as a parameter.  An OpenBao token is required with capabilities = [&quot;read&quot;, &quot;list&quot;] to /v1/sys/metrics. The Prometheus bearer_token or bearer_token_file options must be added to the scrape job.  An example job_name stanza required in the Prometheus config is provided below.  # prometheus.yml scrape_configs: - job_name: 'openbao' metrics_path: &quot;/v1/sys/metrics&quot; params: format: ['prometheus'] scheme: https tls_config: ca_file: your_ca_here.pem bearer_token: &quot;your_openbao_token_here&quot; static_configs: - targets: ['your_openbao_server_here:8200']   An example telemetry configuration to be added to OpenBao's configuration file is shown below:  telemetry { prometheus_retention_time = &quot;30s&quot; disable_hostname = true }   ","version":"Next","tagName":"h3"},{"title":"stackdriver​","type":1,"pageTitle":"telemetry stanza","url":"/openbao/docs/configuration/telemetry/#stackdriver","content":" These telemetry parameters apply to Stackdriver Monitoring.  The Stackdriver telemetry provider uses the official Google Cloud Golang SDK. This means it supports the common ways ofproviding credentials to Google Cloud.  To use this telemetry provider, the service account must have the following minimum scope(s):  https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/monitoring https://www.googleapis.com/auth/monitoring.write   And the following IAM role(s):  roles/monitoring.metricWriter   stackdriver_project_id (string: &quot;&quot;) - The Google Cloud ProjectID to send telemetry data to.stackdriver_location (string: &quot;&quot;) - The GCP or AWS region of the monitored resource.stackdriver_namespace (string: &quot;&quot;) - A namespace identifier for the telemetry data.stackdriver_debug_logs (bool: &quot;false&quot;) - Specifies if OpenBao writes additional stackdriver related debug logs to standard error output (stderr).  It is recommended to also enable the option disable_hostname to avoid having prefixed metrics with hostname and enable instead enable_hostname_label.  telemetry { stackdriver_project_id = &quot;my-test-project&quot; stackdriver_location = &quot;us-east1-a&quot; stackdriver_namespace = &quot;openbao-cluster-a&quot; disable_hostname = true enable_hostname_label = true }   Metrics from OpenBao can be found in Metrics Explorer. All those metrics are shown with a resource type of generic_task, and the metric name is prefixed with custom.googleapis.com/go-metrics/. ","version":"Next","tagName":"h3"},{"title":"OpenBao UI","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/ui/","content":"","keywords":"","version":"Next"},{"title":"Activating the OpenBao UI​","type":1,"pageTitle":"OpenBao UI","url":"/openbao/docs/configuration/ui/#activating-the-openbao-ui","content":" The OpenBao UI is not activated by default. To activate the UI, set the uiconfiguration option in the OpenBao server configuration. OpenBao clients do not need to set this option, since they will not be serving the UI.  ui = true listener &quot;tcp&quot; { # ... }   For more information, please see theOpenBao configuration options.  ","version":"Next","tagName":"h2"},{"title":"Accessing the OpenBao UI​","type":1,"pageTitle":"OpenBao UI","url":"/openbao/docs/configuration/ui/#accessing-the-openbao-ui","content":" The UI runs on the same port as the OpenBao listener. As such, you must configure at least one listener stanza in order to access the UI.  listener &quot;tcp&quot; { address = &quot;10.0.1.35:8200&quot; # If bound to localhost, the OpenBao UI is only # accessible from the local machine! # address = &quot;127.0.0.1:8200&quot; }   In this case, the UI is accessible at the following URL from any machine on the subnet (provided no network firewalls are in place):  https://10.0.1.35:8200/ui/   It is also accessible at any DNS entry that resolves to that IP address, such as the Consul service address (if using Consul):  https://openbao.service.consul:8200/ui/   ","version":"Next","tagName":"h2"},{"title":"Note on TLS​","type":1,"pageTitle":"OpenBao UI","url":"/openbao/docs/configuration/ui/#note-on-tls","content":" When using TLS (recommended), the certificate must be valid for all DNS entries you will be accessing the OpenBao UI on, and any IP addresses on the SAN. If you are running OpenBao with a self-signed certificate, any browsers that access the OpenBao UI will need to have the root CA installed. Failure to do so may result in the browser displaying a warning that the site is &quot;untrusted&quot;. It is highly recommended that client browsers accessing the OpenBao UI install the proper CA root for validation to reduce the chance of a MITM attack. ","version":"Next","tagName":"h3"},{"title":"Feature deprecation notice and plans","type":0,"sectionRef":"#","url":"/openbao/docs/deprecation/","content":"Feature deprecation notice and plans This announcement page is maintained and updated periodically to communicate important decisions made concerning End of Support(EoS) for OpenBao features as well as features we have removed or disabled from the project. We document the removal of features, enable the community with a plan and timeline for eventual deprecations, and supply alternative paths to explore and evaluate to minimize business disruptions. If you have questions or concerns about a deprecated feature, please create a topic on the community forum. Please refer to the FAQ page for frequently asked questions concerning OpenBao feature deprecations. Deprecation Announcement: This indicates the release version during which the announcement was made to deprecate a feature. End of Support: This indicates when a deprecated feature becomes unsupported. Consult the table below and consider the timeline provided to upgrade. Feature Removal: This indicates that the feature is completely removed/disabled from the project. warning Note: All specified targeted version announcements for End of Support and Feature Removal may be subject to change. Feature\tDeprecation announcement\tEnd of Support\tFeature Removal\tMigration Path/Impact\tResources","keywords":"","version":"Next"},{"title":"Integrated storage (Raft) backend","type":0,"sectionRef":"#","url":"/openbao/docs/configuration/storage/raft/","content":"","keywords":"","version":"Next"},{"title":"raft parameters​","type":1,"pageTitle":"Integrated storage (Raft) backend","url":"/openbao/docs/configuration/storage/raft/#raft-parameters","content":" path (string: &quot;&quot;) – The file system path where all the OpenBao data gets stored. This value can be overridden by setting the VAULT_RAFT_PATH environment variable. node_id (string: &quot;&quot;) - The identifier for the node in the Raft cluster. This value can be overridden by setting the VAULT_RAFT_NODE_ID environment variable. performance_multiplier (integer: 0) - An integer multiplier used by servers to scale key Raft timing parameters. Tuning this affects the time it takes OpenBao to detect leader failures and to perform leader elections, at the expense of requiring more network and CPU resources for better performance. Omitting this value or setting it to 0 uses default timing described below. Lower values are used to tighten timing and increase sensitivity while higher values relax timings and reduce sensitivity. By default, OpenBao will use a lower-performance timing that's suitable for minimal OpenBao servers, currently equivalent to setting this to a value of 5 (this default may be changed in future versions of OpenBao, depending if the target minimum server profile changes). Setting this to a value of 1 will configure Raft to its highest-performance mode and is recommended for production OpenBao servers. The maximum allowed value is 10. trailing_logs (integer: 10000) - This controls how many log entries are left in the log store on disk after a snapshot is made. This should only be adjusted when followers cannot catch up to the leader due to a very large snapshot size and high write throughput causing log truncation before a snapshot can be fully installed. If you need to use this to recover a cluster, consider reducing write throughput or the amount of data stored on OpenBao. The default value is 10000 which is suitable for all normal workloads. Thetrailing_logs metric is not the same as max_trailing_logs. snapshot_threshold (integer: 8192) - This controls the minimum number of Raft commit entries between snapshots that are saved to disk. This is a low-level parameter that should rarely need to be changed. Very busy clusters experiencing excessive disk IO may increase this value to reduce disk IO and minimize the chances of all servers taking snapshots at the same time. Increasing this trades off disk IO for disk space since the log will grow much larger and the space in the raft.db file can't be reclaimed till the next snapshot. Servers may take longer to recover from crashes or failover if this is increased significantly as more logs will need to be replayed. snapshot_interval (integer: 120 seconds) - The snapshot interval controls how often Raft checks whether a snapshot operation is required. Raft randomly staggers snapshots between the configured interval and twice the configured interval to keep the entire cluster from performing a snapshot at once. The default snapshot interval is 120 seconds. retry_join (list: []) - A set of connection details for another node in the cluster, which is used to help nodes locate a leader in order to join a cluster. There can be one or more retry_join stanzas. If the connection details for all nodes in the cluster are known in advance, you can include these stanzas to enable nodes to automatically join the Raft cluster. Once one of the nodes is initialized as the leader, the remaining nodes will use their retry_join configuration to locate the leader and join the cluster. Note that when using Shamir seal, the joined nodes will still need to be unsealed manually. See the section below for the parameters accepted by theretry_join stanza. retry_join_as_non_voter (boolean: false) - If set, causes any retry_joinconfig to join the Raft cluster as a non-voter. The node will not participate in the Raft quorum but will still receive the data replication stream, adding read scalability to a cluster. This option has the same effect as the-non-voter flag for thebao operator raft join command, but only affects voting status when joining via retry_join config. This setting can be overridden to true by setting theVAULT_RAFT_RETRY_JOIN_AS_NON_VOTER environment variable to any non-empty value. Only valid if there is at least one retry_join stanza. max_entry_size (integer: 1048576) - This configures the maximum number of bytes for a Raft entry. It applies to both Put operations and transactions. Any put or transaction operation exceeding this configuration value will cause the respective operation to fail. Raft has a suggested max size of data in a Raft log entry. This is based on current architecture, default timing, etc. Integrated Storage also uses a chunk size that is the threshold used for breaking a large value into chunks. By default, the chunk size is the same as Raft's max size log entry. The default value for this configuration is 1048576 -- two times the chunking size. autopilot_reconcile_interval (string: &quot;10s&quot;) - This is the interval after which autopilot will pick up any state changes. State change could mean multiple things; for example a newly joined voter node, initially added as non-voter to the Raft cluster by autopilot has successfully completed the stabilization period thereby qualifying for being promoted as a voter, a node that has become unhealthy and needs to be shown as such in the state API, a node has been marked as dead needing eviction from Raft configuration, etc. autopilot_update_interval (string: &quot;2s&quot;) - This is the interval after which autopilot will poll OpenBao for any updates to the information it cares about. This includes things like the autopilot configuration, current autopilot state, raft configuration, known servers, latest raft index, and stats for all the known servers. The information that autopilot receives will be used to calculate its next state.  ","version":"Next","tagName":"h2"},{"title":"retry_join stanza​","type":1,"pageTitle":"Integrated storage (Raft) backend","url":"/openbao/docs/configuration/storage/raft/#retry_join-stanza","content":" leader_api_addr (string: &quot;&quot;) - Address of a possible leader node. auto_join (string: &quot;&quot;) - Cloud auto-join configuration, usinggo-discover syntax. auto_join_scheme (string: &quot;&quot;) - The optional URI protocol scheme for addresses discovered via auto-join. Available values are http or https. auto_join_port (uint: &quot;&quot;) - The optional port used for addressed discovered via auto-join. leader_tls_servername (string: &quot;&quot;) - The TLS server name to use when connecting with HTTPS. Should match one of the names in the DNS SANs of the remote server certificate. See also Integrated Storage and TLS leader_ca_cert_file (string: &quot;&quot;) - File path to the CA cert of the possible leader node. leader_client_cert_file (string: &quot;&quot;) - File path to the client certificate for the follower node to establish client authentication with the possible leader node. leader_client_key_file (string: &quot;&quot;) - File path to the client key for the follower node to establish client authentication with the possible leader node. leader_ca_cert (string: &quot;&quot;) - CA cert of the possible leader node. leader_client_cert (string: &quot;&quot;) - Client certificate for the follower node to establish client authentication with the possible leader node. leader_client_key (string: &quot;&quot;) - Client key for the follower node to establish client authentication with the possible leader node.  Each retry_join block may provide TLS certificates via file paths or as a single-line certificate string value with newlines delimited by \\n, but not a combination of both. Each retry_joinstanza may contain either a leader_api_addr value or a cloud auto_join configuration value, but not both. When anauto_join value is provided, OpenBao will automatically attempt to discover and resolve potential Raft leader addresses using go-discover. See the go-discoverREADMEfor details on the format of the auto_join value.  By default, OpenBao will attempt to reach discovered peers using HTTPS and port 8200. Operators may override these through theauto_join_scheme and auto_join_portfields respectively.  Example Configuration:  storage &quot;raft&quot; { path = &quot;/Users/foo/raft/&quot; node_id = &quot;node1&quot; retry_join { leader_api_addr = &quot;http://127.0.0.2:8200&quot; leader_ca_cert_file = &quot;/path/to/ca1&quot; leader_client_cert_file = &quot;/path/to/client/cert1&quot; leader_client_key_file = &quot;/path/to/client/key1&quot; } retry_join { leader_api_addr = &quot;http://127.0.0.3:8200&quot; leader_ca_cert_file = &quot;/path/to/ca2&quot; leader_client_cert_file = &quot;/path/to/client/cert2&quot; leader_client_key_file = &quot;/path/to/client/key2&quot; } retry_join { leader_api_addr = &quot;http://127.0.0.4:8200&quot; leader_ca_cert_file = &quot;/path/to/ca3&quot; leader_client_cert_file = &quot;/path/to/client/cert3&quot; leader_client_key_file = &quot;/path/to/client/key3&quot; } retry_join { auto_join = &quot;provider=aws region=eu-west-1 tag_key=openbao tag_value=... access_key_id=... secret_access_key=...&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Integrated storage (Raft) backend","url":"/openbao/docs/configuration/storage/raft/#tutorial","content":" Refer to the Integrated Storage series of tutorials to learn more about implementing OpenBao using Integrated Storage. ","version":"Next","tagName":"h2"},{"title":"Feature deprecation FAQ","type":0,"sectionRef":"#","url":"/openbao/docs/deprecation/faq/","content":"","keywords":"","version":"Next"},{"title":"Q: what is the impact of removing support for x.509 certificates with signatures that use SHA-1?​","type":1,"pageTitle":"Feature deprecation FAQ","url":"/openbao/docs/deprecation/faq/#q-what-is-the-impact-of-removing-support-for-x509-certificates-with-signatures-that-use-sha-1","content":" OpenBao is built with Go 1.21 or later. The standard library in Go 1.18 and later rejects X.509 signatures that use a SHA-1 hash.  If this issue impacts your usage of OpenBao, you can temporarily work around it by deploying OpenBao with the environment variable GODEBUG=x509sha1=1 set. This workaround will fail in a future version of Go, however, the Go team has not said when they will remove this workaround.  If you want to check whether a certificate or CA contains a problematic signature, you can use the OpenSSL CLI:  $ openssl x509 -text -noout -in somecert.pem | grep sha1 Signature Algorithm: sha1WithRSAEncryption Signature Algorithm: sha1WithRSAEncryption   Any signature algorithms that contain sha1 will be potentially problematic.  Here are the use cases that may still use certificates with SHA-1:  Auth methods​  Kerberos Auth MethodKubernetes Auth MethodLDAP Auth MethodJWT/OIDC Auth MethodTLS Certificates Auth Method  Database secrets engines​  Cassandra Database Secrets EngineInfluxDB Database Secrets EngineMySQL/MariaDB Database Secrets Engine  Secrets engines​  Kubernetes Secrets EngineLDAP Secrets EnginePKI Secrets Engine  ","version":"Next","tagName":"h3"},{"title":"Q: what are the phases of deprecation?​","type":1,"pageTitle":"Feature deprecation FAQ","url":"/openbao/docs/deprecation/faq/#q-what-are-the-phases-of-deprecation","content":" OpenBao implements a multi-phased approach to deprecation. The intent of this approach is to provide sufficient warning that a feature will be removed and safe handling of stored data when the associated feature has been removed.  The phases of deprecation are also known as &quot;Deprecation Status&quot;. These statuses are currently reflected in builtin plugins and are exposed via the OpenBao auth, secrets, and plugins CLI/API endpoints. For more information, refer to the corresponding documentation.  The four phases of deprecation are: Supported, Deprecated, Pending Removal, and Removed.  Note: Deprecation Status currently only applies to builtin auth and secrets plugins. All external plugins will report a status of n/a. This is expected behavior.  Supported​  This is the default status and reflects a feature which is still supported. There is no unique behavior or functionality associated with this status.  Deprecated​  This status reflects a feature which has been marked for deprecation in a later release of OpenBao. This is the first phase of the deprecation process. A status of Deprecated has two effects:  After an upgrade, any existing Deprecated feature (builtin auth/secrets plugins enabled via CLI or API prior to upgrade) will log Warn-level messages on unseal. All new usage of Deprecated features will log Warn-level messages. All POST/GET/LIST endpoints associated with this feature will return warnings in response data.  Pending removal​  This status reflects a feature which has been officially deprecated in this release of OpenBao. This is the first phase in the process that fundamentally alters the behavior of OpenBao. The effects are two-fold:  After an upgrade, any existing Pending Removal feature (builtin auth/secrets plugins enabled via CLI or API prior to upgrade) will log Error-level messages to the OpenBao log and cause an immediate shutdown of the OpenBao core. Any new Pending Removal will fail and log Error-level messages to the OpenBao log and CLI/API.  VAULT_ALLOW_PENDING_REMOVAL_MOUNTS​  The Pending Removal behavior may be overriden using a new environment variable: VAULT_ALLOW_PENDING_REMOVAL_MOUNTS. This environment variable effectively allows all Pending Removal features to be treated as Deprecated.  Removed​  This status reflects a feature which has been officially removed from OpenBao. Removed is the last phase of the deprecation process. During this phase, code for this feature no longer exists within OpenBao.  After an upgrade, any existing Removed feature will log Error-level messages to the OpenBao log and cause an immediate shutdown of the OpenBao core. Any new Removed features will fail and log Error-level messages to the OpenBao log and CLI/API.  Migration path​  In order to successfully upgrade, use of the Removed feature must be discontinued. To accomplish this:  Downgrade OpenBao to a previous version. Replace any Removed or Pending Removal feature with the preferred alternative feature. Upgrade to latest desired version. ","version":"Next","tagName":"h3"},{"title":"Product features FAQ","type":0,"sectionRef":"#","url":"/openbao/docs/faq/","content":"Product features FAQ You can access a number of different FAQ pages to get answers to questions about our product and features. These FAQ pages are updated periodically so please check back for the latest updates and new FAQ questions.","keywords":"","version":"Next"},{"title":"Developer quick start","type":0,"sectionRef":"#","url":"/openbao/docs/get-started/developer-qs/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Developer quick start","url":"/openbao/docs/get-started/developer-qs/#prerequisites","content":" A development environment applicable to one of the languages in this quick start (currently Go and Bash (curl))  ","version":"Next","tagName":"h2"},{"title":"Step 1: start OpenBao​","type":1,"pageTitle":"Developer quick start","url":"/openbao/docs/get-started/developer-qs/#step-1-start-openbao","content":" danger Warning: This in-memory “dev” server is useful for practicing with OpenBao locally for the first time, but is insecure and should never be used in production. For developers who need to manage their own production OpenBao installations, this page provides some guidance on how to make your setup more production-friendly.  Run the OpenBao server in a non-production &quot;dev&quot; mode:  $ bao server -dev -dev-root-token-id=&quot;dev-only-token&quot;   The -dev-root-token-id flag for dev servers tells the OpenBao server to allow full root access to anyone who presents a token with the specified value (in this case &quot;dev-only-token&quot;).  danger Warning: The root token is useful for development, but allows full access to all data and functionality of OpenBao, so it must be carefully guarded in production. Ideally, even an administrator of OpenBao would use their own token with limited privileges instead of the root token.  OpenBao is now listening over HTTP on port 8200. With all the setup out of the way, it's time to get coding!  ","version":"Next","tagName":"h2"},{"title":"Step 2: install a client library​","type":1,"pageTitle":"Developer quick start","url":"/openbao/docs/get-started/developer-qs/#step-2-install-a-client-library","content":" To read and write secrets in your application, you need to first configure a client to connect to OpenBao. Let's install the OpenBao client library for your language of choice.  Go Go (official) client library: $ go get github.com/openbao/openbao/api Now, let's add the import statements for the client library to the top of the file. import statements for client library import openbao &quot;github.com/openbao/openbao/api&quot;   ","version":"Next","tagName":"h2"},{"title":"Step 3: authenticate to OpenBao​","type":1,"pageTitle":"Developer quick start","url":"/openbao/docs/get-started/developer-qs/#step-3-authenticate-to-openbao","content":" A variety of authentication methods can be used to prove your application's identity to the OpenBao server. To keep things simple for our example, we'll just use the root token created in Step 1. Paste the following code to initialize a new OpenBao client that will use token-based authentication for all its requests:  GoBash config := openbao.DefaultConfig() config.Address = &quot;http://127.0.0.1:8200&quot; client, err := openbao.NewClient(config) if err != nil { log.Fatalf(&quot;unable to initialize OpenBao client: %v&quot;, err) } client.SetToken(&quot;dev-only-token&quot;)   ","version":"Next","tagName":"h2"},{"title":"Step 4: store a secret​","type":1,"pageTitle":"Developer quick start","url":"/openbao/docs/get-started/developer-qs/#step-4-store-a-secret","content":" Secrets are sensitive data like API keys and passwords that we shouldn’t be storing in our code or configuration files. Instead, we want to store values like this in OpenBao.  We'll use the OpenBao client we just initialized to write a secret to OpenBao, like so:  GoBash secretData := map[string]interface{}{ &quot;password&quot;: &quot;OpenBao123&quot;, } _, err = client.KVv2(&quot;secret&quot;).Put(context.Background(), &quot;my-secret-password&quot;, secretData) if err != nil { log.Fatalf(&quot;unable to write secret: %v&quot;, err) } fmt.Println(&quot;Secret written successfully.&quot;)   A common way of storing secrets is as key-value pairs using the KV secrets engine (v2). In the code we've just added, password is the key in the key-value pair, and OpenBao123 is the value.  We also provided the path to our secret in OpenBao. We will reference this path in a moment when we learn how to retrieve our secret.  Run the code now, and you should see Secret written successfully. If not, check that you've used the correct value for the root token and OpenBao server address.  ","version":"Next","tagName":"h2"},{"title":"Step 5: retrieve a secret​","type":1,"pageTitle":"Developer quick start","url":"/openbao/docs/get-started/developer-qs/#step-5-retrieve-a-secret","content":" Now that we know how to write a secret, let's practice reading one.  Underneath the line where you wrote a secret to OpenBao, let's add a few more lines, where we will be retrieving the secret and unpacking the value:  GoBash secret, err := client.KVv2(&quot;secret&quot;).Get(context.Background(), &quot;my-secret-password&quot;) if err != nil { log.Fatalf(&quot;unable to read secret: %v&quot;, err) } value, ok := secret.Data[&quot;password&quot;].(string) if !ok { log.Fatalf(&quot;value type assertion failed: %T %#v&quot;, secret.Data[&quot;password&quot;], secret.Data[&quot;password&quot;]) }   Last, confirm that the value we unpacked from the read response is correct:  GoBash if value != &quot;OpenBao123&quot; { log.Fatalf(&quot;unexpected password value %q retrieved from openbao&quot;, value) } fmt.Println(&quot;Access granted!&quot;)   If the secret was fetched successfully, you should see the Access granted! message after you run the code. If not, check to see if you provided the correct path to your secret.  That's it! You've just written and retrieved your first OpenBao secret!  Additional examples  To learn how to integrate applications with OpenBao without needing to always change your application code, see the OpenBao Agent documentation. ","version":"Next","tagName":"h2"},{"title":"Glossary","type":0,"sectionRef":"#","url":"/openbao/docs/glossary/","content":"","keywords":"","version":"Next"},{"title":"Audit device​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#audit-device","content":" An audit device is responsible for managing audit logs. Every request to OpenBao and response from OpenBao goes through the configured audit devices. This provides a simple way to integrate OpenBao with multiple audit logging destinations of different types.  ","version":"Next","tagName":"h3"},{"title":"Auth method​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#auth-method","content":" An auth method is used to authenticate users or applications which are connecting to OpenBao. Once authenticated, the auth method returns the list of applicable policies which should be applied. OpenBao takes an authenticated user and returns a client token that can be used for future requests. As an example, the userpass auth method uses a username and password to authenticate the user. Alternatively, the github auth method allows users to authenticate via GitHub.  ","version":"Next","tagName":"h3"},{"title":"Barrier​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#barrier","content":" Almost everything OpenBao writes to storage is encrypted using the keyring, which is protected by the seal. We refer to this practice as &quot;the barrier&quot;. There are a few exceptions to the rule, for example, the seal configuration is stored in an unencrypted file since it's needed to unseal the barrier, and the keyring is encrypted using the root key, while the root key is encrypted using the seal.  ","version":"Next","tagName":"h3"},{"title":"Client token​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#client-token","content":" A client token (aka &quot;OpenBao Token&quot;) is conceptually similar to a session cookie on a web site. Once a user authenticates, OpenBao returns a client token which is used for future requests. The token is used by OpenBao to verify the identity of the client and to enforce the applicable ACL policies. This token is passed via HTTP headers.  ","version":"Next","tagName":"h3"},{"title":"Plugin​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#plugin","content":" Plugins are a feature of OpenBao that can be enabled, disabled, and customized to some degree. All OpenBao auth methods and secrets enginesare considered plugins.  Built-in plugin​  Built-in plugins are shipped with OpenBao, often for commonly used implementations, and require no additional operator intervention to run. Built-in plugins are just like any other backend code inside OpenBao.  External plugin​  External plugins are not shipped with OpenBao and require additional operator intervention to run. OpenBao's external plugins are completely separate, standalone applications that OpenBao executes and communicates with over RPC. Each time an OpenBao secret engine or auth method is mounted, a new process is spawned.  External multiplexed plugin​  An external plugin may make use of plugin multiplexing. A multiplexed plugin allows a single plugin process to be used for multiple mounts of the same type.  ","version":"Next","tagName":"h3"},{"title":"Secret​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#secret","content":" A secret is the term for anything returned by OpenBao which contains confidential or cryptographic material. Not everything returned by OpenBao is a secret, for example system configuration, status information, or policies are not considered secrets. Dynamic secrets always have an associated lease, and static secrets do not. This means clients cannot assume that the dynamic secret contents can be used indefinitely. OpenBao will revoke a dynamic secret at the end of the lease, and an operator may intervene to revoke the Dynamic Secret before the lease is over. This contract between OpenBao and its clients is critical, as it allows for changes in keys and policies without manual intervention.  ","version":"Next","tagName":"h3"},{"title":"Secrets engine​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#secrets-engine","content":" A secrets engine is responsible for managing secrets. Simple secrets engines, such as the &quot;kv&quot; secrets engine, return the same secret when queried. Some secrets engines support using policies to dynamically generate a secret each time they are queried. This allows for unique secrets to be used which allows OpenBao to do fine-grained revocation and policy updates. As an example, a MySQL secrets engine could be configured with a &quot;web&quot; policy. When the &quot;web&quot; secret is read, a new MySQL user/password pair will be generated with a limited set of privileges for the web server.  ","version":"Next","tagName":"h3"},{"title":"Server​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#server","content":" OpenBao depends on a long-running instance which operates as a server. The OpenBao server provides an API which clients interact with and manages the interaction between all the secrets engines, ACL enforcement, and secret lease revocation. Having a server based architecture decouples clients from the security keys and policies, enables centralized audit logging, and simplifies administration for operators.  ","version":"Next","tagName":"h3"},{"title":"Storage backend​","type":1,"pageTitle":"Glossary","url":"/openbao/docs/glossary/#storage-backend","content":" A storage backend is responsible for durable storage ofencrypted data. Backends are not trusted by OpenBao and are only expected to provide durability. The storage backend is configured when starting the OpenBao server. ","version":"Next","tagName":"h3"},{"title":"Installing OpenBao","type":0,"sectionRef":"#","url":"/openbao/docs/install/","content":"","keywords":"","version":"Next"},{"title":"Package manager​","type":1,"pageTitle":"Installing OpenBao","url":"/openbao/docs/install/#package-manager","content":" OpenBao manages packages for Ubuntu, Debian, Fedora, RHEL, Amazon Linux, and other distributions. Follow the instructions at OpenBao Tutorials to add our PGP key, add a repository, and install.  ","version":"Next","tagName":"h2"},{"title":"Precompiled binaries​","type":1,"pageTitle":"Installing OpenBao","url":"/openbao/docs/install/#precompiled-binaries","content":" To install the precompiled binary, download the applicable package for your system. OpenBao is packaged as a zip file.  Once the zip is downloaded, unzip the file into your designated directory. The bao binary inside is all that is necessary to run OpenBao (or bao.exe for Windows). No additional files are required to run OpenBao.  Copy the binary to your system. If you intend to access it from the command-line, ensure that you place the binary somewhere on your PATH.  Refer to the OpenBao Tutorials to start a server, putyour first secret, and use other features of OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Compiling from source​","type":1,"pageTitle":"Installing OpenBao","url":"/openbao/docs/install/#compiling-from-source","content":" To compile from source, you will need Go installed and properly configured (including a GOPATH environment variable set), as well as a copy of git in your PATH.  Clone the OpenBao repository from GitHub into your GOPATH:  $ mkdir -p $GOPATH/src/github.com/openbao &amp;&amp; cd $_ $ git clone https://github.com/openbao/openbao.git $ cd openbao   Bootstrap the project. This will download and compile libraries and tools needed to compile OpenBao:  $ make bootstrap   Build OpenBao for your current system and put the binary in ./bin/ (relative to the git checkout). The make dev target is just a shortcut that builds baofor only your local build environment (no cross-compiled targets).  $ make dev   ","version":"Next","tagName":"h2"},{"title":"Verifying the installation​","type":1,"pageTitle":"Installing OpenBao","url":"/openbao/docs/install/#verifying-the-installation","content":" To verify OpenBao is installed, run bao -h on your system. You should see the help output. If you are executing it from the command line, ensure it is on your PATH to avoid receiving an error that OpenBao is not found.  $ bao -h   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Installing OpenBao","url":"/openbao/docs/install/#tutorial","content":" Following tutorials provide some guidance on production cluster deployment:  Day One PreperationRecommended Patterns ","version":"Next","tagName":"h2"},{"title":"OpenBao internals","type":0,"sectionRef":"#","url":"/openbao/docs/internals/","content":"OpenBao internals This section covers the internals of OpenBao and explains the technical details of how OpenBao functions, its architecture and security properties. Note: Knowledge of OpenBao internals is recommended but not required to use OpenBao. However, if you're operating OpenBao, we recommend understanding the internals.","keywords":"","version":"Next"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/openbao/docs/internals/architecture/","content":"Architecture OpenBao is an intricate system with numerous distinct components. This page details the system architecture and hopes to assist OpenBao users and developers to build a mental model while understanding the theory of operation. warning Note: This page covers the technical details of OpenBao. The descriptions and elements contained within are for users that wish to learn about OpenBao without having to reference the source code. Although not required, we encourage all users and operators to review the provided information before using OpenBao due to its significance in an environment. High-Level overview The diagram below illustrates the intricacies and distinct components of OpenBao. OpenBao’s encryption layer, referred to as the barrier, is responsible for encrypting and decrypting OpenBao data. When the OpenBao server starts, it writes data to its storage backend. Since the storage backend resides outside the barrier, it’s considered untrusted so OpenBao will encrypt the data before it sends them to the storage backend. This mechanism ensures that if a malicious attacker attempts to gain access to the storage backend, the data cannot be compromised since it remains encrypted, until OpenBao decrypts the data. The storage backend provides a durable data persistent layer where data is secured and available across server restarts. When an OpenBao server is started, it begins in a sealed state. Before any operation can be performed on OpenBao, it must be unsealed. This is done by providing the unseal keys. During the OpenBao initialization, it generates an encryption key, which is used to protect all OpenBao data. This key is protected by a root key that is stored alongside all other OpenBao data, but is encrypted by another mechanism: the unseal key. By default, OpenBao uses Shamir's Secret Sharing to split the unseal key into a configured number of shards (key shares or unseal keys). A precise number of shards are required to reconstruct the unseal key, which is then used to decrypt the OpenBao's root key. Refer to the Seal/Unseal documentation for further details. The number of shares and the minimum number of shards required can both be specified. Shamir's technique can be disabled, and the root key can be used directly for unsealing. Once OpenBao retrieves the encryption key, it decrypts the data in the storage backend, and enters the unsealed state. Once unsealed, OpenBao loads the configured audit devices, auth methods, and secrets engines. warning Note: The default OpenBao configuration uses a Shamir seal; however, OpenBao can be auto unsealed by a trusted cloud key management system (KMS) or hardware security module (HSM) to increase security. The configuration of the audit devices, auth methods, and secrets engines are security sensitive and are stored in OpenBao. Users with permissions can modify them and cannot be specified outside of the barrier. By storing them in OpenBao, changes are protected by the ACL system and tracked by audit logs. Requests may be processed from the HTTP API to the core once OpenBao is unsealed. The core manages the flow of requests through the system, enforce ACLs, and ensure audit logging is done. When a client first connects to OpenBao, the client needs to authenticate. OpenBao provides configurable auth methods and offers flexibility within the authentication mechanism used. Mechanisms such as username/password or GitHub may be used for operators, while applications may use public/private keys or tokens to authenticate. An authentication request that flows through the core and into an auth method determines if the request is valid and returns a list of associated policies. Policies are just a named ACL rule. For example, the &quot;root&quot; policy is built-in and permits access to all resources. You may create any number of named policies with fine-grained control over paths. OpenBao operates in an allowed-access mode, meaning the action is not allowed unless access is granted via a policy explicitly. Since a user may have multiple policies associated, actions are allowed when policy permits. Policies are stored and managed by an internal policy store. This internal store is affected through the system backend, which is always mounted at sys/. Once authentication takes place and an auth method provides a set of applicable policies, a new client token is generated and managed by the token store. This client token is used to make future requests. This token method is similar to a cookie sent by a website when a user logs in. Depending on the auth method configuration, the client token may have a lease associated with it, and may need to be renewed periodically to avoid invalidation. Once authenticated, requests are made by providing the client token. The client token is used to verify the client, ensuring they are authorized while loading the relevant policies. The policies are used to authorize the client request. The request is then routed to the secrets engine, which is processed depending on its type. When the secrets engine returns the secret, the core registers it with the expiration manager and attaches a lease ID. Clients use the lease ID to renew or revoke their secret. The expiration manager automatically revokes the secret if a client allows the lease to expire. The core logs requests and responses to the audit broker, distributing the requests to all configured audit devices. Outside of the request flow, the core performs specific background activities. Lease management is critical, allowing expired client tokens or secrets to be revoked automatically. Additionally, OpenBao handles specific partial-failure cases by using write-ahead logging with a rollback manager. This is managed transparently within the core and is not user-visible. Resources To learn more about each components and sub-systems within OpenBao, select a topic from the left-navigation menu.For in depth details, consult the code.To get started with OpenBao, try out our Getting Started tutorial.","keywords":"","version":"Next"},{"title":"High availability","type":0,"sectionRef":"#","url":"/openbao/docs/internals/high-availability/","content":"High availability OpenBao can run in a high availability (HA) mode to protect against outages by running multiple OpenBao servers. Design overview The primary design goal for making OpenBao Highly Available (HA) is to minimize downtime without affecting horizontal scalability. OpenBao is bound by the IO limits of the storage backend rather than the compute requirements. Being bound by the IO limits simplifies the HA approach and avoids complex coordination. Storage backends, such as Integrated Storage, provide additional coordinative functions enabling OpenBao to run in an HA configuration. Supported by the backend, OpenBao will automatically run in HA mode without further configuration. When running in HA mode, OpenBao servers have two states they can be: standby and active. For multiple OpenBao servers sharing a storage backend, only a single instance is active at any time. All standby instances are placed in hot standbys. Only the active server processes all requests; the standby server redirects all requests to an active OpenBao server. Meanwhile, if the active server is sealed, fails, or loses network connectivity, then one of the standby OpenBao server becomes the active instance. Please note that only unsealed OpenBao servers may act as a standby. If a server is in a sealed state, it cannot act as a standby. Servers in a sealed state cannot serve any requests if the active server fails. Tutorial Refer to the following tutorials to learn more. OpenBao with Integrated Storage Reference ArchitectureOpenBao HA Cluster with Integrated Storage","keywords":"","version":"Next"},{"title":"Integrated storage","type":0,"sectionRef":"#","url":"/openbao/docs/internals/integrated-storage/","content":"","keywords":"","version":"Next"},{"title":"Consensus protocol​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/internals/integrated-storage/#consensus-protocol","content":" OpenBao's Integrated Storage uses a consensus protocol to provideConsistency (as defined by CAP). The consensus protocol is based on &quot;Raft: In search of an Understandable Consensus Algorithm&quot;. For a visual explanation of Raft, see The Secret Lives of Data.  ","version":"Next","tagName":"h2"},{"title":"OpenBao limits and maximums","type":0,"sectionRef":"#","url":"/openbao/docs/internals/limits/","content":"","keywords":"","version":"Next"},{"title":"Storage-Related limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#storage-related-limits","content":" ","version":"Next","tagName":"h2"},{"title":"Storage entry size​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#storage-entry-size","content":" The maximum size of an object written to a storage backend is determined by that backend.  For the integrated storage backend, the default limit is 1 MiB. This may be configured via max_entry_size in the storage stanza.  Many of the other limits within OpenBao derive from the maximum size of a storage entry, as described in the next sections. It is possible to recover from an error where a storage entry has reached its maximum size by reconfiguring OpenBao to a larger maximum storage entry. However, using large storage entries also negatively affects performance, as even a small change may become a large read-modify-write cycle on the entire entry. Larger writes may also delay Raft heartbeats, leading to leadership instability.  ","version":"Next","tagName":"h3"},{"title":"Mount point limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#mount-point-limits","content":" All secret engine mount points, and all auth mount points, must each fit within a single storage entry. Each JSON object describing a mount takes about 500 bytes, but is stored in compressed form at a typical cost of about 75 bytes. Each of (1) auth mounts, (2) secret engine mount points, (3) local-only auth methods, and (4) local-only secret engine mounts are stored separately, so the limit applies to each independently.  \tIntegrated storage default (1 MiB)Maximum number of secret engine mount points\t~14000 Maximum number of enabled auth methods\t~14000 Maximum mount point length\tno enforced limit  Specifying distinct per-mount options, or using long mount point paths, can increase the space required per mount.  The number of mount points can be monitored by reading thesys/auth andsys/mounts endpoints from the root namespace and similar sub-paths for namespaces respectively, like: namespace1/sys/auth,namespace1/sys/mounts, etc.  Alternatively, use thevault.core.mount_table.num_entriesandvault.core.mount_table.sizetelemetry metrics to monitor the number of mount points and size of each mount table.  ","version":"Next","tagName":"h3"},{"title":"Namespace limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#namespace-limits","content":" The entire list of namespaces must fit in a single storage entry. However, the effective limit is generally much smaller because each namespace must have at least two secret engine mounts (for sys and identity), one local secret engine (cubbyhole) and one auth engine mount (token).  \tIntegrated storage default (1 MiB)Maximum number of namespaces\t~7000 Maximum number of namespaces with one additional secret engine per namespace\t~4600 Maximum nesting depth for namespaces\t~220  The maximum nesting depth calculation assumes a cost of 40 bytes per namespace path element. 160 nested paths = 160 namespaces ranging from 40 bytes to 6400 bytes.  The number of namespaces can be monitored by queryingsys/namespaces.  To estimate the number of namespaces that can be created, divide the mount point limit by the larger of the number of auth mounts per namespace (including ns_token) and the number of secret mounts per namespace (including identity and sys.)  ","version":"Next","tagName":"h3"},{"title":"Entity and group limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#entity-and-group-limits","content":" The metadata that may be attached to an identity entity or an entity group has the following constraints:  \tLimitNumber of key-value pairs in metadata\t64 Metadata key size\t128 bytes Metadata value size\t512 bytes  OpenBao shards the entities across 256 storage entries. This creates a hard limit of 256MiB on integrated storage with its default settings. Entity aliases are stored inline in the Entity objects and so consume the same pool of storage. Entity definitions are compressed within each storage entry, and the pre-compression size varies with the number of entity aliases and the amount of metadata. Minimally-populated entities about 200 bytes after compression.  Group definitions are stored separately, in their own pool of 256 storage entries. The size of each group object depends on the number of members and the amount of metadata. Group aliases and group membership information is stored inline in each Group object. A group with no metadata, holding 10 entities, will use about 500 bytes per group. A group holding 100 entities would instead consume about 4,000 bytes.  The following table shows a best-case estimate and a more conservative estimate for entities and groups. The number is slightly less than the amount that fits in one shard, to reflect the fact that the first shard to fill up will start inducing failures. This maximum will decrease if each entity has a large amount of metadata, or if each group has a large number of members.  \tIntegrated storage default (1 MiB)Maximum number of identity entities (best case, 200 bytes per entity)\t~1,250,000 Maximum number of identity entities (conservative case, 500 bytes per entity)\t~480,000 Maximum number of identity entities (maximum permitted metadata, 41160 bytes per entity)\t2,400 Maximum number of groups (10 entities per group)\t~480,000 Maximum number of groups (100 entities per group)\t~50,000 Maximum number of members in a group\t~23,000  The number of entities can be monitored using OpenBao's telemetry; see vault.identity.num_entities (total) or vault.identity.entities.count (by namespace).  The cost of entity and group updates grows as the number of objects in each shard increases. This cost can be monitored via thevault.identity.upsert_entity_txn and the vault.identity.upsert_group_txn metrics.  Very large internal groups should be avoided (more than 1000 members), because the membership list in a group must reside in a single storage entry. Instead, consider using external groups or split the group up into multiple sub-groups.  ","version":"Next","tagName":"h3"},{"title":"Token limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#token-limits","content":" One storage entry is used per token; there is thus no upper bound on the number of active tokens. There are no restrictions on the token metadata field, other than the entire token must fit into one storage entry:  \tLimitNumber of key-value pairs in metadata\tno limit Metadata key size\tno limit Metadata value size\tno limit Total size of token metadata\t512 KiB  ","version":"Next","tagName":"h3"},{"title":"Policy limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#policy-limits","content":" The maximum size of a policy is limited by the storage entry size. Policy lists that appear in tokens or entities must fit within a single storage entry.  \tIntegrated storage default (1 MiB)Maximum policy size\t1 MiB Maximum number of policies per namespace\tno limit Maximum number of policies per token\t~28,000 Maximum number of policies per entity or group\t~28,000  Each time a token is used, OpenBao must assemble the collection of policies attached to that token, to the entity, to any groups that the entity belongs to, and recursively to any groups that contain those groups. Very large numbers of policies are possible, but can cause OpenBao’s response time to increase. You can monitor thevault.core.fetch_acl_and_tokenmetric to determine if the time required to assemble an access control list is becoming excessive.  ","version":"Next","tagName":"h3"},{"title":"Versioned key-value store (kv-v2 secret engine)​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#versioned-key-value-store-kv-v2-secret-engine","content":" \tLimitNumber of secrets\tno limit, up to available storage capacity Maximum size of one version of a secret\tslightly less than one storage entry (512 KiB or 1024 KiB) Number of versions of a secret\tdefault 10; configurable per-secret or per-mount Maximum number of versions (not checked when configured)\tat least 24,000  Each version of a secret must fit in a single storage entry; the key-value pairs are converted to JSON before storage.  Version metadata consumes 21 bytes per version and must fit in a single storage entry, separate from the stored data.  Each secret also has version-agnostic metadata. This data can contain a custom_metadata field of user-provided key-value pairs. OpenBao imposes the following custom metadata limits:  \tLimitNumber of custom metadata key-value pairs\t64 Custom metadata key size\t128 bytes Custom metadata value size\t512 bytes  ","version":"Next","tagName":"h3"},{"title":"Transit secret engine​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#transit-secret-engine","content":" The maximum size of a Transit ciphertext or plaintext is limited by OpenBao's maximum request size, as described below.  All archived versions of a single key must fit in a single storage entry. This limit depends on the key size.  Key length\tIntegrated storage default (1 MiB)aes128-gcm96 keys\t4017 aes256-gcm96 keys\t3731 chacha-poly1305 keys\t3731 ed25519 keys\t2841 ecdsa-p256 keys\t1635 ecdsa-p384 keys\t1318 ecdsa-p523 keys\t1078 1024-bit RSA keys\t333 2048-bit RSA keys\t233 4096-bit RSA kyes\t178  ","version":"Next","tagName":"h3"},{"title":"Other limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#other-limits","content":" ","version":"Next","tagName":"h2"},{"title":"Request size​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#request-size","content":" The maximum size of an HTTP request sent to OpenBao is limited by the max_request_size option in the listener stanza. It defaults to 32 MiB. This value, minus the overhead of the HTTP request itself, places an upper bound on any Transit operation, and on the maximum size of any key-value secrets.  ","version":"Next","tagName":"h3"},{"title":"Request duration​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#request-duration","content":" The maximum duration of an OpenBao operation ismax_request_duration, which defaults to 90 seconds. If a particular secret engine takes longer than this to perform an operation on a remote service, the OpenBao client will see a failure.  The environment variable VAULT_CLIENT_TIMEOUT sets a client-side maximum duration as well, which is 60 seconds by default.  ","version":"Next","tagName":"h3"},{"title":"Lease limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#lease-limits","content":" A systemwide maximum TTL, and amaximum TTL per mount point can be configured.  Although no technical maximum exists, high lease counts can cause degradation in system performance. We recommend short default time-to-live values on tokens and leases to avoid a large backlog of unexpired leases, or a large number of simultaneous expirations.  \tLimitMaximum number of leases\tadvisory limit at 256,000 Maximum duration of lease or token\t768 hours by default  The current number of unexpired leases can be monitored via thevault.expire.num_leases metric.  ","version":"Next","tagName":"h3"},{"title":"Transform limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#transform-limits","content":" The Transform secret engine obeys the FF3-1 minimum and maximum sizes on the length of an input, which are a function of the alphabet size.  ","version":"Next","tagName":"h3"},{"title":"External plugin limits​","type":1,"pageTitle":"OpenBao limits and maximums","url":"/openbao/docs/internals/limits/#external-plugin-limits","content":" The plugin system launches a separate process initiated by OpenBao that communicates over RPC. For each secret engine and auth method that's enabled as an external plugin, OpenBao will spawn a process on the host system. For the Database Secrets Engines, external database plugins will spawn a process for every configured connection.  Regardless of plugin type, each of these processes will incur resource overhead on the system, including but not limited to resources such as CPU, memory, networking, and file descriptors. There's no specific limit on the number secrets engines, auth methods, or database configured connections that can be enabled. This ultimately depends on the particular plugin resource utilization, the extent to which that plugin is being called, and the available resources on the system. For plugins of the same type, each additional process will incur a roughly linear increase in resource utilization. This assumes the usage of each plugin of the same type is similar. ","version":"Next","tagName":"h3"},{"title":"Key rotation","type":0,"sectionRef":"#","url":"/openbao/docs/internals/rotation/","content":"","keywords":"","version":"Next"},{"title":"NIST rotation guidance​","type":1,"pageTitle":"Key rotation","url":"/openbao/docs/internals/rotation/#nist-rotation-guidance","content":" Periodic rotation of the encryption keys is recommended, even in the absence of compromise. Due to the nature of the AES-256-GCM encryption used, keys should be rotated before approximately 232 encryptions have been performed, following the guidelines of NIST publication 800-38D.  OpenBao will automatically rotate the backend encryption key prior to reaching 232 encryption operations by default.  Operators can estimate the number of encryptions by summing the following:  The vault.barrier.put telemetry metric.The vault.token.creation metric where the token_type label is batch.The merkle.flushDirty.num_pages metric.The WAL index. ","version":"Next","tagName":"h2"},{"title":"Security model","type":0,"sectionRef":"#","url":"/openbao/docs/internals/security/","content":"Security model Due to the nature of OpenBao and the confidentiality of data it manages, the OpenBao security model is very critical. The overall goal of OpenBao's security model is to provide confidentiality, integrity, availability, accountability, authentication. This means that data at rest and in transit must be secure from eavesdropping or tampering. Clients must be appropriately authenticated and authorized to access data or modify policies. All interactions must be auditable and traced uniquely back to the origin entity, and the system must be robust against intentional attempts to bypass any of its access controls. Threat model The following are the various parts of the OpenBao threat model: Eavesdropping on any OpenBao communication. Client communication with OpenBao should be secure from eavesdropping as well as communication from OpenBao to its storage backend or between OpenBao cluster nodes. Tampering with data at rest or in transit. Any tampering should be detectable and cause OpenBao to abort processing of the transaction. Access to data or controls without authentication or authorization. All requests must be proceeded by the applicable security policies. Access to data or controls without accountability. If audit logging is enabled, requests and responses must be logged before the client receives any secret material. Confidentiality of stored secrets. Any data that leaves OpenBao to rest in the storage backend must be safe from eavesdropping. In practice, this means all data at rest must be encrypted. Availability of secret material in the face of failure. OpenBao supports running in a highly available configuration to avoid loss of availability. The following are not considered part of the OpenBao threat model: Protecting against arbitrary control of the storage backend. An attacker that can perform arbitrary operations against the storage backend can undermine security in any number of ways that are difficult or impossible to protect against. As an example, an attacker could delete or corrupt all the contents of the storage backend causing total data loss for OpenBao. The ability to control reads would allow an attacker to snapshot in a well-known state and rollback state changes if that would be beneficial to them. Protecting against the leakage of the existence of secret material. An attacker that can read from the storage backend may observe that secret material exists and is stored, even if it is kept confidential. Protecting against memory analysis of a running OpenBao. If an attacker is able to inspect the memory state of a running OpenBao instance, then the confidentiality of data may be compromised. Protecting against flaws in external systems or services used by OpenBao. Some authentication methods or secrets engines delegate sensitive operations to systems external to OpenBao. If an attacker can compromise credentials or otherwise exploit a vulnerability in these external systems, then the confidentiality or integrity of data may be compromised. Protecting against malicious plugins or code execution on the underlying host. If an attacker can gain code execution or write privileges to the underlying host, then the confidentiality or the integrity of data may be compromised. Protecting against flaws in clients or systems that access OpenBao. If an attacker can compromise an OpenBao client (e.g., system, browser) and obtain this client’s OpenBao credentials, they can access OpenBao with the level of privilege associated with this client. Protecting against OpenBao administrators supplying vulnerable or malicious configuration data. Any data provided as configuration values to OpenBao's administrative endpoints (e.g. secret engines configurations), or OpenBao's configuration files should be validated. If an attacker can write to OpenBao's configuration, then the confidentiality or integrity of data can be compromised. External threat overview OpenBao architecture compromises of three distinct systems: Client: Speaks to OpenBao over an API.Server: Provides an API and serves requests.Storage backend: Utilized by the server to read and write data. There is no mutual trust between the OpenBao client and server. Clients useTLS to verify the identity of the server and to establish a secure communication channel. Servers require that a client provides a client token for every request which is used to identify the client. A client that does not provide their token is only permitted to make login requests. All server-to-server traffic between OpenBao instances within a cluster uses mutually-authenticated TLS to ensure the confidentiality and integrity of data in transit. Nodes are authenticated prior to joining the cluster by anunseal challenge. The storage backends used by OpenBao are also untrusted by design. OpenBao uses a security barrier for all requests made to the backend. The security barrier automatically encrypts all data leaving OpenBao using a 256-bit Advanced Encryption Standard (AES) cipher in the Galois Counter Mode (GCM) with 96-bit nonces. The nonce is randomly generated for every encrypted object. When data is read from the security barrier, the GCM authentication tag is verified during the decryption process to detect any tampering. Depending on the backend used, OpenBao may communicate with the backend over TLS to provide an added layer of security. In some cases, such as a file backend, this is not applicable. Because storage backends are untrusted, an eavesdropper would only gain access to encrypted data even if communication with the backend was intercepted. Internal threat overview Within the OpenBao system, a critical security concern is an attacker attempting to gain access to secret material they are not authorized to. This is an internal threat if the attacker is already permitted to some level of access to OpenBao, and is able to authenticate. When a client first authenticates with OpenBao, an auth method is used to verify the identity of the client and to return a list of associated ACL policies. This association is configured by operators of OpenBao ahead of time. For example, GitHub users in the &quot;engineering&quot; team may be mapped to the &quot;engineering&quot; and &quot;ops&quot; OpenBao policies. OpenBao then generates a client token which is a randomly generated, serialized value and maps it to the policy list. This client token is then returned to the client. On each request, a client provides this token. OpenBao then uses it to check that the token is valid and has not been revoked or expired, and generates an ACL based on the associated policies. OpenBao uses a strict default deny enforcement strategy. This means unless an associated policy allows for a given action, it will be denied. Each policy specifies a level of access granted to a path in OpenBao. When the policies are merged (if multiple policies are associated with a client), the highest access level permitted is used. For example, if the &quot;engineering&quot; policy permits read/update access to the &quot;eng/&quot; path, and the &quot;ops&quot; policy permits read access to the &quot;ops/&quot; path, then the user gets the union of those. Policy is matched using the most specific defined policy, which may be an exact match or the longest-prefix match glob pattern. SeePolicy Syntax for more details. Certain operations are only permitted by &quot;root&quot; users, which is a distinguished policy built into OpenBao. This is similar to the concept of a root user on a Unix system or an administrator on Windows. In cases where clients are provided with root tokens or associated with the root policy, OpenBao supports the notion of &quot;sudo&quot; privilege. As part of a policy, users may be granted &quot;sudo&quot; privileges to certain paths, so that they can still perform security sensitive operations without being granted global root access to OpenBao. Lastly, OpenBao supports using a Two-person rule for unsealing using Shamir's Secret Sharing technique. When OpenBao is started, it starts in a sealed state. This means that the encryption key needed to read and write from the storage backend is not yet known. The process of unsealing requires providing the root key so that the encryption key can be retrieved. The risk of distributing the root key is that a single malicious attacker with access to it can decrypt the entire OpenBao. Instead, Shamir's technique allows us to split the root key into multiple shares or parts. The number of shares and the threshold needed is configurable, but by default OpenBao generates 5 shares, any 3 of which must be provided to reconstruct the root key. By using a secret sharing technique, we avoid the need to place absolute trust in the holder of the root key, and avoid storing the root key at all. The root key is only retrievable by reconstructing the shares. The shares are not useful for making any requests to OpenBao, and can only be used for unsealing. Once unsealed the standard ACL mechanisms are used for all requests. To make an analogy, a bank puts security deposit boxes inside of a vault. Each security deposit box has a key, while the vault door has both a combination and a key. The vault is encased in steel and concrete so that the door is the only practical entrance. The analogy to OpenBao is that the cryptosystem is the steel and concrete protecting the data. While you could tunnel through the concrete or brute force the encryption keys, it would be prohibitively time consuming. Opening the bank vault requires two-factors: the key and the combination. Similarly, OpenBao requires multiple shares be provided to reconstruct the root key. Once unsealed, each security deposit boxes still requires that the owner provide a key, and similarly the OpenBao ACL system protects all the secrets stored.","keywords":"","version":"Next"},{"title":"Raft protocol overview​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/internals/integrated-storage/#raft-protocol-overview","content":" Raft is a consensus algorithm that is based onPaxos. Compared to Paxos, Raft is designed to have fewer states and a simpler, more understandable algorithm.  The Raft protocol will not be fully covered here. However, a high level description is provided to help you build a mental model. Refer to the complete specification that's described in this paper.  Terminology​  There are a few key terms to know when discussing Raft:  Leader - At any given time, the peer set elects a single node to be the leader. The leader is responsible for ingesting new log entries, replicating to followers, and managing when an entry is committed. The leader node is also the active OpenBao node and followers are standby nodes. Refer to the High Availability document for more information. Log - An ordered sequence of entries (replicated log) to keep track of any cluster changes. The leader is responsible for log replication. When new data is written, for example, a new event creates a log entry. The leader then sends the new log entry to its followers. Any inconsistency within the replicated log entries will indicate an issue. FSM - Finite State Machine. A collection of finite states with transitions between them. As new logs are applied, the FSM is allowed to transition between states. Application of the same sequence of logs must result in the same state, meaning behavior must be deterministic. Peer set - The set of all members participating in log replication. All server nodes are in the peer set of the local cluster. Quorum - A majority of members from a peer set: for a set of size n, quorum requires at least (n+1)/2 members. For example, if there are 5 members in the peer set, we would need 3 nodes to form a quorum. If a quorum of nodes is unavailable for any reason, the cluster becomes unavailable and no new logs can be committed. Committed Entry - An entry is considered committed when it is durably stored on a quorum of nodes. An entry is applied once its committed.  Node states​  Raft nodes are always in one of three states: follower, candidate, or leader. All nodes initially start out as a follower. In this state, nodes can accept log entries from a leader and cast votes. If no entries are received for a period of time, nodes will self-promote to the candidate state. In the candidate state, nodes request votes from their peers. If a candidate receives a quorum of votes, then it is promoted to a leader. The leader must accept new log entries and replicate to all the other followers.  Writing logs​  Once a cluster has a leader, it is able to accept new log entries. A client can request that a leader append a new log entry (from Raft's perspective, a log entry is an opaque binary blob). The leader then writes the entry to durable storage and attempts to replicate to a quorum of followers. Once the log entry is consideredcommitted, it can be applied to a finite state machine. The finite state machine is application specific; in OpenBao's case, we useBoltDB to maintain a cluster state. OpenBao's writes are blocked until they are committed and applied.  Compacting logs​  It would be undesirable to allow a replicated log to grow in an unbounded fashion. Raft provides a mechanism by which the current state is saved to snapshots and its related logs are compacted. Because of the FSM abstraction, restoring the state of the FSM must result in the same state as a replay of old logs. This allows Raft to capture the FSM state at a point in time and then remove all the logs that were used to reach that state. This is performed automatically without user intervention and prevents unbounded disk usage while also minimizing the time spent replaying logs. One of the advantages of using BoltDB is that it allows OpenBao's snapshots to be very light weight. Since OpenBao's data is already persisted to disk in BoltDB, the snapshot process just needs to truncate the raft logs.  Quorum​  Consensus is fault-tolerant while a cluster has quorum. If a quorum of nodes is unavailable, it is impossible to process log entries or reason about peer membership. For example, suppose there are only 2 peers: A and B. The quorum size is also 2, meaning both nodes must agree to commit a log entry. If either A or B fails, it is now impossible to reach quorum. This means the cluster is unable to add or remove a node or to commit any additional log entries. This results inunavailability. At this point, manual intervention is required to remove either A or B and restart the remaining node in bootstrap mode.  A Raft cluster of 3 nodes can tolerate a single node failure while a cluster of 5 can tolerate 2 node failures. The recommended OpenBao production deployment is to run 5 OpenBao servers per cluster. See the Minimum &amp; Scaling and Deployment Table to learn more about the failure tolerance using Integrated Storage.  Performance​  In terms of performance, Raft is comparable to Paxos. Assuming stable leadership, committing a log entry requires a single round trip to half of the cluster. Thus, performance is bound by disk I/O and network latency.  ","version":"Next","tagName":"h3"},{"title":"Raft in OpenBao​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/internals/integrated-storage/#raft-in-openbao","content":" When getting started, a single OpenBao server isinitialized. At this point, the cluster is of size 1, which allows the node to self-elect as a leader. Once a leader is elected, other servers can be added to the peer set in a way that preserves consistency and safety.  The join process is how new nodes are added to the OpenBao cluster; it uses an encrypted challenge/answer workflow. To accomplish this, all nodes in a single Raft cluster must share the same seal configuration. If using an Auto Unseal, the join process can use the configured seal to automatically decrypt the challenge and respond with the answer. If using a Shamir seal, the unseal keys must be provided to the node attempting to join the cluster before it can decrypt the challenge and respond with the decrypted answer.  Since all servers participate as part of the peer set, they all know the current leader. When an API request arrives at a non-leader server, the request is forwarded to the leader.  Similar to other storage backends, data that is written to the Raft log and FSM will be encrypted by OpenBao's barrier.  ","version":"Next","tagName":"h3"},{"title":"Quorum management​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/internals/integrated-storage/#quorum-management","content":" Autopilot​  An Autopilot featureis available since 1.7.x &amp; later versions that include configurable parameters for when a node is treated as healthy before it's considered an eligible voter in the quorum list. Other features which may be enabled include the ability to remove nodes considered as dead from the quorum list after a certain period.  Autopilot is enabled by default and the default configuration values should work well for most OpenBao deployments, but they can be changed if needed.  Autopilot includes stabilization logic for nodes joining the cluster. Recently joined nodes are accepted as non-voter initially until they are in sync with matching Raft index and only after a stability thresholds are they then full voting members. Setting the stability threshold too low can result in cluster instability as nodes will be counted as voters before they are capable of voting.  A dead server cleanup capability is available. With this feature enabled, unhealthy nodes are automatically removed from the Raft cluster without manual operator intervention. This is enabled via the Autopilot API. If you wish to decommission a node manually, this can be done with theremove peer command.  Without autopilot​  In scenarios involving those when a node joins a Raft cluster, it attempts to catch up with the rest of the nodes through the data that it's replicating from the leader. While in this initial synchronisation state, the node cannot vote but is counted for the purposes of quorum. If a number of new nodes join the cluster simultaneously or at similar times, and thereby exceeding the failure tolerance of the cluster, quorum may be lost and the cluster can fail.  For example, consider a scenario where there is a 3-node cluster with a large amount of data and a failure tolerance of 1. An additional 3 new nodes then join the cluster. The cluster now consists of 6 nodes with a failure tolerance of 2, but since all 3 nodes are still catching up, this will result in a loss of quorum.  A 3 node cluster with a large amount of data that's at a failure tolerance of 1.Another 3 new nodes then join the cluster together.Now the cluster consists of 6 nodes with a failure tolerance of 2, but all 3 new nodes are still catching up, resulting in a loss of quorum.  For this reason, we recommend ensuring new nodes have Raft indexes that are close to the leader before adding additional nodes. Raft indexes are visible viabao status.  ","version":"Next","tagName":"h3"},{"title":"Deployment table​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/internals/integrated-storage/#deployment-table","content":" Below is a table that shows quorum size and failure tolerance for various cluster sizes. The recommended production deployment consists of 5 servers. A single server deployment is highly discouraged as data loss is inevitable in a failure scenario.  Servers\tQuorum Size\tFailure Tolerance1\t1\t0 2\t2\t0 3\t2\t1 4\t3\t1 5\t3\t2 6\t4\t2 7\t4\t3  ","version":"Next","tagName":"h3"},{"title":"Minimums & scaling​","type":1,"pageTitle":"Integrated storage","url":"/openbao/docs/internals/integrated-storage/#minimums--scaling","content":" The OpenBao Reference Architecturerecommends a 5 node cluster to ensure a minimum failure tolerance of at least 2.  It is good practise, wherever possible, to retain a failure tolerance of 2 or more.  A scaling approach can be pursued in the event of maintenance and other changes where an additional pair of nodes (ie two) are added in an existing 5 node cluster making for a 7 node cluster. Once new joiners are confirmed to be in sync then the 2 older nodes can be stopped and or destroyed with the same processes being repeated until all other nodes have been replaced. This use of additional nodes on a temporary basis of a 7 node cluster arrangement, concluding back to 5 nodes, may be one way to ensure sufficient failure tolerance is maintained and that changes are made progressively in proportion to the cluster failure tolerance and never exceeding the available failure tolerance in any given time.  The intent with any change or scaling ought to be with the lose of quorum and reduction of the quorum failure tolerances at the forefront and discouraging any practises that compromise that.  Scaling clusters up or down in pairs with 2 nodes each time also has the added advantage of avoiding even numbers and it is always recommended to allow for an odd number of total voters in any cluster. ","version":"Next","tagName":"h3"},{"title":"Telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/","content":"","keywords":"","version":"Next"},{"title":"Working with raw telemetry data​","type":1,"pageTitle":"Telemetry","url":"/openbao/docs/internals/telemetry/#working-with-raw-telemetry-data","content":" You can view raw telemetry data for debugging purposes by interrupting the OpenBao process with USR1 (on *nix) or BREAK (on Windows). When the OpenBao process receives this signal, it dumps telemetry data for the last 10 seconds tostderr.  Raw telemetry data is prefixed with the relevant metric type:  [C] indicates the metric is a counter.[G] indicates the metric is a gauge.[S] indicates the metric is a summary.  ","version":"Next","tagName":"h2"},{"title":"Example raw telemetry dump​","type":1,"pageTitle":"Telemetry","url":"/openbao/docs/internals/telemetry/#example-raw-telemetry-dump","content":" [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.expire.num_leases': 5100.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.num_goroutines': 39.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.sys_bytes': 222746880.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.malloc_count': 109189192.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.free_count': 108408240.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.heap_objects': 780953.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.total_gc_runs': 232.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.alloc_bytes': 72954392.000 [2017-12-19 20:37:50 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.total_gc_pause_ns': 150293024.000 [2017-12-19 20:37:50 +0000 UTC][S] 'vault.merkle.flushDirty': Count: 100 Min: 0.008 Mean: 0.027 Max: 0.183 Stddev: 0.024 Sum: 2.681 LastUpdated: 2017-12-19 20:37:59.848733035 +0000 UTC m=+10463.692105920 [2017-12-19 20:37:50 +0000 UTC][S] 'vault.merkle.saveCheckpoint': Count: 4 Min: 0.021 Mean: 0.054 Max: 0.110 Stddev: 0.039 Sum: 0.217 LastUpdated: 2017-12-19 20:37:57.048458148 +0000 UTC m=+10460.891835029 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.alloc_bytes': 73326136.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.sys_bytes': 222746880.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.malloc_count': 109195904.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.free_count': 108409568.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.heap_objects': 786342.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.total_gc_pause_ns': 150293024.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.expire.num_leases': 5100.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.num_goroutines': 39.000 [2017-12-19 20:38:00 +0000 UTC][G] 'vault.7f320e57f9fe.runtime.total_gc_runs': 232.000 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.route.rollback.consul-': Count: 1 Sum: 0.013 LastUpdated: 2017-12-19 20:38:01.968471579 +0000 UTC m=+10465.811842067 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.rollback.attempt.consul-': Count: 1 Sum: 0.073 LastUpdated: 2017-12-19 20:38:01.968502743 +0000 UTC m=+10465.811873131 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.rollback.attempt.pki-': Count: 1 Sum: 0.070 LastUpdated: 2017-12-19 20:38:01.96867005 +0000 UTC m=+10465.812041936 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.route.rollback.auth-app-id-': Count: 1 Sum: 0.012 LastUpdated: 2017-12-19 20:38:01.969146401 +0000 UTC m=+10465.812516689 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.rollback.attempt.identity-': Count: 1 Sum: 0.063 LastUpdated: 2017-12-19 20:38:01.968029888 +0000 UTC m=+10465.811400276 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.rollback.attempt.database-': Count: 1 Sum: 0.066 LastUpdated: 2017-12-19 20:38:01.969394215 +0000 UTC m=+10465.812764603 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.barrier.get': Count: 16 Min: 0.010 Mean: 0.015 Max: 0.031 Stddev: 0.005 Sum: 0.237 LastUpdated: 2017-12-19 20:38:01.983268118 +0000 UTC m=+10465.826637008 [2017-12-19 20:38:00 +0000 UTC][S] 'vault.merkle.flushDirty': Count: 100 Min: 0.006 Mean: 0.024 Max: 0.098 Stddev: 0.019 Sum: 2.386 LastUpdated: 2017-12-19 20:38:09.848158309 +0000 UTC m=+10473.691527099  ","version":"Next","tagName":"h2"},{"title":"Enable OpenBao telemetry gathering","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/enable-telemetry/","content":"","keywords":"","version":"Next"},{"title":"Before you start​","type":1,"pageTitle":"Enable OpenBao telemetry gathering","url":"/openbao/docs/internals/telemetry/enable-telemetry/#before-you-start","content":" You must have access to your OpenBao configuration file.  ","version":"Next","tagName":"h2"},{"title":"Step 1: Choose an aggregation agent​","type":1,"pageTitle":"Enable OpenBao telemetry gathering","url":"/openbao/docs/internals/telemetry/enable-telemetry/#step-1-choose-an-aggregation-agent","content":" OpenBao uses the go-metrics package to export telemetry and supports the following aggregation agents for time-series monitoring:  Config prefix\tName\tCompanycirconus\tCirconus\tCirconus dogstatsd\tDogStatsD\tDatadog prometheus\tPrometheus\tPrometheus / Open source stackdriver\tCloud Operations\tGoogle statsd\tStatsd\tOpen source statsite\tStatsite\tOpen source  ","version":"Next","tagName":"h2"},{"title":"Step 2: Enable at least one audit device​","type":1,"pageTitle":"Enable OpenBao telemetry gathering","url":"/openbao/docs/internals/telemetry/enable-telemetry/#step-2-enable-at-least-one-audit-device","content":" To include audit-related metrics, you must enable auditing on at least one device with the bao audit enable command. For example, to enable auditing for thefile device and save the logs to /var/log/openbao_audit.log:  $ bao audit enable file file_path=/var/log/openbao_audit.log   ","version":"Next","tagName":"h2"},{"title":"Step 3: Configure telemetry collection​","type":1,"pageTitle":"Enable OpenBao telemetry gathering","url":"/openbao/docs/internals/telemetry/enable-telemetry/#step-3-configure-telemetry-collection","content":" To configure telemetry collection, update the telemetry stanza in your OpenBao configuration with your collection preferences and aggregation agent details.  For example, the following telemetry stanza configures OpenBao with the standard telemetry defaults and connects it to a Statsite agent running on the default port within a company intranet at mycompany.statsite:  telemetry { usage_gauge_period = &quot;10m&quot; maximum_gauge_cardinality = 500 disable_hostname = false enable_hostname_label = false lease_metrics_epsilon = &quot;1h&quot; num_lease_metrics_buckets = 168 add_lease_metrics_namespace_labels = false filter_default = true statsite_address = &quot;mycompany.statsite:8125&quot; }   Many metrics solutions charge by the metric. You can set filter_default to false and use the prefix_filter parameter to include and exclude specific values based on metric name to avoid paying for irrelevant information.  For example, to limit your telemetry to the core token metrics plus the number of leases set to expire:  telemetry { filter_default = false prefix_filter = [&quot;+vault.token&quot;, &quot;-vault.expire&quot;, &quot;+vault.expire.num_leases&quot;] }   ","version":"Next","tagName":"h2"},{"title":"Step 4: Choose a reporting solution​","type":1,"pageTitle":"Enable OpenBao telemetry gathering","url":"/openbao/docs/internals/telemetry/enable-telemetry/#step-4-choose-a-reporting-solution","content":" You need to save or forward your telemetry data to a separate storage solution for reporting, analysis, and alerting. Which solution you need depends on the feature set provided by your aggregation agent and the protocol support of your reporting platform.  Popular reporting solutions compatible with OpenBao:  GrafanaGraphiteInfluxData: TelegrafInfluxData: InfluxDBInfluxData: ChronografInfluxData: KapacitorSplunk  ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Enable OpenBao telemetry gathering","url":"/openbao/docs/internals/telemetry/enable-telemetry/#next-steps","content":" Review theKey metrics for common health checksguide to identify metrics you may want to start monitoring immediately.Review the full list of availabletelemetry parameters.Review the Monitor telemetry and audit device log datatutorial for general monitoring guidance and steps to configure your OpenBao telemetry for Splunk using Telegraf and Fluentd.Review theMonitor telemetry with Prometheus and Grafanatutorial to configure your OpenBao telemetry for Prometheus and Grafana. ","version":"Next","tagName":"h2"},{"title":"Telemetry metrics overview","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/","content":"","keywords":"","version":"Next"},{"title":"Metric types​","type":1,"pageTitle":"Telemetry metrics overview","url":"/openbao/docs/internals/telemetry/metrics/#metric-types","content":" OpenBao provides three types of telemetry metrics:  Counter metrics increment when an event occurs. Counters are cumulative and reset at the end of reporting intervals.Gauge metrics provide measurements of current values.Summary metrics provide observational values. OpenBao commonly uses summaries to measure the time required to for a discrete event to complete.  High-cardinality gauges, like vault.kv.secret.count, update at the interval configured with usage_gauge_period in the telemetry stanza. The default reporting interval for gauge metrics is 10 minutes.  ","version":"Next","tagName":"h2"},{"title":"Metric labels​","type":1,"pageTitle":"Telemetry metrics overview","url":"/openbao/docs/internals/telemetry/metrics/#metric-labels","content":" Some telemetry metrics come with additional metadata that provides context for the measurement. For example, a token metric might include the namespace it belongs to or the authentication method used to create it.  Metric metadata is labeled and incorporated into the metric name for the in-memory telemetry and any other telemetry engine that does not support custom labels.  The metric name in the table below is followed by a list of labels supported, in the order in which they appear, if flattened.  Label\tExample\tDescriptionauth_method\tuserpass\tAuthorization engine type cluster\topenbao-cluster-d54ad07\tName of the cluster where the metric originated creation_ttl\t7d\tTime-to-live assigned at creation, rounded up to the next-highest bucket: 1m, 10m, 20m, 1h, 2h, 1d, 2d, 7d, 30d, or +Inf mount_point\tauth/userpass/\tPath at which an authentication method or secret engine is mounted name\tmemoryLimit\tName of the object being aggregated (for example, a quota or quota rule) namespace\tns1\tA namespace path or root for the root namespace policy\tdefault\tName of the associated policy secret_engine\tkv\tSecrets engine type token_type\tservice\tType of the associated token: batch or service peer_id\tnode-1\tUnique identifier of a raft peer node node_id\tnode-42\tUnique identifier of a raft peer node (duplicates peer_id) snapshot_config_name\tconfig1\tName of the configuration used for automated snapshots ","version":"Next","tagName":"h2"},{"title":"Audit log telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/audit/","content":"","keywords":"","version":"Next"},{"title":"Default metrics​","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/#default-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.audit.log_request_failure {#vault-audit-log_request_failure}","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of audit log request failures across all devices  The number of request failures is a crucial metric.  A non-zero value for vault.audit.log_request_failure indicates that all your configured audit devices failed to log a request (or response). If OpenBao cannot properly audit a request, or the response to a request, the original request will fail.  Refer to the OpenBao logs and any device-specific metrics to troubleshoot the failing audit log device.  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_request {#vault-audit-log_request}","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete all audit log requests across all audit log devices  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_response_failure {#vault-audit-log_response_failure}","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of audit log request failures across all devices  The number of request failures is a crucial metric.  A non-zero value for vault.audit.log_response_failure indicates that one of the configured audit log devices failed to respond to OpenBao. If OpenBao cannot properly audit a request, or the response to a request, the original request will fail.  Refer to the device-specific metrics and logs to troubleshoot the failing audit log device.  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_response {#vault-audit-log_response}","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete audit log responses across all audit log devices  ","version":"Next","tagName":"h3"},{"title":"Audit device metrics​","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/#audit-device-metrics","content":" Device-specific metrics for each enabled audit device. For example, if you enable a file audit device, the related metrics are:vault.audit.file.log_request and vault.audit.file.log_response.  ","version":"Next","tagName":"h2"},{"title":"vault.audit.{DEVICE}.log_request {#vault-audit-device-log_request}","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete all audit log requests across the device  ","version":"Next","tagName":"h3"},{"title":"vault.audit.{DEVICE}.log_response {#vault-audit-device-log_response}","type":1,"pageTitle":"Audit log telemetry","url":"/openbao/docs/internals/telemetry/metrics/audit/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete all audit log responses across the device ","version":"Next","tagName":"h3"},{"title":"Authentication telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/authn/","content":"","keywords":"","version":"Next"},{"title":"Identity metrics​","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/#identity-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.identity.entity.active.monthly {#vault-identity-entity-active-monthly}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of distinct entities (per namespace) that created a token during the past month  OpenBao reports vault.identity.entity.active.monthly at the start of each month when client counting is enabled.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.active.partial_month {#vault-identity-entity-active-partial_month}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of distinct entities (per namespace) that created a token during the current month  OpenBao reports vault.identity.entity.active.partial_month periodically during the month when client counting is enabled.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.active.reporting_period {#vault-identity-entity-active-reporting_period}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of distinct entities (per namespace) that created a token during the configured reporting period  OpenBao reports vault.identity.entity.active.reporting_period at the start of each month when client counting is enabled.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.alias.count {#vault-identity-entity-alias-count}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\taliases\tThe number of identity entities aliases (per authN mount) currently stored in OpenBao  OpenBao updates the alias count every usage_guage_period interval.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.count {#vault-identity-entity-count}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of identity entity aliases (per namespace) currently stored in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.creation {#vault-identity-entity-creation}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe number of identity entities created per namespace  ","version":"Next","tagName":"h3"},{"title":"vault.identity.num_entities {#vault-identity-num_entities}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe total number of identity entities currently stored in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.identity.upsert_entity_txn {#vault-identity-upsert_entity_txn}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to upsert an entity to the in-memory database and, on the active node, persist the data to storage  ","version":"Next","tagName":"h3"},{"title":"vault.identity.upsert_group_txn {#vault-identity-upsert_group_txn}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to upsert group membership to the in-memory database and, on the active node, persist the data to storage  ","version":"Next","tagName":"h3"},{"title":"Lease metrics​","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/#lease-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.expire.fetch-lease-times-by-token {#vault-expire-fetch_lease_times_by_token}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to retrieve lease times by token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.fetch-lease-times {#vault-expire-fetch_lease_times}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to retrieve lease times  ","version":"Next","tagName":"h3"},{"title":"vault.expire.job_manager.queue_length {#vault-expire-job_manager-queue_length}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tleases\tThe total number of pending revocation jobs by queue_id  The queue ID in the queue_id label indicates the mount accessor associated with the expiring lease. For example, the secrets engine or authentication method.  ","version":"Next","tagName":"h3"},{"title":"vault.expire.job_manager.total_jobs {#vault-expire-job_manager-total_jobs}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tleases\tThe total number of pending revocation jobs  ","version":"Next","tagName":"h3"},{"title":"vault.expire.lease_expiration {#vault-expire-lease_expiration}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe number of lease expirations to date  ","version":"Next","tagName":"h3"},{"title":"vault.expire.lease_expiration.error {#vault-expire-lease_expiration-error}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe total number of lease expiration errors  ","version":"Next","tagName":"h3"},{"title":"vault.expire.lease_expiration.time_in_queue {#vault-expire-lease_expiration-time_in_queue}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken for a lease to get to the front of the revoke queue  ","version":"Next","tagName":"h3"},{"title":"vault.expire.leases.by_expiration {#vault-expire-leases-by_expiration}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tleases\tThe number of leases set to expire, grouped by the configured interval  The relevant time intervals are defined in the telemetry stanza for your OpenBao server configuration with the following parameters:  lease_metrics_epsilon: 1 hour (default)num_lease_metrics_buckets: 168 hours (default)add_lease_metrics_namespace_labels: false (default)  OpenBao reports the number of leases due to expire every lease_metrics_epsiloninterval in the time period current_time + num_lease_metrics_buckets.  ","version":"Next","tagName":"h3"},{"title":"vault.expire.num_irrevocable_leases {#vault-expire-num_irrevocable_leases}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tleases\tThe number of leases that cannot be automatically revoked  ","version":"Next","tagName":"h3"},{"title":"vault.expire.num_leases {#vault-expire-num_leases}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tleases\tThe total number of leases eligible for eventual expiry  ","version":"Next","tagName":"h3"},{"title":"vault.expire.register-auth {#vault-expire-register_auth}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to register leases associated with new service tokens  ","version":"Next","tagName":"h3"},{"title":"vault.expire.register {#vault-expire-register}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken for register operations  ","version":"Next","tagName":"h3"},{"title":"vault.expire.renew-token {#vault-expire-renew_token}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to renew a token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.renew {#vault-expire-renew}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to renew a lease  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke-by-token {#vault-expire-revoke_by_token}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to revoke all secrets issued with a given token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke-force {#vault-expire-revoke_force}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to forcibly revoke a token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke-prefix {#vault-expire-revoke_prefix}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to revoke all tokens on a prefix  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke {#vault-expire-revoke}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to revoke a token  ","version":"Next","tagName":"h3"},{"title":"Token metrics​","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/#token-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.token.count {#vault-token-count}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of un-expired and un-revoked tokens available for use in the token store  OpenBao updates the token count every 10 minutes organizes the result by cluster and namespace.  ","version":"Next","tagName":"h3"},{"title":"vault.token.count.by_auth {#vault-token-count-by_auth}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of service tokens created by a particular auth method  OpenBao organizes the token count by cluster, namespace, and authentication method.  ","version":"Next","tagName":"h3"},{"title":"vault.token.count.by_policy {#vault-token-count-by_policy}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of service tokens with a particular policy attached  OpenBao organizes the token count by cluster, namespace, and policy. Tokens with more than one policy attached appear in the gauge for each associated policy.  ","version":"Next","tagName":"h3"},{"title":"vault.token.count.by_ttl {#vault-token-count-by_ttl}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of service tokens assigned a particular time to live (TTL)  OpenBao organizes the token count by cluster, namespace, and the TTL range assigned at creation.  ","version":"Next","tagName":"h3"},{"title":"vault.token.create_root {#vault-token-create_root}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of root tokens created  The vault.token.create_root counts the total number of root tokens created over time, not the number of root tokens currently in use. As a result, the value of vault.token.create_root does not decrease when a root token is revoked.  ","version":"Next","tagName":"h3"},{"title":"vault.token.create {#vault-token-create}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a token in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.createAccessor {#vault-token-createaccessor}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a token accessor in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.creation {#vault-token-creation}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of service or batch tokens created  OpenBao organizes the creation count by cluster, namespace, authentication method, mount point, time to live (TTL), and token type.  ","version":"Next","tagName":"h3"},{"title":"vault.token.lookup {#vault-token-lookup}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to look up a token in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.revoke-tree {#vault-token-revoke_tree}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fully revoke a token tree in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.revoke {#vault-token-revoke}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a token in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.store {#vault-token-store}","type":1,"pageTitle":"Authentication telemetry","url":"/openbao/docs/internals/telemetry/metrics/authn/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to store an updated token entry without writing to the secondary index ","version":"Next","tagName":"h3"},{"title":"Availability telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/availability/","content":"","keywords":"","version":"Next"},{"title":"Default metrics​","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/#default-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.ha.rpc.client.echo {#vault-ha-rpc-client-echo}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to send an echo request from a standby to the active node (also emitted by perf standbys)  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.echo.errors {#vault-ha-rpc-client-echo-errors}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of standby echo request failures (also emitted by perf standbys)  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.forward {#vault-ha-rpc-client-forward}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to forward a request from a standby to the active node  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.forward.errors {#vault-ha-rpc-client-forward-errors}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of standby request forwarding failures  ","version":"Next","tagName":"h3"},{"title":"Merkle tree metrics​","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/#merkle-tree-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.merkle.flushDirty {#vault-merkle-flushdirty}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tThe average time required to flush dirty pages to storage  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.flushDirty.num_pages {#vault-merkle-flushdirty-num_pages}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tpages\tNumber of pages flushed  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.flushDirty.outstanding_pages {#vault-merkle-flushdirty-outstanding_pages}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tpages\tNumber of dirty pages waiting to be flushed  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.saveCheckpoint {#vault-merkle-savecheckpoint}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tThe average time required to save a checkpoint  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.saveCheckpoint.num_dirty {#vault-merkle-savecheckpoint-num_dirty}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tpages\tNumber of dirty pages at checkpoint  ","version":"Next","tagName":"h3"},{"title":"Write-ahead log (WAL) telemetry​","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/#write-ahead-log-wal-telemetry","content":" ","version":"Next","tagName":"h2"},{"title":"vault.wal.deleteWALs {#vault-wal-deletewals}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fully delete a write-ahead log  ","version":"Next","tagName":"h3"},{"title":"vault.wal.flushReady {#vault-wal-flushready}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fully flush a write-ahead log that is ready for storage  ","version":"Next","tagName":"h3"},{"title":"vault.wal.flushReady.queue_len {#vault-wal-flushready-queue_len}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tCurrent size of the write queue in the WAL system  ","version":"Next","tagName":"h3"},{"title":"vault.wal.gc.deleted {#vault-wal-gc-deleted}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of write-ahead logs deleted during garbage collection  ","version":"Next","tagName":"h3"},{"title":"vault.wal.gc.total {#vault-wal-gc-total}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of write-ahead logs currently on disk  ","version":"Next","tagName":"h3"},{"title":"vault.wal.loadWAL {#vault-wal-loadwal}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to load a write-ahead log  ","version":"Next","tagName":"h3"},{"title":"vault.wal.persistWALs {#vault-wal-persistwals}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to persist a write-ahead log  ","version":"Next","tagName":"h3"},{"title":"Log shipping metrics​","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/#log-shipping-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.logshipper.buffer.length {#vault-logshipper-buffer-length}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tbuffer entries\tCurrent length of the log shipper buffer  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.max_length {#vault-logshipper-buffer-max_length}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tbuffer entries\tMaximum length of the log shipper buffer seen to date  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.max_size {#vault-logshipper-buffer-max_size}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tMaximum allowable size of the log shipper buffer  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.size {#vault-logshipper-buffer-size}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tCurrent size of the log shipper buffer  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.streamWALs.guard_found {#vault-logshipper-streamwals-guard_found}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times OpenBao began streaming WAL entires and found a starting index in the merkle tree  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.streamWALs.missing_guard {#vault-logshipper-streamwals-missing_guard}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times OpenBao began streaming WAL entires without finding a starting index in the Merkle tree  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.streamWALs.scanned_entries {#vault-logshipper-streamwals-scanned_entries}","type":1,"pageTitle":"Availability telemetry","url":"/openbao/docs/internals/telemetry/metrics/availability/##","content":" Metric type\tValue\tDescriptionsummary\tentries\tNumber of entries scanned in the buffer before OpenBao found the correct entry ","version":"Next","tagName":"h3"},{"title":"Core system telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/core-system/","content":"","keywords":"","version":"Next"},{"title":"Default metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#default-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.core.active {#vault-core-active}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether the OpenBao node is active  A value of 1 indicates that the node is active.A value of 0 indicates that the node is in standby.  ","version":"Next","tagName":"h3"},{"title":"vault.core.activity.fragment_size {#vault-core-activity-fragment_size}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of type objects observed by the local node  The fragment size metric includes labels to indicate if the objects counted were entities or tokens.  ","version":"Next","tagName":"h3"},{"title":"vault.core.activity.segment_write {#vault-core-activity-segment_write}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to write activity log segments to storage  ","version":"Next","tagName":"h3"},{"title":"vault.core.check_token {#vault-core-check_token}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a token check  ","version":"Next","tagName":"h3"},{"title":"vault.core.fetch_acl_and_token {#vault-core-fetch_acl_and_token}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fetch ACL and token entries  ","version":"Next","tagName":"h3"},{"title":"vault.core.handle_login_request {#vault-core-handle_login_request}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a login request  ","version":"Next","tagName":"h3"},{"title":"vault.core.handle_request {#vault-core-handle_request}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a non-login request  ","version":"Next","tagName":"h3"},{"title":"vault.core.in_flight_requests {#vault-core-in_flight_requests}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\trequests\tNumber of requests currently in progress  ","version":"Next","tagName":"h3"},{"title":"vault.core.leadership_lost {#vault-core-leadership_lost}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTotal time that a high-availability cluster node last maintained leadership  Leadership time updates occur whenever leadership changes. Frequent updates tovault.core.leadership_lost with low leadership times indicates flapping as leader status rotates between nodes.  ","version":"Next","tagName":"h3"},{"title":"vault.core.leadership_setup_failed {#vault-core-leadership_setup_failed}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken by the most recent leadership setup failure  Setup failure time is an important health metric for your high-availability OpenBao installation. We strongly recommend that you closely monitorvault.core.leadership_setup_failed and set alerts that keep you informed of the overall cluster leadership status.  ","version":"Next","tagName":"h3"},{"title":"vault.core.license.expiration_time_epoch {#vault-core-license-expiration_time_epoch}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\ttimestamp\tEpoch time (seconds since 1970-01-01) at which the license will expire  ","version":"Next","tagName":"h3"},{"title":"vault.core.locked_users {#vault-core-locked_users}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tusers\tThe number of users currently locked out of OpenBao  The number of locked users refreshes every 15 minutes.  ","version":"Next","tagName":"h3"},{"title":"vault.core.mount_table.num_entries {#vault-core-mount_table-num_entries}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tobjects\tNumber of mounts in the given mount table  Mountpoint count metrics include labels to indicate whether the relevant table is an authentication table or a logical table and whether the table is replicated or local.  ","version":"Next","tagName":"h3"},{"title":"vault.core.mount_table.size {#vault-core-mount_table-size}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tThe current size of the relevant mount table.  Table size metrics include labels to indicate whether the relevant table is an authentication table or a logical table and whether the table is replicated or local.  ","version":"Next","tagName":"h3"},{"title":"vault.core.post_unseal {#vault-core-post_unseal}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete post-unseal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.pre_seal {#vault-core-pre_seal}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete pre-seal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.seal-internal {#vault-core-seal_internal}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete internal OpenBao seal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.seal-with-request {#vault-core-seal_with_request}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete seal operations that were triggered by explicit request  ","version":"Next","tagName":"h3"},{"title":"vault.core.step_down {#vault-core-step_down}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to step down cluster leadership  ","version":"Next","tagName":"h3"},{"title":"vault.core.unseal {#vault-core-unseal}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete unseal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.unsealed {#vault-core-unsealed}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether OpenBao is currently unsealed  A value of 1 indicates OpenBao is currently unsealed and clients canread secrets.A value of 0 indicates OpenBao is currently sealed and clients cannotread secrets.  ","version":"Next","tagName":"h3"},{"title":"Barrier metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#barrier-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.barrier.delete {#vault-barrier-delete}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a DELETE operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.get {#vault-barrier-get}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a GET operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.list {#vault-barrier-list}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a LIST operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.put {#vault-barrier-put}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a PUT operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"Caching metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#caching-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.cache.delete {#vault-cache-delete}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of deletes from the LRU cache  ","version":"Next","tagName":"h3"},{"title":"vault.cache.hit {#vault-cache-hit}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of hits against the LRU cache that avoided a read from configured storage  ","version":"Next","tagName":"h3"},{"title":"vault.cache.miss {#vault-cache-miss}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of misses against the LRU cache that required a read from configured storage  ","version":"Next","tagName":"h3"},{"title":"vault.cache.write {#vault-cache-write}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of writes to the LRU cache  ","version":"Next","tagName":"h3"},{"title":"Metric collection metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#metric-collection-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.metrics.collection {#vault-metrics-collection}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tThe average time required (per gauge type) to collect usage data  ","version":"Next","tagName":"h3"},{"title":"vault.metrics.collection.error {#vault-metrics-collection-error}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe total number of errors (per gauge type) that OpenBao encountered while collecting usage data  ","version":"Next","tagName":"h3"},{"title":"vault.metrics.collection.interval {#vault-metrics-collection-interval}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tUnits\tDescriptionsummary\ttime duration\tThe current value of usage_gauge_period  ","version":"Next","tagName":"h3"},{"title":"Quota metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#quota-metrics","content":" Quota metrics relate to rate limit and lease count quotas. Each metric comes with a name label that identifies the specific quota.  ","version":"Next","tagName":"h2"},{"title":"vault.quota.lease_count.counter {#vault-quota-lease_count-counter}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tlease\tTotal number of leases associated with the named quota rule  The number of leases reported is specific to the quota rule listed in the namelabel, not the number of leases in general. For example, if the named rule allows for 50 leases max and there are currently 40 leases in the scope of that quota rule, the value of vault.quota.lease_count.counter is 40 even if there are 1000 other leases that are unscoped or in the scope of other quota rules.  ","version":"Next","tagName":"h3"},{"title":"vault.quota.lease_count.max {#vault-quota-lease_count-max}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tlease\tMaximum number of leases allowed by the named quota rule  ","version":"Next","tagName":"h3"},{"title":"vault.quota.lease_count.violation {#vault-quota-lease_count-violation}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of requests rejected due to exceeding the named lease count quota  ","version":"Next","tagName":"h3"},{"title":"vault.quota.rate_limit.violation {#vault-quota-rate_limit-violation}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of requests rejected due to exceeding the named rate limit quota rule  ","version":"Next","tagName":"h3"},{"title":"Rollback metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#rollback-metrics","content":" Rollback metrics for each configured mount point. Metric names convert forward slashes (/) in mount names to dashes (-). For example, if you have the auth/token backend configured, the corresponding mount point metric string is auth-token  ","version":"Next","tagName":"h2"},{"title":"vault.rollback.attempt.{MOUNTPOINT} {#vault-rollback-attempt-mountpoint}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to perform a rollback operation on the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.inflight {#vault-rollback-inflight}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of rollback operations inflight  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.queued {#vault-rollback-queued}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionguage\tnumber\tThe number of rollback operations waiting to be started  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.waiting {#vault-rollback-waiting}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime between queueing a rollback operation and the operation starting  ","version":"Next","tagName":"h3"},{"title":"Route metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#route-metrics","content":" Mount-specific route metrics for each configured mount point. Metric names convert forward slashes (/) in mount names to dashes (-). For example, if you have the auth/token backend configured, the corresponding mount point metric string is auth-token  ","version":"Next","tagName":"h2"},{"title":"vault.route.create.{MOUNTPOINT} {#vault-route-create-mountpoint}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a create request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.delete.{MOUNTPOINT} {#vault-route-delete-mountpoint}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a delete request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.list.{MOUNTPOINT} {#vault-route-list-mountpoint}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a list request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.read.{MOUNTPOINT} {#vault-route-read-mountpoint}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a read request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.rollback.{MOUNTPOINT} {#vault-route-rollback-mountpoint}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a rollback request to the backend and for the backend to complete the operation for the given mount point  OpenBao automatically schedules and performs mount point rollback operations to clean up partial errors.  ","version":"Next","tagName":"h3"},{"title":"Runtime metrics​","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/#runtime-metrics","content":" Runtime metrics relate specifically to the Go runtime for your OpenBao instance.  ","version":"Next","tagName":"h2"},{"title":"vault.runtime.alloc_bytes {#vault-runtime-alloc_bytes}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tSpace currently allocated to OpenBao processes  The number of allocated bytes may peak from time to time, but should always return to a steady state value in a health OpenBao installation.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.free_count {#vault-runtime-free_count}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of freed objects  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.gc_pause_ns {#vault-runtime-gc_pause_ns}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptionsummary\tns\tTime required to complete the last garbage collection run  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.heap_objects {#vault-runtime-heap_objects}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of objects on the heap in memory  The vault.runtime.heap_objects metric is a good memory pressure indicator. We recommend monitoring vault.runtime.heap_objects to establish an accurate baseline and thresholds for alerting on the health of your OpenBao installation.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.malloc_count {#vault-runtime-malloc_count}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of allocated heap objects in memory  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.num_goroutines {#vault-runtime-num_goroutines}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of Go routines running in memory  The vault.runtime.num_goroutines metric is a good system load indicator. We recommend monitoring vault.runtime.num_goroutines to establish an accurate baseline and thresholds for alerting on the health of your OpenBao installation.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.sys_bytes {#vault-runtime-sys_bytes}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of bytes allocated to OpenBao  The total number of allocated system bytes includes space currently used by the heap plus space that has been reclaimed by, but not returned to, the operating system.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.total_gc_pause_ns {#vault-runtime-total_gc_pause_ns}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tns\tThe total garbage collector pause time since OpenBao was last started  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.total_gc_runs {#vault-runtime-total_gc_runs}","type":1,"pageTitle":"Core system telemetry","url":"/openbao/docs/internals/telemetry/metrics/core-system/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tThe total number of garbage collection runs since OpenBao was last started ","version":"Next","tagName":"h3"},{"title":"Database telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/database/","content":"","keywords":"","version":"Next"},{"title":"Secrets database metrics​","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/#secrets-database-metrics","content":" Metrics related to your configured secrets engines, including database-specific metrics for each named secrets engine. For example, if you enable a PostgreSQL secrets engine called postgresql-prod, the relatedCreateUser.error metric is database.postgresql-prod.CreateUser.error.  ","version":"Next","tagName":"h2"},{"title":"database.Close {#database-close}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to close a database secret engine (across all database secrets engines)  ","version":"Next","tagName":"h3"},{"title":"database.Close.error {#database-close-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while closing database connections  ","version":"Next","tagName":"h3"},{"title":"database.CreateUser {#database-createuser}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.CreateUser.error {#database-createuser-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while creating users  ","version":"Next","tagName":"h3"},{"title":"database.Initialize {#database-initialize}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to initialize a database secret engine (across all database secrets engines)  ","version":"Next","tagName":"h3"},{"title":"database.Initialize.error {#database-initialize-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while initializing the database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Close {#database-name-close}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to close the database secrets engine {NAME}  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Close.error {#database-name-close-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while closing database connections  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.CreateUser {#database-name-createuser}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.CreateUser.error {#database-name-createuser-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while creating users  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Initialize {#database-name-initialize}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to initialize a database secret engine for the named database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Initialize.error {#database-name-initialize-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while initializing the database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RenewUser {#database-name-renewuser}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to renew a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RenewUser.error {#database-name-renewuser-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while renewing users  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RevokeUser {#database-name-revokeuser}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RevokeUser.error {#database-name-revokeuser-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while revoking users  ","version":"Next","tagName":"h3"},{"title":"database.RenewUser {#database-renewuser}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to renew a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.RenewUser.error {#database-renewuser-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while renewing users  ","version":"Next","tagName":"h3"},{"title":"database.RevokeUser {#database-revokeuser}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.RevokeUser.error {#database-revokeuser-error}","type":1,"pageTitle":"Database telemetry","url":"/openbao/docs/internals/telemetry/metrics/database/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while revoking users ","version":"Next","tagName":"h3"},{"title":"Policy telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/policy/","content":"","keywords":"","version":"Next"},{"title":"Default metrics​","type":1,"pageTitle":"Policy telemetry","url":"/openbao/docs/internals/telemetry/metrics/policy/#default-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.policy.delete_policy {#vault-policy-delete_policy}","type":1,"pageTitle":"Policy telemetry","url":"/openbao/docs/internals/telemetry/metrics/policy/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to delete a policy  ","version":"Next","tagName":"h3"},{"title":"vault.policy.get_policy {#vault-policy-get_policy}","type":1,"pageTitle":"Policy telemetry","url":"/openbao/docs/internals/telemetry/metrics/policy/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to read a policy  ","version":"Next","tagName":"h3"},{"title":"vault.policy.list_policies {#vault-policy-list_policies}","type":1,"pageTitle":"Policy telemetry","url":"/openbao/docs/internals/telemetry/metrics/policy/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to list all policies  ","version":"Next","tagName":"h3"},{"title":"vault.policy.set_policy {#vault-policy-set_policy}","type":1,"pageTitle":"Policy telemetry","url":"/openbao/docs/internals/telemetry/metrics/policy/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to set a policy ","version":"Next","tagName":"h3"},{"title":"All OpenBao telemetry metrics","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/all/","content":"","keywords":"","version":"Next"},{"title":"Full metric list​","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/#full-metric-list","content":" ","version":"Next","tagName":"h2"},{"title":"database.Close {#database-close}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to close a database secret engine (across all database secrets engines)  ","version":"Next","tagName":"h3"},{"title":"database.Close.error {#database-close-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while closing database connections  ","version":"Next","tagName":"h3"},{"title":"database.CreateUser {#database-createuser}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.CreateUser.error {#database-createuser-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while creating users  ","version":"Next","tagName":"h3"},{"title":"database.Initialize {#database-initialize}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to initialize a database secret engine (across all database secrets engines)  ","version":"Next","tagName":"h3"},{"title":"database.Initialize.error {#database-initialize-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while initializing the database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Close {#database-name-close}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to close the database secrets engine {NAME}  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Close.error {#database-name-close-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while closing database connections  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.CreateUser {#database-name-createuser}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.CreateUser.error {#database-name-createuser-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while creating users  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Initialize {#database-name-initialize}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to initialize a database secret engine for the named database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Initialize.error {#database-name-initialize-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while initializing the database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RenewUser {#database-name-renewuser}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to renew a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RenewUser.error {#database-name-renewuser-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while renewing users  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RevokeUser {#database-name-revokeuser}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RevokeUser.error {#database-name-revokeuser-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while revoking users  ","version":"Next","tagName":"h3"},{"title":"database.RenewUser {#database-renewuser}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to renew a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.RenewUser.error {#database-renewuser-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while renewing users  ","version":"Next","tagName":"h3"},{"title":"database.RevokeUser {#database-revokeuser}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.RevokeUser.error {#database-revokeuser-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while revoking users  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_current_entry {#secrets-pki-tidy-cert_store_current_entry}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tIndex of the certificate store entry currently being verified by the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_deleted_count {#secrets-pki-tidy-cert_store_deleted_count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of entries deleted from the certificate store  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_total_entries_remaining {#secrets-pki-tidy-cert_store_total_entries_remaining}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in the certificate store checked, but not removed, during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_total_entries {#secrets-pki-tidy-cert_store_total_entries}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in the certificate store to verify during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.duration {#secrets-pki-tidy-duration}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete the PKI tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.failure {#secrets-pki-tidy-failure}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the PKI tidy operation failed to finish due to errors  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_current_entry {#secrets-pki-tidy-revoked_cert_current_entry}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tIndex of the revoked certificate store entry currently being verified by the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_deleted_count {#secrets-pki-tidy-revoked_cert_deleted_count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of entries deleted from the certificate store for revoked certificates  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries_fixed_issuers {#secrets-pki-tidy-revoked_cert_total_entries_fixed_issuers}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in the certificate store found to have incorrect issuer information that were fixed during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries_incorrect_issuers {#secrets-pki-tidy-revoked_cert_total_entries_incorrect_issuers}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of entries in the certificate store found to have incorrect issuer information  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries_remaining {#secrets-pki-tidy-revoked_cert_total_entries_remaining}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of revoked certificates in the certificate store checked, but not removed, during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries {#secrets-pki-tidy-revoked_cert_total_entries}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of revoked certificate entries in the certificate store to be verified during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.start_time_epoch {#secrets-pki-tidy-start_time_epoch}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tseconds\tEpoch time (seconds since 1970-01-01) when the PKI tidy operation began  The start time metric reports a value of 0 if the PKI tidy operation is not currently active.  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.success {#secrets-pki-tidy-success}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the PKI tidy operation completed successfully  ","version":"Next","tagName":"h3"},{"title":"vault.audit.{DEVICE}.log_request_failure {#vault-audit-device-log_request_failure}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of audit log request failures  ","version":"Next","tagName":"h3"},{"title":"vault.audit.{DEVICE}.log_request {#vault-audit-device-log_request}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete all audit log requests across the device  ","version":"Next","tagName":"h3"},{"title":"vault.audit.{DEVICE}.log_response_failure {#vault-audit-device-log_response_failure}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of audit log request failures  ","version":"Next","tagName":"h3"},{"title":"vault.audit.{DEVICE}.log_response {#vault-audit-device-log_response}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete all audit log responses across the device  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_request_failure {#vault-audit-log_request_failure}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of audit log request failures across all devices  The number of request failures is a crucial metric.  A non-zero value for vault.audit.log_request_failure indicates that all your configured audit devices failed to log a request (or response). If OpenBao cannot properly audit a request, or the response to a request, the original request will fail.  Refer to the OpenBao logs and any device-specific metrics to troubleshoot the failing audit log device.  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_request {#vault-audit-log_request}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete all audit log requests across all audit log devices  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_response_failure {#vault-audit-log_response_failure}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of audit log request failures across all devices  The number of request failures is a crucial metric.  A non-zero value for vault.audit.log_response_failure indicates that one of the configured audit log devices failed to respond to OpenBao. If OpenBao cannot properly audit a request, or the response to a request, the original request will fail.  Refer to the device-specific metrics and logs to troubleshoot the failing audit log device.  ","version":"Next","tagName":"h3"},{"title":"vault.audit.log_response {#vault-audit-log_response}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete audit log responses across all audit log devices  ","version":"Next","tagName":"h3"},{"title":"vault.autopilot.failure_tolerance {#vault-autopilot-failure_tolerance}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnodes\tThe number of healthy nodes in excess of quorum  The failure tolerance indicates how many currently healthy nodes can fail without losing quorum.  ","version":"Next","tagName":"h3"},{"title":"vault.autopilot.healthy {#vault-autopilot-healthy}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether all nodes are healthy  A value of 1 on the gauge means that Autopilot deems all nodes healthy.A value of 0 on the gauge means that Autopilot deems at least 1 node unhealthy.  ","version":"Next","tagName":"h3"},{"title":"vault.autopilot.node.healthy {#vault-autopilot-node-healthy}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether the active node is healthy  A value of 1 on the gauge means that Autopilot deems the node indicated bynode_id is healthy.A value of 0 on the gauge means that Autopilot cannot communicate with the node indicated by node_id, or deems the node unhealthy.  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.delete {#vault-barrier-delete}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a DELETE operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.get {#vault-barrier-get}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a GET operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.list {#vault-barrier-list}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a LIST operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.put {#vault-barrier-put}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a PUT operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.cache.delete {#vault-cache-delete}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of deletes from the LRU cache  ","version":"Next","tagName":"h3"},{"title":"vault.cache.hit {#vault-cache-hit}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of hits against the LRU cache that avoided a read from configured storage  ","version":"Next","tagName":"h3"},{"title":"vault.cache.miss {#vault-cache-miss}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of misses against the LRU cache that required a read from configured storage  ","version":"Next","tagName":"h3"},{"title":"vault.cache.write {#vault-cache-write}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of writes to the LRU cache  ","version":"Next","tagName":"h3"},{"title":"vault.core.active {#vault-core-active}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether the OpenBao node is active  A value of 1 indicates that the node is active.A value of 0 indicates that the node is in standby.  ","version":"Next","tagName":"h3"},{"title":"vault.core.activity.fragment_size {#vault-core-activity-fragment_size}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of type objects observed by the local node  The fragment size metric includes labels to indicate if the objects counted were entities or tokens.  ","version":"Next","tagName":"h3"},{"title":"vault.core.activity.segment_write {#vault-core-activity-segment_write}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to write activity log segments to storage  ","version":"Next","tagName":"h3"},{"title":"vault.core.check_token {#vault-core-check_token}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a token check  ","version":"Next","tagName":"h3"},{"title":"vault.core.fetch_acl_and_token {#vault-core-fetch_acl_and_token}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fetch ACL and token entries  ","version":"Next","tagName":"h3"},{"title":"vault.core.handle_login_request {#vault-core-handle_login_request}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a login request  ","version":"Next","tagName":"h3"},{"title":"vault.core.handle_request {#vault-core-handle_request}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a non-login request  ","version":"Next","tagName":"h3"},{"title":"vault.core.in_flight_requests {#vault-core-in_flight_requests}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\trequests\tNumber of requests currently in progress  ","version":"Next","tagName":"h3"},{"title":"vault.core.leadership_lost {#vault-core-leadership_lost}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTotal time that a high-availability cluster node last maintained leadership  Leadership time updates occur whenever leadership changes. Frequent updates tovault.core.leadership_lost with low leadership times indicates flapping as leader status rotates between nodes.  ","version":"Next","tagName":"h3"},{"title":"vault.core.leadership_setup_failed {#vault-core-leadership_setup_failed}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken by the most recent leadership setup failure  Setup failure time is an important health metric for your high-availability OpenBao installation. We strongly recommend that you closely monitorvault.core.leadership_setup_failed and set alerts that keep you informed of the overall cluster leadership status.  ","version":"Next","tagName":"h3"},{"title":"vault.core.license.expiration_time_epoch {#vault-core-license-expiration_time_epoch}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\ttimestamp\tEpoch time (seconds since 1970-01-01) at which the license will expire  ","version":"Next","tagName":"h3"},{"title":"vault.core.locked_users {#vault-core-locked_users}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tusers\tThe number of users currently locked out of OpenBao  The number of locked users refreshes every 15 minutes.  ","version":"Next","tagName":"h3"},{"title":"vault.core.mount_table.num_entries {#vault-core-mount_table-num_entries}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tobjects\tNumber of mounts in the given mount table  Mountpoint count metrics include labels to indicate whether the relevant table is an authentication table or a logical table and whether the table is replicated or local.  ","version":"Next","tagName":"h3"},{"title":"vault.core.mount_table.size {#vault-core-mount_table-size}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tThe current size of the relevant mount table.  Table size metrics include labels to indicate whether the relevant table is an authentication table or a logical table and whether the table is replicated or local.  ","version":"Next","tagName":"h3"},{"title":"vault.core.post_unseal {#vault-core-post_unseal}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete post-unseal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.pre_seal {#vault-core-pre_seal}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete pre-seal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.seal-internal {#vault-core-seal_internal}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete internal OpenBao seal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.seal-with-request {#vault-core-seal_with_request}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete seal operations that were triggered by explicit request  ","version":"Next","tagName":"h3"},{"title":"vault.core.step_down {#vault-core-step_down}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to step down cluster leadership  ","version":"Next","tagName":"h3"},{"title":"vault.core.unseal {#vault-core-unseal}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete unseal operations  ","version":"Next","tagName":"h3"},{"title":"vault.core.unsealed {#vault-core-unsealed}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether OpenBao is currently unsealed  A value of 1 indicates OpenBao is currently unsealed and clients canread secrets.A value of 0 indicates OpenBao is currently sealed and clients cannotread secrets.  ","version":"Next","tagName":"h3"},{"title":"vault.expire.fetch-lease-times-by-token {#vault-expire-fetch_lease_times_by_token}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to retrieve lease times by token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.fetch-lease-times {#vault-expire-fetch_lease_times}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to retrieve lease times  ","version":"Next","tagName":"h3"},{"title":"vault.expire.job_manager.queue_length {#vault-expire-job_manager-queue_length}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tleases\tThe total number of pending revocation jobs by queue_id  The queue ID in the queue_id label indicates the mount accessor associated with the expiring lease. For example, the secrets engine or authentication method.  ","version":"Next","tagName":"h3"},{"title":"vault.expire.job_manager.total_jobs {#vault-expire-job_manager-total_jobs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tleases\tThe total number of pending revocation jobs  ","version":"Next","tagName":"h3"},{"title":"vault.expire.lease_expiration {#vault-expire-lease_expiration}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe number of lease expirations to date  ","version":"Next","tagName":"h3"},{"title":"vault.expire.lease_expiration.error {#vault-expire-lease_expiration-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe total number of lease expiration errors  ","version":"Next","tagName":"h3"},{"title":"vault.expire.lease_expiration.time_in_queue {#vault-expire-lease_expiration-time_in_queue}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken for a lease to get to the front of the revoke queue  ","version":"Next","tagName":"h3"},{"title":"vault.expire.leases.by_expiration {#vault-expire-leases-by_expiration}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tleases\tThe number of leases set to expire, grouped by the configured interval  The relevant time intervals are defined in the telemetry stanza for your OpenBao server configuration with the following parameters:  lease_metrics_epsilon: 1 hour (default)num_lease_metrics_buckets: 168 hours (default)add_lease_metrics_namespace_labels: false (default)  OpenBao reports the number of leases due to expire every lease_metrics_epsiloninterval in the time period current_time + num_lease_metrics_buckets.  ","version":"Next","tagName":"h3"},{"title":"vault.expire.num_irrevocable_leases {#vault-expire-num_irrevocable_leases}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tleases\tThe number of leases that cannot be automatically revoked  ","version":"Next","tagName":"h3"},{"title":"vault.expire.num_leases {#vault-expire-num_leases}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tleases\tThe total number of leases eligible for eventual expiry  ","version":"Next","tagName":"h3"},{"title":"vault.expire.register-auth {#vault-expire-register_auth}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to register leases associated with new service tokens  ","version":"Next","tagName":"h3"},{"title":"vault.expire.register {#vault-expire-register}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken for register operations  ","version":"Next","tagName":"h3"},{"title":"vault.expire.renew-token {#vault-expire-renew_token}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to renew a token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.renew {#vault-expire-renew}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to renew a lease  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke-by-token {#vault-expire-revoke_by_token}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to revoke all secrets issued with a given token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke-force {#vault-expire-revoke_force}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to forcibly revoke a token  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke-prefix {#vault-expire-revoke_prefix}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to revoke all tokens on a prefix  ","version":"Next","tagName":"h3"},{"title":"vault.expire.revoke {#vault-expire-revoke}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to revoke a token  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.echo {#vault-ha-rpc-client-echo}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to send an echo request from a standby to the active node (also emitted by perf standbys)  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.echo.errors {#vault-ha-rpc-client-echo-errors}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of standby echo request failures (also emitted by perf standbys)  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.forward {#vault-ha-rpc-client-forward}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime taken to forward a request from a standby to the active node  ","version":"Next","tagName":"h3"},{"title":"vault.ha.rpc.client.forward.errors {#vault-ha-rpc-client-forward-errors}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of standby request forwarding failures  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.active.monthly {#vault-identity-entity-active-monthly}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of distinct entities (per namespace) that created a token during the past month  OpenBao reports vault.identity.entity.active.monthly at the start of each month when client counting is enabled.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.active.partial_month {#vault-identity-entity-active-partial_month}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of distinct entities (per namespace) that created a token during the current month  OpenBao reports vault.identity.entity.active.partial_month periodically during the month when client counting is enabled.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.active.reporting_period {#vault-identity-entity-active-reporting_period}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of distinct entities (per namespace) that created a token during the configured reporting period  OpenBao reports vault.identity.entity.active.reporting_period at the start of each month when client counting is enabled.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.alias.count {#vault-identity-entity-alias-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\taliases\tThe number of identity entities aliases (per authN mount) currently stored in OpenBao  OpenBao updates the alias count every usage_guage_period interval.  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.count {#vault-identity-entity-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe number of identity entity aliases (per namespace) currently stored in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.identity.entity.creation {#vault-identity-entity-creation}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe number of identity entities created per namespace  ","version":"Next","tagName":"h3"},{"title":"vault.identity.num_entities {#vault-identity-num_entities}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tentities\tThe total number of identity entities currently stored in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.identity.upsert_entity_txn {#vault-identity-upsert_entity_txn}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to upsert an entity to the in-memory database and, on the active node, persist the data to storage  ","version":"Next","tagName":"h3"},{"title":"vault.identity.upsert_group_txn {#vault-identity-upsert_group_txn}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to upsert group membership to the in-memory database and, on the active node, persist the data to storage  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.length {#vault-logshipper-buffer-length}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbuffer entries\tCurrent length of the log shipper buffer  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.max_length {#vault-logshipper-buffer-max_length}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbuffer entries\tMaximum length of the log shipper buffer seen to date  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.max_size {#vault-logshipper-buffer-max_size}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tMaximum allowable size of the log shipper buffer  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.buffer.size {#vault-logshipper-buffer-size}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tCurrent size of the log shipper buffer  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.streamWALs.guard_found {#vault-logshipper-streamwals-guard_found}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times OpenBao began streaming WAL entires and found a starting index in the merkle tree  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.streamWALs.missing_guard {#vault-logshipper-streamwals-missing_guard}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times OpenBao began streaming WAL entires without finding a starting index in the Merkle tree  ","version":"Next","tagName":"h3"},{"title":"vault.logshipper.streamWALs.scanned_entries {#vault-logshipper-streamwals-scanned_entries}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tentries\tNumber of entries scanned in the buffer before OpenBao found the correct entry  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.flushDirty {#vault-merkle-flushdirty}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tThe average time required to flush dirty pages to storage  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.flushDirty.num_pages {#vault-merkle-flushdirty-num_pages}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tpages\tNumber of pages flushed  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.flushDirty.outstanding_pages {#vault-merkle-flushdirty-outstanding_pages}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tpages\tNumber of dirty pages waiting to be flushed  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.saveCheckpoint {#vault-merkle-savecheckpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tThe average time required to save a checkpoint  ","version":"Next","tagName":"h3"},{"title":"vault.merkle.saveCheckpoint.num_dirty {#vault-merkle-savecheckpoint-num_dirty}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tpages\tNumber of dirty pages at checkpoint  ","version":"Next","tagName":"h3"},{"title":"vault.metrics.collection {#vault-metrics-collection}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tThe average time required (per gauge type) to collect usage data  ","version":"Next","tagName":"h3"},{"title":"vault.metrics.collection.error {#vault-metrics-collection-error}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe total number of errors (per gauge type) that OpenBao encountered while collecting usage data  ","version":"Next","tagName":"h3"},{"title":"vault.metrics.collection.interval {#vault-metrics-collection-interval}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tUnits\tDescriptionsummary\ttime duration\tThe current value of usage_gauge_period  ","version":"Next","tagName":"h3"},{"title":"vault.policy.delete_policy {#vault-policy-delete_policy}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to delete a policy  ","version":"Next","tagName":"h3"},{"title":"vault.policy.get_policy {#vault-policy-get_policy}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to read a policy  ","version":"Next","tagName":"h3"},{"title":"vault.policy.list_policies {#vault-policy-list_policies}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to list all policies  ","version":"Next","tagName":"h3"},{"title":"vault.policy.set_policy {#vault-policy-set_policy}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to set a policy  ","version":"Next","tagName":"h3"},{"title":"vault.quota.lease_count.counter {#vault-quota-lease_count-counter}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tlease\tTotal number of leases associated with the named quota rule  The number of leases reported is specific to the quota rule listed in the namelabel, not the number of leases in general. For example, if the named rule allows for 50 leases max and there are currently 40 leases in the scope of that quota rule, the value of vault.quota.lease_count.counter is 40 even if there are 1000 other leases that are unscoped or in the scope of other quota rules.  ","version":"Next","tagName":"h3"},{"title":"vault.quota.lease_count.max {#vault-quota-lease_count-max}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tlease\tMaximum number of leases allowed by the named quota rule  ","version":"Next","tagName":"h3"},{"title":"vault.quota.lease_count.violation {#vault-quota-lease_count-violation}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of requests rejected due to exceeding the named lease count quota  ","version":"Next","tagName":"h3"},{"title":"vault.quota.rate_limit.violation {#vault-quota-rate_limit-violation}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of requests rejected due to exceeding the named rate limit quota rule  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.cursor.count {#vault-raft_storage-bolt-cursor-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of cursors created in the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.allocated_bytes {#vault-raft_storage-bolt-freelist-allocated_bytes}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tTotal space allocated for the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.free_pages {#vault-raft_storage-bolt-freelist-free_pages}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of free pages in the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.pending_pages {#vault-raft_storage-bolt-freelist-pending_pages}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of pending pages in the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.used_bytes {#vault-raft_storage-bolt-freelist-used_bytes}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tTotal space used by the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.node.count {#vault-raft_storage-bolt-node-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of node allocations for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.node.dereferences {#vault-raft_storage-bolt-node-dereferences}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of node dereferences by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.page.bytes_allocated {#vault-raft_storage-bolt-page-bytes_allocated}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tTotal space allocated to the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.page.count {#vault-raft_storage-bolt-page-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of page allocations in the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.rebalance.count {#vault-raft_storage-bolt-rebalance-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of node rebalances performed by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.rebalance.time {#vault-raft_storage-bolt-rebalance-time}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the Bolt database to rebalance nodes  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.spill.count {#vault-raft_storage-bolt-spill-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of nodes spilled by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.spill.time {#vault-raft_storage-bolt-spill-time}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTotal time spent spilling by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.split.count {#vault-raft_storage-bolt-split-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of nodes split by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.transaction.currently_open_read_transactions {#vault-raft_storage-bolt-transaction-currently_open_read_transactions}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of in-process read transactions for the Bolt DB  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.transaction.started_read_transactions {#vault-raft_storage-bolt-transaction-started_read_transactions}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of read transactions started by the Bolt DB  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.write.count {#vault-raft_storage-bolt-write-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of writes performed by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.write.time {#vault-raft_storage-bolt-write-time}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tms\tTotal cumulative time the Bolt database has spent writing to disk.  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.follower.applied_index_delta {#vault-raft_storage-follower-applied_index_delta}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tThe difference between the index applied by the leader and the index applied by the follower as reported by echoes  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.follower.last_heartbeat_ms {#vault-raft_storage-follower-last_heartbeat_ms}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tms\tTime since the follower last received a heartbeat request  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.stats.applied_index {#vault-raft_storage-stats-applied_index}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tHighest index of raft log last applied to the finite state machine or added to fsm_pending queue  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.stats.commit_index {#vault-raft_storage-stats-commit_index}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tIndex of the last raft log committed to disk on the node  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.stats.fsm_pending {#vault-raft_storage-stats-fsm_pending}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of raft logs queued by the node for the finite state machine to apply  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.delete {#vault-raft_storage-delete}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to insert log entry to delete path  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.entry_size {#vault-raft_storage-entry_size}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tbytes\tThe total size of a raft entry during log application  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.get {#vault-raft_storage-get}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to retrieve a value for the given path from the finite state machine  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.list {#vault-raft_storage-list}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to list all entries under the prefix from the finite state machine  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.put {#vault-raft_storage-put}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to insert a log entry to the persist path  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.transaction {#vault-raft_storage-transaction}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to insert operations into a single log  ","version":"Next","tagName":"h3"},{"title":"vault.raft.apply {#vault-raft-apply}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of transactions in the configured interval  The vault.raft.apply metric is generally a good indicator of the write load on your raft internal storage.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.barrier {#vault-raft-barrier}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the node started the barrier  A node starts the barrier by issuing a blocking call when it wants to ensure that all pending operations that need to be applied to the finite state machine are properly queued.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.candidate.electSelf {#vault-raft-candidate-electself}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required for a node to send a vote request to a peer  ","version":"Next","tagName":"h3"},{"title":"vault.raft.commitNumLogs {#vault-raft-commitnumlogs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of logs processed for application to the finite state machine in a single batch  ","version":"Next","tagName":"h3"},{"title":"vault.raft.commitTime {#vault-raft-committime}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to commit a new entry to the raft log on the leader node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.compactLogs {#vault-raft-compactlogs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to trim unnecessary logs  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.apply {#vault-raft-fsm-apply}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of logs committed by the finite state machine since the last interval  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.applyBatch {#vault-raft-fsm-applybatch}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the finite state machine to apply the most recent batch of logs  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.applyBatchNum {#vault-raft-fsm-applybatchnum}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of logs applied in the most recent batch  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.enqueue {#vault-raft-fsm-enqueue}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to queue up a batch of logs for the finite state machine to apply  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.restore {#vault-raft-fsm-restore}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the finite state machine to complete a restore operation from a snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.snapshot {#vault-raft-fsm-snapshot}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the finite state machine to record state information for the current snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.store_config {#vault-raft-fsm-store_config}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to store the most recent raft configuration  ","version":"Next","tagName":"h3"},{"title":"vault.raft.get {#vault-raft-get}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to retrieve an entry from underlying storage  ","version":"Next","tagName":"h3"},{"title":"vault.raft.leader.dispatchLog {#vault-raft-leader-dispatchlog}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required for the leader node to write a log entry to disk  ","version":"Next","tagName":"h3"},{"title":"vault.raft.leader.dispatchNumLogs {#vault-raft-leader-dispatchnumlogs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of logs committed to disk in the most recent batch  ","version":"Next","tagName":"h3"},{"title":"vault.raft.leader.lastContact {#vault-raft-leader-lastcontact}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime since the leader was last able to contact the follower nodes when checking its leader lease  ","version":"Next","tagName":"h3"},{"title":"vault.raft.list {#vault-raft-list}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to retrieve a list of keys from underlying storage  ","version":"Next","tagName":"h3"},{"title":"vault.raft.peers {#vault-raft-peers}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionguage\tnumber\tThe number of peers in the raft cluster configuration  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.appendEntries.log {#vault-raft-replication-appendentries-log}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of logs replicated to a node to establish parity with leader logs  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.appendEntries.rpc {#vault-raft-replication-appendentries-rpc}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to replicate leader node log entries to all follower nodes with appendEntries  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.heartbeat {#vault-raft-replication-heartbeat}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to invoke appendEntries on a peer so the peer does not time out  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.installSnapshot {#vault-raft-replication-installsnapshot}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process an installSnapshot RPC call  Only nodes currently in the follower state reportvault.raft.replication.installSnapshot metrics.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.restore {#vault-raft-restore}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times that the node performed a restore operation  In the context of raft storage, a restore operation refers to the process where raft consumes an external snapshot to restore its state.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.restoreUserSnapshot {#vault-raft-restoreusersnapshot}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to restore the finite state machine from a user snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.appendEntries {#vault-raft-rpc-appendentries}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process a remote appendEntries call from a node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.appendEntries.processLogs {#vault-raft-rpc-appendentries-processlogs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to completely process the outstanding logs for the given node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.appendEntries.storeLogs {#vault-raft-rpc-appendentries-storelogs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to record any outstanding logs since the last request to append entries for the given node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.installSnapshot {#vault-raft-rpc-installsnapshot}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process an installSnapshot RPC call  Only nodes currently in the follower state reportvault.raft.rpc.installSnapshot metrics.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.processHeartbeat {#vault-raft-rpc-processheartbeat}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process a heartbeat request  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.requestVote {#vault-raft-rpc-requestvote}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a requestVote call  ","version":"Next","tagName":"h3"},{"title":"vault.raft.snapshot.create {#vault-raft-snapshot-create}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to capture a new snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.snapshot.persist {#vault-raft-snapshot-persist}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to record snapshot meta information to disk while taking snapshots  ","version":"Next","tagName":"h3"},{"title":"vault.raft.snapshot.takeSnapshot {#vault-raft-snapshot-takesnapshot}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTotal time required to create and persist the current snapshot  In most cases, vault.raft.snapshot.takeSnapshot is approximately equal tovault.raft.snapshot.create + vault.raft.snapshot.persist.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.state.candidate {#vault-raft-state-candidate}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the raft server initiated an election  ","version":"Next","tagName":"h3"},{"title":"vault.raft.state.follower {#vault-raft-state-follower}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of times in the configured interval that the raft server became a follower  Nodes transition to follower state under the following conditions:  when the node joins the clusterwhen a leader is elected, but the node was not elected leader  ","version":"Next","tagName":"h3"},{"title":"vault.raft.state.leader {#vault-raft-state-leader}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the raft server became a leader  ","version":"Next","tagName":"h3"},{"title":"vault.raft.transition.heartbeat_timeout {#vault-raft-transition-heartbeat_timeout}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of times that the node transitioned to candidate state after not receiving a heartbeat message from the last known leader  ","version":"Next","tagName":"h3"},{"title":"vault.raft.transition.leader_lease_timeout {#vault-raft-transition-leader_lease_timeout}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe number of times the leader could not contact a quorum of nodes and therefore stepped down  ","version":"Next","tagName":"h3"},{"title":"vault.raft.verify_leader {#vault-raft-verify_leader}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times in the configured interval that the node confirmed it is still the leader  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.attempt.{MOUNTPOINT} {#vault-rollback-attempt-mountpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to perform a rollback operation on the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.inflight {#vault-rollback-inflight}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of rollback operations inflight  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.queued {#vault-rollback-queued}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionguage\tnumber\tThe number of rollback operations waiting to be started  ","version":"Next","tagName":"h3"},{"title":"vault.rollback.waiting {#vault-rollback-waiting}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime between queueing a rollback operation and the operation starting  ","version":"Next","tagName":"h3"},{"title":"vault.route.create.{MOUNTPOINT} {#vault-route-create-mountpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a create request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.delete.{MOUNTPOINT} {#vault-route-delete-mountpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a delete request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.list.{MOUNTPOINT} {#vault-route-list-mountpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a list request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.read.{MOUNTPOINT} {#vault-route-read-mountpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a read request to the backend and for the backend to complete the operation for the given mount point  ","version":"Next","tagName":"h3"},{"title":"vault.route.rollback.{MOUNTPOINT} {#vault-route-rollback-mountpoint}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to send a rollback request to the backend and for the backend to complete the operation for the given mount point  OpenBao automatically schedules and performs mount point rollback operations to clean up partial errors.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.alloc_bytes {#vault-runtime-alloc_bytes}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tSpace currently allocated to OpenBao processes  The number of allocated bytes may peak from time to time, but should always return to a steady state value in a health OpenBao installation.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.free_count {#vault-runtime-free_count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of freed objects  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.gc_pause_ns {#vault-runtime-gc_pause_ns}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tns\tTime required to complete the last garbage collection run  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.heap_objects {#vault-runtime-heap_objects}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of objects on the heap in memory  The vault.runtime.heap_objects metric is a good memory pressure indicator. We recommend monitoring vault.runtime.heap_objects to establish an accurate baseline and thresholds for alerting on the health of your OpenBao installation.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.malloc_count {#vault-runtime-malloc_count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of allocated heap objects in memory  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.num_goroutines {#vault-runtime-num_goroutines}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of Go routines running in memory  The vault.runtime.num_goroutines metric is a good system load indicator. We recommend monitoring vault.runtime.num_goroutines to establish an accurate baseline and thresholds for alerting on the health of your OpenBao installation.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.sys_bytes {#vault-runtime-sys_bytes}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of bytes allocated to OpenBao  The total number of allocated system bytes includes space currently used by the heap plus space that has been reclaimed by, but not returned to, the operating system.  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.total_gc_pause_ns {#vault-runtime-total_gc_pause_ns}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tns\tThe total garbage collector pause time since OpenBao was last started  ","version":"Next","tagName":"h3"},{"title":"vault.runtime.total_gc_runs {#vault-runtime-total_gc_runs}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tThe total number of garbage collection runs since OpenBao was last started  ","version":"Next","tagName":"h3"},{"title":"vault.secret.kv.count {#vault-secret-kv-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in each key-value secrets engines  OpenBao organizes the key-value pair count by cluster, namespace, and mount point.  ","version":"Next","tagName":"h3"},{"title":"vault.secret.lease.creation {#vault-secret-lease-creation}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of leases created by secrets engines  OpenBao organizes the lease count by cluster, namespace, secret engine, mount point, and time to live (TTL).  ","version":"Next","tagName":"h3"},{"title":"vault.token.count {#vault-token-count}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of un-expired and un-revoked tokens available for use in the token store  OpenBao updates the token count every 10 minutes organizes the result by cluster and namespace.  ","version":"Next","tagName":"h3"},{"title":"vault.token.count.by_auth {#vault-token-count-by_auth}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of service tokens created by a particular auth method  OpenBao organizes the token count by cluster, namespace, and authentication method.  ","version":"Next","tagName":"h3"},{"title":"vault.token.count.by_policy {#vault-token-count-by_policy}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of service tokens with a particular policy attached  OpenBao organizes the token count by cluster, namespace, and policy. Tokens with more than one policy attached appear in the gauge for each associated policy.  ","version":"Next","tagName":"h3"},{"title":"vault.token.count.by_ttl {#vault-token-count-by_ttl}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of service tokens assigned a particular time to live (TTL)  OpenBao organizes the token count by cluster, namespace, and the TTL range assigned at creation.  ","version":"Next","tagName":"h3"},{"title":"vault.token.create_root {#vault-token-create_root}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of root tokens created  The vault.token.create_root counts the total number of root tokens created over time, not the number of root tokens currently in use. As a result, the value of vault.token.create_root does not decrease when a root token is revoked.  ","version":"Next","tagName":"h3"},{"title":"vault.token.create {#vault-token-create}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a token in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.createAccessor {#vault-token-createaccessor}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a token accessor in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.creation {#vault-token-creation}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of service or batch tokens created  OpenBao organizes the creation count by cluster, namespace, authentication method, mount point, time to live (TTL), and token type.  ","version":"Next","tagName":"h3"},{"title":"vault.token.lookup {#vault-token-lookup}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to look up a token in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.revoke-tree {#vault-token-revoke_tree}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fully revoke a token tree in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.revoke {#vault-token-revoke}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a token in OpenBao  ","version":"Next","tagName":"h3"},{"title":"vault.token.store {#vault-token-store}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to store an updated token entry without writing to the secondary index  ","version":"Next","tagName":"h3"},{"title":"vault.wal.deleteWALs {#vault-wal-deletewals}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fully delete a write-ahead log  ","version":"Next","tagName":"h3"},{"title":"vault.wal.flushReady {#vault-wal-flushready}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to fully flush a write-ahead log that is ready for storage  ","version":"Next","tagName":"h3"},{"title":"vault.wal.flushReady.queue_len {#vault-wal-flushready-queue_len}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tCurrent size of the write queue in the WAL system  ","version":"Next","tagName":"h3"},{"title":"vault.wal.gc.deleted {#vault-wal-gc-deleted}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of write-ahead logs deleted during garbage collection  ","version":"Next","tagName":"h3"},{"title":"vault.wal.gc.total {#vault-wal-gc-total}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of write-ahead logs currently on disk  ","version":"Next","tagName":"h3"},{"title":"vault.wal.loadWAL {#vault-wal-loadwal}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to load a write-ahead log  ","version":"Next","tagName":"h3"},{"title":"vault.wal.persistWALs {#vault-wal-persistwals}","type":1,"pageTitle":"All OpenBao telemetry metrics","url":"/openbao/docs/internals/telemetry/metrics/all/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to persist a write-ahead log ","version":"Next","tagName":"h3"},{"title":"Raft telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/raft/","content":"","keywords":"","version":"Next"},{"title":"Default metrics​","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/#default-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.raft.apply {#vault-raft-apply}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of transactions in the configured interval  The vault.raft.apply metric is generally a good indicator of the write load on your raft internal storage.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.barrier {#vault-raft-barrier}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the node started the barrier  A node starts the barrier by issuing a blocking call when it wants to ensure that all pending operations that need to be applied to the finite state machine are properly queued.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.candidate.electSelf {#vault-raft-candidate-electself}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required for a node to send a vote request to a peer  ","version":"Next","tagName":"h3"},{"title":"vault.raft.commitNumLogs {#vault-raft-commitnumlogs}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of logs processed for application to the finite state machine in a single batch  ","version":"Next","tagName":"h3"},{"title":"vault.raft.commitTime {#vault-raft-committime}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to commit a new entry to the raft log on the leader node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.compactLogs {#vault-raft-compactlogs}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to trim unnecessary logs  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.apply {#vault-raft-fsm-apply}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of logs committed by the finite state machine since the last interval  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.applyBatch {#vault-raft-fsm-applybatch}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the finite state machine to apply the most recent batch of logs  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.applyBatchNum {#vault-raft-fsm-applybatchnum}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of logs applied in the most recent batch  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.enqueue {#vault-raft-fsm-enqueue}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to queue up a batch of logs for the finite state machine to apply  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.restore {#vault-raft-fsm-restore}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the finite state machine to complete a restore operation from a snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.snapshot {#vault-raft-fsm-snapshot}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the finite state machine to record state information for the current snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.fsm.store_config {#vault-raft-fsm-store_config}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to store the most recent raft configuration  ","version":"Next","tagName":"h3"},{"title":"vault.raft.get {#vault-raft-get}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to retrieve an entry from underlying storage  ","version":"Next","tagName":"h3"},{"title":"vault.raft.list {#vault-raft-list}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to retrieve a list of keys from underlying storage  ","version":"Next","tagName":"h3"},{"title":"vault.raft.peers {#vault-raft-peers}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionguage\tnumber\tThe number of peers in the raft cluster configuration  ","version":"Next","tagName":"h3"},{"title":"vault.raft.restore {#vault-raft-restore}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times that the node performed a restore operation  In the context of raft storage, a restore operation refers to the process where raft consumes an external snapshot to restore its state.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.restoreUserSnapshot {#vault-raft-restoreusersnapshot}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to restore the finite state machine from a user snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.appendEntries {#vault-raft-rpc-appendentries}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process a remote appendEntries call from a node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.appendEntries.processLogs {#vault-raft-rpc-appendentries-processlogs}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to completely process the outstanding logs for the given node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.appendEntries.storeLogs {#vault-raft-rpc-appendentries-storelogs}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to record any outstanding logs since the last request to append entries for the given node  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.installSnapshot {#vault-raft-rpc-installsnapshot}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process an installSnapshot RPC call  Only nodes currently in the follower state reportvault.raft.rpc.installSnapshot metrics.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.processHeartbeat {#vault-raft-rpc-processheartbeat}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process a heartbeat request  ","version":"Next","tagName":"h3"},{"title":"vault.raft.rpc.requestVote {#vault-raft-rpc-requestvote}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a requestVote call  ","version":"Next","tagName":"h3"},{"title":"vault.raft.snapshot.create {#vault-raft-snapshot-create}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to capture a new snapshot  ","version":"Next","tagName":"h3"},{"title":"vault.raft.snapshot.persist {#vault-raft-snapshot-persist}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to record snapshot meta information to disk while taking snapshots  ","version":"Next","tagName":"h3"},{"title":"vault.raft.snapshot.takeSnapshot {#vault-raft-snapshot-takesnapshot}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTotal time required to create and persist the current snapshot  In most cases, vault.raft.snapshot.takeSnapshot is approximately equal tovault.raft.snapshot.create + vault.raft.snapshot.persist.  ","version":"Next","tagName":"h3"},{"title":"vault.raft.state.candidate {#vault-raft-state-candidate}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the raft server initiated an election  ","version":"Next","tagName":"h3"},{"title":"vault.raft.state.follower {#vault-raft-state-follower}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of times in the configured interval that the raft server became a follower  Nodes transition to follower state under the following conditions:  when the node joins the clusterwhen a leader is elected, but the node was not elected leader  ","version":"Next","tagName":"h3"},{"title":"vault.raft.state.leader {#vault-raft-state-leader}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the raft server became a leader  ","version":"Next","tagName":"h3"},{"title":"vault.raft.transition.heartbeat_timeout {#vault-raft-transition-heartbeat_timeout}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of times that the node transitioned to candidate state after not receiving a heartbeat message from the last known leader  ","version":"Next","tagName":"h3"},{"title":"vault.raft.transition.leader_lease_timeout {#vault-raft-transition-leader_lease_timeout}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tThe number of times the leader could not contact a quorum of nodes and therefore stepped down  ","version":"Next","tagName":"h3"},{"title":"vault.raft.verify_leader {#vault-raft-verify_leader}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times in the configured interval that the node confirmed it is still the leader  ","version":"Next","tagName":"h3"},{"title":"Autopilot metrics​","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/#autopilot-metrics","content":"  &lt;Note heading=&quot;Metrics only apply to the active node&quot;&gt; Autopilot only runs on the active node, so autopilot metrics are only captured for the current active node. &lt;/Note&gt;   ","version":"Next","tagName":"h2"},{"title":"vault.autopilot.failure_tolerance {#vault-autopilot-failure_tolerance}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnodes\tThe number of healthy nodes in excess of quorum  The failure tolerance indicates how many currently healthy nodes can fail without losing quorum.  ","version":"Next","tagName":"h3"},{"title":"vault.autopilot.healthy {#vault-autopilot-healthy}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether all nodes are healthy  A value of 1 on the gauge means that Autopilot deems all nodes healthy.A value of 0 on the gauge means that Autopilot deems at least 1 node unhealthy.  ","version":"Next","tagName":"h3"},{"title":"vault.autopilot.node.healthy {#vault-autopilot-node-healthy}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tboolean\tIndicates whether the active node is healthy  A value of 1 on the gauge means that Autopilot deems the node indicated bynode_id is healthy.A value of 0 on the gauge means that Autopilot cannot communicate with the node indicated by node_id, or deems the node unhealthy.  ","version":"Next","tagName":"h3"},{"title":"Leadership change metrics​","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/#leadership-change-metrics","content":" Leadership change metrics indicate the overall performance of the integrated storage on raft servers and the network connection between raft nodes.  ","version":"Next","tagName":"h2"},{"title":"vault.raft.leader.dispatchLog {#vault-raft-leader-dispatchlog}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required for the leader node to write a log entry to disk  ","version":"Next","tagName":"h3"},{"title":"vault.raft.leader.dispatchNumLogs {#vault-raft-leader-dispatchnumlogs}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of logs committed to disk in the most recent batch  ","version":"Next","tagName":"h3"},{"title":"vault.raft.leader.lastContact {#vault-raft-leader-lastcontact}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime since the leader was last able to contact the follower nodes when checking its leader lease  ","version":"Next","tagName":"h3"},{"title":"Raft replication metrics​","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/#raft-replication-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.raft.replication.appendEntries.log {#vault-raft-replication-appendentries-log}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tnumber\tNumber of logs replicated to a node to establish parity with leader logs  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.appendEntries.rpc {#vault-raft-replication-appendentries-rpc}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to replicate leader node log entries to all follower nodes with appendEntries  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.heartbeat {#vault-raft-replication-heartbeat}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to invoke appendEntries on a peer so the peer does not time out  ","version":"Next","tagName":"h3"},{"title":"vault.raft.replication.installSnapshot {#vault-raft-replication-installsnapshot}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to process an installSnapshot RPC call  Only nodes currently in the follower state reportvault.raft.replication.installSnapshot metrics.  ","version":"Next","tagName":"h3"},{"title":"Storage metrics​","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/#storage-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.raft_storage.bolt.cursor.count {#vault-raft_storage-bolt-cursor-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of cursors created in the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.allocated_bytes {#vault-raft_storage-bolt-freelist-allocated_bytes}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tTotal space allocated for the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.free_pages {#vault-raft_storage-bolt-freelist-free_pages}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of free pages in the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.pending_pages {#vault-raft_storage-bolt-freelist-pending_pages}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of pending pages in the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.freelist.used_bytes {#vault-raft_storage-bolt-freelist-used_bytes}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tTotal space used by the freelist for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.node.count {#vault-raft_storage-bolt-node-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of node allocations for the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.node.dereferences {#vault-raft_storage-bolt-node-dereferences}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of node dereferences by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.page.bytes_allocated {#vault-raft_storage-bolt-page-bytes_allocated}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tbytes\tTotal space allocated to the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.page.count {#vault-raft_storage-bolt-page-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of page allocations in the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.rebalance.count {#vault-raft_storage-bolt-rebalance-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of node rebalances performed by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.rebalance.time {#vault-raft_storage-bolt-rebalance-time}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required by the Bolt database to rebalance nodes  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.spill.count {#vault-raft_storage-bolt-spill-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of nodes spilled by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.spill.time {#vault-raft_storage-bolt-spill-time}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTotal time spent spilling by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.split.count {#vault-raft_storage-bolt-split-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of nodes split by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.transaction.currently_open_read_transactions {#vault-raft_storage-bolt-transaction-currently_open_read_transactions}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of in-process read transactions for the Bolt DB  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.transaction.started_read_transactions {#vault-raft_storage-bolt-transaction-started_read_transactions}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of read transactions started by the Bolt DB  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.write.count {#vault-raft_storage-bolt-write-count}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of writes performed by the Bolt database  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.bolt.write.time {#vault-raft_storage-bolt-write-time}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptioncounter\tms\tTotal cumulative time the Bolt database has spent writing to disk.  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.follower.applied_index_delta {#vault-raft_storage-follower-applied_index_delta}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tThe difference between the index applied by the leader and the index applied by the follower as reported by echoes  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.follower.last_heartbeat_ms {#vault-raft_storage-follower-last_heartbeat_ms}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tms\tTime since the follower last received a heartbeat request  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.stats.applied_index {#vault-raft_storage-stats-applied_index}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tHighest index of raft log last applied to the finite state machine or added to fsm_pending queue  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.stats.commit_index {#vault-raft_storage-stats-commit_index}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tIndex of the last raft log committed to disk on the node  ","version":"Next","tagName":"h3"},{"title":"vault.raft_storage.stats.fsm_pending {#vault-raft_storage-stats-fsm_pending}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of raft logs queued by the node for the finite state machine to apply  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.delete {#vault-raft_storage-delete}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to insert log entry to delete path  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.entry_size {#vault-raft_storage-entry_size}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptionsummary\tbytes\tThe total size of a raft entry during log application  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.get {#vault-raft_storage-get}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to retrieve a value for the given path from the finite state machine  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.list {#vault-raft_storage-list}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to list all entries under the prefix from the finite state machine  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.put {#vault-raft_storage-put}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to insert a log entry to the persist path  ","version":"Next","tagName":"h3"},{"title":"vault.raft-storage.transaction {#vault-raft_storage-transaction}","type":1,"pageTitle":"Raft telemetry","url":"/openbao/docs/internals/telemetry/metrics/raft/##","content":" Metric type\tValue\tDescriptiontimer\tms\tTime required to insert operations into a single log ","version":"Next","tagName":"h3"},{"title":"Secrets telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/secrets/","content":"","keywords":"","version":"Next"},{"title":"Default metrics​","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/#default-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.secret.kv.count {#vault-secret-kv-count}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in each key-value secrets engines  OpenBao organizes the key-value pair count by cluster, namespace, and mount point.  ","version":"Next","tagName":"h3"},{"title":"vault.secret.lease.creation {#vault-secret-lease-creation}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of leases created by secrets engines  OpenBao organizes the lease count by cluster, namespace, secret engine, mount point, and time to live (TTL).  ","version":"Next","tagName":"h3"},{"title":"PKI metrics​","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/#pki-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"secrets.pki.tidy.cert_store_current_entry {#secrets-pki-tidy-cert_store_current_entry}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tIndex of the certificate store entry currently being verified by the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_deleted_count {#secrets-pki-tidy-cert_store_deleted_count}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of entries deleted from the certificate store  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_total_entries_remaining {#secrets-pki-tidy-cert_store_total_entries_remaining}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in the certificate store checked, but not removed, during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.cert_store_total_entries {#secrets-pki-tidy-cert_store_total_entries}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in the certificate store to verify during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.duration {#secrets-pki-tidy-duration}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete the PKI tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.failure {#secrets-pki-tidy-failure}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the PKI tidy operation failed to finish due to errors  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_current_entry {#secrets-pki-tidy-revoked_cert_current_entry}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tIndex of the revoked certificate store entry currently being verified by the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_deleted_count {#secrets-pki-tidy-revoked_cert_deleted_count}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of entries deleted from the certificate store for revoked certificates  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries_fixed_issuers {#secrets-pki-tidy-revoked_cert_total_entries_fixed_issuers}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of entries in the certificate store found to have incorrect issuer information that were fixed during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries_incorrect_issuers {#secrets-pki-tidy-revoked_cert_total_entries_incorrect_issuers}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tTotal number of entries in the certificate store found to have incorrect issuer information  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries_remaining {#secrets-pki-tidy-revoked_cert_total_entries_remaining}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of revoked certificates in the certificate store checked, but not removed, during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.revoked_cert_total_entries {#secrets-pki-tidy-revoked_cert_total_entries}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tnumber\tNumber of revoked certificate entries in the certificate store to be verified during the tidy operation  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.start_time_epoch {#secrets-pki-tidy-start_time_epoch}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptiongauge\tseconds\tEpoch time (seconds since 1970-01-01) when the PKI tidy operation began  The start time metric reports a value of 0 if the PKI tidy operation is not currently active.  ","version":"Next","tagName":"h3"},{"title":"secrets.pki.tidy.success {#secrets-pki-tidy-success}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of times the PKI tidy operation completed successfully  ","version":"Next","tagName":"h3"},{"title":"Secrets database metrics​","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/#secrets-database-metrics","content":" Metrics related to your configured secrets engines, including database-specific metrics for each named secrets engine. For example, if you enable a PostgreSQL secrets engine called postgresql-prod, the relatedCreateUser.error metric is database.postgresql-prod.CreateUser.error.  ","version":"Next","tagName":"h2"},{"title":"database.Close {#database-close}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to close a database secret engine (across all database secrets engines)  ","version":"Next","tagName":"h3"},{"title":"database.Close.error {#database-close-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while closing database connections  ","version":"Next","tagName":"h3"},{"title":"database.CreateUser {#database-createuser}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.CreateUser.error {#database-createuser-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while creating users  ","version":"Next","tagName":"h3"},{"title":"database.Initialize {#database-initialize}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to initialize a database secret engine (across all database secrets engines)  ","version":"Next","tagName":"h3"},{"title":"database.Initialize.error {#database-initialize-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while initializing the database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Close {#database-name-close}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to close the database secrets engine {NAME}  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Close.error {#database-name-close-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while closing database connections  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.CreateUser {#database-name-createuser}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to create a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.CreateUser.error {#database-name-createuser-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while creating users  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Initialize {#database-name-initialize}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to initialize a database secret engine for the named database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.Initialize.error {#database-name-initialize-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while initializing the database  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RenewUser {#database-name-renewuser}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to renew a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RenewUser.error {#database-name-renewuser-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while renewing users  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RevokeUser {#database-name-revokeuser}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a user for the named database secrets engine  ","version":"Next","tagName":"h3"},{"title":"database.{NAME}.RevokeUser.error {#database-name-revokeuser-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered for the named database secrets engines while revoking users  ","version":"Next","tagName":"h3"},{"title":"database.RenewUser {#database-renewuser}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to renew a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.RenewUser.error {#database-renewuser-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while renewing users  ","version":"Next","tagName":"h3"},{"title":"database.RevokeUser {#database-revokeuser}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to revoke a user across all database secrets engines  ","version":"Next","tagName":"h3"},{"title":"database.RevokeUser.error {#database-revokeuser-error}","type":1,"pageTitle":"Secrets telemetry","url":"/openbao/docs/internals/telemetry/metrics/secrets/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of errors encountered across all database secrets engines while revoking users ","version":"Next","tagName":"h3"},{"title":"Storage plugin telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/internals/telemetry/metrics/storage/","content":"","keywords":"","version":"Next"},{"title":"Barrier metrics​","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/#barrier-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.barrier.delete {#vault-barrier-delete}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a DELETE operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.get {#vault-barrier-get}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a GET operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.list {#vault-barrier-list}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a LIST operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"vault.barrier.put {#vault-barrier-put}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptionsummary\tms\tTime required to complete a PUT operation at the barrier  ","version":"Next","tagName":"h3"},{"title":"Caching metrics​","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/#caching-metrics","content":" ","version":"Next","tagName":"h2"},{"title":"vault.cache.delete {#vault-cache-delete}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of deletes from the LRU cache  ","version":"Next","tagName":"h3"},{"title":"vault.cache.hit {#vault-cache-hit}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of hits against the LRU cache that avoided a read from configured storage  ","version":"Next","tagName":"h3"},{"title":"vault.cache.miss {#vault-cache-miss}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of misses against the LRU cache that required a read from configured storage  ","version":"Next","tagName":"h3"},{"title":"vault.cache.write {#vault-cache-write}","type":1,"pageTitle":"Storage plugin telemetry","url":"/openbao/docs/internals/telemetry/metrics/storage/##","content":" Metric type\tValue\tDescriptioncounter\tnumber\tNumber of writes to the LRU cache ","version":"Next","tagName":"h3"},{"title":"Token authentication","type":0,"sectionRef":"#","url":"/openbao/docs/internals/token/","content":"Token authentication The token auth method is built-in and is at the core of client authentication. Other auth methods may be used to authenticate a client, but they eventually result in the generation of a client token managed by the token backend. Every token has a number of properties: ID - The primary ID of a token is a randomly generated valueDisplay Name - Optionally, a human readable display nameMetadata - Metadata used for audit loggingNumber of Uses - Optionally, a restricted use countParent ID - Optionally, a parent token which created this child tokenPolicies - An associated list of ACL policiesSource Path - The path at which the token was generated (e.g. auth/github/login) The properties of a token are immutable once created. The exception to this is the number of uses, which is decremented on each request. Each of these properties enable OpenBao to do a number of interesting things. Each token maintains the source path, or the login path, that was used to create the token. This is used to allow source based revocation. For example, if we believe our GitHub organization was compromised, we may want to revoke all tokens generated via auth/github/login. This would be done by using thesys/revoke-prefix/ API with the auth/github/ prefix. Revoking the prefix will revoke all client tokens generated at that path, as well as all dynamic secrets generated by those tokens. This provides a powerful &quot;break glass&quot; procedure during a potential compromise. If a token is created by another auth method, they do not have a parent token. However, any tokens created by the auth/token/create API have a parent token, namely the token used to make that request. By maintaining this parent-child relationship, OpenBao models token trees. Child tokens can be created with a subset of the parent policies, allowing for dropping of privileges. When a token is revoked, the entire sub-tree of tokens is revoked with it. This allows clients to safely generate child tokens and then revoke them all along with the root. Child tokens are very useful, especially when combined with limited use tokens. When a token is created, its use count can be optionally specified. Providing a use count of one makes a one time token. This means the token can be used for a single request before being automatically revoked. This can be generalized to any number of uses. Limited use tokens cannot be used to create sub-tokens, but they can be a powerful way to allow extremely limited access to OpenBao.","keywords":"","version":"Next"},{"title":"Platforms","type":0,"sectionRef":"#","url":"/openbao/docs/platform/","content":"Platforms This section covers running OpenBao on various platforms (such as Kubernetes) and explains architecture, configuration, installation and security considerations.","keywords":"","version":"Next"},{"title":"GitHub actions","type":0,"sectionRef":"#","url":"/openbao/docs/platform/github-actions/","content":"","keywords":"","version":"Next"},{"title":"Example​","type":1,"pageTitle":"GitHub actions","url":"/openbao/docs/platform/github-actions/#example","content":" Here is an example vault-action step in a workflow:  jobs: build: # ... steps: # ... - name: Import Secrets uses: hashicorp/vault-action@v2.4.0 with: url: https://vault.example.com:8200 token: ${{ secrets.VAULT_TOKEN }} caCertificate: ${{ secrets.VAULT_CA_CERT }} secrets: | secret/data/ci/aws accessKey | AWS_ACCESS_KEY_ID ; secret/data/ci/aws secretKey | AWS_SECRET_ACCESS_KEY ; secret/data/ci npm_token   This example will authenticate to Vault instance at https://vault.example.com:8200 with the GitHub secrets defined inVAULT_TOKEN and VAULT_CA_CERT, and will add environment variables available for next steps in the workflow:  The secret at path secret/data/ci/aws with the key accessKey available in the environment variable AWS_ACCESS_KEY_IDThe secret at path secret/data/ci/aws with the key secretKey available in the environment variable AWS_SECRET_ACCESS_KEYThe secret at path secret/data/ci with the key npm_token available in the environment variable NPM_TOKEN  ","version":"Next","tagName":"h2"},{"title":"Further information​","type":1,"pageTitle":"GitHub actions","url":"/openbao/docs/platform/github-actions/#further-information","content":" For more information on using the vault-action GitHub Action, visit:  Vault GitHub action documentationVault GitHub actions tutorial ","version":"Next","tagName":"h2"},{"title":"Kubernetes","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/","content":"","keywords":"","version":"Next"},{"title":"Use cases​","type":1,"pageTitle":"Kubernetes","url":"/openbao/docs/platform/k8s/#use-cases","content":" Running a Vault Service: The Vault server cluster can run directly on Kubernetes. This can be used by applications running within Kubernetes as well as external to Kubernetes, as long as they can communicate to the server via the network.  Accessing and Storing Secrets: Applications using the Vault service running in Kubernetes can access and store secrets from Vault using a number of differentsecret engines and authentication methods.  Running a Highly Available Vault Service: By using pod affinities, highly available backend storage (such as Consul) and auto-unseal, Vault can become a highly available service in Kubernetes.  Encryption as a Service: Applications using the Vault service running in Kubernetes can leverage the Transit secret engineas &quot;encryption as a service&quot;. This allows applications to offload encryption needs to Vault before storing data at rest.  Audit Logs for Vault: Operators can choose to attach a persistent volume to the Vault cluster which can be used to store audit logs.  And more! Vault can run directly on Kubernetes, so in addition to the native integrations provided by Vault itself, any other tool built for Kubernetes can choose to leverage Vault.  ","version":"Next","tagName":"h2"},{"title":"Getting started with Vault and kubernetes​","type":1,"pageTitle":"Kubernetes","url":"/openbao/docs/platform/k8s/#getting-started-with-vault-and-kubernetes","content":" There are several ways to try Vault with Kubernetes in different environments.  ","version":"Next","tagName":"h2"},{"title":"Guides​","type":1,"pageTitle":"Kubernetes","url":"/openbao/docs/platform/k8s/#guides","content":" Vault Installation to Minikube via Helm with Integrated Storage covers installing Vault locally using Minikube and the official Helm chart. Vault Installation to Red Hat OpenShift via Helm covers installing Vault using Helm on Red Hat's OpenShift platform. Integrate a Kubernetes Cluster with an External Vault provides an example of making Vault accessible via a Kubernetes service and endpoint. Vault on Kubernetes Deployment Guide covers the steps required to install and configure a single HashiCorp Vault cluster.  ","version":"Next","tagName":"h3"},{"title":"High level comparison of integrations​","type":1,"pageTitle":"Kubernetes","url":"/openbao/docs/platform/k8s/#high-level-comparison-of-integrations","content":" There are currently 3 different integrations to help Kubernetes workloads seamlessly consume secrets from Vault, without the need to modify the application to interact directly with Vault. Each integration addresses slightly different use-cases. The following is a brief overview of the strengths of each integration.  Agent injector​  No durable secret storage outside Vault. All secrets written to disk are in ephemeral in-memory volumes.No highly privileged service accounts required. All secrets are fetched with the pod's own service account without the need for any other service accounts to impersonate it.More mature solution, with proven production record and advanced features like templating, wider array of auth methods, etc.  Vault Secrets Operator​  More native UX for app developers. Workloads can mount Kubernetes secrets without adding any Vault-specific configuration.Reduced load on Vault. Secrets are synced per CRD instead of per consuming pod.Better Vault secret availability. Kubernetes secrets act as a durable cluster-local cache of Vault secrets.  Vault CSI provider​  The CSI driver that the provider is based on is vendor neutral.No durable secret storage outside Vault if the secret sync feature isn't used. All secrets written to disk are in ephemeral in-memory volumes.  ","version":"Next","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"Kubernetes","url":"/openbao/docs/platform/k8s/#documentation","content":" Vault on Kubernetes Security Considerations provides recommendations specific to securely running Vault in a production Kubernetes environment. ","version":"Next","tagName":"h3"},{"title":"Vault lambda extension","type":0,"sectionRef":"#","url":"/openbao/docs/platform/aws/lambda-extension/","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#usage","content":" To use the extension, include one of the following ARNs as a layer in your Lambda function, depending on your desired architecture.  amd64 (x86_64):  arn:aws:lambda:&lt;your-region&gt;:634166935893:layer:vault-lambda-extension:13   arm64:  arn:aws:lambda:&lt;your-region&gt;:634166935893:layer:vault-lambda-extension-arm64:1   Where region may be any of af-south-1, ap-east-1, ap-northeast-1,ap-northeast-2, ap-northeast-3, ap-south-1, ap-southeast-1,ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1,eu-west-1, eu-west-2, eu-west-3, me-south-1, sa-east-1, us-east-1,us-east-2, us-west-1, us-west-2.  The extension authenticates with Vault using AWS IAM auth, and all configuration is supplied via environment variables. There are two methods to read secrets, which can both be used side-by-side:  Recommended: Make unauthenticated requests to the extension's local proxy server at http://127.0.0.1:8200, which will add an authentication header and proxy to the configured VAULT_ADDR. Responses from Vault are returned without modification.Configure environment variables such as VAULT_SECRET_PATH for the extension to read a secret and write it to disk.  ","version":"Next","tagName":"h2"},{"title":"Adding the extension to your existing lambda and Vault infrastructure​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#adding-the-extension-to-your-existing-lambda-and-vault-infrastructure","content":" Requirements​  ARN of the role your Lambda runs asAn instance of Vault accessible from AWS LambdaAn authenticated vault clientA secret in Vault that you want your Lambda to access, and a policy giving read access to itYour Lambda function must use one of the supported runtimes for extensions  Step 1. configure Vault​  Enable the aws auth method.  $ vault auth enable aws   Configure the AWS client to use the default options.  $ vault write -force auth/aws/config/client   Create a role prefixed with the AWS environment name.  $ vault write auth/aws/role/vault-lambda-role \\ auth_type=iam \\ bound_iam_principal_arn=&quot;${YOUR_ARN}&quot; \\ policies=&quot;${YOUR_POLICY}&quot; \\ ttl=1h   Step 2. option a) install the extension for lambda functions packaged in zip archives​  If you deploy your Lambda function as a zip file, you can add the extension to your Lambda layers using the console or cli:  arn:aws:lambda:&lt;your-region&gt;:634166935893:layer:vault-lambda-extension:11   Step 2. option b) install the extension for lambda functions packaged in container images​  Alternatively, if you deploy your Lambda function as a container image, simply place the built binary in the /opt/extensions directory of your image.  Fetch the binary fromreleases.hashicorp.com. The following command requires cURL.  $ curl --silent https://releases.hashicorp.com/vault-lambda-extension/0.5.0/vault-lambda-extension_0.5.0_linux_amd64.zip \\ --output vault-lambda-extension.zip   Unzip the downloaded binary.  $ unzip vault-lambda-extension.zip   Optionally, you can verify the integrity of the downloaded zip using the release archive checksum verification instructionshere.  Or to build the binary from source. This requires Golang installed. Run from the root of this repository.  $ GOOS=linux GOARCH=amd64 go build -o vault-lambda-extension main.go   Step 3. configure vault-lambda-extension​  Configure the extension using Lambda environment variables:  Set the Vault API address.  $ VAULT_ADDR=http://vault.example.com:8200   Set the AWS IAM auth mount point (i.e. the path segment after auth/ from above).  $ VAULT_AUTH_PROVIDER=aws   Set the Vault role to authenticate as. Must be configured for the ARN of your Lambda's role.  $ VAULT_AUTH_ROLE=vault-lambda-role   The path to a secret in Vault. Can be static or dynamic. Unless VAULT_SECRET_FILE is specified, JSON response will be written to/tmp/vault/secret.json.  $ VAULT_SECRET_PATH=secret/lambda-app/token   If everything is correctly set up, your Lambda function can then read secret material from /tmp/vault/secret.json. The exact contents of the JSON object will depend on the secret read, but its schema is the Secret structfrom the Vault API module.  Alternatively, you can send normal Vault API requests over HTTP to the local proxy at http://127.0.0.1:8200, and the extension will add authentication before forwarding the request. Vault responses will be returned unmodified. Although local communication is over plain HTTP, the proxy server will use TLS to communicate with Vault if configured to do so as detailed below.  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#configuration","content":" The extension is configured via Lambda environment variables. Most of the Vault CLI client's environment variables are available, as well as some additional variables to configure auth, which secret(s) to read and where to write secrets.  Environment variable\tDescription\tRequired\tExample valueVLE_VAULT_ADDR\tVault address to connect to. Takes precedence over VAULT_ADDR so that clients of the proxy server can be configured using the standard VAULT_ADDR\tNo\thttps://x.x.x.x:8200 VAULT_ADDR\tVault address to connect to if VLE_VAULT_ADDR is not set. Required if VLE_VAULT_ADDR is not set\tNo\thttps://x.x.x.x:8200 VAULT_AUTH_PROVIDER\tName of the configured AWS IAM auth route on Vault\tYes\taws VAULT_AUTH_ROLE\tVault role to authenticate as\tYes\tlambda-app VAULT_IAM_SERVER_ID\tValue to pass to the Vault server via the X-Vault-AWS-IAM-Server-ID HTTP Header for AWS Authentication\tNo\tvault.example.com VAULT_SECRET_PATH\tSecret path to read, written to /tmp/vault/secret.json unless VAULT_SECRET_FILE is specified\tNo\tdatabase/creds/lambda-app VAULT_SECRET_FILE\tPath to write the JSON response for VAULT_SECRET_PATH\tNo\t/tmp/db.json VAULT_SECRET_PATH_FOO\tAdditional secret path to read, where FOO can be any name, as long as a matching VAULT_SECRET_FILE_FOO is specified\tNo\tsecret/lambda-app/token VAULT_SECRET_FILE_FOO\tMust exist for any correspondingly named VAULT_SECRET_PATH_FOO. Name has no further effect beyond matching to the correct path variable\tNo\t/tmp/token VAULT_RUN_MODE\tAvailable options are default, proxy, and file. Proxy mode makes requests to the extension's local proxy server. File mode configures the extension to read and write secrets to disk. Default mode uses both file and proxy mode. The default is default.\tNo\tdefault VAULT_TOKEN_EXPIRY_GRACE_PERIOD\tPeriod at the end of the proxy server's auth token TTL where it will consider the token expired and attempt to re-authenticate to Vault. Must have a unit and be parseable by time.Duration. Defaults to 10s.\tNo\t1m VAULT_STS_ENDPOINT_REGION\tThe region of the STS regional endpoint to authenticate with. If the AWS IAM auth mount specified uses a regional STS endpoint, then this needs to match the region of that endpoint. Defaults to using the global endpoint, or the region the Lambda resides in if AWS_STS_REGIONAL_ENDPOINTS is set to regional\tNo\teu-west-1  The remaining environment variables are not required, and function exactly as described in the Vault Commands (CLI) documentation. However, note that VAULT_CLIENT_TIMEOUT cannot extend the timeout beyond the 10s initialization timeout imposed by the Extensions API when writing files to disk.  Environment variable\tDescription\tRequired\tExample valueVAULT_CACERT\tPath to a PEM-encoded CA certificate file on the local disk\tNo\t/tmp/ca.crt VAULT_CAPATH\tPath to a directory of PEM-encoded CA certificate files on the local disk\tNo\t/tmp/certs VAULT_CLIENT_CERT\tPath to a PEM-encoded client certificate on the local disk\tNo\t/tmp/client.crt VAULT_CLIENT_KEY\tPath to an unencrypted, PEM-encoded private key on disk which corresponds to the matching client certificate\tNo\t/tmp/client.key VAULT_CLIENT_TIMEOUT\tTimeout for Vault requests. Default value is 60s. Ignored by proxy server. Any value over 10s will exceed the Extensions API timeout and therefore have no effect\tNo\t5s VAULT_MAX_RETRIES\tMaximum number of retries on 5xx error codes. Defaults to 2. Ignored by proxy server\tNo\t2 VAULT_SKIP_VERIFY\tDo not verify Vault's presented certificate before communicating with it. Setting this variable is not recommended and voids Vault's security model\tNo\ttrue VAULT_TLS_SERVER_NAME\tName to use as the SNI host when connecting via TLS\tNo\tvault.example.com VAULT_RATE_LIMIT\tOnly applies to a single invocation of the extension. See Vault Commands (CLI) documentation for details. Ignored by proxy server\tNo\t10 VAULT_NAMESPACE\tThe namespace to use for pre-configured secrets. Ignored by proxy server\tNo\teducation VAULT_DEFAULT_CACHE_TTL\tThe time to live configuration (aka, TTL) of the cache used by proxy server. Must have a unit and be parsable as a time.Duration. Required for caching to be enabled.\tNo\t15m VAULT_DEFAULT_CACHE_ENABLED\tEnable caching for all requests, without needing to set the X-Vault-Cache-Control header for each request. Must be set to a boolean value.\tNo\ttrue VAULT_ASSUMED_ROLE_ARN\tValid ARN of an IAM role that can be assumed by the execution role assigned to your Lambda function.\tNo\tarn:aws:iam::123456789012:role/xaccounts3access VAULT_LOG_LEVEL\tLog verbosity level, one of TRACE, DEBUG, INFO, WARN, ERROR, OFF. Defaults to INFO.\tNo\tDEBUG  ","version":"Next","tagName":"h2"},{"title":"AWS STS client configuration​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#aws-sts-client-configuration","content":" In addition to Vault configuration, you can configure certain aspects of the STS client the extension uses through the usual AWS environment variables. For example, if your Vault instance's IAM auth is configured to use regional STS endpoints:  $ vault write auth/aws/config/client \\ sts_endpoint=&quot;https://sts.eu-west-1.amazonaws.com&quot; \\ sts_region=&quot;eu-west-1&quot;   Then you may need to configure the extension's STS client to also use the regional STS endpoint by setting AWS_STS_REGIONAL_ENDPOINTS=regional, because both the AWS Golang SDK and Vault IAM auth method default to using the global endpoint in many regions. See documentation on sts_regional_endpoints for more information.  ","version":"Next","tagName":"h3"},{"title":"Caching​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#caching","content":" Caching can be configured for the extension's local proxy server so that it does not forward every HTTP request to Vault. The main consideration behind caching design is to make caching an explicit opt-in at the request level, so that it is only enabled for scenarios where caching makes sense without negative impact in others. To turn on caching, set the environment variableVAULT_DEFAULT_CACHE_TTL to a valid value that is parsable as a time.Duration in Go, for example, &quot;15m&quot;, &quot;1h&quot;, &quot;2m3s&quot; or &quot;1h2m3s&quot;, depending on application needs. An invalid or negative value will be treated the same as a missing value, in which case, caching will not be set up and enabled.  Then requests with HTTP method of &quot;GET&quot;, and the HTTP headerX-Vault-Cache-Control: cache will be returned directly from the cache if there's a cache hit. On a cache miss the request will be forwarded to Vault and the response returned and cached. If the header is set toX-Vault-Cache-Control: recache, the cache lookup will be skipped, and the request will be forwarded to Vault and the response returned and cached. Currently, the cache key is a hash of the request URL path, headers, body, and token.  Caching may also be enabled for all requests by setting the environment variableVAULT_DEFAULT_CACHE_ENABLED to true. Then all requests will be fetched and/or cached as though the header X-Vault-Cache-Control: cache was present. Setting the header to nocache on a request will opt-out of caching entirely in this configuration. Setting the header to recache will skip the cache lookup and return and cache the response from Vault as described previously.  warning Warning! The Vault Lambda Extension's cache is only in-memory and will not be persisted when the Lambda execution environment shuts down. In order words, the cache TTL is capped to the duration of the Lambda execution environment.  ","version":"Next","tagName":"h3"},{"title":"Limitations​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#limitations","content":" Secrets written to disk or returned from the proxy server will not be automatically refreshed when they expire. This is particularly important if you configure the extension to write secrets to disk, because the extension will only write to disk once per execution environment, rather than once per function invocation. If you use provisioned concurrency or if your Lambda is invoked often enough that execution contexts live beyond the lifetime of the secret, then secrets on disk are likely to become invalid.  In line with Lambda best practices, we recommend avoiding writing secrets to disk where possible, and exclusively consuming secrets via the proxy server. However, the proxy server will still not perform any additional processing with returned secrets such as automatic lease renewal. The proxy server's own Vault auth token is the only thing that gets automatically refreshed. It will synchronously refresh its own token before proxying requests if the token is expired (including a grace window), and it will attempt to renew its token if the token is nearly expired but renewable.  ","version":"Next","tagName":"h2"},{"title":"Performance impact​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#performance-impact","content":" AWS Lambda pricing is based on number of invocations, time of execution and memory used. The following table details some approximate performance related statistics to help assess the cost impact of this extension. Note that AWS Lambda allocates CPU power in proportion to memory so results will vary widely. These benchmarks were run with the minimum 128MB of memory allocated so aim to give an approximate baseline.  Metric\tValue\tDescription\tDerivationLayer size\t8.5MB\tThe size of the unpacked extension binary\tls -la Init latency\t8.5ms (standard deviation 2.4ms) + one network round trip to authenticate to Vault\tExtension initialization time in a new execution environment. Authentication round trip time will be highly deployment-dependent\tInstrumented in code Invoke latency\t&lt;1ms\tThe base processing time for each function invocation, assuming no calls to the proxy server\tInstrumented in code Memory impact\t12MB\tThe marginal impact on &quot;Max Memory Used&quot; when running the extension\tAs reported by Lambda when running Hello World function with and without extension  ","version":"Next","tagName":"h2"},{"title":"Uploading to your own AWS account and region​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#uploading-to-your-own-aws-account-and-region","content":" If you would like to upload the extension as a Lambda layer in your own AWS account and region, you can do the following:  $ curl --silent https://releases.hashicorp.com/vault-lambda-extension/0.5.0/vault-lambda-extension_0.5.0_linux_amd64.zip \\ --output vault-lambda-extension.zip   Set your target AWS region.  $ export REGION=&quot;YOUR REGION HERE&quot;   Upload the extension as a Lambda layer.  $ aws lambda publish-layer-version \\ --layer-name vault-lambda-extension \\ --zip-file &quot;fileb://vault-lambda-extension.zip&quot; \\ --region &quot;${REGION}&quot;   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Vault lambda extension","url":"/openbao/docs/platform/aws/lambda-extension/#tutorial","content":" For step-by-step instructions, refer to the Vault AWS Lambda Extension tutorial for details on how to create an AWS Lambda function and use the Vault Lambda Extension to authenticate with Vault. ","version":"Next","tagName":"h2"},{"title":"Command line arguments","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/csi/configurations/","content":"Command line arguments The following command line arguments are supported by the Vault CSI provider. Most settings support being set by, in ascending order of precedence: Environment variablesCommand line argumentsSecret Provider Class parameters If installing via the helm chart, they can be set using e.g.--set &quot;csi.extraArgs={-debug=true}&quot;. -cache-size (int: 1000) - Set the maximum number of Vault tokens that will be cached in-memory. One Vault token will be stored for each pod on the same node that mounts secrets. Setting to 0 will disable the cache and force each volume mount request to reauthenticate to Vault. -debug (bool: false) - Set to true to enable debug level logging. -endpoint (string: &quot;/tmp/vault.sock&quot;) - Path to unix socket on which the provider will listen for gRPC calls from the driver. -health-addr (string: &quot;:8080&quot;) - The address of the HTTP listener for reporting health. -hmac-secret-name (string: &quot;vault-csi-provider-hmac-key&quot;) - Configure the Kubernetes secret name that the provider creates to store an HMAC key for generating secret version hashes. -vault-addr (string: &quot;https://127.0.0.1:8200&quot;) - Default address for connecting to Vault. Can also be specified via the VAULT_ADDR environment variable. Note: It is highly recommended to only set the Vault address when installing the helm chart. The helm chart will install Vault Agent as a sidecar to the Vault CSI Provider for caching and renewals, but setting -vault-addrhere will cause the Vault CSI Provider to bypass the Agent's cache. -vault-mount (string: &quot;kubernetes&quot;) - Default Vault mount path for Kubernetes authentication. Can be overridden per Secret Provider Class object. -vault-namespace (string: &quot;&quot;) - (v1.1.0+) Default Vault namespace for Vault requests. Can also be specified via the VAULT_NAMESPACE environment variable. -vault-tls-ca-cert (string: &quot;&quot;) - (v1.1.0+) Path on disk to a single PEM-encoded CA certificate to trust for Vault. Takes precendence over-vault-tls-ca-directory. Can also be specified via the VAULT_CACERTenvironment variable. -vault-tls-ca-directory (string: &quot;&quot;) - (v1.1.0+) Path on disk to a directory of PEM-encoded CA certificates to trust for Vault. Can also be specified via the VAULT_CAPATH environment variable. -vault-tls-server-name (string: &quot;&quot;) - (v1.1.0+) Name to use as the SNI host when connecting to Vault via TLS. Can also be specified via theVAULT_TLS_SERVER_NAME environment variable. -vault-tls-client-cert (string: &quot;&quot;) - (v1.1.0+) Path on disk to a PEM-encoded client certificate for mTLS communication with Vault. If set, also requires -vault-tls-client-key. Can also be specified via theVAULT_CLIENT_CERT environment variable. -vault-tls-client-key (string: &quot;&quot;) - (v1.1.0+) Path on disk to a PEM-encoded client key for mTLS communication with Vault. If set, also requires -vault-tls-client-cert. Can also be specified via theVAULT_CLIENT_KEY environment variable. -vault-tls-skip-verify (bool: false) - (v1.1.0+) Disable verification of TLS certificates. Can also be specified via the VAULT_SKIP_VERIFY environment variable. -version (bool: false) - print version information and exit. Secret provider class parameters The following parameters are supported by the Vault provider. Each parameter is an entry under spec.parameters in a SecretProviderClass object. The full structure is illustrated in the examples. roleName (string: &quot;&quot;) - Name of the role to be used during login with Vault. vaultAddress (string: &quot;&quot;) - The address of the Vault server. Note: It is highly recommended to only set the Vault address when installing the helm chart. The helm chart will install Vault Agent as a sidecar to the Vault CSI Provider for caching and renewals, but setting vaultAddress here will cause the Vault CSI Provider to bypass the Agent's cache. vaultSkipTLSVerify (string: &quot;false&quot;) - When set to true, skips verification of the Vault server certificate. Setting this to true is not recommended for production. vaultCACertPath (string: &quot;&quot;) - The path on disk where the Vault CA certificate can be found when verifying the Vault server certificate. vaultCADirectory (string: &quot;&quot;) - The directory on disk where the Vault CA certificate can be found when verifying the Vault server certificate. vaultTLSClientCertPath (string: &quot;&quot;) - The path on disk where the client certificate can be found for mTLS communications with Vault. vaultTLSClientKeyPath (string: &quot;&quot;) - The path on disk where the client key can be found for mTLS communications with Vault. vaultTLSServerName (string: &quot;&quot;) - The name to use as the SNI host when connecting via TLS. vaultAuthMountPath (string: &quot;kubernetes&quot;) - The name of the auth mount used for login. Can be a Kubernetes or JWT auth mount. Mutually exclusive with vaultKubernetesMountPath. vaultKubernetesMountPath (string: &quot;kubernetes&quot;) - The name of the auth mount used for login. Can be a Kubernetes or JWT auth mount. Mutually exclusive with vaultAuthMountPath. audience (string: &quot;&quot;) - Specifies a custom audience for the requesting pod's service account token, generated using theTokenRequest API. The resulting token is used to authenticate to Vault, so if you specify anaudience for your Kubernetes auth role, it must match the audience specified here. If not set, the token audiences will default to the Kubernetes cluster's default API audiences. objects (array) - An array of secrets to retrieve from Vault. objectName (string: &quot;&quot;) - The alias of the object which can be referenced within the secret provider class and the name of the secret file. method (string: &quot;GET&quot;) - The type of HTTP request. Supported values include &quot;GET&quot; and &quot;PUT&quot;. secretPath (string: &quot;&quot;) - The path in Vault where the secret is located. For secrets that are retrieved via HTTP GET method, the secretPath can include optional URI parameters, for example, the version of the KV2 secret: objects: | - objectName: &quot;app-secret&quot; secretPath: &quot;secret/data/test?version=1&quot; secretKey: &quot;password&quot; secretKey (string: &quot;&quot;) - The key in the Vault secret to extract. If omitted, the whole response from Vault will be written as JSON. filePermission (integer: 0o644) - The file permissions to set for this secret's file. encoding (string: &quot;utf-8&quot;) - The encoding of the secret value. Supports decoding utf-8 (default), hex, and base64 values. secretArgs (map: {}) - Additional arguments to be sent to Vault for a specific secret. Arguments can vary for different secret engines. For example: secretArgs: common_name: 'test.example.com' ttl: '24h' secretArgs are sent as part of the HTTP request body. Therefore, they are only effective for HTTP PUT/POST requests, for instance, the request used to generate a new certificate. To supply additional parameters for secrets retrieved via HTTP GET, include optional URI parameters in secretPath.","keywords":"","version":"Next"},{"title":"Vault CSI provider examples","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/csi/examples/","content":"","keywords":"","version":"Next"},{"title":"File based dynamic database credentials​","type":1,"pageTitle":"Vault CSI provider examples","url":"/openbao/docs/platform/k8s/csi/examples/#file-based-dynamic-database-credentials","content":" The following Secret Provider Class retrieves dynamic database credentials from Vault and extracts the generated username and password. The secrets are then mounted as files in the configured mount location.  --- apiVersion: secrets-store.csi.x-k8s.io/v1alpha1 kind: SecretProviderClass metadata: name: vault-db-creds spec: provider: vault parameters: roleName: 'app' objects: | - objectName: &quot;dbUsername&quot; secretPath: &quot;database/creds/db-app&quot; secretKey: &quot;username&quot; - objectName: &quot;dbPassword&quot; secretPath: &quot;database/creds/db-app&quot; secretKey: &quot;password&quot;   Next, a pod can be created to use this Secret Provider Class to populate the secrets in the pod:  apiVersion: apps/v1 kind: Deployment metadata: name: app labels: app: demo spec: selector: matchLabels: app: demo replicas: 1 template: metadata: annotations: labels: app: demo spec: serviceAccountName: app containers: - name: app image: my-app:1.0.0 volumeMounts: - name: 'vault-db-creds' mountPath: '/mnt/secrets-store' readOnly: true volumes: - name: vault-db-creds csi: driver: 'secrets-store.csi.k8s.io' readOnly: true volumeAttributes: secretProviderClass: 'vault-db-creds'   The pod mounts a CSI volume and specifies the Secret Provider Class (vault-db-creds) created above. The secrets created from that provider class are mounted to /mnt/secrets-store. When this pod is created the containers will find two files containing secrets:  /mnt/secrets-store/dbUsername/mnt/secrets-store/dbPassword  ","version":"Next","tagName":"h2"},{"title":"Environment variable dynamic database credentials​","type":1,"pageTitle":"Vault CSI provider examples","url":"/openbao/docs/platform/k8s/csi/examples/#environment-variable-dynamic-database-credentials","content":" The following Secret Provider Class retrieves dynamic database credentials from Vault and extracts the generated username and password. The secrets are then synced to Kubernetes secrets so that they can be mounted as environment variables in the containers.  --- apiVersion: secrets-store.csi.x-k8s.io/v1alpha1 kind: SecretProviderClass metadata: name: vault-db-creds spec: provider: vault secretObjects: - secretName: vault-db-creds-secret type: Opaque data: - objectName: dbUsername # References dbUsername below key: username # Key within k8s secret for this value - objectName: dbPassword key: password parameters: roleName: 'app' objects: | - objectName: &quot;dbUsername&quot; secretPath: &quot;database/creds/db-app&quot; secretKey: &quot;username&quot; - objectName: &quot;dbPassword&quot; secretPath: &quot;database/creds/db-app&quot; secretKey: &quot;password&quot;   Next, a pod can be created which uses this Secret Provider Class to populate the secrets in the pod's environment:  apiVersion: apps/v1 kind: Deployment metadata: name: app labels: app: demo spec: selector: matchLabels: app: demo replicas: 1 template: metadata: annotations: labels: app: demo spec: serviceAccountName: app containers: - name: app image: my-app:1.0.0 env: - name: DB_USERNAME valueFrom: secretKeyRef: name: vault-db-creds-secret key: username - name: DB_PASSWORD valueFrom: secretKeyRef: name: vault-db-creds-secret key: password volumeMounts: - name: 'vault-db-creds' mountPath: '/mnt/secrets-store' readOnly: true volumes: - name: vault-db-creds csi: driver: 'secrets-store.csi.k8s.io' readOnly: true volumeAttributes: secretProviderClass: 'vault-db-creds'   The pod mounts a CSI volume and specifies the Secret Provider Class (vault-db-creds) created above. The secrets created from that provider class are mounted to /mnt/secrets-store, additionally a Kubernetes secret called vault-db-creds is created and referenced in two environment variables. ","version":"Next","tagName":"h2"},{"title":"Vault CSI provider","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/csi/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/#overview","content":" At a high level, the CSI Secrets Store driver allows users to create SecretProviderClass objects. This object defines which secret provider to use and what secrets to retrieve. When pods requesting CSI volumes are created, the CSI Secrets Store driver will send the request to the Vault CSI Provider if the provider is vault. The Vault CSI Provider will then use Secret Provider Class specified and the pod's service account to retrieve the secrets from Vault, and mount them into the pod's CSI volume.  The secret is retrieved from Vault and populated to the CSI secrets store volume during the ContainerCreation phase. This means that pods will be blocked from starting until the secrets have been read from Vault and written to the volume.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/#features","content":" The following features are supported by the Vault CSI Provider:  All Vault secret engines supported.Authentication using the requesting pod's service account.TLS/mTLS communications with Vault.Rendering Vault secrets to files.Dynamic lease caching and renewal performed by Agent.Syncing secrets to Kubernetes secrets to be used as environment variables.Installation via Vault Helm  ","version":"Next","tagName":"h3"},{"title":"Supported kubernetes versions","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/##","content":" The following Kubernetes minor releases are currently supported. The latest version is tested against each Kubernetes version. It may work with other versions of Kubernetes, but those are not supported.  1.271.261.251.241.23  ","version":"Next","tagName":"h2"},{"title":"Authenticating with Vault​","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/#authenticating-with-vault","content":" The Vault CSI Provider will authenticate with Vault as the service account of the pod that mounts the CSI volume. Kubernetes andJWT auth methods are supported. The pod's service account must be bound to a Vault role and a policy granting access to the secrets desired.  It is highly recommended to run pods with dedicated Kubernetes service accounts to ensure applications cannot access more secrets than they require.  ","version":"Next","tagName":"h2"},{"title":"Secret provider class example​","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/#secret-provider-class-example","content":" The following is an example of a Secret Provider Class using the vault provider:  --- apiVersion: secrets-store.csi.x-k8s.io/v1alpha1 kind: SecretProviderClass metadata: name: vault-db-creds spec: # Vault CSI Provider provider: vault parameters: # Vault role name to use during login roleName: 'app' # Vault address and TLS connection config is normally best configured by the # helm chart, but can be overridden per SecretProviderClass: # Vault's hostname #vaultAddress: 'https://vault:8200' # TLS CA certification for validation #vaultCACertPath: '/vault/tls/ca.crt' objects: | - objectName: &quot;dbUsername&quot; secretPath: &quot;database/creds/db-app&quot; secretKey: &quot;username&quot; - objectName: &quot;dbPassword&quot; secretPath: &quot;database/creds/db-app&quot; secretKey: &quot;password&quot; # &quot;objectName&quot; is an alias used within the SecretProviderClass to reference # that specific secret. This will also be the filename containing the secret. # &quot;secretPath&quot; is the path in Vault where the secret should be retrieved. # &quot;secretKey&quot; is the key within the Vault secret response to extract a value from.   warning Secret Provider Class is a namespaced object in Kubernetes.  ","version":"Next","tagName":"h2"},{"title":"Using secret provider classes​","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/#using-secret-provider-classes","content":" An application pod uses the example Secret Provider Class above by mounting it as a CSI volume:  --- apiVersion: apps/v1 kind: Deployment metadata: name: app labels: app: demo spec: selector: matchLabels: app: demo replicas: 1 template: spec: serviceAccountName: app containers: - name: app image: my-app:1.0.0 volumeMounts: - name: 'vault-db-creds' mountPath: '/mnt/secrets-store' readOnly: true volumes: - name: vault-db-creds csi: driver: 'secrets-store.csi.k8s.io' readOnly: true volumeAttributes: secretProviderClass: 'vault-db-creds'   In this example volumes.csi is created on the application deployment and references the Secret Provider Class named vault-db-creds.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/#tutorial","content":" Refer to the Vault CSI Providertutorial to learn how to set up Vault and its dependencies with a Helm chart. ","version":"Next","tagName":"h2"},{"title":"Installing the Vault CSI provider","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/csi/installation/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/installation/#prerequisites","content":" Kubernetes 1.16+ for both the master and worker nodes (Linux-only)Secrets store CSI driver installedTokenRequest endpoint available, which requires setting the flags--service-account-signing-key-file and --service-account-issuer forkube-apiserver. Set by default from 1.20+ and earlier in most managed services.  ","version":"Next","tagName":"h2"},{"title":"Installation using helm​","type":1,"pageTitle":"Installing the Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/installation/#installation-using-helm","content":" The Vault Helm chart is the recommended way to install and configure the Vault CSI Provider in Kubernetes.  To install a new instance of Vault and the Vault CSI Provider, first add the HashiCorp helm repository and ensure you have access to the chart:  warning Note: Vault CSI Provider Helm installation requires Vault Helm 0.10.0+.  $ helm repo add hashicorp https://helm.releases.hashicorp.com &quot;hashicorp&quot; has been added to your repositories $ helm search repo hashicorp/vault NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart   Then install the chart and enable the CSI feature by setting thecsi.enabled value to true:  warning Note: this will also install the Vault server and Agent Injector.  $ helm install vault hashicorp/vault --set=&quot;csi.enabled=true&quot;   Upgrades may be performed with helm upgrade on an existing installation. Please always run Helm with --dry-run before any install or upgrade to verify changes.  You can see all the available values settings by running helm inspect values hashicorp/vault or by reading the Vault Helm Configuration Docs. Commonly used values in the Helm chart include limiting the namespaces the Vault CSI Provider runs in, TLS options and more.  ","version":"Next","tagName":"h2"},{"title":"Installation on OpenShift​","type":1,"pageTitle":"Installing the Vault CSI provider","url":"/openbao/docs/platform/k8s/csi/installation/#installation-on-openshift","content":" We recommend using the Vault agent injector on Openshiftinstead of the Secrets Store CSI driver. OpenShiftdoes not recommendusing hostPath mounting in production orcertify Helm chartsusing CSI objects because pods must run as privileged. Pods will have elevated access to other pods on the same node, which OpenShift does not recommend.  You can run the Secrets Store CSI driver with additional security configurations on a OpenShift development or testing cluster.  Deploy the Secrets Store CSI driver and Vault Helm chart to your OpenShift cluster.  Then, patch the DaemonSet for the Vault CSI provider to run with a privileged security context.  $ kubectl patch daemonset vault-csi-provider \\ --type='json' \\ --patch='[{&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/securityContext&quot;, &quot;value&quot;: {&quot;privileged&quot;: true} }]'   The Secrets Store CSI driver and Vault CSI provider need hostPath mount access. Add the service account for the Secrets Store CSI driver to the privilegedsecurity context constraint.  $ oc adm policy add-scc-to-user privileged system:serviceaccount:${KUBERNETES_VAULT_NAMESPACE}:secrets-store-csi-driver   Add the service account for the Vault CSI provider to the privilegedsecurity context constraint.  $ oc adm policy add-scc-to-user privileged system:serviceaccount:${KUBERNETES_VAULT_NAMESPACE}:vault-csi-provider   You need to give additional access to the application retrieving secrets with the Vault CSI provider. Create a SecurityContextConstraint to allowHostDirVolumePlugin, allowHostDirVolumePlugin, andallowHostPorts for the application's service account. You can adjust the other attributes based on your application's runtime configuration.  $ cat &gt; application-scc.yaml &lt;&lt; EOF apiVersion: security.openshift.io/v1 kind: SecurityContextConstraints metadata: name: vault-csi-provider allowPrivilegedContainer: false allowHostDirVolumePlugin: true allowHostNetwork: true allowHostPorts: true allowHostIPC: false allowHostPID: false readOnlyRootFilesystem: false defaultAddCapabilities: - SYS_ADMIN runAsUser: type: RunAsAny seLinuxContext: type: RunAsAny fsGroup: type: RunAsAny users: - system:serviceaccount:${KUBERNETES_APPLICATION_NAMESPACE}:${APPLICATION_SERVICE_ACCOUNT} EOF   Add the security context constraint for the application.  $ kubectl apply -f application-scc.yaml  ","version":"Next","tagName":"h2"},{"title":"Helm chart","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/","content":"","keywords":"","version":"Next"},{"title":"Supported kubernetes versions","type":1,"pageTitle":"Helm chart","url":"/openbao/docs/platform/k8s/helm/##","content":" The following Kubernetes minor releases are currently supported. The latest version is tested against each Kubernetes version. It may work with other versions of Kubernetes, but those are not supported.  1.271.261.251.241.23  ","version":"Next","tagName":"h2"},{"title":"Using the helm chart​","type":1,"pageTitle":"Helm chart","url":"/openbao/docs/platform/k8s/helm/#using-the-helm-chart","content":" Helm must be installed and configured on your machine. Please refer to the Helm documentation or the Vault Installation to Minikube via Helm tutorial.  To use the Helm chart, add the Hashicorp helm repository and check that you have access to the chart:  $ helm repo add hashicorp https://helm.releases.hashicorp.com &quot;hashicorp&quot; has been added to your repositories $ helm search repo hashicorp/vault NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart   info Important: The Helm chart is new and under significant development. Please always run Helm with --dry-run before any install or upgrade to verify changes.  Example chart usage:  Installing the latest release of the Vault Helm chart with pods prefixed with the name vault.  $ helm install vault hashicorp/vault   Installing a specific version of the chart.  # List the available releases $ helm search repo hashicorp/vault -l NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart hashicorp/vault\t0.24.0 1.13.1 Official HashiCorp Vault Chart hashicorp/vault\t0.23.0 1.12.1 Official HashiCorp Vault Chart hashicorp/vault\t0.22.1 1.12.0 Official HashiCorp Vault Chart hashicorp/vault\t0.22.0 1.11.3 Official HashiCorp Vault Chart hashicorp/vault\t0.21.0 1.11.2 Official HashiCorp Vault Chart hashicorp/vault\t0.20.1 1.10.3 Official HashiCorp Vault Chart ... # Install version 0.25.0 $ helm install vault hashicorp/vault --version 0.25.0   warning Security Warning: By default, the chart runs in standalone mode. This mode uses a single Vault server with a file storage backend. This is a less secure and less resilient installation that is NOT appropriate for a production setup. It is highly recommended to use a properly secured Kubernetes cluster,learn the available configuration options, and read the production deployment checklist.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Helm chart","url":"/openbao/docs/platform/k8s/helm/#tutorial","content":" Refer to the Kubernetestutorials series to learn how to run Vault on Kubernetes. ","version":"Next","tagName":"h2"},{"title":"Helm chart examples","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/","content":"","keywords":"","version":"Next"},{"title":"Tutorial​","type":1,"pageTitle":"Helm chart examples","url":"/openbao/docs/platform/k8s/helm/examples/#tutorial","content":" Refer to the Run Vault on Kubernetestutorial series to learn how to run Vault on Kubernetes. ","version":"Next","tagName":"h2"},{"title":"Development","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/development/","content":"","keywords":"","version":"Next"},{"title":"Tutorial​","type":1,"pageTitle":"Development","url":"/openbao/docs/platform/k8s/helm/examples/development/#tutorial","content":" Refer to the Injecting Secrets into Kubernetes Pods via Vault Helm Sidecar tutorial to learn how to set up Vault and the Vault Agent Injector service with the Vault Helm chart. ","version":"Next","tagName":"h2"},{"title":"HA Cluster with Raft and TLS","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/ha-tls/","content":"","keywords":"","version":"Next"},{"title":"External Vault","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/external/","content":"","keywords":"","version":"Next"},{"title":"Learn​","type":1,"pageTitle":"External Vault","url":"/openbao/docs/platform/k8s/helm/examples/external/#learn","content":" Refer to the Integrate a Kubernetes Cluster with an External Vaultguide for a step-by-step tutorial. ","version":"Next","tagName":"h2"},{"title":"Before you start​","type":1,"pageTitle":"HA Cluster with Raft and TLS","url":"/openbao/docs/platform/k8s/helm/examples/ha-tls/#before-you-start","content":" Follow the steps from the example HA Vault Cluster with Integrated Storage to build the cluster. Follow the examples and instructions in Standalone Server with TLS to create a TLS certificate.  ","version":"Next","tagName":"h2"},{"title":"Solution 1: Use auto-join and set the TLS server in your Raft configuration​","type":1,"pageTitle":"HA Cluster with Raft and TLS","url":"/openbao/docs/platform/k8s/helm/examples/ha-tls/#solution-1-use-auto-join-and-set-the-tls-server-in-your-raft-configuration","content":" The join warning disappears if you use auto-join and set the expected TLS server name (${CN}) withleader_tls_servernamein the Raft stanza for your Vault configuration.  For example:  storage &quot;raft&quot; { path = &quot;/vault/data&quot; retry_join { leader_api_addr = &quot;https://vault-0.${SERVICE}:8200&quot; leader_tls_servername = &quot;${CN}&quot; leader_client_cert_file = &quot;/vault/tls/vault.crt&quot; leader_client_key_file = &quot;/vault/tls/vault.key&quot; leader_ca_cert_file = &quot;/vault/tls/vault.ca&quot; } retry_join { leader_api_addr = &quot;https://vault-1.${SERVICE}:8200&quot; leader_tls_servername = &quot;${CN}&quot; leader_client_cert_file = &quot;/vault/tls/vault.crt&quot; leader_client_key_file = &quot;/vault/tls/vault.key&quot; leader_ca_cert_file = &quot;/vault/tls/vault.ca&quot; } retry_join { leader_api_addr = &quot;https://vault-2.${SERVICE}:8200&quot; leader_tls_servername = &quot;${CN}&quot; leader_client_cert_file = &quot;/vault/tls/vault.crt&quot; leader_client_key_file = &quot;/vault/tls/vault.key&quot; leader_ca_cert_file = &quot;/vault/tls/vault.ca&quot; } }   ","version":"Next","tagName":"h2"},{"title":"Solution 2: Add a load balancer to your Raft configuration​","type":1,"pageTitle":"HA Cluster with Raft and TLS","url":"/openbao/docs/platform/k8s/helm/examples/ha-tls/#solution-2--add-a-load-balancer-to-your-raft-configuration","content":" If you have a load balancer for your Vault cluster, you can add a singleretry_join stanza to your Raft configuration and use the load balancer address for leader_api_addr.  For example:  storage &quot;raft&quot; { path = &quot;/vault/data&quot; retry_join { leader_api_addr = &quot;https://vault-active:8200&quot; leader_client_cert_file = &quot;/vault/tls/vault.crt&quot; leader_client_key_file = &quot;/vault/tls/vault.key&quot; leader_ca_cert_file = &quot;/vault/tls/vault.ca&quot; } }  ","version":"Next","tagName":"h2"},{"title":"Highly available Vault cluster with integrated storage (Raft)","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/ha-with-raft/","content":"Highly available Vault cluster with integrated storage (Raft) warning Important Note: This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart. Integrated storage (raft) can be enabled using the server.ha.raft.enabled value: helm install vault hashicorp/vault \\ --set='server.ha.enabled=true' \\ --set='server.ha.raft.enabled=true' Next, initialize and unseal vault-0 pod: kubectl exec -ti vault-0 -- vault operator init kubectl exec -ti vault-0 -- vault operator unseal Finally, join the remaining pods to the Raft cluster and unseal them. The pods will need to communicate directly so we'll configure the pods to use the internal service provided by the Helm chart: kubectl exec -ti vault-1 -- vault operator raft join http://vault-0.vault-internal:8200 kubectl exec -ti vault-1 -- vault operator unseal kubectl exec -ti vault-2 -- vault operator raft join http://vault-0.vault-internal:8200 kubectl exec -ti vault-2 -- vault operator unseal To verify if the Raft cluster has successfully been initialized, run the following. First, login using the root token on the vault-0 pod: kubectl exec -ti vault-0 -- vault login Next, list all the raft peers: $ kubectl exec -ti vault-0 -- vault operator raft list-peers Node Address State Voter ---- ------- ----- ----- a1799962-8711-7f28-23f0-cea05c8a527d vault-0.vault-internal:8201 leader true e6876c97-aaaa-a92e-b99a-0aafab105745 vault-1.vault-internal:8201 follower true 4b5d7383-ff31-44df-e008-6a606828823b vault-2.vault-internal:8201 follower true Vault with Integrated Storage (Raft) is now ready to use!","keywords":"","version":"Next"},{"title":"Bootstrapping kubernetes auth method","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/kubernetes-auth/","content":"Bootstrapping kubernetes auth method warning Important Note: This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart. In this example, we will walk through how to set up the Kubernetes Auth Method. This assumes the following commands will be run inside a Vault pod running in Kubernetes. Exec into the Vault pod: kubectl exec -it vault-0 -- /bin/sh If you didn't set server.dev.enabled=true, you'll need to log in to Vault first using vault login. Then run the following commands to configure the Kubernetes Auth Method: vault auth enable kubernetes vault write auth/kubernetes/config \\ kubernetes_host=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT From here you can continue to configure Vault from the Kubernetes Auth Method documentation.","keywords":"","version":"Next"},{"title":"Vault agent injector TLS with Cert-Manager","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls-cert-manager/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Vault agent injector TLS with Cert-Manager","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls-cert-manager/#prerequisites","content":" Install cert-manager if not already installed (see the cert-manager documentation). For example, with helm:  $ helm repo add jetstack https://charts.jetstack.io $ helm repo update $ helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --set installCRDs=true   ","version":"Next","tagName":"h2"},{"title":"Create a certificate authority (CA)​","type":1,"pageTitle":"Vault agent injector TLS with Cert-Manager","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls-cert-manager/#create-a-certificate-authority-ca","content":" For this example we will bootstrap a self-signed certificate authority (CA) Issuer. If you already have a ClusterIssuer configured for your cluster, you may skip this step.  apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: selfsigned spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: injector-selfsigned-ca spec: isCA: true commonName: Agent Inject CA secretName: injector-ca-secret duration: 87660h # 10 years privateKey: algorithm: ECDSA size: 256 issuerRef: name: selfsigned kind: Issuer group: cert-manager.io --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: injector-ca-issuer spec: ca: secretName: injector-ca-secret   Save that to a file named ca-issuer.yaml, and apply to your Kubernetes cluster:  $ kubectl apply -n vault -f ca-issuer.yaml issuer.cert-manager.io/selfsigned created certificate.cert-manager.io/injector-selfsigned-ca created issuer.cert-manager.io/injector-ca-issuer created $ kubectl -n vault get issuers -o wide NAME READY STATUS AGE injector-ca-issuer True Signing CA verified 7s selfsigned True 7s $ kubectl -n vault get certificates injector-selfsigned-ca -o wide NAME READY SECRET ISSUER STATUS AGE injector-selfsigned-ca True injector-ca-secret selfsigned Certificate is up to date and has not expired 32s   ","version":"Next","tagName":"h2"},{"title":"Create the Vault agent injector certificate​","type":1,"pageTitle":"Vault agent injector TLS with Cert-Manager","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls-cert-manager/#create-the-vault-agent-injector-certificate","content":" Next we can create a request for cert-manager to generate a certificate and key signed by the certificate authority above. This certificate and key will be used by the Vault Agent Injector for TLS communications with the Kubernetes API.  The Certificate request object references the CA issuer created above, and specifies the name of the Secret where the CA, Certificate, and Key will be stored by cert-manager.  apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: injector-certificate spec: secretName: injector-tls duration: 24h renewBefore: 144m # roughly 10% of 24h dnsNames: - vault-agent-injector-svc - vault-agent-injector-svc.vault - vault-agent-injector-svc.vault.svc issuerRef: name: injector-ca-issuer commonName: Agent Inject Cert   warning Important Note: The dnsNames for the certificate must be configured to use the name of the Vault Agent Injector Kubernetes service and namespace where it is deployed.  In this example the Vault Agent Injector service name is vault-agent-injector-svc in the vault namespace. This uses the pattern &lt;k8s service name&gt;.&lt;k8s namespace&gt;.svc.  Save the Certificate yaml to a file and apply to your cluster:  $ kubectl -n vault apply -f injector-certificate.yaml certificate.cert-manager.io/injector-certificate created $ kubectl -n vault get certificates injector-certificate -o wide NAME READY SECRET ISSUER STATUS AGE injector-certificate True injector-tls injector-ca-issuer Certificate is up to date and has not expired 41s $ kubectl -n vault get secret injector-tls NAME TYPE DATA AGE injector-tls kubernetes.io/tls 3 6m59s   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Vault agent injector TLS with Cert-Manager","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls-cert-manager/#configuration","content":" Now that a certificate authority and a signed certificate have been created, we can now configure Helm and the Vault Agent Injector to use them.  Install the Vault Agent Injector with the following custom values:  $ helm install vault hashicorp/vault \\ --namespace=vault \\ --set injector.replicas=2 \\ --set injector.leaderElector.enabled=false \\ --set injector.certs.secretName=injector-tls \\ --set injector.webhook.annotations=&quot;cert-manager.io/inject-ca-from: {{ .Release.Namespace }}/injector-certificate&quot;  ","version":"Next","tagName":"h2"},{"title":"Standalone server with audit storage","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/standalone-audit/","content":"Standalone server with audit storage warning Important Note: This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart. The below values.yaml can be used to set up a single server Vault cluster with auditing enabled. server: standalone: enabled: true config: | listener &quot;tcp&quot; { tls_disable = true address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; } storage &quot;file&quot; { path = &quot;/vault/data&quot; } service: enabled: true dataStorage: enabled: true size: 10Gi storageClass: null accessMode: ReadWriteOnce auditStorage: enabled: true size: 10Gi storageClass: null accessMode: ReadWriteOnce After Vault has been deployed, initialized and unsealed, auditing can be enabled by running the following command against the Vault pod: $ kubectl exec -ti &lt;POD NAME&gt; -- vault audit enable file file_path=/vault/audit/vault_audit.log ","keywords":"","version":"Next"},{"title":"Vault agent injector TLS configuration","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls/","content":"","keywords":"","version":"Next"},{"title":"Create a certificate authority (CA)​","type":1,"pageTitle":"Vault agent injector TLS configuration","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls/#create-a-certificate-authority-ca","content":" First, create a private key to be used by our custom Certificate Authority (CA):  $ openssl genrsa -out injector-ca.key 2048   Next, create a certificate authority certificate:  warning Important Note: Values such as days (how long the certificate is valid for) should be configured for your environment.  $ openssl req \\ -x509 \\ -new \\ -nodes \\ -key injector-ca.key \\ -sha256 \\ -days 1825 \\ -out injector-ca.crt \\ -subj &quot;/C=US/ST=CA/L=San Francisco/O=HashiCorp/CN=vault-agent-injector-svc&quot;   ","version":"Next","tagName":"h2"},{"title":"Create Vault agent injector certificate​","type":1,"pageTitle":"Vault agent injector TLS configuration","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls/#create-vault-agent-injector-certificate","content":" Next we can create a certificate and key signed by the certificate authority generated above. This certificate and key will be used by the Vault Agent Injector for TLS communications with the Kubernetes API.  First, create a private key for the certificate:  $ openssl genrsa -out tls.key 2048   Next, create a certificate signing request (CSR) to be used when signing the certificate:  $ openssl req \\ -new \\ -key tls.key \\ -out tls.csr \\ -subj &quot;/C=US/ST=CA/L=San Francisco/O=HashiCorp/CN=vault-agent-injector-svc&quot;   After creating the CSR, create an extension file to configure additional parameters for signing the certificate.  warning Important Note: The alternative names for the certificate must be configured to use the name of the Vault Agent Injector Kubernetes service and namespace where its created.  In this example the Vault Agent Injector service name is vault-agent-injector-svc in the vault namespace. This uses the pattern &lt;k8s service name&gt;.&lt;k8s namespace&gt;.svc.cluster.local.  $ cat &lt;&lt;EOF &gt;csr.conf authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = @alt_names [alt_names] DNS.1 = vault-agent-injector-svc DNS.2 = vault-agent-injector-svc.vault DNS.3 = vault-agent-injector-svc.vault.svc DNS.4 = vault-agent-injector-svc.vault.svc.cluster.local EOF   Finally, sign the certificate:  warning Important Note: Values such as days (how long the certificate is valid for) should be configured for your environment.  $ openssl x509 \\ -req \\ -in tls.csr \\ -CA injector-ca.crt \\ -CAkey injector-ca.key \\ -CAcreateserial \\ -out tls.crt \\ -days 1825 \\ -sha256 \\ -extfile csr.conf   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Vault agent injector TLS configuration","url":"/openbao/docs/platform/k8s/helm/examples/injector-tls/#configuration","content":" Now that a certificate authority and a signed certificate have been created, we can now configure Helm and the Vault Agent Injector to use them.  First, create a Kubernetes secret containing the certificate and key created above:  warning Important Note: This example assumes the Vault Agent Injector is running in the vault namespace.  $ kubectl create secret generic injector-tls \\ --from-file tls.crt \\ --from-file tls.key \\ --namespace=vault   Next, base64 encode the certificate authority so Kubernetes can verify the authenticity of the certificate:  $ export CA_BUNDLE=$(cat injector-ca.crt | base64)   Finally, install the Vault Agent Injector with the following custom values:  $ helm install vault hashicorp/vault \\ --namespace=vault \\ --set=&quot;injector.certs.secretName=injector-tls&quot; \\ --set=&quot;injector.certs.caBundle=${CA_BUNDLE?}&quot;  ","version":"Next","tagName":"h2"},{"title":"Standalone server with load balanced UI","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/standalone-load-balanced-ui/","content":"Standalone server with load balanced UI warning Important Note: This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart. The below values.yaml can be used to set up a single server Vault cluster with a LoadBalancer to allow external access to the UI and API. server: standalone: enabled: true config: | ui = true listener &quot;tcp&quot; { tls_disable = 1 address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; } storage &quot;file&quot; { path = &quot;/vault/data&quot; } service: enabled: true dataStorage: enabled: true size: 10Gi storageClass: null accessMode: ReadWriteOnce ui: enabled: true serviceType: LoadBalancer ","keywords":"","version":"Next"},{"title":"Run Vault on OpenShift","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/openshift/","content":"","keywords":"","version":"Next"},{"title":"Requirements​","type":1,"pageTitle":"Run Vault on OpenShift","url":"/openbao/docs/platform/k8s/helm/openshift/#requirements","content":" The following are required to install Vault and Vault Agent Injector on OpenShift:  Cluster Admin privileges to bind the auth-delegator role to Vault's service accountHelm v3.6+OpenShift 4.3+Vault Helm v0.6.0+Vault K8s v0.4.0+  warning Note: Support for Consul on OpenShift is available since Consul 1.9. However, for highly available deployments, Raft integrated storage is recommended.  ","version":"Next","tagName":"h2"},{"title":"Additional resources​","type":1,"pageTitle":"Run Vault on OpenShift","url":"/openbao/docs/platform/k8s/helm/openshift/#additional-resources","content":" The documentation, configuration and examples for Vault Helm and Vault K8s Agent Injector are applicable to OpenShift installations. For more examples see the existing documentation:  Vault Helm documentationVault K8s documentation  ","version":"Next","tagName":"h2"},{"title":"Helm chart​","type":1,"pageTitle":"Run Vault on OpenShift","url":"/openbao/docs/platform/k8s/helm/openshift/#helm-chart","content":" The Vault Helm chartis the recommended way to install and configure Vault on OpenShift. In addition to running Vault itself, the Helm chart is the primary method for installing and configuring Vault Agent Injection Mutating Webhook.  While the Helm chart automatically sets up complex resources and exposes the configuration to meet your requirements, it does not automatically operate Vault. You are still responsible for learning how to monitor, backup, upgrade, etc. the Vault cluster.  warning Security Warning: By default, the chart runs in standalone mode. This mode uses a single Vault server with a file storage backend. This is a less secure and less resilient installation that is NOT appropriate for a production setup. It is highly recommended to use a properly secured Kubernetes cluster,learn the available configuration options, and read the production deployment checklist.  ","version":"Next","tagName":"h2"},{"title":"How-To​","type":1,"pageTitle":"Run Vault on OpenShift","url":"/openbao/docs/platform/k8s/helm/openshift/#how-to","content":" ","version":"Next","tagName":"h2"},{"title":"Install Vault​","type":1,"pageTitle":"Run Vault on OpenShift","url":"/openbao/docs/platform/k8s/helm/openshift/#install-vault","content":" To use the Helm chart, add the Hashicorp helm repository and check that you have access to the chart:  $ helm repo add hashicorp https://helm.releases.hashicorp.com &quot;hashicorp&quot; has been added to your repositories $ helm search repo hashicorp/vault NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart   info Important: The Helm chart is new and under significant development. Please always run Helm with --dry-run before any install or upgrade to verify changes.  Use helm install to install the latest release of the Vault Helm chart.  $ helm install vault hashicorp/vault   Or install a specific version of the chart.  # List the available releases $ helm search repo hashicorp/vault -l NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart hashicorp/vault\t0.24.0 1.13.1 Official HashiCorp Vault Chart hashicorp/vault\t0.23.0 1.12.1 Official HashiCorp Vault Chart hashicorp/vault\t0.22.1 1.12.0 Official HashiCorp Vault Chart hashicorp/vault\t0.22.0 1.11.3 Official HashiCorp Vault Chart hashicorp/vault\t0.21.0 1.11.2 Official HashiCorp Vault Chart hashicorp/vault\t0.20.1 1.10.3 Official HashiCorp Vault Chart ... # Install version 0.25.0 $ helm install vault hashicorp/vault --version 0.25.0   The helm install command accepts parameters to override default configuration values inline or defined in a file. For all OpenShift deployments, global.openshiftshould be set to true.  Override the server.dev.enabled configuration value:  $ helm install vault hashicorp/vault \\ --set &quot;global.openshift=true&quot; \\ --set &quot;server.dev.enabled=true&quot;   Override all the configuration found in a file:  $ cat override-values.yml global: openshift: true server: ha: enabled: true replicas: 5 ## $ helm install vault hashicorp/vault \\ --values override-values.yml   Dev mode​  The Helm chart may run a Vault server in development. This installs a single Vault server with a memory storage backend.  info Dev mode: This is ideal for learning and demonstration environments but NOT recommended for a production environment.  Install the latest Vault Helm chart in development mode.  $ helm install vault hashicorp/vault \\ --set &quot;global.openshift=true&quot; \\ --set &quot;server.dev.enabled=true&quot;   Highly available raft mode​  The following creates a Vault cluster using the Raft integrated storage backend.  Install the latest Vault Helm chart in HA Raft mode:  $ helm install vault hashicorp/vault \\ --set='global.openshift=true' \\ --set='server.ha.enabled=true' \\ --set='server.ha.raft.enabled=true'   Next, initialize and unseal vault-0 pod:  $ oc exec -ti vault-0 -- vault operator init $ oc exec -ti vault-0 -- vault operator unseal   Finally, join the remaining pods to the Raft cluster and unseal them. The pods will need to communicate directly so we'll configure the pods to use the internal service provided by the Helm chart:  $ oc exec -ti vault-1 -- vault operator raft join http://vault-0.vault-internal:8200 $ oc exec -ti vault-1 -- vault operator unseal $ oc exec -ti vault-2 -- vault operator raft join http://vault-0.vault-internal:8200 $ oc exec -ti vault-2 -- vault operator unseal   To verify if the Raft cluster has successfully been initialized, run the following.  First, login using the root token on the vault-0 pod:  $ oc exec -ti vault-0 -- vault login   Next, list all the raft peers:  $ oc exec -ti vault-0 -- vault operator raft list-peers Node Address State Voter ---- ------- ----- ----- a1799962-8711-7f28-23f0-cea05c8a527d vault-0.vault-internal:8201 leader true e6876c97-aaaa-a92e-b99a-0aafab105745 vault-1.vault-internal:8201 follower true 4b5d7383-ff31-44df-e008-6a606828823b vault-2.vault-internal:8201 follower true   Vault with integrated storage (Raft) is now ready to use!  External mode​  The Helm chart may be run in external mode. This installs no Vault server and relies on a network addressable Vault server to exist.  Install the latest Vault Helm chart in external mode.  $ helm install vault hashicorp/vault \\ --set &quot;global.openshift=true&quot; \\ --set &quot;injector.externalVaultAddr=http://external-vault:8200&quot;   ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Run Vault on OpenShift","url":"/openbao/docs/platform/k8s/helm/openshift/#tutorial","content":" Refer to the Integrate a Kubernetes Cluster with an External Vaulttutorial to learn how to use an external Vault within a Kubernetes cluster. ","version":"Next","tagName":"h2"},{"title":"Standalone server with TLS","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/examples/standalone-tls/","content":"","keywords":"","version":"Next"},{"title":"1. create key & certificate using kubernetes CA​","type":1,"pageTitle":"Standalone server with TLS","url":"/openbao/docs/platform/k8s/helm/examples/standalone-tls/#1-create-key--certificate-using-kubernetes-ca","content":" There are four variables that will be used in this example.  # SERVICE is the name of the Vault service in kubernetes. # It does not have to match the actual running service, though it may help for consistency. export SERVICE=vault-server-tls # NAMESPACE where the Vault service is running. export NAMESPACE=vault-namespace # SECRET_NAME to create in the kubernetes secrets store. export SECRET_NAME=vault-server-tls # TMPDIR is a temporary working directory. export TMPDIR=/tmp # CSR_NAME will be the name of our certificate signing request as seen by kubernetes. export CSR_NAME=vault-csr   Create a key for Kubernetes to sign. $ openssl genrsa -out ${TMPDIR}/vault.key 2048 Generating RSA private key, 2048 bit long modulus   ...................................................................................................+++ ...............+++ e is 65537 (0x10001)   2. Create a Certificate Signing Request (CSR). 1. Create a file `${TMPDIR}/csr.conf` with the following contents: ```bash cat &lt;&lt;EOF &gt;${TMPDIR}/csr.conf [req] req_extensions = v3_req distinguished_name = req_distinguished_name [req_distinguished_name] [ v3_req ] basicConstraints = CA:FALSE keyUsage = nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = serverAuth subjectAltName = @alt_names [alt_names] DNS.1 = *.${SERVICE} DNS.2 = *.${SERVICE}.${NAMESPACE} DNS.3 = *.${SERVICE}.${NAMESPACE}.svc DNS.4 = *.${SERVICE}.${NAMESPACE}.svc.cluster.local IP.1 = 127.0.0.1 EOF   Create a CSR. openssl req -new \\ -key ${TMPDIR}/vault.key \\ -subj &quot;/CN=system:node:${SERVICE}.${NAMESPACE}.svc;/O=system:nodes&quot; \\ -out ${TMPDIR}/server.csr \\ -config ${TMPDIR}/csr.conf Create the certificate  warning Important Note: If you are using EKS, certificate signing requirements have changed. As per the AWS certificate signing documentation, EKS version 1.22 and later now requires the signerName to be beta.eks.amazonaws.com/app-serving, otherwise, the CSR will be approved but the certificate will not be issued.  Create a file ${TMPDIR}/csr.yaml with the following contents: cat &lt;&lt;EOF &gt;${TMPDIR}/csr.yaml apiVersion: certificates.k8s.io/v1 kind: CertificateSigningRequest metadata: name: ${CSR_NAME} spec: signerName: kubernetes.io/kubelet-serving groups: - system:authenticated request: $(base64 ${TMPDIR}/server.csr | tr -d '\\n') signerName: kubernetes.io/kubelet-serving usages: - digital signature - key encipherment - server auth EOF Send the CSR to Kubernetes. $ kubectl create -f ${TMPDIR}/csr.yaml certificatesigningrequest.certificates.k8s.io/vault-csr created   info If this process is automated, you may need to wait to ensure the CSR has been received and stored:kubectl get csr ${CSR_NAME}  Approve the CSR in Kubernetes. $ kubectl certificate approve ${CSR_NAME} certificatesigningrequest.certificates.k8s.io/vault-csr approved Verify that the certificate was approved and issued. $ kubectl get csr ${CSR_NAME} NAME AGE SIGNERNAME REQUESTOR CONDITION vault-csr 1m13s kubernetes.io/kubelet-serving kubernetes-admin Approved,Issued   ","version":"Next","tagName":"h2"},{"title":"2. store key, cert, and kubernetes CA into kubernetes secrets store​","type":1,"pageTitle":"Standalone server with TLS","url":"/openbao/docs/platform/k8s/helm/examples/standalone-tls/#2-store-key-cert-and-kubernetes-ca-into-kubernetes-secrets-store","content":" Retrieve the certificate. $ serverCert=$(kubectl get csr ${CSR_NAME} -o jsonpath='{.status.certificate}')   info If this process is automated, you may need to wait to ensure the certificate has been created. If it hasn't, this will return an empty string.  Write the certificate out to a file. $ echo &quot;${serverCert}&quot; | openssl base64 -d -A -out ${TMPDIR}/vault.crt Retrieve Kubernetes CA. kubectl get secret \\ -o jsonpath=&quot;{.items[?(@.type==\\&quot;kubernetes.io/service-account-token\\&quot;)].data['ca\\.crt']}&quot; \\ | base64 --decode &gt; ${TMPDIR}/vault.ca Create the namespace. $ kubectl create namespace ${NAMESPACE} namespace/vault-namespace created Store the key, cert, and Kubernetes CA into Kubernetes secrets. $ kubectl create secret generic ${SECRET_NAME} \\ --namespace ${NAMESPACE} \\ --from-file=vault.key=${TMPDIR}/vault.key \\ --from-file=vault.crt=${TMPDIR}/vault.crt \\ --from-file=vault.ca=${TMPDIR}/vault.ca # secret/vault-server-tls created   ","version":"Next","tagName":"h2"},{"title":"3. helm configuration​","type":1,"pageTitle":"Standalone server with TLS","url":"/openbao/docs/platform/k8s/helm/examples/standalone-tls/#3-helm-configuration","content":" The below custom-values.yaml can be used to set up a single server Vault cluster using TLS. This assumes that a Kubernetes secret exists with the server certificate, key and certificate authority:  global: enabled: true tlsDisable: false server: extraEnvironmentVars: VAULT_CACERT: /vault/userconfig/vault-server-tls/vault.ca volumes: - name: userconfig-vault-server-tls secret: defaultMode: 420 secretName: vault-server-tls # Matches the ${SECRET_NAME} from above volumeMounts: - mountPath: /vault/userconfig/vault-server-tls name: userconfig-vault-server-tls readOnly: true standalone: enabled: true config: | listener &quot;tcp&quot; { address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; tls_cert_file = &quot;/vault/userconfig/vault-server-tls/vault.crt&quot; tls_key_file = &quot;/vault/userconfig/vault-server-tls/vault.key&quot; tls_client_ca_file = &quot;/vault/userconfig/vault-server-tls/vault.ca&quot; } storage &quot;file&quot; { path = &quot;/vault/data&quot; }  ","version":"Next","tagName":"h2"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/configuration/","content":"Configuration warning Important Note: This chart is not compatible with Helm 2. Please use Helm 3.6+ with this chart. The chart is highly customizable usingHelm configuration values. Each value has a default tuned for an optimal getting started experience with Vault. Before going into production, please review the parameters below and consider if they're appropriate for your deployment. global - These global values affect multiple components of the chart. enabled (boolean: true) - The master enabled/disabled configuration. If this is true, most components will be installed by default. If this is false, no components will be installed by default and manually opting-in is required, such as by setting server.enabled to true. imagePullSecrets (array: []) - References secrets to be used when pulling images from private registries. See Pull an Image from a Private Registry for more details. May be specified as an array of name map entries or just as an array of names: imagePullSecrets: - name: image-pull-secret # or imagePullSecrets: - image-pull-secret tlsDisable (boolean: true) - When set to true, changes URLs from https to http (such as the VAULT_ADDR=http://127.0.0.1:8200 environment variable set on the Vault pods). externalVaultAddr (string: &quot;&quot;) - External vault server address for the injector and CSI provider to use. Setting this will disable deployment of a vault server. A service account with token review permissions is automatically created if server.serviceAccount.create=true is set for the external Vault server to use. openshift (boolean: false) - If true, enables configuration specific to OpenShift such as NetworkPolicy, SecurityContext, and Route. psp - Values that configure Pod Security Policy. enable (boolean: false) - When set to true, enables Pod Security Policies for Vault and Vault Agent Injector. annotations (dictionary: {}) - This value defines additional annotations to add to the Pod Security Policies. This can either be YAML or a YAML-formatted multi-line templated string. annotations: seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default seccomp.security.alpha.kubernetes.io/defaultProfileName: runtime/default apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default # or annotations: | seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default seccomp.security.alpha.kubernetes.io/defaultProfileName: runtime/default apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default serverTelemetry - Values that configure metrics and telemetry prometheusOperator (boolean: false) - When set to true, enables integration with the Prometheus Operator. Be sure to configure the top-level serverTelemetry section for more details and required configuration values. injector - Values that configure running a Vault Agent Injector Admission Webhook Controller within Kubernetes. enabled (boolean or string: &quot;-&quot;) - When set to true, the Vault Agent Injector Admission Webhook controller will be created. When set to &quot;-&quot;, defaults to the value of global.enabled. externalVaultAddr (string: &quot;&quot;) - Deprecated: Please use global.externalVaultAddr instead. replicas (int: 1) - The number of pods to deploy to create a highly available cluster of Vault Agent Injectors. Requires Vault K8s 0.7.0 to have more than 1 replica. leaderElector - Values that configure the Vault Agent Injector leader election for HA deployments. enabled (boolean: true) - When set to true, enables leader election for Vault Agent Injector. This is required when using auto-tls and more than 1 replica. image - Values that configure the Vault Agent Injector Docker image. repository (string: &quot;hashicorp/vault-k8s&quot;) - The name of the Docker image for Vault Agent Injector. tag (string: &quot;1.2.1&quot;) - The tag of the Docker image for the Vault Agent Injector. This should be pinned to a specific version when running in production. Otherwise, other changes to the chart may inadvertently upgrade your admission controller. pullPolicy (string: &quot;IfNotPresent&quot;) - The pull policy for container images. The default pull policy is IfNotPresent which causes the Kubelet to skip pulling an image if it already exists. agentImage - Values that configure the Vault Agent sidecar image. repository (string: &quot;hashicorp/vault&quot;) - The name of the Docker image for the Vault Agent sidecar. This should be set to the official Vault Docker image. tag (string: &quot;1.14.0&quot;) - The tag of the Vault Docker image to use for the Vault Agent Sidecar. Vault 1.3.1+ is required by the admission controller. agentDefaults - Values that configure the injected Vault Agent containers default values. cpuLimit (string: &quot;500m&quot;) - The default CPU limit for injected Vault Agent containers. cpuRequest (string: &quot;250m&quot;) - The default CPU request for injected Vault Agent containers. memLimit (string: &quot;128Mi&quot;) - The default memory limit for injected Vault Agent containers. memRequest (string: &quot;64Mi&quot;) - The default memory request for injected Vault Agent containers. ephemeralLimit (string: &quot;&quot;) - The default ephemeral storage limit for injected Vault Agent containers. ephemeralRequest (string: &quot;&quot;) - The default ephemeral storage request for injected Vault Agent containers. template (string: &quot;map&quot;) - The default template type for rendered secrets if no custom templates are defined. Possible values include map and json. templateConfig - Default values within Agent's template_config stanza. exitOnRetryFailure (boolean: true) - Controls whether Vault Agent exits after it has exhausted its number of template retry attempts due to failures. staticSecretRenderInterval (string: &quot;&quot;) - Configures how often Vault Agent Template should render non-leased secrets such as KV v2. See the Vault Agent Templates documentation for more details. metrics - Values that configure the Vault Agent Injector metric exporter. enabled (boolean: false) - When set to true, the Vault Agent Injector exports Prometheus metrics at the /metrics path. authPath (string: &quot;auth/kubernetes&quot;) - Mount path of the Vault Kubernetes Auth Method. logLevel (string: &quot;info&quot;) - Configures the log verbosity of the injector. Supported log levels: trace, debug, error, warn, info. logFormat (string: &quot;standard&quot;) - Configures the log format of the injector. Supported log formats: &quot;standard&quot;, &quot;json&quot;. revokeOnShutdown (boolean: false) - Configures all Vault Agent sidecars to revoke their token when shutting down. securityContext - Security context for the pod template and the injector container pod (dictionary: {}) - Defines the securityContext for the injector Pod, as YAML or a YAML-formatted multi-line templated string. Default if not specified: runAsNonRoot: true runAsGroup: {{ .Values.injector.gid | default 1000 }} runAsUser: {{ .Values.injector.uid | default 100 }} fsGroup: {{ .Values.injector.gid | default 1000 }} container (dictionary: {}) - Defines the securityContext for the injector container, as YAML or a YAML-formatted multi-line templated string. Default if not specified: allowPrivilegeEscalation: false capabilities: drop: - ALL resources (dictionary: {}) - The resource requests and limits (CPU, memory, etc.) for each container of the injector. This should be a YAML dictionary of a Kubernetes ResourceRequirements object. If this isn't specified, then the pods won't request any specific amount of resources, which limits the ability for Kubernetes to make efficient use of compute resources. Setting this is highly recommended. resources: requests: memory: '256Mi' cpu: '250m' limits: memory: '256Mi' cpu: '250m' webhook - Values that control the Mutating Webhook Configuration. failurePolicy (string: &quot;Ignore&quot;) - Configures failurePolicy of the webhook. To block pod creation while the webhook is unavailable, set the policy to &quot;Fail&quot;. See Failure Policy. matchPolicy (string: &quot;Exact&quot;) - Specifies the approach to accepting changes based on the rules of the MutatingWebhookConfiguration. See Match Policy. timeoutSeconds (int: 30) - Specifies the number of seconds before the webhook request will be ignored or fails. If it is ignored or fails depends on the failurePolicy. See timeouts. namespaceSelector (object: {}) - The selector used by the admission webhook controller to limit what namespaces where injection can happen. If unset, all non-system namespaces are eligible for injection. See Matching requests: namespace selector. namespaceSelector: matchLabels: sidecar-injector: enabled objectSelector (object: {}) - The selector used by the admission webhook controller to limit what objects can be affected by mutation. See Matching requests: object selector. objectSelector: matchLabels: sidecar-injector: enabled annotations (string or object: {}) - Defines additional annotations to attach to the webhook. This can either be YAML or a YAML-formatted multi-line templated string. namespaceSelector (dictionary: {}) - Deprecated: please use webhook.namespaceSelector instead. objectSelector (dictionary: {}) - Deprecated: please use webhook.objectSelector instead. extraLabels (dictionary: {}) - This value defines additional labels for Vault Agent Injector pods. extraLabels: 'sample/label1': 'foo' 'sample/label2': 'bar' certs - The certs section configures how the webhook TLS certs are configured. These are the TLS certs for the Kube apiserver communicating to the webhook. By default, the injector will generate and manage its own certs, but this requires the ability for the injector to update its own MutatingWebhookConfiguration. In a production environment, custom certs should probably be used. Configure the values below to enable this. secretName (string: &quot;&quot;) - secretName is the name of the Kubernetes secret that has the TLS certificate and private key to serve the injector webhook. If this is null, then the injector will default to its automatic management mode. caBundle (string: &quot;&quot;) - The PEM-encoded CA public certificate bundle for the TLS certificate served by the injector. This must be specified as a string and can't come from a secret because it must be statically configured on the Kubernetes MutatingAdmissionWebhook resource. This only needs to be specified if secretName is not null. certName (string: &quot;tls.crt&quot;) - The name of the certificate file within the secretName secret. keyName (string: &quot;tls.key&quot;) - The name of the key file within the secretName secret. extraEnvironmentVars (dictionary: {}) - Extra environment variables to set in the injector deployment. # Example setting injector TLS options in a deployment: extraEnvironmentVars: AGENT_INJECT_TLS_MIN_VERSION: tls13 AGENT_INJECT_TLS_CIPHER_SUITES: ... affinity - This value defines the affinity for Vault Agent Injector pods. This can either be multi-line string or YAML matching the PodSpec's affinity field. It defaults to allowing only a single pod on each node, which minimizes risk of the cluster becoming unusable if a node is lost. If you need to run more pods per node (for example, testing on Minikube), set this value to null. # Recommended default server affinity: affinity: | podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchLabels: app.kubernetes.io/name: {{ template &quot;vault.name&quot; . }}-agent-injector app.kubernetes.io/instance: &quot;{{ .Release.Name }}&quot; component: webhook topologyKey: kubernetes.io/hostname topologySpreadConstraints (array: []) - Topology settingsfor injector pods. This can either be YAML or a YAML-formatted multi-line templated string. tolerations (array: []) - Toleration Settings for injector pods. This should be either a multi-line string or YAML matching the Toleration array. nodeSelector (dictionary: {}) - nodeSelector labels for injector pod assignment, formatted as a muli-line string or YAML map. priorityClassName (string: &quot;&quot;) - Priority class for injector pods annotations (dictionary: {}) - This value defines additional annotations for injector pods. This can either be YAML or a YAML-formatted multi-line templated string. annotations: &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; # or annotations: | &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; failurePolicy (string: &quot;Ignore&quot;) - Deprecated: please use webhook.failurePolicy instead. webhookAnnotations (dictionary: {}) - Deprecated: please use webhook.annotations instead. service - The service section configures the Kubernetes service for the Vault Agent Injector. annotations (dictionary: {}) - This value defines additional annotations to add to the Vault Agent Injector service. This can either be YAML or a YAML-formatted multi-line templated string. annotations: &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; # or annotations: | &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; serviceAccount - Injector serviceAccount specific config annotations (dictionary: {}) - Extra annotations to attach to the injector serviceAccount. This can either be YAML or a YAML-formatted multi-line templated string. hostNetwork (boolean: false) - When set to true, configures the Vault Agent Injector to run on the host network. This is useful when alternative cluster networking is used. port (int: 8080) - Configures the port the Vault Agent Injector listens on. podDisruptionBudget (dictionary: {}) - A disruption budget limits the number of pods of a replicated application that are down simultaneously from voluntary disruptions. podDisruptionBudget: maxUnavailable: 1 strategy (dictionary: {}) - Strategy for updating the deployment. This can be a multi-line string or a YAML map. strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate # or strategy: | rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate livenessProbe - Values that configure the liveness probe for the injector. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. initialDelaySeconds (int: 60) - Sets the initial delay of the liveness probe when the container starts. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. readinessProbe - Values that configure the readiness probe for the injector. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. initialDelaySeconds (int: 60) - Sets the initial delay of the readiness probe when the container starts. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. startupProbe - Values that configure the startup probe for the injector. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. initialDelaySeconds (int: 60) - Sets the initial delay of the startup probe when the container starts. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. server - Values that configure running a Vault server within Kubernetes. enabled (boolean or string: &quot;-&quot;) - When set to true, the Vault server will be created. When set to &quot;-&quot;, defaults to the value of global.enabled. image - Values that configure the Vault Docker image. repository (string: &quot;hashicorp/vault&quot;) - The name of the Docker image for the containers running Vault. tag (string: &quot;1.14.0&quot;) - The tag of the Docker image for the containers running Vault. This should be pinned to a specific version when running in production. Otherwise, other changes to the chart may inadvertently upgrade your admission controller. pullPolicy (string: &quot;IfNotPresent&quot;) - The pull policy for container images. The default pull policy is IfNotPresent which causes the Kubelet to skip pulling an image if it already exists. updateStrategyType (string: &quot;OnDelete&quot;) - Configure the Update Strategy Type for the StatefulSet. logLevel (string: &quot;&quot;) - Configures the Vault server logging verbosity. If set this will override values defined in the Vault configuration file. Supported log levels include: trace, debug, info, warn, error. logFormat (string: &quot;&quot;) - Configures the Vault server logging format. If set this will override values defined in the Vault configuration file. Supported log formats include: standard, json. resources (dictionary: {}) - The resource requests and limits (CPU, memory, etc.) for each container of the server. This should be a YAML dictionary of a Kubernetes resource object. If this isn't specified, then the pods won't request any specific amount of resources, which limits the ability for Kubernetes to make efficient use of compute resources. Setting this is highly recommended. resources: requests: memory: '10Gi' limits: memory: '10Gi' ingress - Values that configure Ingress services for Vault. warning If deploying on OpenShift, these ingress settings are ignored. Use the route configuration to expose Vault on OpenShift. If ha is enabled the Ingress will point to the active vault server via the active Service. This requires vault 1.4+ and service_registration to be set in the vault config. enabled (boolean: false) - When set to true, an Ingress service will be created. labels (dictionary: {}) - Labels for the ingress service. annotations (dictionary: {}) - This value defines additional annotations to add to the Ingress service. This can either be YAML or a YAML-formatted multi-line templated string. annotations: kubernetes.io/ingress.class: nginx kubernetes.io/tls-acme: &quot;true&quot; # or annotations: | kubernetes.io/ingress.class: nginx kubernetes.io/tls-acme: &quot;true&quot; ingressClassName (string: &quot;&quot;) - Specify the IngressClass that should be used to implement the Ingress activeService (boolean: true) - When HA mode is enabled and K8s service registration is being used, configure the ingress to point to the Vault active service. extraPaths (array: []) - Configures extra paths to prepend to the host configuration. This is useful when working with annotation based services. extraPaths: - path: /* backend: service: name: ssl-redirect port: number: use-annotation tls (array: []) - Configures the TLS portion of the Ingress spec, where hosts is a list of the hosts defined in the Common Name of the TLS certificate, and secretName is the name of the Secret containing the required TLS files such as certificates and keys. tls: - hosts: - sslexample.foo.com - sslexample.bar.com secretName: testsecret-tls hosts - Values that configure the Ingress host rules. host (string: &quot;chart-example.local&quot;): Name of the host to use for Ingress. paths (array: []): Deprecated: server.ingress.extraPaths should be used instead. A list of paths that will be directed to the Vault service. At least one path is required. paths: - / - /vault route - Values that configure Route services for Vault in OpenShift warning If ha is enabled the Route will point to the active vault server via the active Service (requires vault 1.4+ and service_registration to be set in the vault config). enabled (boolean: false) - When set to true, a Route for Vault will be created. activeService (boolean: true) - When HA mode is enabled and K8s service registration is being used, configure the route to point to the Vault active service. labels (dictionary: {}) - Labels for the Route annotations (dictionary: {}) - Annotations to add to the Route. This can either be YAML or a YAML-formatted multi-line templated string. host (string: &quot;chart-example.local&quot;) - Sets the hostname for the Route. tls (dictionary: {termination: passthrough}) - TLS config that will be passed directly to the route's TLS config, which can be used to configure other termination methods that terminate TLS at the router. authDelegator - Values that configure the Cluster Role Binding attached to the Vault service account. enabled (boolean: true) - When set to true, a Cluster Role Binding will be bound to the Vault service account. This Cluster Role Binding has the necessary privileges for Vault to use the Kubernetes Auth Method. readinessProbe - Values that configure the readiness probe for the Vault pods. enabled (boolean: true) - When set to true, a readiness probe will be applied to the Vault pods. path (string: &quot;&quot;) - When set to a value, enables HTTP/HTTPS probes instead of using the default exec probe. The http/https scheme is controlled by the tlsDisable value. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. initialDelaySeconds (int: 5) - When set to a value, configures the number of seconds after the container has started before probe initiates. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. port (int: 8200) - When set to a value, overrides the default port used for the server readiness probe. readinessProbe: enabled: true path: /v1/sys/health?standbyok=true failureThreshold: 2 initialDelaySeconds: 5 periodSeconds: 5 successThreshold: 1 timeoutSeconds: 3 port: 8200 livenessProbe - Values that configure the liveness probe for the Vault pods. enabled (boolean: false) - When set to true, a liveness probe will be applied to the Vault pods. path (string: &quot;/v1/sys/health?standbyok=true&quot;) - When set to a value, enables HTTP/HTTPS probes instead of using the default exec probe. The http/https scheme is controlled by the tlsDisable value. initialDelaySeconds (int: 60) - Sets the initial delay of the liveness probe when the container starts. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. port (int: 8200) - When set to a value, overrides the default port used for the server liveness probe. livenessProbe: enabled: true path: /v1/sys/health?standbyok=true initialDelaySeconds: 60 failureThreshold: 2 periodSeconds: 5 successThreshold: 1 timeoutSeconds: 3 port: 8200 terminationGracePeriodSeconds (int: 10) - Optional duration in seconds the pod needs to terminate gracefully. See: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/ preStopSleepSeconds (int: 5) - Used to set the sleep time during the preStop step. postStart (array: []) - Used to define commands to run after the pod is ready. This can be used to automate processes such as initialization or bootstrapping auth methods. postStart: - /bin/sh - -c - /vault/userconfig/myscript/run.sh extraInitContainers (array: null) - extraInitContainers is a list of init containers. Specified as a YAML list. This is useful if you need to run a script to provision TLS certificates or write out configuration files in a dynamic way. extraContainers (array: null) - The extra containers to be applied to the Vault server pods. extraContainers: - name: mycontainer image: 'app:0.0.0' env: ... extraEnvironmentVars (dictionary: {}) - The extra environment variables to be applied to the Vault server. # Extra Environment Variables are defined as key/value strings. extraEnvironmentVars: GOOGLE_REGION: global GOOGLE_PROJECT: myproject GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/myproject/myproject-creds.json shareProcessNamespace (boolean: false) - Enables process namespace sharing between Vault and the extraContainers. This is useful if Vault must be signaled, e.g. to send a SIGHUP for log rotation. extraArgs (string: null) - The extra arguments to be applied to the Vault server startup command. extraArgs: '-config=/path/to/extra/config.hcl -log-format=json' extraPorts (array: []) - additional ports to add to the server statefulset extraPorts: - containerPort: 8300 name: http-monitoring extraSecretEnvironmentVars (array: []) - The extra environment variables populated from a secret to be applied to the Vault server. envName (string: required) - Name of the environment variable to be populated in the Vault container. secretName (string: required) - Name of Kubernetes secret used to populate the environment variable defined by envName. secretKey (string: required) - Name of the key where the requested secret value is located in the Kubernetes secret. # Extra Environment Variables populated from a secret. extraSecretEnvironmentVars: - envName: AWS_SECRET_ACCESS_KEY secretName: vault secretKey: AWS_SECRET_ACCESS_KEY extraVolumes (array: []) - Deprecated: please use volumes instead. A list of extra volumes to mount to Vault servers. This is useful for bringing in extra data that can be referenced by other configurations at a well known path, such as TLS certificates. The value of this should be a list of objects. Each object supports the following keys: type (string: required) - Type of the volume, must be one of &quot;configMap&quot; or &quot;secret&quot;. Case sensitive. name (string: required) - Name of the configMap or secret to be mounted. This also controls the path that it is mounted to. The volume will be mounted to /vault/userconfig/&lt;name&gt; by default unless path is configured. path (string: /vault/userconfigs) - Name of the path where a configMap or secret is mounted. If not specified the volume will be mounted to /vault/userconfig/&lt;name of volume&gt;. defaultMode (string: &quot;420&quot;) - Default mode of the mounted files. extraVolumes: - type: 'secret' name: 'vault-certs' path: '/etc/pki' volumes (array: null) - A list of volumes made available to all containers. This takes standard Kubernetes volume definitions. volumes: - name: plugins emptyDir: {} volumeMounts (array: null) - A list of volumes mounts made available to all containers. This takes standard Kubernetes volume definitions. volumeMounts: - mountPath: /usr/local/libexec/vault name: plugins readOnly: true affinity - This value defines the affinity for server pods. This should be either a multi-line string or YAML matching the PodSpec's affinity field. It defaults to allowing only a single pod on each node, which minimizes risk of the cluster becoming unusable if a node is lost. If you need to run more pods per node (for example, testing on Minikube), set this value to null. # Recommended default server affinity: affinity: | podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchLabels: app.kubernetes.io/name: {{ template &quot;vault.name&quot; . }} app.kubernetes.io/instance: &quot;{{ .Release.Name }}&quot; component: server topologyKey: kubernetes.io/hostname topologySpreadConstraints (array: []) - Topology settingsfor server pods. This can either be YAML or a YAML-formatted multi-line templated string. tolerations (array: []) - This value defines the tolerations that are acceptable when being scheduled. This should be either a multi-line string or YAML matching the Toleration array in a PodSpec. tolerations: | - key: 'node.kubernetes.io/unreachable' operator: 'Exists' effect: 'NoExecute' tolerationSeconds: 6000 nodeSelector (dictionary: {}) - This value defines additional node selection criteria for more control over where the Vault servers are deployed. This should be formatted as a multi-line string or YAML map. nodeSelector: | disktype: ssd networkPolicy - Values that configure the Vault Network Policy. enabled (boolean: false) - When set to true, enables a Network Policy for the Vault cluster. egress (array: []) - This value configures the egress network policy rules. egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 8200 priorityClassName (string: &quot;&quot;) - Priority class for server pods extraLabels (dictionary: {}) - This value defines additional labels for server pods. extraLabels: 'sample/label1': 'foo' 'sample/label2': 'bar' annotations (dictionary: {}) - This value defines additional annotations for server pods. This can either be YAML or a YAML-formatted multi-line templated string. annotations: &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; # or annotations: | &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; service - Values that configure the Kubernetes service created for Vault. These options are also used for the active and standby services when ha is enabled. enabled (boolean: true) - When set to true, a Kubernetes service will be created for Vault. active - Values that apply only to the vault-active service. enabled (boolean: true) - When set to true, the vault-active Kubernetes service will be created for Vault, selecting pods which label themselves as the cluster leader with vault-active: &quot;true&quot;. standby - Values that apply only to the vault-standby service. enabled (boolean: true) - When set to true, the vault-standby Kubernetes service will be created for Vault, selecting pods which label themselves as a cluster follower with vault-active: &quot;false&quot;. clusterIP (string) - ClusterIP controls whether an IP address (cluster IP) is attached to the Vault service within Kubernetes. By default the Vault service will be given a Cluster IP address, set to None to disable. When disabled Kubernetes will create a &quot;headless&quot; service. Headless services can be used to communicate with pods directly through DNS instead of a round robin load balancer. type (string: &quot;ClusterIP&quot;) - Sets the type of service to create, such as NodePort. externalTrafficPolicy (string: &quot;Cluster&quot;) - The externalTrafficPolicy can be set to either Cluster or Local and is only valid for LoadBalancer and NodePort service types. port (int: 8200) - Port on which Vault server is listening inside the pod. targetPort (int: 8200) - Port on which the service is listening. nodePort (int:) - When type is set to NodePort, the bound node port can be configured using this value. A random port will be assigned if this is left blank. activeNodePort (int:) - (When HA mode is enabled) If type is set to &quot;NodePort&quot;, a specific nodePort value can be configured for the active service, and will be random if left blank. standbyNodePort (int:) - (When HA mode is enabled) If type is set to &quot;NodePort&quot;, a specific nodePort value can be configured for the standby service, will be random if left blank. publishNotReadyAddresses (boolean: true) - If true, do not wait for pods to be ready before including them in the services' targets. Does not apply to the headless service, which is used for cluster-internal communication. instanceSelector enabled (boolean: true) - When set to false, the service selector used for the vault, vault-active, and vault-standby services will not filter on app.kubernetes.io/instance. This means they may select pods from outside this deployment of the Helm chart. Does not affect the headless vault-internal service with ClusterIP: None. annotations (dictionary: {}) - This value defines additional annotations for the service. This can either be YAML or a YAML-formatted multi-line templated string. annotations: &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; # or annotations: | &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; serviceAccount - Values that configure the Kubernetes service account created for Vault. create (boolean: true): If set to true, creates a service account used by Vault. name (string: &quot;&quot;): Name of the service account to use. If not set and create is true, a name is generated using the name of the installation (default is &quot;vault&quot;). annotations (dictionary: {}) - This value defines additional annotations for the service account. This can either be YAML or a YAML-formatted multi-line templated string. annotations: &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; # or annotations: | &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; extraLabels (dictionary: {}) - This value defines additional labels for the Vault Server service account. extraLabels: 'sample/label1': 'foo' 'sample/label2': 'bar' serviceDiscovery - Values that configure permissions required for Vault Server to automatically discover and join a Vault cluster using pod metadata. enabled (boolean: true) - Enable or disable a service account role binding with the permissions required for Vault's Kubernetes service_registration config option. dataStorage - This configures the volume used for storing Vault data when not using external storage such as Consul. enabled (boolean: true) - Enables a persistent volume to be created for storing Vault data when not using an external storage service. size (string: 10Gi) - Size of the volume to be created for Vault's data storage when not using an external storage service. storageClass (string: null) - Name of the storage class to use when creating the data storage volume. mountPath (string: /vault/data) - Configures the path in the Vault pod where the data storage will be mounted. accessMode (string: ReadWriteOnce) - Type of access mode of the storage device. See the official Kubernetes for more information. annotations (dictionary: {}) - This value defines additional annotations to add to the data PVCs. This can either be YAML or a YAML-formatted multi-line templated string. annotations: kubernetes.io/my-pvc: foobar # or annotations: | kubernetes.io/my-pvc: foobar auditStorage - This configures the volume used for storing Vault's audit logs. See the Vault documentation for more information. enabled (boolean: false) - Enables a persistent volume to be created for storing Vault's audit logs. size (string: 10Gi) - Size of the volume to be created for Vault's audit logs. storageClass (string: null) - Name of the storage class to use when creating the audit storage volume. mountPath (string: /vault/audit) - Configures the path in the Vault pod where the audit storage will be mounted. accessMode (string: ReadWriteOnce) - Type of access mode of the storage device. annotations (dictionary: {}) - This value defines additional annotations to add to the audit PVCs. This can either be YAML or a YAML-formatted multi-line templated string. annotations: kubernetes.io/my-pvc: foobar # or annotations: | kubernetes.io/my-pvc: foobar dev - This configures dev mode for the Vault server. enabled (boolean: false) - Enables dev mode for the Vault server. This mode is useful for experimenting with Vault without needing to unseal. devRootToken (string: &quot;root&quot;) - Configures the root token for the Vault development server. warning Security Warning: Never, ever, ever run a &quot;dev&quot; mode server in production. It is insecure and will lose data on every restart (since it stores data in-memory). It is only made for development or experimentation. standalone - This configures standalone mode for the Vault server. enabled (boolean: true) - Enables standalone mode for the Vault server. This mode uses the file storage backend and requires a volume for persistence (dataStorage). config (string or object: &quot;{}&quot;) - A raw string of extra HCL or JSON configuration for Vault servers. This will be saved as-is into a ConfigMap that is read by the Vault servers. This can be used to add additional configuration that isn't directly exposed by the chart. If an object is provided, it will be written as JSON. # ExtraConfig values are formatted as a multi-line string: config: | api_addr = &quot;http://POD_IP:8200&quot; listener &quot;tcp&quot; { tls_disable = 1 address = &quot;0.0.0.0:8200&quot; } storage &quot;file&quot; { path = &quot;/vault/data&quot; } This can also be set using Helm's --set flag (vault-helm v0.1.0 and later), using the following syntax: --set server.standalone.config='{ listener &quot;tcp&quot; { address = &quot;0.0.0.0:8200&quot; }' ha - This configures ha mode for the Vault server. enabled (boolean: false) - Enables ha mode for the Vault server. This mode uses a highly available backend storage (such as Consul) to store Vault's data. By default this is configured to use Consul Helm. For a complete list of storage backends, see the Vault documentation. apiAddr: (string: &quot;{}&quot;) - Set the API address configuration for a Vault cluster. If set to an empty string, the pod IP address is used. clusterAddr (string: null) - Set the cluster_addr configuration for Vault HA. If null, defaults to https://$(HOSTNAME).{{ template &quot;vault.fullname&quot; . }}-internal:8201. raft - This configures raft integrated storage mode for the Vault server. enabled (boolean: false) - Enables raft integrated storage mode for the Vault server. This mode uses persistent volumes for storage. setNodeId (boolean: false) - Set the Node Raft ID to the name of the pod. config (string or object: &quot;{}&quot;) - A raw string of extra HCL or JSON configuration for Vault servers. This will be saved as-is into a ConfigMap that is read by the Vault servers. This can be used to add additional configuration that isn't directly exposed by the chart. If an object is provided, it will be written as JSON. replicas (int: 3) - The number of pods to deploy to create a highly available cluster of Vault servers. updatePartition (int: 0) - If an updatePartition is specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet’s .spec.template is updated. If set to 0, this disables partition updates. For more information see the official Kubernetes documentation. config (string or object: &quot;{}&quot;) - A raw string of extra HCL or JSON configuration for Vault servers. This will be saved as-is into a ConfigMap that is read by the Vault servers. This can be used to add additional configuration that isn't directly exposed by the chart. If an object is provided, it will be written as JSON. # ExtraConfig values are formatted as a multi-line string: config: | ui = true api_addr = &quot;http://POD_IP:8200&quot; listener &quot;tcp&quot; { tls_disable = 1 address = &quot;0.0.0.0:8200&quot; } storage &quot;consul&quot; { path = &quot;vault/&quot; address = &quot;HOST_IP:8500&quot; } This can also be set using Helm's --set flag (vault-helm v0.1.0 and later), using the following syntax: --set server.ha.config='{ listener &quot;tcp&quot; { address = &quot;0.0.0.0:8200&quot; }' disruptionBudget - Values that configures the disruption budget policy. See the official Kubernetes documentation for more information. enabled (boolean: true) - Enables disruption budget policy to limit the number of pods that are down simultaneously from voluntary disruptions. maxUnavailable (int: null) - The maximum number of unavailable pods. By default, this will be automatically computed based on the server.replicas value to be (n/2)-1. If you need to set this to 0, you will need to add a --set 'server.disruptionBudget.maxUnavailable=0'flag to the helm chart installation command because of a limitation in the Helm templating language. statefulSet - This configures settings for the Vault Statefulset. annotations (dictionary: {}) - This value defines additional annotations to add to the Vault statefulset. This can either be YAML or a YAML-formatted multi-line templated string. annotations: kubernetes.io/my-statefulset: foobar # or annotations: | kubernetes.io/my-statefulset: foobar securityContext - Set the Pod and container security contexts pod (dictionary: {}) - Defines the securityContext for the server Pods, as YAML or a YAML-formatted multi-line templated string. Default if not specified and global.openshift=false: runAsNonRoot: true runAsGroup: {{ .Values.server.gid | default 1000 }} runAsUser: {{ .Values.server.uid | default 100 }} fsGroup: {{ .Values.server.gid | default 1000 }} Defaults to empty if not specified and global.openshift=true. container (dictionary: {}) - Defines the securityContext for the server containers, as YAML or a YAML-formatted multi-line templated string. Default if not specified and global.openshift=false: allowPrivilegeEscalation: false Defaults to empty if not specified and global.openshift=true. ui - Values that configure the Vault UI. enabled (boolean: false) - If true, the UI will be enabled. The UI will only be enabled on Vault servers. If server.enabled is false, then this setting has no effect. To expose the UI in some way, you must configure ui.service. serviceType (string: ClusterIP) - The service type to register. This defaults to ClusterIP. The available service types are documented onthe Kubernetes website. publishNotReadyAddresses (boolean: true) - If set to true, will route traffic to Vault pods that aren't ready (if they're sealed or uninitialized. activeVaultPodOnly (boolean: false) - If set to true, the UI service will only route to the active pod in a Vault HA cluster. serviceNodePort (int: null) - Sets the Node Port value when using serviceType: NodePort on the Vault UI service. externalPort (int: 8200) - Sets the external port value of the service. targetPort (int: 8200) - Sets the target port value of the service. externalTrafficPolicy (string: &quot;Cluster&quot;) - The externalTrafficPolicy can be set to either Cluster or Local and is only valid for LoadBalancer and NodePort service types. loadBalancerSourceRanges (array) - This value defines additional source CIDRs when using serviceType: LoadBalancer. loadBalancerSourceRanges: - 10.0.0.0/16 - 120.78.23.3/32 loadBalancerIP (string) - This value defines the IP address of the load balancer when using serviceType: LoadBalancer. annotations (dictionary: {}) - This value defines additional annotations for the UI service. This can either be YAML or a YAML-formatted multi-line templated string. annotations: &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; # or annotations: | &quot;sample/annotation1&quot;: &quot;foo&quot; &quot;sample/annotation2&quot;: &quot;bar&quot; csi - Values that configure running the Vault CSI Provider. enabled (boolean: false) - When set to true, the Vault CSI Provider daemonset will be created. image - Values that configure the Vault CSI Provider Docker image. repository (string: &quot;hashicorp/vault-csi-provider&quot;) - The name of the Docker image for the Vault CSI Provider. tag (string: &quot;1.4.0&quot;) - The tag of the Docker image for the Vault CSI Provider.. This should be pinned to a specific version when running in production. Otherwise, other changes to the chart may inadvertently upgrade your CSI provider. pullPolicy (string: &quot;IfNotPresent&quot;) - The pull policy for container images. The default pull policy is IfNotPresent which causes the Kubelet to skip pulling an image if it already exists locally. volumes (array: null) - A list of volumes made available to all containers. This takes standard Kubernetes volume definitions. volumes: - name: plugins emptyDir: {} volumeMounts (array: null) - A list of volumes mounts made available to all containers. This takes standard Kubernetes volume mount definitions. volumeMounts: - mountPath: /usr/local/libexec/vault name: plugins readOnly: true resources (dictionary: {}) - The resource requests and limits (CPU, memory, etc.) for each of the CSI containers. This should be a YAML dictionary of a Kubernetes resource object. If this isn't specified, then the pods won't request any specific amount of resources, which limits the ability for Kubernetes to make efficient use of compute resources. Setting this is highly recommended. resources: requests: memory: '10Gi' limits: memory: '10Gi' hmacSecretName (string: &quot;&quot;) - Override the default secret name for the CSI Provider's HMAC key used for generating secret versions. daemonSet - Values that configure the Vault CSI Provider daemonSet. updateStrategy - Values that configure the Vault CSI Provider update strategy. type (string: &quot;RollingUpdate&quot;) - The type of update strategy to be used when the daemonset is updated using Helm upgrades. maxUnavailable (int: null) - The maximum number of unavailable pods during an upgrade. annotations (dictionary: {}) - This value defines additional annotations to add to the Vault CSI Provider daemonset. This can either be YAML or a YAML-formatted multi-line templated string. annotations: foo: bar # or annotations: | foo: bar extraLabels (dictionary: {}) - This value defines additional labels for the CSI provider daemonset. providersDir (string: &quot;/etc/kubernetes/secrets-store-csi-providers&quot;) - Provider host path (must match the CSI provider's path) kubeletRootDir (string: &quot;/var/lib/kubelet&quot;) - Kubelet host path securityContext - Security context for the pod template and container in the csi provider daemonSet pod (dictionary: {}) - Pod-level securityContext. May be specified as YAML or a YAML-formatted multi-line templated string. container (dictionary: {}) - Container-level securityContext. May be specified as YAML or a YAML-formatted multi-line templated string. pod - Values that configure the Vault CSI Provider pod. annotations (dictionary: {}) - This value defines additional annotations to add to the Vault CSI Provider pods. This can either be YAML or a YAML-formatted multi-line templated string. annotations: foo: bar # or annotations: | foo: bar extraLabels (dictionary: {}) - This value defines additional labels for CSI provider pods. nodeSelector (dictionary: {}) - nodeSelector labels for csi pod assignment, formatted as a multi-line string or YAML map. nodeSelector: beta.kubernetes.io/arch: amd64 affinity (dictionary: {}) - This should be either a multi-line string or YAML matching the PodSpec's affinity field. tolerations (array: []) - Toleration Settings for CSI pods. This should be a multi-line string or YAML matching the Toleration array in a PodSpec. priorityClassName (string: &quot;&quot;) - Priority class for CSI Provider pods serviceAccount - Values that configure the Vault CSI Provider's serviceaccount. annotations (dictionary: {}) - This value defines additional annotations for the serviceAccount definition. This can either be YAML or a YAML-formatted multi-line templated string. annotations: foo: bar # or annotations: | foo: bar extraLabels (dictionary: {}) - This value defines additional labels for the CSI provider service account. readinessProbe - Values that configure the readiness probe for the Vault CSI Provider pods. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. initialDelaySeconds (int: 5) - When set to a value, configures the number of seconds after the container has started before probe initiates. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. livenessProbe - Values that configure the liveness probe for the Vault CSI Provider pods. initialDelaySeconds (int: 5) - Sets the initial delay of the liveness probe when the container starts. failureThreshold (int: 2) - When set to a value, configures how many probe failures will be tolerated by Kubernetes. periodSeconds (int: 5) - When set to a value, configures how often (in seconds) to perform the probe. successThreshold (int: 1) - When set to a value, configures the minimum consecutive successes for the probe to be considered successful after having failed. timeoutSeconds (int: 3) - When set to a value, configures the number of seconds after which the probe times out. debug (bool: false) - When set to true, enables debug logging on the Vault CSI Provider daemonset. extraArgs (array: []) - The extra arguments to be applied to the CSI pod startup command. See here for available flags. agent - Configures the Vault Agent sidecar for the CSI Provider enabled (bool: true) - whether to enable the agent sidecar for the CSI provider extraArgs (array: []) - The extra arguments to be applied to the agent startup command. image - Values that configure the Vault Agent sidecar image for the CSI Provider. pullPolicy (string: &quot;IfNotPresent&quot;) - The pull policy for agent image. The default pull policy is IfNotPresent which causes the Kubelet to skip pulling an image if it already exists. repository (string: &quot;hashicorp/vault&quot;) - The name of the Docker image for the Vault Agent sidecar. This should be set to the official Vault Docker image. tag (string: &quot;1.14.0&quot;) - The tag of the Vault Docker image to use for the Vault Agent Sidecar. logFormat (string: &quot;standard&quot;) - logLevel (string: &quot;info&quot;) - resources (dictionary: {}) - The resource requests and limits (CPU, memory, etc.) for the agent. This should be a YAML dictionary of a Kubernetes ResourceRequirements object. resources: requests: memory: '256Mi' cpu: '250m' limits: memory: '256Mi' cpu: '250m' serverTelemetry - Values the configure metrics and telemetry. Enabling these features requires setting the telemetry {} stanza in the Vault configuration. See the telemetrydocs for more on the Vault configuration. Currently, this chart does not support authenticating to Vault's metrics endpoint, so the following telemetry {} block must be included in the listener &quot;tcp&quot; {} stanza of the Vault configuration: listener &quot;tcp&quot; { tls_disable = 1 address = &quot;0.0.0.0:8200&quot; telemetry { unauthenticated_metrics_access = &quot;true&quot; } } In addition, a top level telemetry {} stanza must also be included in the Vault configuration, such as: telemetry { prometheus_retention_time = &quot;30s&quot;, disable_hostname = true } serviceMonitor - Values that configure monitoring the Vault server enabled (boolean: false) - When set to true, enable deployment of the Vault Server ServiceMonitor CustomResource. The Prometheus operator must be installed before enabling this feature. If not, the chart will fail to install due to missing CustomResourceDefinitions provided by the operator. Instructions on how to install the Helm chart can be found here. More information can be found here in thetheserepositories selectors (dictionary: {}) - Selector labels to add to the ServiceMonitor. interval (string: &quot;30s&quot;) - Interval at which Prometheus scrapes metrics. scrapeTimeout (string: &quot;10s&quot;) - Timeout for Prometheus scrapes. prometheusRules - Values that configure Prometheus rules. enabled (boolean: false) - Deploy the PrometheusRule custom resource for AlertManager-based alerts. Requires that AlertManager is properly deployed. selectors (dictionary: {}) - Selector labels to add to the Prometheus rules. rules: (array: []) - Prometheus rules to create. For example: rules: - alert: vault-HighResponseTime annotations: message: The response time of Vault is over 500ms on average over the last 5 minutes. expr: vault_core_handle_request{quantile=&quot;0.5&quot;, namespace=&quot;mynamespace&quot;} &gt; 500 for: 5m labels: severity: warning - alert: vault-HighResponseTime annotations: message: The response time of Vault is over 1s on average over the last 5 minutes. expr: vault_core_handle_request{quantile=&quot;0.5&quot;, namespace=&quot;mynamespace&quot;} &gt; 1000 for: 5m labels: severity: critical ","keywords":"","version":"Next"},{"title":"Configuring Vault helm with terraform","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/terraform/","content":"","keywords":"","version":"Next"},{"title":"Further examples​","type":1,"pageTitle":"Configuring Vault helm with terraform","url":"/openbao/docs/platform/k8s/helm/terraform/#further-examples","content":" ","version":"Next","tagName":"h2"},{"title":"Vault config as a multi-line string​","type":1,"pageTitle":"Configuring Vault helm with terraform","url":"/openbao/docs/platform/k8s/helm/terraform/#vault-config-as-a-multi-line-string","content":" YamlOpenTofu server: ha: enabled: true raft: enabled: true setNodeId: true config: | ui = false listener &quot;tcp&quot; { tls_disable = 1 address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; } storage &quot;raft&quot; { path = &quot;/vault/data&quot; } service_registration &quot;kubernetes&quot; {} seal &quot;awskms&quot; { region = &quot;us-west-2&quot; kms_key_id = &quot;alias/my-kms-key&quot; }   ","version":"Next","tagName":"h3"},{"title":"Lists of volumes and volumeMounts​","type":1,"pageTitle":"Configuring Vault helm with terraform","url":"/openbao/docs/platform/k8s/helm/terraform/#lists-of-volumes-and-volumemounts","content":" YamlOpenTofu server: volumes: - name: userconfig-my-gcp-iam secret: defaultMode: 420 secretName: my-gcp-iam volumeMounts: - mountPath: /vault/userconfig/my-gcp-iam name: userconfig-my-gcp-iam readOnly: true   ","version":"Next","tagName":"h3"},{"title":"Annotations​","type":1,"pageTitle":"Configuring Vault helm with terraform","url":"/openbao/docs/platform/k8s/helm/terraform/#annotations","content":" Annotations can be set as a YAML map:  YamlOpenTofu server: ingress: annotations: service.beta.kubernetes.io/azure-load-balancer-internal: true service.beta.kubernetes.io/azure-load-balancer-internal-subnet: apps-subnet   or as a multi-line string:  YamlOpenTofu server: ingress: annotations: | service.beta.kubernetes.io/azure-load-balancer-internal: true service.beta.kubernetes.io/azure-load-balancer-internal-subnet: apps-subnet  ","version":"Next","tagName":"h3"},{"title":"Agent injector vs. Vault CSI provider","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/injector-csi/","content":"","keywords":"","version":"Next"},{"title":"Vault sidecar agent injector​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#vault-sidecar-agent-injector","content":" The Vault Sidecar Agent Injector leverages the sidecar pattern to alter pod specifications to include a Vault Agent container that renders Vault secrets to a shared memory volume. By rendering secrets to a shared volume, containers within the pod can consume Vault secrets without being Vault-aware. The injector is a Kubernetes mutating webhook controller. The controller intercepts pod events and applies mutations to the pod if annotations exist within the request. This functionality is provided by the vault-k8s project and can be automatically installed and configured using the Vault Helm chart.    ","version":"Next","tagName":"h2"},{"title":"Vault CSI provider​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#vault-csi-provider","content":" The Vault CSI provider allows pods to consume Vault secrets by using ephemeral CSI Secrets Store volumes. At a high level, the CSI Secrets Store driver enables users to create SecretProviderClass objects. These objects define which secret provider to use and what secrets to retrieve. When pods requesting CSI volumes are made, the CSI Secrets Store driver sends the request to the Vault CSI provider if the provider is vault. The Vault CSI provider then uses the specified SecretProviderClass and the pod’s service account to retrieve the secrets from Vault and mount them into the pod’s CSI volume. Note that the secret is retrieved from Vault and populated to the CSI secrets store volume during the ContainerCreation phase. Therefore, pods are blocked from starting until the secrets are read from Vault and written to the volume.    warning Note: Secrets are fetched earlier in the pod lifecycle, therefore, they have fewer compatibility issues with Sidecars, such as Istio.  Before we get into some of the similarities and differences between the two solutions, let's look at several common design considerations.  Secret projections: Every application requires secrets to explicitly presented. Typically, applications expect secrets to be either exported as environment variables or written to a file that the application can read on startup. Keep that in mind as you’re deciding on a suitable method to use. Secret scope: Some applications are deployed across multiple Kubernetes environments (e.g., dev, qa, prod) across your data centers, the edge, or public clouds. Some services run outside of Kubernetes on VMs, serverless, or other cloud-managed services. You may face scenarios where these applications need to share sets of secrets across these heterogeneous environments. Scoping the secrets correctly to be either local to the Kubernetes environment or global across different environments helps ensure that each application can easily and securely access its own set of secrets within the environment it is deployed in. Secret types: Secrets can be text files, binary files, tokens, or certs, or they can be statically or dynamically generated. They can also be valid permanently or time-scoped, and can vary in size. You need to consider the secret types your application requires and how they’re projected into the application. Secret definition: You also need to consider how each secret is defined, created, updated, and removed, as well as the tooling associated with that process. Encryption: Encrypting secrets both at rest and in transit is a critical requirement for many enterprise organizations. Governance: Applications and secrets can have a many-to-many relationship that requires careful considerations when granting access for applications to retrieve their respective secrets. As the number of applications and secrets scale, so does the challenge of managing their access policies. Secrets updates and rotation: Secrets can be leased, time-scoped, or automatically rotated, and each scenario needs to be a programmatic process to ensure the new secret is propagated to the application pods properly. Secret caching: In certain Kubernetes environments (e.g., edge or retail), there is a potential need for secret caching in the case of communication or network failures between the environment and the secret storage. Auditability: Keeping a secret access audit log detailing all secret access information is critical to ensure traceability of secret-access events.  Now that you're familiar with some of the design considerations, we'll explore the similarities and differences between the two solutions to help you determine the best solution to use as you design and implement your secrets management strategy in a Kubernetes environment.  ","version":"Next","tagName":"h2"},{"title":"Similarities​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#similarities","content":" Both Agent Injection and Vault CSI solutions have the following similarities:  They simplify retrieving different types of secrets stored in Vault and expose them to the target pod running on Kubernetes without knowing the not-so-trivial Vault processes. It’s important to note that there is no need to change the application logic or code to use these solutions, therefore, making it easier to migrate brownfield applications into Kubernetes. Developers working on greenfield applications can leverage the Vault SDKs to integrate with Vault directly. They support all types of Vault secrets engines. This support allows you to leverage an extensive set of secret types, ranging from static key-value secrets to dynamically generated database credentials and TLS certs with customized TTL. They leverage the application’s Kubernetes pod service account token as Secret Zero to authenticate with Vault via the Kubernetes auth method. With this method, there is no need to manage yet another separate identity to identify the application pods when authenticating to Vault. Secret lifetime is tied to the lifetime of the pod for both methods. While this holds true for file contents inside the pod, this also holds true for Kubernetes secrets that CSI creates. Secrets are automatically created and deleted as the pod is created and deleted.    They require the desired secrets to exist within Vault before deploying the application. They require the pod’s service account to bind to a Vault role with a policy enabling access to desired secrets (that is, Kubernetes RBAC isn’t used to authorize access to secrets). They can both be deployed via Helm. They require successfully retrieving secrets from Vault before the pods are started. They rely on user-defined pod annotations to retrieve the required secrets from Vault.  ","version":"Next","tagName":"h2"},{"title":"Differences​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#differences","content":" Now that you understand the similarities, there are differences between these two solutions for considerations:  The Sidecar Agent Injector solution is composed of two elements: The Sidecar Service Injector, which is deployed as a cluster service and is responsible for intercepting Kubernetes apiserver pod events and mutating pod specs to add required sidecar containersThe Vault Sidecar Container, which is deployed alongside each application pod and is responsible for authenticating into Vault, retrieving secrets from Vault, and rendering secrets for the application to consume. In contrast, the Vault CSI Driver is deployed as a daemonset on every node in the Kubernetes cluster and uses the Secret Provider Class specified and the pod’s service account to retrieve the secrets from Vault and mount them into the pod’s CSI volume. The Sidecar Agent Injector supports all Vault auto-auth methods. The Sidecar CSI driver supports only Vault’s Kubernetes auth method. The Sidecar container launched with every application pod uses Vault Agent, which provides a powerful set of capabilities such as auto-auth, templating, and caching. The CSI driver does not use the Vault Agent and therefore lacks these functionalities. The Vault CSI driver supports rendering Vault secrets into Kubernetes secrets and environment variables. Sidecar Injector Service does not support rendering secrets into Kubernetes secrets; however, there are ways to agent templating to render secrets into environment variables. The CSI driver uses hostPath to mount ephemeral volumes into the pods, which some container platforms (e.g., OpenShift) disable by default. On the other hand, Sidecar Agent Service uses in-memory tmpfs volumes. Sidecar Injector Service automatically renews, rotates, and fetches secrets/tokens while the CSI Driver does not support that.  ","version":"Next","tagName":"h2"},{"title":"Comparison chart​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#comparison-chart","content":" The below chart provides a high-level comparison between the two solutions.  warning Note: Shared Memory Volume Environment Variable can be achieved through Agent templating.    ","version":"Next","tagName":"h2"},{"title":"Going beyond the native kubernetes secrets​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#going-beyond-the-native-kubernetes-secrets","content":" On the surface, Kubernetes native secrets might seem similar to the two approaches presented above, but there are significant differences between them:  Kubernetes is not a secrets management solution. It does have native support for secrets, but that is quite different from an enterprise secrets management solution. Kubernetes secrets are scoped to the cluster only, and many applications will have some services running outside Kubernetes or in other Kubernetes clusters. Having these applications use Kubernetes secrets from outside a Kubernetes environment will be cumbersome and introduce authentication and authorization challenges. Therefore, considering the secret scope as part of the design process is critical. Kubernetes secrets are static in nature. You can define secrets by using kubectl or the Kubernetes API, but once they are defined, they are stored in etcd and presented to pods only during pod creation. Defining secrets in this manner may create scenarios where secrets get stale, outdated, or expired, requiring additional workflows to update and rotate the secrets, and then re-deploy the application to use the new version, which can add complexity and become quite time-consuming. Ensure consideration is given to all requirements for secret freshness, updates, and rotation as part of your design process. The secret access management security model is tied to the Kubernetes RBAC model. This model can be challenging for users who are not familiar with Kubernetes. Adopting a platform-agnostic security governance model can enable you to adapt workflows for applications regardless of how and where they are running.  ","version":"Next","tagName":"h2"},{"title":"Summary​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#summary","content":" Designing secrets management in Kubernetes is an intricate task. There are multiple approaches, each with its own set of attributes. We recommend exploring the options presented in this document to increase your understanding of the internals and decide on the best option for your use case.  ","version":"Next","tagName":"h2"},{"title":"Additional resources​","type":1,"pageTitle":"Agent injector vs. Vault CSI provider","url":"/openbao/docs/platform/k8s/injector-csi/#additional-resources","content":" HashiCorp Vault: Delivering Secrets with Kubernetes Retrieve HashiCorp Vault Secrets with Kubernetes CSI Mount Vault Secrets Through Container Storage Interface (CSI) Volume Injecting Secrets into Kubernetes Pods via Vault Agent Containers Vault Sidecar Injector Configurations and Examples Vault CSI Driver Configurations and Examples ","version":"Next","tagName":"h2"},{"title":"Run Vault on kubernetes","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/helm/run/","content":"","keywords":"","version":"Next"},{"title":"Helm chart​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#helm-chart","content":" The Vault Helm chartis the recommended way to install and configure Vault on Kubernetes. In addition to running Vault itself, the Helm chart is the primary method for installing and configuring Vault to integrate with other services such as Consul for High Availability (HA) deployments.  While the Helm chart automatically sets up complex resources and exposes the configuration to meet your requirements, it does not automatically operate Vault. You are still responsible for learning how to monitor, backup, upgrade, etc. the Vault cluster.  warning Security Warning: By default, the chart runs in standalone mode. This mode uses a single Vault server with a file storage backend. This is a less secure and less resilient installation that is NOT appropriate for a production setup. It is highly recommended to use a properly secured Kubernetes cluster,learn the available configuration options, and read the production deployment checklist.  ","version":"Next","tagName":"h2"},{"title":"How-To​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#how-to","content":" ","version":"Next","tagName":"h2"},{"title":"Install Vault​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#install-vault","content":" Helm must be installed and configured on your machine. Please refer to the Helm documentation or the Vault Installation to Minikube via Helm tutorial.  To use the Helm chart, add the Hashicorp helm repository and check that you have access to the chart:  $ helm repo add hashicorp https://helm.releases.hashicorp.com &quot;hashicorp&quot; has been added to your repositories $ helm search repo hashicorp/vault NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart   info Important: The Helm chart is new and under significant development. Please always run Helm with --dry-run before any install or upgrade to verify changes.  Use helm install to install the latest release of the Vault Helm chart.  $ helm install vault hashicorp/vault   Or install a specific version of the chart.  # List the available releases $ helm search repo hashicorp/vault -l NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart hashicorp/vault\t0.24.0 1.13.1 Official HashiCorp Vault Chart hashicorp/vault\t0.23.0 1.12.1 Official HashiCorp Vault Chart hashicorp/vault\t0.22.1 1.12.0 Official HashiCorp Vault Chart hashicorp/vault\t0.22.0 1.11.3 Official HashiCorp Vault Chart hashicorp/vault\t0.21.0 1.11.2 Official HashiCorp Vault Chart hashicorp/vault\t0.20.1 1.10.3 Official HashiCorp Vault Chart ... # Install version 0.25.0 $ helm install vault hashicorp/vault --version 0.25.0   The helm install command accepts parameters to override default configuration values inline or defined in a file.  Override the server.dev.enabled configuration value:  $ helm install vault hashicorp/vault \\ --set &quot;server.dev.enabled=true&quot;   Override all the configuration found in a file:  $ cat override-values.yml server: ha: enabled: true replicas: 5 ## $ helm install vault hashicorp/vault \\ --values override-values.yml   Dev mode​  The Helm chart may run a Vault server in development. This installs a single Vault server with a memory storage backend.  info Dev mode: This is ideal for learning and demonstration environments but NOT recommended for a production environment.  Install the latest Vault Helm chart in development mode.  $ helm install vault hashicorp/vault \\ --set &quot;server.dev.enabled=true&quot;   Standalone mode​  The Helm chart defaults to run in standalone mode. This installs a single Vault server with a file storage backend.  Install the latest Vault Helm chart in standalone mode.  $ helm install vault hashicorp/vault   HA mode​  The Helm chart may be run in high availability (HA) mode. This installs three Vault servers with an existing Consul storage backend. It is suggested that Consul is installed via the Consul Helm chart.  Install the latest Vault Helm chart in HA mode.  $ helm install vault hashicorp/vault \\ --set &quot;server.ha.enabled=true&quot;   Refer to the Vault Installation to Minikube via Helm tutorial to learn how to set up Consul and Vault in HA mode.  External mode​  The Helm chart may be run in external mode. This installs no Vault server and relies on a network addressable Vault server to exist.  Install the latest Vault Helm chart in external mode.  $ helm install vault hashicorp/vault \\ --set &quot;injector.externalVaultAddr=http://external-vault:8200&quot;   Refer to the Integrate a Kubernetes Cluster with an External Vaulttutorial to learn how to use an external Vault within a Kubernetes cluster.  ","version":"Next","tagName":"h3"},{"title":"View the Vault UI​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#view-the-vault-ui","content":" The Vault UI is enabled but NOT exposed as service for security reasons. The Vault UI can also be exposed via port-forwarding or through a uiconfiguration value.  Expose the Vault UI with port-forwarding:  $ kubectl port-forward vault-0 8200:8200 Forwarding from 127.0.0.1:8200 -&gt; 8200 Forwarding from [::1]:8200 -&gt; 8200 ##...   ","version":"Next","tagName":"h3"},{"title":"Initialize and unseal Vault​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#initialize-and-unseal-vault","content":" After the Vault Helm chart is installed in standalone or ha mode one of the Vault servers need to beinitialized. The initialization generates the credentials necessary tounseal all the Vault servers.  CLI initialize and unseal​  View all the Vault pods in the current namespace:  $ kubectl get pods -l app.kubernetes.io/name=vault NAME READY STATUS RESTARTS AGE vault-0 0/1 Running 0 1m49s vault-1 0/1 Running 0 1m49s vault-2 0/1 Running 0 1m49s   Initialize one Vault server with the default number of key shares and default key threshold:  $ kubectl exec -ti vault-0 -- vault operator init Unseal Key 1: MBFSDepD9E6whREc6Dj+k3pMaKJ6cCnCUWcySJQymObb Unseal Key 2: zQj4v22k9ixegS+94HJwmIaWLBL3nZHe1i+b/wHz25fr Unseal Key 3: 7dbPPeeGGW3SmeBFFo04peCKkXFuuyKc8b2DuntA4VU5 Unseal Key 4: tLt+ME7Z7hYUATfWnuQdfCEgnKA2L173dptAwfmenCdf Unseal Key 5: vYt9bxLr0+OzJ8m7c7cNMFj7nvdLljj0xWRbpLezFAI9 Initial Root Token: s.zJNwZlRrqISjyBHFMiEca6GF ##...   The output displays the key shares and initial root key generated.  Unseal the Vault server with the key shares until the key threshold is met:  ## Unseal the first vault server until it reaches the key threshold $ kubectl exec -ti vault-0 -- vault operator unseal # ... Unseal Key 1 $ kubectl exec -ti vault-0 -- vault operator unseal # ... Unseal Key 2 $ kubectl exec -ti vault-0 -- vault operator unseal # ... Unseal Key 3   Repeat the unseal process for all Vault server pods. When all Vault server pods are unsealed they report READY 1/1.  $ kubectl get pods -l app.kubernetes.io/name=vault NAME READY STATUS RESTARTS AGE vault-0 1/1 Running 0 1m49s vault-1 1/1 Running 0 1m49s vault-2 1/1 Running 0 1m49s   Google KMS auto unseal​  The Helm chart may be run with Google KMS for Auto Unseal. This enables Vault server pods to auto unseal if they are rescheduled.  Vault Helm requires the Google Cloud KMS credentials stored incredentials.json and mounted as a secret in each Vault server pod.  Create the secret​  First, create the secret in Kubernetes:  kubectl create secret generic kms-creds --from-file=credentials.json   Vault Helm mounts this to /vault/userconfig/kms-creds/credentials.json.  Config example​  This is a Vault Helm configuration that uses Google KMS:  global: enabled: true server: extraEnvironmentVars: GOOGLE_REGION: global GOOGLE_PROJECT: &lt;PROJECT NAME&gt; GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/kms-creds/credentials.json volumes: - name: userconfig-kms-creds secret: defaultMode: 420 secretName: kms-creds volumeMounts: - mountPath: /vault/userconfig/kms-creds name: userconfig-kms-creds readOnly: true ha: enabled: true replicas: 3 config: | ui = true listener &quot;tcp&quot; { tls_disable = 1 address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; } seal &quot;gcpckms&quot; { project = &quot;&lt;NAME OF PROJECT&gt;&quot; region = &quot;global&quot; key_ring = &quot;&lt;NAME OF KEYRING&gt;&quot; crypto_key = &quot;&lt;NAME OF KEY&gt;&quot; } storage &quot;consul&quot; { path = &quot;vault&quot; address = &quot;HOST_IP:8500&quot; }   Amazon KMS auto unseal​  The Helm chart may be run with AWS KMS for Auto Unseal. This enables Vault server pods to auto unseal if they are rescheduled.  Vault Helm requires the AWS credentials stored as environment variables that are defined in each Vault server pod.  Create the secret​  First, create a secret with your KMS access key/secret:  $ kubectl create secret generic kms-creds \\ --from-literal=AWS_ACCESS_KEY_ID=&quot;${AWS_ACCESS_KEY_ID?}&quot; \\ --from-literal=AWS_SECRET_ACCESS_KEY=&quot;${AWS_SECRET_ACCESS_KEY?}&quot;   Config example​  This is a Vault Helm configuration that uses AWS KMS:  global: enabled: true server: extraSecretEnvironmentVars: - envName: AWS_ACCESS_KEY_ID secretName: kms-creds secretKey: AWS_ACCESS_KEY_ID - envName: AWS_SECRET_ACCESS_KEY secretName: kms-creds secretKey: AWS_SECRET_ACCESS_KEY ha: enabled: true config: | ui = true listener &quot;tcp&quot; { tls_disable = 1 address = &quot;[::]:8200&quot; cluster_address = &quot;[::]:8201&quot; } seal &quot;awskms&quot; { region = &quot;KMS_REGION_HERE&quot; kms_key_id = &quot;KMS_KEY_ID_HERE&quot; } storage &quot;consul&quot; { address = &quot;HOST_IP:8500&quot; path = &quot;vault/&quot; }   ","version":"Next","tagName":"h3"},{"title":"Probes​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#probes","content":" Probes are essential for detecting failures, rescheduling and using pods in Kubernetes. The helm chart offers configurable readiness and liveliness probes which can be customized for a variety of use cases.  Vault's /sys/health` endpoint can be customized to change the behavior of the health check. For example, we can change the Vault readiness probe to show the Vault pods are ready even if they're still uninitialized and sealed using the following probe:  server: readinessProbe: enabled: true path: '/v1/sys/health?standbyok=true&amp;sealedcode=204&amp;uninitcode=204'   Using this customized probe, a postStart script could automatically run once the pod is ready for additional setup.  ","version":"Next","tagName":"h3"},{"title":"Upgrading Vault on kubernetes​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#upgrading-vault-on-kubernetes","content":" To upgrade Vault on Kubernetes, we follow the same pattern asgenerally upgrading Vault, except we can use the Helm chart to update the Vault server StatefulSet. It is important to understand how to generally upgrade Vault before reading this section.  The Vault StatefulSet uses OnDelete update strategy. It is critical to use OnDelete instead of RollingUpdate because standbys must be updated before the active primary. A failover to an older version of Vault must always be avoided.  danger IMPORTANT NOTE: Always back up your data before upgrading! Vault does not make backward-compatibility guarantees for its data store. Simply replacing the newly-installed Vault binary with the previous version may not cleanly downgrade Vault, as upgrades may perform changes to the underlying data structure that make the data incompatible with a downgrade. If you need to roll back to a previous version of Vault, you should roll back your data store as well.  Upgrading Vault servers​  danger IMPORTANT NOTE: Helm will install the latest chart found in a repo by default. It's recommended to specify the chart version when upgrading.  To initiate the upgrade, set the server.image values to the desired Vault version, either in a values yaml file or on the command line. For illustrative purposes, the example below uses vault:123.456.  server: image: repository: 'vault' tag: '123.456'   Next, list the Helm versions and choose the desired version to install.  $ helm search repo hashicorp/vault NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault\t0.25.0 1.14.0 Official HashiCorp Vault Chart   Next, test the upgrade with --dry-run first to verify the changes sent to the Kubernetes cluster.  $ helm upgrade vault hashicorp/vault --version=0.25.0 \\ --set='server.image.repository=vault' \\ --set='server.image.tag=123.456' \\ --dry-run   This should cause no changes (although the resources are updated). If everything is stable, helm upgrade can be run.  The helm upgrade command should have updated the StatefulSet template for the Vault servers, however, no pods have been deleted. The pods must be manually deleted to upgrade. Deleting the pods does not delete any persisted data.  If Vault is not deployed using ha mode, the single Vault server may be deleted by running:  $ kubectl delete pod &lt;name of Vault pod&gt;   If Vault is deployed using ha mode, the standby pods must be upgraded first. Vault has K8s service discovery built in (when enabled in the server configuration) and will automatically change the labels of the pod with its current leader status. These labels can be used to filter the pods.  For example, select all pods that are Vault standbys:  $ kubectl get pods -l vault-active=false   Select the active Vault pod:  $ kubectl get pods -l vault-active=true   Next, sequentially delete every pod that is not the active primary, ensuring the quorum is maintained at all times:  $ kubectl delete pod &lt;name of Vault pod&gt;   If auto-unseal is not being used, the newly scheduled Vault standby pods needs to be unsealed:  $ kubectl exec -ti &lt;name of pod&gt; -- vault operator unseal   Finally, once the standby nodes have been updated and unsealed, delete the active primary:  $ kubectl delete pod &lt;name of Vault primary&gt;   Similar to the standby nodes, the former primary also needs to be unsealed:  $ kubectl exec -ti &lt;name of pod&gt; -- vault operator unseal   After a few moments the Vault cluster should elect a new active primary. The Vault cluster is now upgraded!  ","version":"Next","tagName":"h3"},{"title":"Protecting sensitive Vault configurations​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#protecting-sensitive-vault-configurations","content":" Vault Helm renders a Vault configuration file during installation and stores the file in a Kubernetes configmap. Some configurations require sensitive data to be included in the configuration file and would not be encrypted at rest once created in Kubernetes.  The following example shows how to add extra configuration files to Vault Helm to protect sensitive configurations from being in plaintext at rest using Kubernetes secrets.  First, create a partial Vault configuration with the sensitive settings Vault loads during startup:  $ cat &lt;&lt;EOF &gt;&gt;config.hcl storage &quot;mysql&quot; { username = &quot;user1234&quot; password = &quot;secret123!&quot; database = &quot;vault&quot; } EOF   Next, create a Kubernetes secret containing this partial configuration:  $ kubectl create secret generic vault-storage-config \\ --from-file=config.hcl   Finally, mount this secret as an extra volume and add an additional -config flag to the Vault startup command:  $ helm install vault hashicorp/vault \\ --set='server.volumes[0].name=userconfig-vault-storage-config' \\ --set='server.volumes[0].secret.defaultMode=420' \\ --set='server.volumes[0].secret.secretName=vault-storage-config' \\ --set='server.volumeMounts[0].mountPath=/vault/userconfig/vault-storage-config' \\ --set='server.volumeMounts[0].name=userconfig-vault-storage-config' \\ --set='server.volumeMounts[0].readOnly=true' \\ --set='server.extraArgs=-config=/vault/userconfig/vault-storage-config/config.hcl'   ","version":"Next","tagName":"h3"},{"title":"Architecture​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#architecture","content":" We recommend running Vault on Kubernetes with the samegeneral architectureas running it anywhere else. There are some benefits Kubernetes can provide that eases operating a Vault cluster and we document those below. The standardproduction deployment tutorial is still an important read even if running Vault within Kubernetes.  ","version":"Next","tagName":"h2"},{"title":"Production deployment checklist​","type":1,"pageTitle":"Run Vault on kubernetes","url":"/openbao/docs/platform/k8s/helm/run/#production-deployment-checklist","content":" End-to-End TLS. Vault should always be used with TLS in production. If intermediate load balancers or reverse proxies are used to front Vault, they should not terminate TLS. This way traffic is always encrypted in transit to Vault and minimizes risks introduced by intermediate layers. See theofficial documentationfor example on configuring Vault Helm to use TLS.  Single Tenancy. Vault should be the only main process running on a machine. This reduces the risk that another process running on the same machine is compromised and can interact with Vault. This can be accomplished by using Vault Helm's affinity configurable. See theofficial documentationfor example on configuring Vault Helm to use affinity rules.  Enable Auditing. Vault supports several auditing backends. Enabling auditing provides a history of all operations performed by Vault and provides a forensics trail in the case of misuse or compromise. Audit logs securely hash any sensitive data, but access should still be restricted to prevent any unintended disclosures. Vault Helm includes a configurable auditStorage option that provisions a persistent volume to store audit logs. See theofficial documentationfor an example on configuring Vault Helm to use auditing.  Immutable Upgrades. Vault relies on an external storage backend for persistence, and this decoupling allows the servers running Vault to be managed immutably. When upgrading to new versions, new servers with the upgraded version of Vault are brought online. They are attached to the same shared storage backend and unsealed. Then the old servers are destroyed. This reduces the need for remote access and upgrade orchestration which may introduce security gaps. See theupgrade section for instructions on upgrading Vault on Kubernetes.  Upgrade Frequently. Vault is actively developed, and updating frequently is important to incorporate security fixes and any changes in default settings such as key lengths or cipher suites. Subscribe to the Vault mailing list and GitHub CHANGELOG for updates.  Restrict Storage Access. Vault encrypts all data at rest, regardless of which storage backend is used. Although the data is encrypted, an attacker with arbitrary control can cause data corruption or loss by modifying or deleting keys. Access to the storage backend should be restricted to only Vault to avoid unauthorized access or operations. ","version":"Next","tagName":"h3"},{"title":"Agent sidecar injector","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/injector/","content":"","keywords":"","version":"Next"},{"title":"Supported kubernetes versions","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/##","content":" The following Kubernetes minor releases are currently supported. The latest version is tested against each Kubernetes version. It may work with other versions of Kubernetes, but those are not supported.  1.271.261.251.241.23  ","version":"Next","tagName":"h2"},{"title":"Overview​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#overview","content":" The Vault Agent Injector works by intercepting pod CREATE and UPDATEevents in Kubernetes. The controller parses the event and looks for the metadata annotation vault.hashicorp.com/agent-inject: true. If found, the controller will alter the pod specification based on other annotations present.  ","version":"Next","tagName":"h2"},{"title":"Mutations​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#mutations","content":" At a minimum, every container in the pod will be configured to mount a shared memory volume. This volume is mounted to /vault/secrets and will be used by the Vault Agent containers for sharing secrets with the other containers in the pod.  Next, two types of Vault Agent containers can be injected: init and sidecar. The init container will prepopulate the shared memory volume with the requested secrets prior to the other containers starting. The sidecar container will continue to authenticate and render secrets to the same location as the pod runs. Using annotations, the initialization and sidecar containers may be disabled.  Last, two additional types of volumes can be optionally mounted to the Vault Agent containers. The first is secret volume containing TLS requirements such as client and CA (certificate authority) certificates and keys. This volume is useful when communicating and verifying the Vault server's authenticity using TLS. The second is a configuration map containing Vault Agent configuration files. This volume is useful to customize Vault Agent beyond what the provided annotations offer.  ","version":"Next","tagName":"h3"},{"title":"Authenticating with Vault​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#authenticating-with-vault","content":" The primary method of authentication with Vault when using the Vault Agent Injector is the service account attached to the pod. Other authentication methods can be configured using annotations.  For Kubernetes authentication, the service account must be bound to a Vault role and a policy granting access to the secrets desired.  A service account must be present to use the Vault Agent Injector with the Kubernetes authentication method. It is not recommended to bind Vault roles to the default service account provided to pods if no service account is defined.  ","version":"Next","tagName":"h3"},{"title":"Requesting secrets​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#requesting-secrets","content":" There are two methods of configuring the Vault Agent containers to render secrets:  the vault.hashicorp.com/agent-inject-secret annotation, ora configuration map containing Vault Agent configuration files.  Only one of these methods may be used at any time.  Secrets via annotations​  To configure secret injection using annotations, the user must supply:  one or more secret annotations, andthe Vault role used to access those secrets.  The annotation must have the format:  vault.hashicorp.com/agent-inject-secret-&lt;unique-name&gt;: /path/to/secret   The unique name will be the filename of the rendered secret and must be unique if multiple secrets are defined by the user. For example, consider the following secret annotations:  vault.hashicorp.com/agent-inject-secret-foo: database/roles/app vault.hashicorp.com/agent-inject-secret-bar: consul/creds/app vault.hashicorp.com/role: 'app'   The first annotation will be rendered to /vault/secrets/foo and the second annotation will be rendered to /vault/secrets/bar.  It's possible to set the file format of the rendered secret using the annotation. For example the following secret will be rendered to /vault/secrets/foo.txt:  vault.hashicorp.com/agent-inject-secret-foo.txt: database/roles/app vault.hashicorp.com/role: 'app'   The secret unique name must consist of alphanumeric characters, ., _ or -.  Secret templates​  warning Vault Agent uses the Consul Template project to render secrets. For more information on writing templates, see the Consul Template documentation.  How the secret is rendered to the file is also configurable. To configure the template used, the user must supply a template annotation using the same unique name of the secret. The annotation must have the following format:  vault.hashicorp.com/agent-inject-template-&lt;unique-name&gt;: | &lt; TEMPLATE HERE &gt;   For example, consider the following:  vault.hashicorp.com/agent-inject-secret-foo: 'database/creds/db-app' vault.hashicorp.com/agent-inject-template-foo: | {{- with secret &quot;database/creds/db-app&quot; -}} postgres://{{ .Data.username }}:{{ .Data.password }}@postgres:5432/mydb?sslmode=disable {{- end }} vault.hashicorp.com/role: 'app'   The rendered secret would look like this within the container:  $ cat /vault/secrets/foo postgres://v-kubernet-pg-app-q0Z7WPfVN:A1a-BUEuQR52oAqPrP1J@postgres:5432/mydb?sslmode=disable   warning The default left and right template delimiters are {{ and }}.  If no template is provided the following generic template is used:  {{ with secret &quot;/path/to/secret&quot; }} {{ range $k, $v := .Data }} {{ $k }}: {{ $v }} {{ end }} {{ end }}   For example, the following annotation will use the default template to render PostgreSQL secrets found at the configured path:  vault.hashicorp.com/agent-inject-secret-foo: 'database/roles/pg-app' vault.hashicorp.com/role: 'app'   The rendered secret would look like this within the container:  $ cat /vault/secrets/foo password: A1a-BUEuQR52oAqPrP1J username: v-kubernet-pg-app-q0Z7WPfVNqqTJuoDqCTY-1576529094   warning Some secrets such as KV are stored in maps. Their data can be accessed using .Data.data.&lt;NAME&gt;  ","version":"Next","tagName":"h3"},{"title":"Renewals and updating secrets​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#renewals-and-updating-secrets","content":" For more information on when Vault Agent fetches and renews secrets, see theAgent documentation.  ","version":"Next","tagName":"h3"},{"title":"Vault agent configuration map​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#vault-agent-configuration-map","content":" For advanced use cases, it may be required to define Vault Agent configuration files to mount instead of using secret and template annotations. The Vault Agent Injector supports mounting ConfigMaps by specifying the name using the vault.hashicorp.com/agent-configmapannotation. The configuration files will be mounted to /vault/configs.  The configuration map must contain either one or both of the following files:  config-init.hcl used by the init container. This must have exit_after_auth set to true.config.hcl used by the sidecar container. This must have exit_after_auth set to false.  An example of mounting a Vault Agent configmap can be found here.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Agent sidecar injector","url":"/openbao/docs/platform/k8s/injector/#tutorial","content":" Refer to the Injecting Secrets into Kubernetes Pods via Vault Helm Sidecar guide for a step-by-step tutorial. ","version":"Next","tagName":"h2"},{"title":"Annotations","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/injector/annotations/","content":"","keywords":"","version":"Next"},{"title":"Agent annotations​","type":1,"pageTitle":"Annotations","url":"/openbao/docs/platform/k8s/injector/annotations/#agent-annotations","content":" Agent annotations change the Vault Agent containers templating configuration. For example, agent annotations allow users to define what secrets they want, how to render them, optional commands to run, etc.  vault.hashicorp.com/agent-inject - configures whether injection is explicitly enabled or disabled for a pod. This should be set to a true or false value. Defaults to false. vault.hashicorp.com/agent-inject-status - blocks further mutations by adding the value injected to the pod after a successful mutation. vault.hashicorp.com/agent-configmap - name of the configuration map where Vault Agent configuration file and templates can be found. vault.hashicorp.com/agent-image - name of the Vault docker image to use. This value overrides the default image configured in the injector and is usually not needed. Defaults to hashicorp/vault:1.12.3. vault.hashicorp.com/agent-init-first - configures the pod to run the Vault Agent init container first if true (last if false). This is useful when other init containers need pre-populated secrets. This should be set to a true or falsevalue. Defaults to false. vault.hashicorp.com/agent-inject-command - configures Vault Agent to run a command after the template has been rendered. To map a command to a specific secret, use the same unique secret name: vault.hashicorp.com/agent-inject-command-SECRET-NAME. For example, if a secret annotation vault.hashicorp.com/agent-inject-secret-foobaris configured, vault.hashicorp.com/agent-inject-command-foobar would map a command to that secret. vault.hashicorp.com/agent-inject-secret - configures Vault Agent to retrieve the secrets from Vault required by the container. The name of the secret is any unique string after vault.hashicorp.com/agent-inject-secret-, such as vault.hashicorp.com/agent-inject-secret-foobar. The value is the path in Vault where the secret is located. vault.hashicorp.com/agent-inject-template - configures the template Vault Agent should use for rendering a secret. The name of the template is any unique string after vault.hashicorp.com/agent-inject-template-, such asvault.hashicorp.com/agent-inject-template-foobar. This should map to the same unique value provided in vault.hashicorp.com/agent-inject-secret-. If not provided, a default generic template is used. vault.hashicorp.com/agent-inject-containers - comma-separated list that specifies in which containers the secrets volume should be mounted. If not provided, the secrets volume will be mounted in all containers in the pod. vault.hashicorp.com/secret-volume-path - configures where on the filesystem a secret will be rendered. To map a path to a specific secret, use the same unique secret name:vault.hashicorp.com/secret-volume-path-SECRET-NAME. For example, if a secret annotationvault.hashicorp.com/agent-inject-secret-foobar is configured,vault.hashicorp.com/secret-volume-path-foobar would configure where that secret is rendered. If no secret name is provided, this sets the default for all rendered secrets in the pod. vault.hashicorp.com/agent-inject-file - configures the filename and path in the secrets volume where a Vault secret will be written. This should be used with vault.hashicorp.com/secret-volume-path, which mounts a memory volume to the specified path. If secret-volume-path is used, the path can be omitted from this value. To map a filename to a specific secret, use the same unique secret name:vault.hashicorp.com/agent-inject-file-SECRET-NAME. For example, if a secret annotationvault.hashicorp.com/agent-inject-secret-foobar is configured,vault.hashicorp.com/agent-inject-file-foobar would configure the filename. vault.hashicorp.com/agent-inject-perms - configures the permissions of the file to create in the secrets volume. The name of the secret is the string after &quot;vault.hashicorp.com/agent-inject-perms-&quot;, and should map to the same unique value provided in &quot;vault.hashicorp.com/agent-inject-secret-&quot;. The value is the octal permission, for example: 0644. vault.hashicorp.com/agent-inject-template-file - configures the path and filename of the custom template to use. This should be used with vault.hashicorp.com/extra-secret, which mounts a Kubernetes secret to /vault/custom. To map a template file to a specific secret, use the same unique secret name: vault.hashicorp.com/agent-inject-template-file-SECRET-NAME. For example, if a secret annotation vault.hashicorp.com/agent-inject-secret-foobar is configured,vault.hashicorp.com/agent-inject-template-file-foobar would configure the template file. vault.hashicorp.com/agent-inject-default-template - configures the default template type for rendering secrets if no custom template is defined. Possible values include map and json. Defaults to map. vault.hashicorp.com/template-config-exit-on-retry-failure - controls whether Vault Agent exits after it has exhausted its number of template retry attempts due to failures. Defaults to true. See Vault Agent Template Config for more details. vault.hashicorp.com/template-static-secret-render-interval - If specified, configures how often Vault Agent Template should render non-leased secrets such as KV v2. See Vault Agent Template Config for more details. vault.hashicorp.com/agent-extra-secret - mounts Kubernetes secret as a volume at/vault/custom in the sidecar/init containers. Useful for custom Agent configs with auto-auth methods such as approle that require paths to secrets be present. vault.hashicorp.com/agent-inject-token - configures Vault Agent to share the Vault token with other containers in the pod, in a file named token in the root of the secrets volume (i.e. /vault/secrets/token). This is helpful when other containers communicate directly with Vault but require auto-authentication provided by Vault Agent. This should be set to a true or false value. Defaults to false. vault.hashicorp.com/agent-limits-cpu - configures the CPU limits on the Vault Agent containers. Defaults to 500m. Setting this to an empty string disables CPU limits. vault.hashicorp.com/agent-limits-mem - configures the memory limits on the Vault Agent containers. Defaults to 128Mi. Setting this to an empty string disables memory limits. vault.hashicorp.com/agent-limits-ephemeral - configures the ephemeral storage limit on the Vault Agent containers. Defaults to unset, which disables ephemeral storage limits. Also available as a command-line option (-ephemeral-storage-limit) or environment variable (AGENT_INJECT_EPHEMERAL_LIMIT) to set the default for all injected Agent containers. Note: Pod limits are equal to the sum of all container limits. Setting this limit without setting it for other containers will also affect the limits of other containers in the pod. See Kubernetes resources documentation for more details. vault.hashicorp.com/agent-requests-cpu - configures the CPU requests on the Vault Agent containers. Defaults to 250m. Setting this to an empty string disables CPU requests. vault.hashicorp.com/agent-requests-mem - configures the memory requests on the Vault Agent containers. Defaults to 64Mi. Setting this to an empty string disables memory requests. vault.hashicorp.com/agent-requests-ephemeral - configures the ephemeral storage requests on the Vault Agent Containers. Defaults to unset, which disables ephemeral storage requests (and will default to the ephemeral limit if set). Also available as a command-line option (-ephemeral-storage-request) or environment variable (AGENT_INJECT_EPHEMERAL_REQUEST) to set the default for all injected Agent containers. Note: Pod requests are equal to the sum of all container requests. Setting this limit without setting it for other containers will also affect the requests of other containers in the pod. SeeKubernetes resources documentation for more details. vault.hashicorp.com/agent-revoke-on-shutdown - configures whether the sidecar will revoke it's own token before shutting down. This setting will only be applied to the Vault Agent sidecar container. This should be set to a true or falsevalue. Defaults to false. vault.hashicorp.com/agent-revoke-grace - configures the grace period, in seconds, for revoking it's own token before shutting down. This setting will only be applied to the Vault Agent sidecar container. Defaults to 5s. vault.hashicorp.com/agent-pre-populate - configures whether an init container is included to pre-populate the shared memory volume with secrets prior to the containers starting. vault.hashicorp.com/agent-pre-populate-only - configures whether an init container is the only injected container. If true, no sidecar container will be injected at runtime of the pod. Enabling this option is recommended for workloads of type CronJob or Job to ensure a clean pod termination. vault.hashicorp.com/preserve-secret-case - configures Vault Agent to preserve the secret name case when creating the secret files. This should be set to a trueor false value. Defaults to false. vault.hashicorp.com/agent-run-as-user - sets the user (uid) to run Vault agent as. Also available as a command-line option (-run-as-user) or environment variable (AGENT_INJECT_RUN_AS_USER) for the injector. Defaults to 100. vault.hashicorp.com/agent-run-as-group - sets the group (gid) to run Vault agent as. Also available as a command-line option (-run-as-group) or environment variable (AGENT_INJECT_RUN_AS_GROUP) for the injector. Defaults to 1000. vault.hashicorp.com/agent-set-security-context - controls whetherSecurityContext is set in injected containers. Also available as a command-line option (-set-security-context) or environment variable (AGENT_INJECT_SET_SECURITY_CONTEXT). Defaults to true. vault.hashicorp.com/agent-run-as-same-user - run the injected Vault agent containers as the User (uid) of the first application container in the pod. Requires Spec.Containers[0].SecurityContext.RunAsUser to be set in the pod spec. Also available as a command-line option (-run-as-same-user) or environment variable (AGENT_INJECT_RUN_AS_SAME_USER). Defaults to false.  warning Note: If the first application container in the pod is running as root (uid 0), the run-as-same-user annotation will fail injection with an error.  vault.hashicorp.com/agent-share-process-namespace - setsshareProcessNamespace in the Pod spec where Vault Agent is injected. Defaults to false. vault.hashicorp.com/agent-cache-enable - configures Vault Agent to enablecaching. In Vault 1.7+ this annotation will also enable a Vault Agent persistent cache. This persistent cache will be shared between the init and sidecar container to reuse tokens and leases retrieved by the init container. Defaults to false. vault.hashicorp.com/agent-cache-use-auto-auth-token - configures Vault Agent cache to authenticate on behalf of the requester. Set to force to enable. Disabled by default. vault.hashicorp.com/agent-cache-listener-port - configures Vault Agent cache listening port. Defaults to 8200. vault.hashicorp.com/agent-copy-volume-mounts - copies the mounts from the specified container and mounts them to the Vault Agent containers. The service account volume is ignored. vault.hashicorp.com/agent-service-account-token-volume-name - the optional name of a projected volume containing a service account token for use with auto-auth against Vault's Kubernetes auth method. If the volume is mounted to another container in the deployment, the token volume will be mounted to the same location in the vault-agent containers. Otherwise it will be mounted at the default location of /var/run/secrets/vault.hashicorp.com/serviceaccount/. vault.hashicorp.com/agent-enable-quit - enable the /agent/v1/quit endpoint on an injected agent. This option defaults to false, and if true will be set on the existing cache listener, or a new localhost listener with a basic cache stanza configured. The agent-cache-listener-port annotation can be used to change the port. vault.hashicorp.com/agent-telemetry - specifies the telemetry configuration for the Vault Agent sidecar. The name of the config is any unique string aftervault.hashicorp.com/agent-telemetry-, such as vault.hashicorp.com/agent-telemetry-prometheus_retention_time. This annotation can be reused multiple times to configure multiple settings for the agent telemetry. vault.hashicorp.com/go-max-procs - set the GOMAXPROCS environment variable for injected agents vault.hashicorp.com/agent-json-patch - change the injected agent sidecar container using a JSON patch before it is created. This can be used to add, remove, or modify any attribute of the container. For example, setting this to [{&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/name&quot;, &quot;value&quot;: &quot;different-name&quot;}] will update the agent container's name to be different-nameinstead of the default vault-agent. vault.hashicorp.com/agent-init-json-patch - same as vault.hashicorp.com/agent-json-patch, except that the JSON patch will be applied to the injected init container instead.  ","version":"Next","tagName":"h2"},{"title":"Vault annotations​","type":1,"pageTitle":"Annotations","url":"/openbao/docs/platform/k8s/injector/annotations/#vault-annotations","content":" Vault annotations change how the Vault Agent containers communicate with Vault. For example, Vault's address, TLS certificates to use, client parameters such as timeouts, etc.  vault.hashicorp.com/auth-config - configures additional parameters for the configured authentication method. The name of the config is any unique string aftervault.hashicorp.com/auth-config-, such as vault.hashicorp.com/auth-config-role-id-file-path. This annotation can be reused multiple times to configure multiple settings for the authentication method. Some authentication methods may require additional secrets and should be mounted via thevault.hashicorp.com/agent-extra-secret annotation. For a list of valid authentication configurations, see the Vault Agent auto-auth documentation. vault.hashicorp.com/auth-path - configures the authentication path for the Kubernetes auth method. Defaults to auth/kubernetes. vault.hashicorp.com/auth-type - configures the authentication type for Vault Agent. Defaults to kubernetes. For a list of valid authentication methods, see the Vault Agentauto-auth documentation. vault.hashicorp.com/auth-min-backoff - set the min_backoff option in the auto-auth config. Requires Vault 1.11+. vault.hashicorp.com/auth-max-backoff - set the max_backoff option in the auto-auth config vault.hashicorp.com/agent-auto-auth-exit-on-err - set the exit_on_err option in the auto-auth config vault.hashicorp.com/ca-cert - path of the CA certificate used to verify Vault's TLS. vault.hashicorp.com/ca-key - path of the CA public key used to verify Vault's TLS. vault.hashicorp.com/client-cert - path of the client certificate used when communicating with Vault via mTLS. vault.hashicorp.com/client-key - path of the client public key used when communicating with Vault via mTLS. vault.hashicorp.com/client-max-retries - configures number of Vault Agent retry attempts when certain errors are encountered. Defaults to 2, for 3 total attempts. Set this to 0 or less to disable retrying. Error codes that are retried are 412 (client consistency requirement not satisfied) and all 5xx except for 501 (not implemented). vault.hashicorp.com/client-timeout - configures the request timeout threshold, in seconds, of the Vault Agent when communicating with Vault. Defaults to 60sand accepts value types of 60, 60s or 1m. vault.hashicorp.com/log-level - configures the verbosity of the Vault Agent log level. Default is info. vault.hashicorp.com/log-format - configures the log type for Vault Agent. Possible values are standard and json. Default is standard. vault.hashicorp.com/proxy-address - configures the HTTP proxy to use when connecting to a Vault server. vault.hashicorp.com/role - configures the Vault role used by the Vault Agent auto-auth method. Required when vault.hashicorp.com/agent-configmap is not set. vault.hashicorp.com/service - configures the Vault address for the injected Vault Agent to use. This value overrides the default Vault address configured in the injector, and may either be the address of a Vault service within the same Kubernetes cluster as the injector, or an external Vault URL. vault.hashicorp.com/tls-secret - name of the Kubernetes secret containing TLS Client and CA certificates and keys. This is mounted to /vault/tls. vault.hashicorp.com/tls-server-name - name of the Vault server to verify the authenticity of the server when communicating with Vault over TLS. vault.hashicorp.com/tls-skip-verify - if true, configures the Vault Agent to skip verification of Vault's TLS certificate. It's not recommended to set this value to true in a production environment. vault.hashicorp.com/agent-disable-idle-connections - Comma-separated list of Vault Agent features where idle connections should be disabled. Also available as a command-line option (-disable-idle-connections) or environment variable (AGENT_INJECT_DISABLE_IDLE_CONNECTIONS) to set the default for all injected Agents. vault.hashicorp.com/agent-disable-keep-alives - Comma-separated list of Vault Agent features where keep-alives should be disabled. Also available as a command-line option (-disable-keep-alives) or environment variable (AGENT_INJECT_DISABLE_KEEP_ALIVES) to set the default for all injected Agents. ","version":"Next","tagName":"h2"},{"title":"Installing the agent injector","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/injector/installation/","content":"","keywords":"","version":"Next"},{"title":"TLS options​","type":1,"pageTitle":"Installing the agent injector","url":"/openbao/docs/platform/k8s/injector/installation/#tls-options","content":" Admission webhook controllers require TLS to run within Kubernetes. The Injector defaults to supporting TLS 1.2 and above, and supports configuring the minimum supported TLS version and list of enabled cipher suites. These can be set via the following environment variables:  Environment variable\tDescriptionAGENT_INJECT_TLS_MIN_VERSION\tMinimum supported version of TLS. Defaults to tls12. Accepted values are tls10, tls11, tls12, or tls13. AGENT_INJECT_TLS_CIPHER_SUITES\tComma-separated list of enabled cipher suites for TLS 1.0-1.2. (Cipher suites are not configurable for TLS 1.3.)  warning Warning: TLS 1.1 and lower are generally considered insecure.  These may be set in a Helm chart deployment via theinjector.extraEnvironmentVarsoption:  helm install vault hashicorp/vault \\ --set=&quot;injector.extraEnvironmentVars.AGENT_INJECT_TLS_MIN_VERSION=tls13&quot; \\ --set=&quot;injector.extraEnvironmentVars.AGENT_INJECT_TLS_CIPHER_SUITES=...&quot;   The Vault Agent Injector also supports two TLS management options:  Auto TLS generation (default)Manual TLS  ","version":"Next","tagName":"h2"},{"title":"Auto TLS​","type":1,"pageTitle":"Installing the agent injector","url":"/openbao/docs/platform/k8s/injector/installation/#auto-tls","content":" By default, the Vault Agent Injector will bootstrap TLS by generating a certificate authority and creating a certificate/key to be used by the controller. If using Vault Helm, the chart will automatically create the necessary DNS entries for the controller's service used to verify the certificate.  ","version":"Next","tagName":"h3"},{"title":"Manual TLS​","type":1,"pageTitle":"Installing the agent injector","url":"/openbao/docs/platform/k8s/injector/installation/#manual-tls","content":" If desired, users can supply their own TLS certificates, key and certificate authority. The following is required to configure TLS manually:  Server certificate/keyBase64 PEM encoded Certificate Authority bundle  For more information on configuring manual TLS, see the Vault Helm cert values.  This option may also be used in conjunction with cert-manager for certificate management.  ","version":"Next","tagName":"h3"},{"title":"Multiple replicas and TLS​","type":1,"pageTitle":"Installing the agent injector","url":"/openbao/docs/platform/k8s/injector/installation/#multiple-replicas-and-tls","content":" The Vault Agent Injector can be run with multiple replicas if using Manual TLS or cert-manager, and as of v0.7.0 multiple replicas are also supported withAuto TLS. The number of replicas is controlled in the Vault Helm chart by the injector.replicas value.  With Auto TLS and multiple replicas, a leader replica is determined by ownership of a ConfigMap named vault-k8s-leader. Another replica can become the leader once the current leader replica stops running, and the Kubernetes garbage collector deletes the ConfigMap. The leader replica is in charge of generating the CA and patching the webhook caBundle in Kubernetes, and also generating and distributing the certificate and key to the &quot;followers&quot;. The followers read the certificate and key needed for the webhook service listener from a Kubernetes Secret, which is updated by the leader when a certificate is near expiration.  With Manual TLS and multiple replicas,injector.leaderElector.enabledcan be set to false since leader determination is not necessary in this case.  ","version":"Next","tagName":"h2"},{"title":"Namespace selector​","type":1,"pageTitle":"Installing the agent injector","url":"/openbao/docs/platform/k8s/injector/installation/#namespace-selector","content":" By default, the Vault Agent Injector will process all namespaces in Kubernetes except the system namespaces kube-system and kube-public. To limit what namespaces the injector can work in a namespace selector can be defined to match labels attached to namespaces.  For more information on configuring namespace selection, see the Vault Helm namespaceSelector value. ","version":"Next","tagName":"h2"},{"title":"Vault Secrets Operator","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/#overview","content":" The Vault Secrets Operator operates by watching for changes to its supported set of Custom Resource Definitions (CRD). Each CRD provides the specification required to allow the operator to synchronize from one of the supported sources for secrets to a Kubernetes Secret. The operator writes the source secret data directly to the destination Kubernetes Secret, ensuring that any changes made to the source are replicated to the destination over its lifetime. In this way, an application only needs to have access to the destination secret in order to make use of the secret data contained within.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/#features","content":" The following features are supported by the Vault Secrets Operator:  Support for syncing from multiple secret sources.Automatic secret drift and remediation.Automatic secret rotation for Deployment, ReplicaSet, StatefulSet Kubernetes resource types.Prometheus specific instrumentation for monitoring the Operator.Support for installing using: Helm or Kustomize see the installation docs for more details  ","version":"Next","tagName":"h2"},{"title":"Supported secret sources​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/#supported-secret-sources","content":" The Vault Secrets Operator supports syncing from multiple secret sources. Refer to the secret sources overview for more details.  ","version":"Next","tagName":"h2"},{"title":"Supported kubernetes versions","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/##","content":" The following Kubernetes minor releases are currently supported. The latest version is tested against each Kubernetes version. It may work with other versions of Kubernetes, but those are not supported.  1.271.261.251.241.23  ","version":"Next","tagName":"h2"},{"title":"Supported Kubernetes distributions​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/#supported-kubernetes-distributions","content":" The Vault Secrets Operator has been tested successfully in the following hosted Kubernetes environments:  Amazon Elastic Kubernetes Service (EKS)Google Kubernetes Engine (GKE)Microsoft Azure Kubernetes Service (AKS)Red Hat OpenShift  Basic integration tests are available in the project repository. Please report any issues here.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/#tutorial","content":" Refer to the Vault Secrets Operator on Kubernetes tutorial to learn the end-to-end workflow using the Vault Secrets Operator. ","version":"Next","tagName":"h2"},{"title":"Vault agent injector examples","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/injector/examples/","content":"","keywords":"","version":"Next"},{"title":"Before using the Vault agent injector​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#before-using-the-vault-agent-injector","content":" Before applying Vault Agent injection annotations to pods, the following requirements should be satisfied.  ","version":"Next","tagName":"h2"},{"title":"Connectivity​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#connectivity","content":" the Kubernetes API can connect to the Vault Agent injector service on port 443, and the injector can connect to the Kubernetes API,Vault can connect to the Kubernetes API,Pods in the Kubernetes cluster can connect to Vault.  warning Note: The Kubernetes API typically runs on the master nodes, and the Vault Agent injector on a worker node in a Kubernetes cluster. On Kubernetes clusters that have aggregator routing enabled (ex. GKE private clusters), the Kubernetes API will connect directly to the injector service endpoint, which is on port 8080.  ","version":"Next","tagName":"h3"},{"title":"Kubernetes and Vault configuration​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#kubernetes-and-vault-configuration","content":" Kubernetes auth method should be configured and enabled in Vault,Pod should have a service account,desired secrets exist within Vault,the service account should be bound to a Vault role with a policy enabling access to desired secrets.  For more information on configuring the Vault Kubernetes auth method,see the official documentation.  ","version":"Next","tagName":"h3"},{"title":"Debugging​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#debugging","content":" If an error occurs with a mutation request, Kubernetes will attach the error to the owner of the pod. Check the following for errors:  If the pod was created by a deployment or statefulset, check for errors in the replicasetthat owns the pod.If the pod was created by a job, check the job for errors.  ","version":"Next","tagName":"h2"},{"title":"Patching existing pods​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#patching-existing-pods","content":" To patch existing pods, a Kubernetes patch can be applied to add the required annotations to pods. When applying a patch, the pods will be rescheduled.  First, create the patch:  cat &lt;&lt;EOF &gt;&gt; ./patch.yaml spec: template: metadata: annotations: vault.hashicorp.com/agent-inject: &quot;true&quot; vault.hashicorp.com/agent-inject-status: &quot;update&quot; vault.hashicorp.com/agent-inject-secret-db-creds: &quot;database/creds/db-app&quot; vault.hashicorp.com/agent-inject-template-db-creds: | {{- with secret &quot;database/creds/db-app&quot; -}} postgres://{{ .Data.username }}:{{ .Data.password }}@postgres:5432/appdb?sslmode=disable {{- end }} vault.hashicorp.com/role: &quot;db-app&quot; vault.hashicorp.com/ca-cert: &quot;/vault/tls/ca.crt&quot; vault.hashicorp.com/client-cert: &quot;/vault/tls/client.crt&quot; vault.hashicorp.com/client-key: &quot;/vault/tls/client.key&quot; vault.hashicorp.com/tls-secret: &quot;vault-tls-client&quot; EOF   Next, apply the patch:  kubectl patch deployment &lt;MY DEPLOYMENT&gt; --patch &quot;$(cat patch.yaml)&quot;   The pod should now be rescheduled with additional containers. The pod can be inspected using the kubectl describe command:  kubectl describe pod &lt;name of pod&gt;   ","version":"Next","tagName":"h2"},{"title":"Deployments, StatefulSets, etc.​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#deployments-statefulsets-etc","content":" The annotations for configuring Vault Agent injection must be on the pod specification. Since higher level resources such as Deployments wrap pod specification templates, Vault Agent Injector can be used with all of these higher level constructs, too.  An example Deployment below shows how to enable Vault Agent injection:  --- apiVersion: v1 kind: ServiceAccount metadata: name: app-example --- apiVersion: apps/v1 kind: Deployment metadata: name: app-example-deployment spec: replicas: 1 selector: matchLabels: app: app-example template: metadata: labels: app: app-example annotations: vault.hashicorp.com/agent-inject: 'true' vault.hashicorp.com/agent-inject-secret-db-creds: 'database/creds/db-app' vault.hashicorp.com/agent-inject-template-db-creds: | {{- with secret &quot;database/creds/db-app&quot; -}} postgres://{{ .Data.username }}:{{ .Data.password }}@postgres:5432/appdb?sslmode=disable {{- end }} vault.hashicorp.com/role: 'db-app' vault.hashicorp.com/ca-cert: '/vault/tls/ca.crt' vault.hashicorp.com/client-cert: '/vault/tls/client.crt' vault.hashicorp.com/client-key: '/vault/tls/client.key' vault.hashicorp.com/tls-secret: 'vault-tls-client' spec: containers: - name: app image: 'app:1.0.0' serviceAccountName: app-example   ","version":"Next","tagName":"h2"},{"title":"ConfigMap example​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#configmap-example","content":" The following example creates a deployment that mounts a Kubernetes ConfigMap containing Vault Agent configuration files. For a complete list of the Vault Agent configuration settings, see the Agent documentation.  --- apiVersion: v1 kind: ServiceAccount metadata: name: app-example --- apiVersion: apps/v1 kind: Deployment metadata: name: app-example-deployment spec: replicas: 1 selector: matchLabels: app: app-example template: metadata: labels: app: app-example annotations: vault.hashicorp.com/agent-inject: 'true' vault.hashicorp.com/agent-configmap: 'my-configmap' vault.hashicorp.com/tls-secret: 'vault-tls-client' spec: containers: - name: app image: 'app:1.0.0' serviceAccountName: app-example --- apiVersion: v1 kind: ConfigMap metadata: name: my-configmap data: config.hcl: | &quot;auto_auth&quot; = { &quot;method&quot; = { &quot;config&quot; = { &quot;role&quot; = &quot;db-app&quot; } &quot;type&quot; = &quot;kubernetes&quot; } &quot;sink&quot; = { &quot;config&quot; = { &quot;path&quot; = &quot;/home/vault/.token&quot; } &quot;type&quot; = &quot;file&quot; } } &quot;exit_after_auth&quot; = false &quot;pid_file&quot; = &quot;/home/vault/.pid&quot; &quot;template&quot; = { &quot;contents&quot; = &quot;{{- with secret \\&quot;database/creds/db-app\\&quot; -}}postgres://{{ .Data.username }}:{{ .Data.password }}@postgres:5432/mydb?sslmode=disable{{- end }}&quot; &quot;destination&quot; = &quot;/vault/secrets/db-creds&quot; } &quot;vault&quot; = { &quot;address&quot; = &quot;https://vault.demo.svc.cluster.local:8200&quot; &quot;ca_cert&quot; = &quot;/vault/tls/ca.crt&quot; &quot;client_cert&quot; = &quot;/vault/tls/client.crt&quot; &quot;client_key&quot; = &quot;/vault/tls/client.key&quot; } config-init.hcl: | &quot;auto_auth&quot; = { &quot;method&quot; = { &quot;config&quot; = { &quot;role&quot; = &quot;db-app&quot; } &quot;type&quot; = &quot;kubernetes&quot; } &quot;sink&quot; = { &quot;config&quot; = { &quot;path&quot; = &quot;/home/vault/.token&quot; } &quot;type&quot; = &quot;file&quot; } } &quot;exit_after_auth&quot; = true &quot;pid_file&quot; = &quot;/home/vault/.pid&quot; &quot;template&quot; = { &quot;contents&quot; = &quot;{{- with secret \\&quot;database/creds/db-app\\&quot; -}}postgres://{{ .Data.username }}:{{ .Data.password }}@postgres:5432/mydb?sslmode=disable{{- end }}&quot; &quot;destination&quot; = &quot;/vault/secrets/db-creds&quot; } &quot;vault&quot; = { &quot;address&quot; = &quot;https://vault.demo.svc.cluster.local:8200&quot; &quot;ca_cert&quot; = &quot;/vault/tls/ca.crt&quot; &quot;client_cert&quot; = &quot;/vault/tls/client.crt&quot; &quot;client_key&quot; = &quot;/vault/tls/client.key&quot; }   ","version":"Next","tagName":"h2"},{"title":"Environment variable example​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#environment-variable-example","content":" The following example demonstrates how templates can be used to create environment variables. A template should be created that exports a Vault secret as an environment variable and the application container should source those files during startup.  --- apiVersion: apps/v1 kind: Deployment metadata: name: web-deployment labels: app: web spec: replicas: 1 selector: matchLabels: app: web template: metadata: labels: app: web annotations: vault.hashicorp.com/agent-inject: 'true' vault.hashicorp.com/role: 'web' vault.hashicorp.com/agent-inject-secret-config: 'secret/data/web' # Environment variable export template vault.hashicorp.com/agent-inject-template-config: | {{- with secret &quot;secret/data/web&quot; -}} export api_key=&quot;{{ .Data.data.payments_api_key }}&quot; {{- end }} spec: serviceAccountName: web containers: - name: web image: alpine:latest command: ['sh', '-c'] args: ['source /vault/secrets/config &amp;&amp; &lt;entrypoint script&gt;'] ports: - containerPort: 9090   ","version":"Next","tagName":"h2"},{"title":"AppRole authentication​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#approle-authentication","content":" The following example demonstrates how the AppRole authentication method can be used by Vault Agent for retrieving secrets. A Kubernetes secret containing the AppRole secret ID and role ID should be created first.  --- apiVersion: apps/v1 kind: Deployment metadata: name: web-deployment labels: app: web spec: replicas: 1 selector: matchLabels: app: web template: metadata: labels: app: web annotations: vault.hashicorp.com/agent-inject: 'true' vault.hashicorp.com/agent-extra-secret: 'approle-example' vault.hashicorp.com/auth-type: 'approle' vault.hashicorp.com/auth-path: 'auth/approle' vault.hashicorp.com/auth-config-role-id-file-path: '/vault/custom/role-id' vault.hashicorp.com/auth-config-secret-id-file-path: '/vault/custom/secret-id' vault.hashicorp.com/agent-inject-secret-db-creds: 'database/creds/db-app' vault.hashicorp.com/agent-inject-template-db-creds: | {{- with secret &quot;database/creds/db-app&quot; -}} postgres://{{ .Data.username }}:{{ .Data.password }}@postgres.postgres.svc:5432/wizard?sslmode=disable {{- end }} vault.hashicorp.com/role: 'my-role' vault.hashicorp.com/tls-secret: 'vault-tls' vault.hashicorp.com/ca-cert: '/vault/tls/ca.crt' spec: serviceAccountName: web containers: - name: web image: alpine:latest args: ['sh', '-c', 'source /vault/secrets/config &amp;&amp; &lt;entrypoint script&gt;'] ports: - containerPort: 9090   ","version":"Next","tagName":"h2"},{"title":"PKI cert example​","type":1,"pageTitle":"Vault agent injector examples","url":"/openbao/docs/platform/k8s/injector/examples/#pki-cert-example","content":" The following example demonstrates how to use the pkiCert function andwriteToFile function from consul-template to create two files from a template: one for the certificate and CA (cert.pem) and one for the key (cert.key) generated by Vault's PKI Secrets Engine.  --- apiVersion: apps/v1 kind: Deployment metadata: name: web-deployment labels: app: web spec: replicas: 1 selector: matchLabels: app: web template: metadata: labels: app: web annotations: vault.hashicorp.com/agent-inject: 'true' vault.hashicorp.com/role: 'web' vault.hashicorp.com/agent-inject-secret-certs: 'pki/issue/cert' vault.hashicorp.com/agent-inject-template-certs: | {{- with pkiCert &quot;pki/issue/cert&quot; &quot;common_name=test.example.com&quot; &quot;ttl=2h&quot; -}} {{ .Cert }}{{ .CA }}{{ .Key }} {{ .Key | writeToFile &quot;/vault/secrets/cert.key&quot; &quot;vault&quot; &quot;vault&quot; &quot;0644&quot; }} {{ .CA | writeToFile &quot;/vault/secrets/cert.pem&quot; &quot;vault&quot; &quot;vault&quot; &quot;0644&quot; }} {{ .Cert | writeToFile &quot;/vault/secrets/cert.pem&quot; &quot;vault&quot; &quot;vault&quot; &quot;0644&quot; &quot;append&quot; }} {{- end -}} spec: serviceAccountName: web containers: - name: web image: nginx  ","version":"Next","tagName":"h2"},{"title":"Vault Secrets Operator examples","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/examples/","content":"","keywords":"","version":"Next"},{"title":"Using VaultStaticSecrets for imagePullSecrets​","type":1,"pageTitle":"Vault Secrets Operator examples","url":"/openbao/docs/platform/k8s/vso/examples/#using-vaultstaticsecrets-for-imagepullsecrets","content":" Vault Secret Operator supports Kubernetes' templating of Secrets based on their Secret Type by setting theDestination.Type field of the VaultStaticSecret. Users who have configured private container registries can use the kubernetes.io/dockerconfigjson or kubernetes.io/dockerconfig types to appropriately format a Kubernetes secret with the contents of their Vault KV Secret.  # Write the secret to Vault: $ vault kv put kvv2/docker/config .dockerconfigjson=`cat ~/.docker/config.json`   # Apply a VaultStaticSecret which populates the k8s secret named 'myregistryKey' in the applications namespace # Note: this Secret uses the `default` VaultAuthMethod. apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultStaticSecret metadata: namespace: awesomeapps name: vault-kv-app spec: type: kv-v2 mount: kvv2 path: docker/config # dest k8s secret destination: name: myregistryKey create: true type: &quot;kubernetes.io/dockerconfigjson&quot; --- # Example pod from # https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod apiVersion: v1 kind: Pod metadata: name: foo namespace: awesomeapps spec: containers: - name: foo image: janedoe/awesomeapp:v1 imagePullSecrets: - name: myregistrykey  ","version":"Next","tagName":"h2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/api-reference/","content":"","keywords":"","version":"Next"},{"title":"Packages​","type":1,"pageTitle":"API Reference","url":"/openbao/docs/platform/k8s/vso/api-reference/#packages","content":" secrets.hashicorp.com/v1beta1  ","version":"Next","tagName":"h2"},{"title":"secrets.hashicorp.com/v1beta1​","type":1,"pageTitle":"API Reference","url":"/openbao/docs/platform/k8s/vso/api-reference/#secretshashicorpcomv1beta1","content":" Package v1beta1 contains API Schema definitions for the secrets v1beta1 API group  ","version":"Next","tagName":"h2"},{"title":"Resource Types​","type":1,"pageTitle":"API Reference","url":"/openbao/docs/platform/k8s/vso/api-reference/#resource-types","content":" HCPAuthHCPAuthListHCPVaultSecretsAppHCPVaultSecretsAppListVaultAuthVaultAuthListVaultConnectionVaultConnectionListVaultDynamicSecretVaultDynamicSecretListVaultPKISecretVaultPKISecretListVaultStaticSecretVaultStaticSecretList  Destination​  Destination provides the configuration that will be applied to the destination Kubernetes Secret during a Vault Secret -&gt; K8s Secret sync.  Appears in:  HCPVaultSecretsAppSpecVaultDynamicSecretSpecVaultPKISecretSpecVaultStaticSecretSpec  Field\tDescriptionname string\tName of the Secret create boolean\tCreate the destination Secret. If the Secret already exists this should be set to false. labels object (keys:string, values:string)\tLabels to apply to the Secret. Requires Create to be set to true. annotations object (keys:string, values:string)\tAnnotations to apply to the Secret. Requires Create to be set to true. type SecretType\tType of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.  HCPAuth​  HCPAuth is the Schema for the hcpauths API  Appears in:  HCPAuthList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tHCPAuth metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec HCPAuthSpec\t  HCPAuthList​  HCPAuthList contains a list of HCPAuth  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tHCPAuthList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items HCPAuth array\t  HCPAuthServicePrincipal​  HCPAuthServicePrincipal provides HCPAuth configuration options needed for authenticating to HCP using a service principal configured in SecretRef.  Appears in:  HCPAuthSpec  Field\tDescriptionsecretRef string\tSecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI/HCP) namespace which provides the HCP ServicePrincipal clientID, and clientSecret. The secret data must have the following structure { &quot;clientID&quot;: &quot;clientID&quot;, &quot;clientSecret&quot;: &quot;clientSecret&quot;, }  HCPAuthSpec​  HCPAuthSpec defines the desired state of HCPAuth  Appears in:  HCPAuth  Field\tDescriptionorganizationID string\tOrganizationID of the HCP organization. projectID string\tProjectID of the HCP project. allowedNamespaces string array\tAllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which HCPAuthMethods can be used by which namespaces. Accepted values: []* - wildcard, all namespaces. []b - list of namespaces. unset - disallow all namespaces except the Operator's the HCPAuthMethod's namespace, this is the default behavior. method string\tMethod to use when authenticating to Vault. servicePrincipal HCPAuthServicePrincipal\tServicePrincipal provides the necessary configuration for authenticating to HCP using a service principal. For security reasons, only project-level service principals should ever be used.  HCPVaultSecretsApp​  HCPVaultSecretsApp is the Schema for the hcpvaultsecretsapps API  Appears in:  HCPVaultSecretsAppList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tHCPVaultSecretsApp metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec HCPVaultSecretsAppSpec\t  HCPVaultSecretsAppList​  HCPVaultSecretsAppList contains a list of HCPVaultSecretsApp  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tHCPVaultSecretsAppList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items HCPVaultSecretsApp array\t  HCPVaultSecretsAppSpec​  HCPVaultSecretsAppSpec defines the desired state of HCPVaultSecretsApp  Appears in:  HCPVaultSecretsApp  Field\tDescriptionappName string\tAppName of the Vault Secrets Application that is to be synced. hcpAuthRef string\tHCPAuthRef to the HCPAuth resource, can be prefixed with a namespace, eg: namespaceA/vaultAuthRefB. If no namespace prefix is provided it will default to the namespace of the HCPAuth CR. If no value is specified for HCPAuthRef the Operator will default to the default HCPAuth, configured in its own Kubernetes namespace. HCPAuthRef string json:&quot;hcpAuthRef,omitempty&quot; refreshAfter string\tRefreshAfter a period of time, in duration notation e.g. 30s, 1m, 24h rolloutRestartTargets RolloutRestartTarget array\tRolloutRestartTargets should be configured whenever the application(s) consuming the HCP Vault Secrets App does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a &quot;rollout-restart&quot; for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details. destination Destination\tDestination provides configuration necessary for syncing the HCP Vault Application secrets to Kubernetes.  RolloutRestartTarget​  RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: &quot;2023-03-23T13:39:31Z&quot; Supported resources: Deployment, DaemonSet, StatefulSet  Appears in:  HCPVaultSecretsAppSpecVaultDynamicSecretSpecVaultPKISecretSpecVaultStaticSecretSpec  Field\tDescriptionkind string name string\t  StorageEncryption​  StorageEncryption provides the necessary configuration need to encrypt the storage cache entries using Vault's Transit engine. It only supports Kubernetes Auth for now.  Appears in:  VaultAuthSpec  Field\tDescriptionmount string\tMount path of the Transit engine in Vault. keyName string\tKeyName to use for encrypt/decrypt operations via Vault Transit.  VaultAuth​  VaultAuth is the Schema for the vaultauths API  Appears in:  VaultAuthList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultAuth metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec VaultAuthSpec\t  VaultAuthConfigAWS​  VaultAuthConfigAWS provides VaultAuth configuration options needed for authenticating to Vault via an AWS AuthMethod. Will use creds from SecretRef or IRSAServiceAccount if provided, in that order. If neither are provided, the underlying node role or instance profile will be used to authenticate to Vault.  Appears in:  VaultAuthSpec  Field\tDescriptionrole string\tVault role to use for authenticating region string\tAWS Region to use for signing the authentication request headerValue string\tThe Vault header value to include in the STS signing request sessionName string\tThe role session name to use when creating a webidentity provider stsEndpoint string\tThe STS endpoint to use; if not set will use the default iamEndpoint string\tThe IAM endpoint to use; if not set will use the default secretRef string\tSecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include access_key_id, secret_access_key, session_token irsaServiceAccount string\tIRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with &quot;eks.amazonaws.com/role-arn&quot;. This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration  VaultAuthConfigAppRole​  VaultAuthConfigAppRole provides VaultAuth configuration options needed for authenticating to Vault via an AppRole AuthMethod.  Appears in:  VaultAuthSpec  Field\tDescriptionroleId string\tRoleID of the AppRole Role to use for authenticating to Vault. secretRef string\tSecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named id which holds the AppRole Role's secretID.  VaultAuthConfigJWT​  VaultAuthConfigJWT provides VaultAuth configuration options needed for authenticating to Vault.  Appears in:  VaultAuthSpec  Field\tDescriptionrole string\tRole to use for authenticating to Vault. secretRef string\tSecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named jwt which holds the JWT token. serviceAccount string\tServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend. audiences string array\tTokenAudiences to include in the ServiceAccount token. tokenExpirationSeconds integer\tTokenExpirationSeconds to set the ServiceAccount token.  VaultAuthConfigKubernetes​  VaultAuthConfigKubernetes provides VaultAuth configuration options needed for authenticating to Vault.  Appears in:  VaultAuthSpec  Field\tDescriptionrole string\tRole to use for authenticating to Vault. serviceAccount string\tServiceAccount to use when authenticating to Vault's kubernetes authentication backend. audiences string array\tTokenAudiences to include in the ServiceAccount token. tokenExpirationSeconds integer\tTokenExpirationSeconds to set the ServiceAccount token.  VaultAuthList​  VaultAuthList contains a list of VaultAuth  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultAuthList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items VaultAuth array\t  VaultAuthSpec​  VaultAuthSpec defines the desired state of VaultAuth  Appears in:  VaultAuth  Field\tDescriptionvaultConnectionRef string\tVaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: namespaceA/vaultConnectionRefB. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to default VaultConnection, configured in its own Kubernetes namespace. namespace string\tNamespace to auth to in Vault allowedNamespaces string array\tAllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []* - wildcard, all namespaces. []b - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior. method string\tMethod to use when authenticating to Vault. mount string\tMount to use when authenticating to auth method. params object (keys:string, values:string)\tParams to use when authenticating to Vault headers object (keys:string, values:string)\tHeaders to be included in all Vault requests. kubernetes VaultAuthConfigKubernetes\tKubernetes specific auth configuration, requires that the Method be set to kubernetes. appRole VaultAuthConfigAppRole\tAppRole specific auth configuration, requires that the Method be set to appRole. jwt VaultAuthConfigJWT\tJWT specific auth configuration, requires that the Method be set to jwt. aws VaultAuthConfigAWS\tAWS specific auth configuration, requires that Method be set to aws. storageEncryption StorageEncryption\tStorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically, there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true  VaultConnection​  VaultConnection is the Schema for the vaultconnections API  Appears in:  VaultConnectionList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultConnection metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec VaultConnectionSpec\t  VaultConnectionList​  VaultConnectionList contains a list of VaultConnection  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultConnectionList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items VaultConnection array\t  VaultConnectionSpec​  VaultConnectionSpec defines the desired state of VaultConnection  Appears in:  VaultConnection  Field\tDescriptionaddress string\tAddress of the Vault server headers object (keys:string, values:string)\tHeaders to be included in all Vault requests. tlsServerName string\tTLSServerName to use as the SNI host for TLS connections. caCertSecretRef string\tCACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as ca.crt. skipTLSVerify boolean\tSkipTLSVerify for TLS connections.  VaultDynamicSecret​  VaultDynamicSecret is the Schema for the vaultdynamicsecrets API  Appears in:  VaultDynamicSecretList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultDynamicSecret metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec VaultDynamicSecretSpec\t  VaultDynamicSecretList​  VaultDynamicSecretList contains a list of VaultDynamicSecret  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultDynamicSecretList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items VaultDynamicSecret array\t  VaultDynamicSecretSpec​  VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret  Appears in:  VaultDynamicSecret  Field\tDescriptionvaultAuthRef string\tVaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: namespaceA/vaultAuthRefB. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the default VaultAuth, configured in its own Kubernetes namespace. namespace string\tNamespace where the secrets engine is mounted in Vault. mount string\tMount path of the secret's engine in Vault. requestHTTPMethod string\tRequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method. path string\tPath in Vault to get the credentials for, and is relative to Mount. Please consult secrets if you are uncertain about what 'path' should be set to. params object (keys:string, values:string)\tParams that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult secrets if you are uncertain about what 'params' should/can be set to. renewalPercent integer\tRenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter. revoke boolean\tRevoke the existing lease on VDS resource deletion. allowStaticCreds boolean\tAllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as &quot;static roles&quot;, or &quot;static credentials&quot;, with a request path that contains &quot;static-creds&quot;. rolloutRestartTargets RolloutRestartTarget array\tRolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a &quot;rollout-restart&quot; for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details. destination Destination\tDestination provides configuration necessary for syncing the Vault secret to Kubernetes.  VaultPKISecret​  VaultPKISecret is the Schema for the vaultpkisecrets API  Appears in:  VaultPKISecretList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultPKISecret metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec VaultPKISecretSpec\t  VaultPKISecretList​  VaultPKISecretList contains a list of VaultPKISecret  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultPKISecretList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items VaultPKISecret array\t  VaultPKISecretSpec​  VaultPKISecretSpec defines the desired state of VaultPKISecret  Appears in:  VaultPKISecret  Field\tDescriptionvaultAuthRef string\tVaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: namespaceA/vaultAuthRefB. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the default VaultAuth, configured in its own Kubernetes namespace. namespace string\tNamespace to get the secret from in Vault mount string\tMount for the secret in Vault role string\tRole in Vault to use when issuing TLS certificates. revoke boolean\tRevoke the certificate when the resource is deleted. clear boolean\tClear the Kubernetes secret when the resource is deleted. expiryOffset string\tExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string &quot;&quot; to prevent certificate rotation. issuerRef string\tIssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL. rolloutRestartTargets RolloutRestartTarget array\tRolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a &quot;rollout-restart&quot; for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details. destination Destination\tDestination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to &quot;kubernetes.io/tls&quot;, &quot;tls.key&quot; will be set to the &quot;private_key&quot; response from Vault, and &quot;tls.crt&quot; will be set to &quot;certificate&quot; + &quot;ca_chain&quot; from the Vault response (&quot;issuing_ca&quot; is used when &quot;ca_chain&quot; is empty). The &quot;remove_roots_from_chain=true&quot; option is used with Vault to exclude the root CA from the Vault response. commonName string\tCommonName to include in the request. altNames string array\tAltNames to include in the request May contain both DNS names and email addresses. ipSans string array\tIPSans to include in the request. uriSans string array\tThe requested URI SANs. otherSans string array\tRequested other SANs, in an array with the format oid;type:value for each entry. ttl string\tTTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc. format string\tFormat for the certificate. Choices: &quot;pem&quot;, &quot;der&quot;, &quot;pem_bundle&quot;. If &quot;pem_bundle&quot;, any private key and issuing cert will be appended to the certificate pem. If &quot;der&quot;, the value will be base64 encoded. Default: pem privateKeyFormat string\tPrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to &quot;pkcs8&quot; to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der notAfter string\tNotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ excludeCNFromSans boolean\tExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false  VaultSecretLease​  Appears in:  VaultDynamicSecretStatus  Field\tDescriptionid string\tID of the Vault secret. duration integer\tLeaseDuration of the Vault secret. renewable boolean\tRenewable Vault secret lease requestID string\tRequestID of the Vault secret request.  VaultStaticCredsMetaData​  Appears in:  VaultDynamicSecretStatus  Field\tDescriptionlastVaultRotation integer\tLastVaultRotation represents the last time Vault rotated the password rotationPeriod integer\tRotationPeriod is number in seconds between each rotation, effectively a &quot;time to live&quot;. This value is compared to the LastVaultRotation to determine if a password needs to be rotated rotationSchedule string\tRotationSchedule is a &quot;cron style&quot; string representing the allowed schedule for each rotation. e.g. &quot;1 0 * * *&quot; would rotate at one minute past midnight (00:01) every day. ttl integer\tTTL is the seconds remaining before the next rotation.  VaultStaticSecret​  VaultStaticSecret is the Schema for the vaultstaticsecrets API  Appears in:  VaultStaticSecretList  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultStaticSecret metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec VaultStaticSecretSpec\t  VaultStaticSecretList​  VaultStaticSecretList contains a list of VaultStaticSecret  Field\tDescriptionapiVersion string\tsecrets.hashicorp.com/v1beta1 kind string\tVaultStaticSecretList metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items VaultStaticSecret array\t  VaultStaticSecretSpec​  VaultStaticSecretSpec defines the desired state of VaultStaticSecret  Appears in:  VaultStaticSecret  Field\tDescriptionvaultAuthRef string\tVaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: namespaceA/vaultAuthRefB. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the default VaultAuth, configured in its own Kubernetes namespace. namespace string\tNamespace to get the secret from in Vault mount string\tMount for the secret in Vault path string\tPath of the secret in Vault, corresponds to the path parameter for, kv-v1 kv-v2 version integer\tVersion of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: version type string\tType of the Vault static secret refreshAfter string\tRefreshAfter a period of time, in duration notation e.g. 30s, 1m, 24h hmacSecretData boolean\tHMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault. rolloutRestartTargets RolloutRestartTarget array\tRolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a &quot;rollout-restart&quot; for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details. destination Destination\tDestination provides configuration necessary for syncing the Vault secret to Kubernetes. ","version":"Next","tagName":"h3"},{"title":"Installing the Vault Secrets Operator","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/installation/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/installation/#prerequisites","content":" A Kubernetes cluster running 1.23+Helm 3.7+  ","version":"Next","tagName":"h2"},{"title":"Installation using helm​","type":1,"pageTitle":"Installing the Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/installation/#installation-using-helm","content":" Install Helm before beginning.  The Vault Secrets Operator Helm chart is the recommended way of installing and configuring the Vault Secrets Operator.  To install a new instance of the Vault Secrets Operator, first add the HashiCorp helm repository and ensure you have access to the chart:  $ helm repo add hashicorp https://helm.releases.hashicorp.com &quot;hashicorp&quot; has been added to your repositories $ helm search repo hashicorp/vault-secrets-operator NAME CHART VERSION\tAPP VERSION\tDESCRIPTION hashicorp/vault-secrets-operator\t0.3.1 0.3.1 Official HashiCorp Vault Secrets Operator Chart   Then install the Operator:  $ helm install --create-namespace --namespace vault-secrets-operator vault-secrets-operator hashicorp/vault-secrets-operator --version 0.3.1   ","version":"Next","tagName":"h2"},{"title":"Upgrading using helm​","type":1,"pageTitle":"Installing the Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/installation/#upgrading-using-helm","content":" Upgrades may be performed with helm upgrade on an existing install. Please always run Helm with --dry-run before any install or upgrade to verify changes.  ","version":"Next","tagName":"h2"},{"title":"Helm chart values​","type":1,"pageTitle":"Installing the Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/installation/#helm-chart-values","content":" All supported Helm chart values can be found here ","version":"Next","tagName":"h3"},{"title":"Run the Vault Secrets Operator on OpenShift","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/openshift/","content":"","keywords":"","version":"Next"},{"title":"OperatorHub​","type":1,"pageTitle":"Run the Vault Secrets Operator on OpenShift","url":"/openbao/docs/platform/k8s/vso/openshift/#operatorhub","content":" The Vault Secrets Operator is certified by Red Hat and therefore included in the OperatorHub section of an OpenShift cluster's web console.  Navigate to the OperatorHub page of your OpenShift cluster and search for Vault Secrets Operator, then follow the instructions to install.  ","version":"Next","tagName":"h2"},{"title":"Helm chart​","type":1,"pageTitle":"Run the Vault Secrets Operator on OpenShift","url":"/openbao/docs/platform/k8s/vso/openshift/#helm-chart","content":" The Vault Secrets Operator may also be installed in OpenShift using the Helm chart. (See Installation for an overview of installation using the Helm chart.) The examples below show example values.yaml files for each configuration, which would be used with helm install as below:  helm install vault-secrets-operator hashicorp/vault-secrets-operator \\ --create-namespace \\ --namespace vault-secrets-operator \\ --version 0.2.0 \\ --values values.yaml   For OpenShift, increasing the memory requests and limits has proven necessary in some cases, so those settings are included in the examples below.  ","version":"Next","tagName":"h2"},{"title":"Default images​","type":1,"pageTitle":"Run the Vault Secrets Operator on OpenShift","url":"/openbao/docs/platform/k8s/vso/openshift/#default-images","content":" These values would use the default operator image from HashiCorp's Docker Hub repository.  controller: manager: resources: limits: memory: 256Mi requests: memory: 128Mi   ","version":"Next","tagName":"h3"},{"title":"UBI-based images certified by Red Hat​","type":1,"pageTitle":"Run the Vault Secrets Operator on OpenShift","url":"/openbao/docs/platform/k8s/vso/openshift/#ubi-based-images-certified-by-red-hat","content":" These values would use UBI-based images from the Red Hat's certified container registry. Authentication may be required.  controller: kubeRbacProxy: image: repository: registry.redhat.io/openshift4/ose-kube-rbac-proxy tag: v4.13.0 manager: image: repository: registry.connect.redhat.com/hashicorp/vault-secrets-operator tag: 0.2.0-ubi resources: limits: memory: 256Mi requests: memory: 128Mi   tip UBI-based Vault Secrets Operator images are also published to HashiCorp's DockerHub and Amazon ECR repositories. ","version":"Next","tagName":"h3"},{"title":"Vault Secrets Operator helm chart","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/helm/","content":"","keywords":"","version":"Next"},{"title":"Top-Level Stanzas​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#top-level-stanzas","content":" Use these links to navigate to a particular top-level stanza.  controllermetricsServicedefaultVaultConnectiondefaultAuthMethodtelemetrytests  ","version":"Next","tagName":"h2"},{"title":"All Values​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#all-values","content":" ","version":"Next","tagName":"h2"},{"title":"controller​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#h-controller","content":" controller - Top level configuration for the vault secrets operator deployment. This consists of a controller and a kube rbac proxy container. replicas (integer: 1) - Set the number of replicas for the operator. hostAliases (array&lt;map&gt;) - Host Aliases settings for vault-secrets-operator pod. The value is an array of PodSpec HostAlias maps. ref: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/Example: hostAliases: ip: 192.168.1.100 hostnames: vault.example.com nodeSelector (map) - nodeSelector labels for vault-secrets-operator pod assignment. ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselectorExample: nodeSelector: beta.kubernetes.io/arch: amd64 tolerations (array&lt;map&gt;) - Toleration Settings for vault-secrets-operator pod. The value is an array of PodSpec Toleration maps. ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/Example: tolerations: key: &quot;key1&quot; operator: &quot;Equal&quot; value: &quot;value1&quot; effect: &quot;NoSchedule&quot; affinity - Affinity settings for vault-secrets-operator pod. The value is a map of PodSpec Affinity maps. ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinityExample: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: matchExpressions: key: topology.kubernetes.io/zone operator: In values: antarctica-east1antarctica-west1 kubeRbacProxy - Settings related to the kubeRbacProxy container. This container is an HTTP proxy for the controller manager which performs RBAC authorization against the Kubernetes API using SubjectAccessReviews. image - Image sets the repo and tag of the kube-rbac-proxy image to use for the controller. repository (string: gcr.io/kubebuilder/kube-rbac-proxy) tag (string: v0.14.1) resources (map) - Configures the default resources for the kube rbac proxy container. For more information on configuring resources, see the K8s documentation:https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ limits cpu (string: 500m) memory (string: 128Mi) requests cpu (string: 5m) memory (string: 64Mi) imagePullSecrets (array&lt;map&gt;) - Image pull secret to use for private container registry authentication which will be applied to the controllers service account. Alternatively, the value may be specified as an array of strings. Example: imagePullSecrets: - name: pull-secret-name-1 - name: pull-secret-name-2 Refer to https://kubernetes.io/docs/concepts/containers/images/#using-a-private-registry. extraLabels - Extra labels to attach to the deployment. This should be formatted as a YAML object (map) annotations - This value defines additional annotations for the deployment. This should be formatted as a YAML object (map) manager - Settings related to the vault-secrets-operator container. image - Image sets the repo and tag of the vault-secrets-operator image to use for the controller. repository (string: hashicorp/vault-secrets-operator) tag (string: 0.3.1) clientCache - Configures the client cache which is used by the controller to cache (and potentially persist) vault tokens that are the result of using the VaultAuthMethod. This enables re-use of Vault Tokens throughout their TTLs as well as the ability to renew. Persistence is only useful in the context of Dynamic Secrets, so &quot;none&quot; is an okay default. persistenceModel (string: &quot;&quot;) - Defines the -client-cache-persistence-model which caches+persists vault tokens. Valid values are: &quot;none&quot; - in-memory client cache is used, no tokens are persisted. &quot;direct-unencrypted&quot; - in-memory client cache is persisted, unencrypted. This is NOT recommended for any production workload. &quot;direct-encrypted&quot; - in-memory client cache is persisted encrypted using the Vault Transit engine. Note: It is strongly encouraged to not use the setting of &quot;direct-unencrypted&quot; in production due to the potential of vault tokens being leaked as they would then be stored in clear text. default: &quot;none&quot; cacheSize (integer: &quot;&quot;) - Defines the size of the in-memory LRU cache in entries, that is used by the client cache controller. Larger numbers will increase memory usage by the controller, lower numbers will cause more frequent evictions of the client cache which can result in additional Vault client counts. default: 10000 storageEncryption - StorageEncryption provides the necessary configuration to encrypt the client storage cache within Kubernetes objects using (required) Vault Transit Engine. This should only be configured when client cache persistence with encryption is enabled and will deploy an additional VaultAuthMethod to be used by the Vault Transit Engine. E.g. when controller.manager.clientCache.persistenceModel=direct-encryptedSupported Vault authentication methods for the Transit Auth method are: jwt, appRole, aws, and kubernetes. Typically, there should only ever be one VaultAuth configured with StorageEncryption in the Cluster. enabled (boolean: false) - toggles the deployment of the Transit VaultAuthMethod CR. vaultConnectionRef (string: default) - Vault Connection Ref to be used by the Transit VaultAuthMethod. Default setting will use the default VaultConnectionRef, which must also be configured. keyName (string: &quot;&quot;) - KeyName to use for encrypt/decrypt operations via Vault Transit. transitMount (string: &quot;&quot;) - Mount path for the Transit VaultAuthMethod. namespace (string: &quot;&quot;) - Vault namespace for the Transit VaultAuthMethod CR. method (string: kubernetes) - Vault Auth method to be used with the Transit VaultAuthMethod CR. mount (string: kubernetes) - Mount path for the Transit VaultAuthMethod. kubernetes - Vault Kubernetes auth method specific configuration role (string: &quot;&quot;) - Vault Auth Role to use This is a required field and must be setup in Vault prior to deploying the helm chart if defaultAuthMethod.enabled=true serviceAccount (string: &quot;&quot;) - Kubernetes ServiceAccount associated with the Transit Vault Auth Role Defaults to using the Operator's service-account. tokenAudiences (array&lt;string&gt;: []) - Token Audience should match the audience of the vault kubernetes auth role. jwt - Vault JWT auth method specific configuration role (string: &quot;&quot;) - Vault Auth Role to use This is a required field and must be setup in Vault prior to deploying the helm chart if using JWT for the Transit VaultAuthMethod. secretRef (string: &quot;&quot;) - One of the following is required prior to deploying the helm chart K8s secret that contains the JWTK8s service account if a service account JWT is used as a Vault JWT auth token and needs generating by VSO. Name of Kubernetes Secret that has the Vault JWT auth token. The Kubernetes Secret must contain a key named jwt which references the JWT token, and must exist in the namespace of any consuming VaultSecret CR. This is a required field if a JWT token is provided. serviceAccount (string: default) - Kubernetes ServiceAccount to generate a service account JWT tokenAudiences (array&lt;string&gt;: []) - Token Audience should match the bound_audiences or the aud list in bound_claims if applicable of the Vault JWT auth role. appRole - AppRole auth method specific configuration roleId (string: &quot;&quot;) - AppRole Role's RoleID to use for authenticating to Vault. This is a required field when using appRole and must be setup in Vault prior to deploying the helm chart. secretRef (string: &quot;&quot;) - Name of Kubernetes Secret that has the AppRole Role's SecretID used to authenticate with Vault. The Kubernetes Secret must contain a key named id which references the AppRole Role's SecretID, and must exist in the namespace of any consuming VaultSecret CR. This is a required field when using appRole and must be setup in Vault prior to deploying the helm chart. aws - AWS auth method specific configuration role (string: &quot;&quot;) - Vault Auth Role to use This is a required field and must be setup in Vault prior to deploying the helm chart if using the AWS for the Transit auth method. region (string: &quot;&quot;) - AWS region to use for signing the authentication request Optional, but most commonly will be the EKS cluster region. headerValue (string: &quot;&quot;) - Vault header value to include in the STS signing request sessionName (string: &quot;&quot;) - The role session name to use when creating a WebIdentity provider stsEndpoint (string: &quot;&quot;) - The STS endpoint to use; if not set will use the default iamEndpoint (string: &quot;&quot;) - The IAM endpoint to use; if not set will use the default secretRef (string: &quot;&quot;) - The name of a Kubernetes Secret which holds credentials for AWS. Supported keys include access_key_id, secret_access_key, session_token irsaServiceAccount (string: &quot;&quot;) - Name of a Kubernetes service account that is configured with IAM Roles for Service Accounts (IRSA). Should be annotated with &quot;eks.amazonaws.com/role-arn&quot;. params (map) - Params to use when authenticating to Vault using this auth method. params: param-something1: &quot;foo&quot; headers ( map: &quot;&quot;) - Headers to be included in all Vault requests. headers: X-vault-something1: &quot;foo&quot; maxConcurrentReconciles (integer: &quot;&quot;) - Defines the maximum number of concurrent reconciles by the controller. NOTE: Currently this is only used by the reconciliation logic of dynamic secrets. default: 100 extraEnv (array&lt;map&gt;) - Defines additional environment variables to be added to the vault-secrets-opearator manager container. extraEnv: name: HTTP_PROXY value: http://proxy.example.com extraArgs (array: []) - Defines additional commandline arguments to be passed to the vault-secrets-operator manager container. extraArgs: -zap-log-level=5 resources (map) - Configures the default resources for the vault-secrets-operator container. For more information on configuring resources, see the K8s documentation:https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ limits cpu (string: 500m) memory (string: 128Mi) requests cpu (string: 10m) memory (string: 64Mi) podSecurityContext - Configures the Pod security contexthttps://kubernetes.io/docs/tasks/configure-pod-container/security-context runAsNonRoot (boolean: true) securityContext - Configures the container security contexthttps://kubernetes.io/docs/tasks/configure-pod-container/security-context allowPrivilegeEscalation (boolean: false) controllerConfigMapYaml (map) - Sets the configuration settings used by the controller. Any custom changes will be reflected in the data field of the configmap. For more information on configuring resources, see the K8s documentation:https://kubernetes.io/docs/concepts/configuration/configmap/ health healthProbeBindAddress (string: :8081) leaderElection leaderElect (boolean: true) resourceName (string: b0d477c0.hashicorp.com) metrics bindAddress (string: 127.0.0.1:8080) webhook port (integer: 9443) kubernetesClusterDomain (string: cluster.local) - Configures the environment variable KUBERNETES_CLUSTER_DOMAIN used by KubeDNS. terminationGracePeriodSeconds (integer: 120) - Duration in seconds the pod needs to terminate gracefully. See: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/ preDeleteHookTimeoutSeconds (integer: 120) - Timeout in seconds for the pre-delete hook  ","version":"Next","tagName":"h3"},{"title":"metricsService​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#h-metricsservice","content":" metricsService (map) - Configure the metrics service ports used by the metrics service. Set the configuration fo the metricsService port. ports (map) - Set the port settings for the metrics service. For more information on configuring resources, see the K8s documentation:https://kubernetes.io/docs/concepts/services-networking/service/ name (string: https) port (integer: 8443) protocol (string: TCP) targetPort (string: https) type (string: ClusterIP)  ","version":"Next","tagName":"h3"},{"title":"defaultVaultConnection​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#h-defaultvaultconnection","content":" defaultVaultConnection - Configures the default VaultConnection CR which will be used by resources if they do not specify a VaultConnection reference. The name is 'default' and will always be installed in the same namespace as the operator. NOTE: It is strongly recommended to deploy the vault secrets operator in a secure Vault environment which includes a configuration utilizing TLS and installing Vault into its own restricted namespace. enabled (boolean: false) - toggles the deployment of the VaultAuthMethod CR address (string: &quot;&quot;) - Address of the Vault Server Example: http://vault.default.svc.cluster.local:8200 caCertSecret (string: &quot;&quot;) - CACertSecret is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as ca.crt. Note: This secret must exist prior to deploying the CR. tlsServerName (string: &quot;&quot;) - TLSServerName to use as the SNI host for TLS connections. skipTLSVerify (boolean: false) - SkipTLSVerify for TLS connections. headers (map) - Headers to be included in all Vault requests. headers: X-vault-something: &quot;foo&quot;  ","version":"Next","tagName":"h3"},{"title":"defaultAuthMethod​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#h-defaultauthmethod","content":" defaultAuthMethod - Configures and deploys the default VaultAuthMethod CR which will be used by resources if they do not specify a VaultAuthMethod reference. The name is 'default' and will always be installed in the same namespace as the operator. NOTE: It is strongly recommended to deploy the vault secrets operator in a secure Vault environment which includes a configuration utilizing TLS and installing Vault into its own restricted namespace. enabled (boolean: false) - toggles the deployment of the VaultAuthMethod CR namespace (string: &quot;&quot;) - Vault namespace for the VaultAuthMethod CR method (string: kubernetes) - Vault Auth method to be used with the VaultAuthMethod CR mount (string: kubernetes) - Mount path for the Vault Auth Method. kubernetes - Vault Kubernetes auth method specific configuration role (string: &quot;&quot;) - Vault Auth Role to use This is a required field and must be setup in Vault prior to deploying the helm chart if defaultAuthMethod.enabled=true serviceAccount (string: default) - Kubernetes ServiceAccount associated with the default Vault Auth Role tokenAudiences (array&lt;string&gt;: []) - Token Audience should match the audience of the vault kubernetes auth role. jwt - Vault JWT auth method specific configuration role (string: &quot;&quot;) - Vault Auth Role to use This is a required field and must be setup in Vault prior to deploying the helm chart if using the JWT for the default auth method. secretRef (string: &quot;&quot;) - One of the following is required prior to deploying the helm chart K8s secret that contains the JWTK8s service account if a service account JWT is used as a Vault JWT auth token and needs generating by VSO Name of Kubernetes Secret that has the Vault JWT auth token. The Kubernetes Secret must contain a key named jwt which references the JWT token, and must exist in the namespace of any consuming VaultSecret CR. This is a required field if a JWT token is provided. serviceAccount (string: default) - Kubernetes ServiceAccount to generate a service account JWT tokenAudiences (array&lt;string&gt;: []) - Token Audience should match the bound_audiences or the aud list in bound_claims if applicable of the Vault JWT auth role. appRole - AppRole auth method specific configuration roleId (string: &quot;&quot;) - AppRole Role's RoleID to use for authenticating to Vault. This is a required field when using appRole and must be setup in Vault prior to deploying the helm chart. secretRef (string: &quot;&quot;) - Name of Kubernetes Secret that has the AppRole Role's SecretID used to authenticate with Vault. The Kubernetes Secret must contain a key named id which references the AppRole Role's SecretID, and must exist in the namespace of any consuming VaultSecret CR. This is a required field when using appRole and must be setup in Vault prior to deploying the helm chart. aws - AWS auth method specific configuration role (string: &quot;&quot;) - Vault Auth Role to use This is a required field and must be setup in Vault prior to deploying the helm chart if using the AWS for the default auth method. region (string: &quot;&quot;) - AWS region to use for signing the authentication request Optional, but most commonly will be the region where the EKS cluster is running headerValue (string: &quot;&quot;) - Vault header value to include in the STS signing request sessionName (string: &quot;&quot;) - The role session name to use when creating a WebIdentity provider stsEndpoint (string: &quot;&quot;) - The STS endpoint to use; if not set will use the default iamEndpoint (string: &quot;&quot;) - The IAM endpoint to use; if not set will use the default secretRef (string: &quot;&quot;) - The name of a Kubernetes Secret which holds credentials for AWS. Supported keys includeaccess_key_id, secret_access_key, session_token irsaServiceAccount (string: &quot;&quot;) - Name of a Kubernetes service account that is configured with IAM Roles for Service Accounts (IRSA). Should be annotated with &quot;eks.amazonaws.com/role-arn&quot;. params (map) - Params to use when authenticating to Vault params: param-something1: &quot;foo&quot; headers (map) - Headers to be included in all Vault requests. headers: X-vault-something1: &quot;foo&quot;  ","version":"Next","tagName":"h3"},{"title":"telemetry​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#h-telemetry","content":" telemetry - Configures a Prometheus ServiceMonitor serviceMonitor enabled (boolean: false) - The Prometheus operator must be installed before enabling this feature, if not the chart will fail to install due to missing CustomResourceDefinitions provided by the operator. Instructions on how to install the Helm chart can be found here:https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stackMore information can be found here:https://github.com/prometheus-operator/prometheus-operatorhttps://github.com/prometheus-operator/kube-prometheus Enable deployment of the Vault Secrets Operator ServiceMonitor CustomResource. selectors (string: &quot;&quot;) - Selector labels to add to the ServiceMonitor. When empty, defaults to: release: prometheus scheme (string: https) - Scheme of the service Prometheus scrapes metrics from. This must match the scheme of the metrics service of VSO port (string: https) - Port at which Prometheus scrapes metrics. This must match the port of the metrics service of VSO path (string: /metrics) - Path at which Prometheus scrapes metrics bearerTokenFile (string: /var/run/secrets/kubernetes.io/serviceaccount/token) - File Prometheus reads bearer token from for scraping metrics interval (string: 30s) - Interval at which Prometheus scrapes metrics scrapeTimeout (string: 10s) - Timeout for Prometheus scrapes  ","version":"Next","tagName":"h3"},{"title":"tests​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#h-tests","content":" tests - # Used by unit tests, and will not be rendered except when using helm template, this can be safely ignored. enabled (boolean: true)  ","version":"Next","tagName":"h3"},{"title":"Helm chart examples​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#helm-chart-examples","content":" The below config.yaml results in a single replica installation of the Vault Secrets Operator with a default vault connection and auth method custom resource deployed. It expects a local Vault installation within the kubernetes cluster accessible via http://vault.default.svc.cluster.local:8200 with TLS disabled, and a Vault Auth Method to be setup against the default ServiceAccount.  # config.yaml defaultVaultConnection: enabled: true defaultAuthMethod: enabled: true   ","version":"Next","tagName":"h2"},{"title":"Customizing the helm chart​","type":1,"pageTitle":"Vault Secrets Operator helm chart","url":"/openbao/docs/platform/k8s/vso/helm/#customizing-the-helm-chart","content":" If you need to extend the Helm chart with additional options, we recommend using a third-party tool, such as kustomize using the project repo config/ path in the vault-secrets-operator project. ","version":"Next","tagName":"h2"},{"title":"Vault Secrets Operator","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/sources/","content":"","keywords":"","version":"Next"},{"title":"Secret sources​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/#secret-sources","content":" VaultHCP Vault Secrets ","version":"Next","tagName":"h2"},{"title":"HCP Vault Secrets source","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/sources/hvs/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"HCP Vault Secrets source","url":"/openbao/docs/platform/k8s/vso/sources/hvs/#overview","content":" The Vault secrets operator (VSO) syncs your HCP Vault Secrets app (HVSA) to a Kubernetes Secret. Vault syncs each HCPVaultSecretsApp custom resource periodically to ensure that changes to the secret source are properly reflected in the Kubernetes secret.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"HCP Vault Secrets source","url":"/openbao/docs/platform/k8s/vso/sources/hvs/#features","content":" Periodic synchronization of HCP Vault Secrets app to a destination Kubernetes Secret.Automatic drift detection and remediation when the destination Kubernetes Secret is modified or deleted.Supports all VSO features, including rollout-restarts on secret rotation or during drift remediation.Supports authentication to HCP using HCP service principals.  ","version":"Next","tagName":"h2"},{"title":"Supported HCP authentication methods​","type":1,"pageTitle":"HCP Vault Secrets source","url":"/openbao/docs/platform/k8s/vso/sources/hvs/#supported-hcp-authentication-methods","content":" Backend\tDescriptionHCP Service Principals\tRelies on static credentials for authenticating to HCP  ","version":"Next","tagName":"h3"},{"title":"HCP Vault Secrets sync example​","type":1,"pageTitle":"HCP Vault Secrets source","url":"/openbao/docs/platform/k8s/vso/sources/hvs/#hcp-vault-secrets-sync-example","content":" The following Kubernetes configuration can be used to sync the HCP Vault Secrets app, vso-example, to the Kubernetes Secret, vso-app-secret, in the vso-example-ns Kubernetes Namespace. It assumes that you have already setup service principal Kubernetes secret, and have created the HCP Vault Secrets app.  Use the following Kubernetes configuration to sync your HCP Vault Secrets app, vso-example, to the Kubernetes secret, vso-app-secret, in the vso-example-ns Kubernetes namespace. The example configuration assumes you already a HCP Vault Secrets app created and have yourservice principal Kubernetes secretconfigured.  Refer to the Kubernetes VSO installation guidebefore applying any of the example configurations below.  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: HCPAuth metadata: name: hcp-auth namespace: vso-example-ns spec: organizationID: xxxxxxxx-76e9-4e17-b5e9-xxxxxxxx4c33 projectID: xxxxxxxx-bd16-443f-a266-xxxxxxxxcb52 servicePrincipal: secretRef: vso-app-sp --- apiVersion: secrets.hashicorp.com/v1beta1 kind: HCPVaultSecretsApp metadata: name: vso-app namespace: vso-example-ns spec: appName: vso-app hcpAuthRef: hcp-auth destination: create: true name: vso-app-secret   For more details on any of the custom resources mentioned here, please see theapi-reference. ","version":"Next","tagName":"h3"},{"title":"Vault credential resolver","type":0,"sectionRef":"#","url":"/openbao/docs/platform/servicenow/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Vault credential resolver","url":"/openbao/docs/platform/servicenow/#overview","content":" ServiceNow uses MID servers deployed inside customer networks to perform agent-less discovery of their infrastructure. As infrastructure such as databases or servers are discovered, their attributes such as address and software versions are stored in a database. Naturally, this process requires a wide array of credentials. Customers can use ServiceNow's built-in credential storage, or install an external credential resolver to take advantage of their existing enterprise-grade secret storage solution.    The Vault Credential Resolver is one such resolver. The MID server will not store or cache any credentials marked as external, and will invoke the credential resolver each time it requires credentials.  The Vault Credential Resolver is designed to communicate with a Vault Agent service installed on the same machine as the MID server. Authentication is handled between the Agent and Vault, and Vault Agent also handles caching and renewing leased secrets to ensure the load on Vault is minimized.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Vault credential resolver","url":"/openbao/docs/platform/servicenow/#features","content":" The following features are supported by the Vault Credential Resolver:  KV, Active Directory and AWS secret engines.Communication with Vault via Vault Agent.TLS communication with Vault Agent. ","version":"Next","tagName":"h3"},{"title":"Telemetry","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/telemetry/","content":"Telemetry The Vault Secrets Operator is instrumented with Prometheus metrics in the following ways: The operator will emit the default controller-runtime metrics as outlined in the monitoringCustom metrics related to the operator internals which are defined in internal/metrics/metrics.goAbility to deploy a Prometheus Service Monitor, configured via the Helm Chart telemetry stanza.Ability to deploy a Metrics Service, configured via the Helm Chart metricsService stanza.","keywords":"","version":"Next"},{"title":"Configuring the Vault credential resolver","type":0,"sectionRef":"#","url":"/openbao/docs/platform/servicenow/configuration/","content":"","keywords":"","version":"Next"},{"title":"MID server properties​","type":1,"pageTitle":"Configuring the Vault credential resolver","url":"/openbao/docs/platform/servicenow/configuration/#mid-server-properties","content":" The following properties are supported by the Vault Credential Resolver:  mid.external_credentials.vault.address (string: &quot;&quot;) - Address of Vault Agent as resolveable by the MID server. For example, if Vault Agent is on the same server as the MID server it could be https://127.0.0.1:8200. mid.external_credentials.vault.ca (string: &quot;&quot;) - The CA certificate to trust for TLS in PEM format. If unset, the system's trusted CAs will be used. mid.external_credentials.vault.tls_skip_verify (string: &quot;&quot;) - When set to true, skips verification of the Vault server TLS certificiate. Setting this to true is not recommended for production.  ","version":"Next","tagName":"h2"},{"title":"Configuring discovery credentials​","type":1,"pageTitle":"Configuring the Vault credential resolver","url":"/openbao/docs/platform/servicenow/configuration/#configuring-discovery-credentials","content":" To consume Vault credentials from your MID server, you will need to:  Create a secret in VaultConfigure the resolver to use that secret  ","version":"Next","tagName":"h2"},{"title":"Creating a secret in Vault​","type":1,"pageTitle":"Configuring the Vault credential resolver","url":"/openbao/docs/platform/servicenow/configuration/#creating-a-secret-in-vault","content":" The credential resolver supports reading credentials from the following secret engines:  Active DirectoryAWSK/V v1K/V v2  When creating K/V secrets, you must use the following keys for each component to ensure it is correctly mapped to ServiceNow's credential fields:  Key\tDescription\tSupported aliasesusername\tThe username\taccess_key password\tThe password\tsecret_key, current_password private_key\tThe private SSH key passphrase\tThe passphrase for the private SSH key\t  Most ServiceNow credential types will expect at least a username and either a password or a private key. To help surface errors early, the credential resolver validates that a username and password are present for:  awsbasicjdbcjmsssh_passwordvmwarewindows  And the credential resolver expects the following types to specify at least a username and a private key:  api_keycfg_chef_credentialsinfobloxsn_cfg_ansiblesn_disco_certmgmt_certificate_cassh_private_key  ","version":"Next","tagName":"h3"},{"title":"Configuring the resolver to use a secret​","type":1,"pageTitle":"Configuring the Vault credential resolver","url":"/openbao/docs/platform/servicenow/configuration/#configuring-the-resolver-to-use-a-secret","content":" In the ServiceNow UI:  Navigate to &quot;Discovery - Credentials&quot; -&gt; New Select a type from the listTick &quot;External credential store&quot;Fill in a meaningful nameSet &quot;Credential ID&quot; to the path in Vault where your secret is located, e.g. for a KV v2 secret engine mounted at &quot;secret&quot;, you might have a secret stored under &quot;ssh&quot;: secret/data/ssh. Check the API docs for your secret engine if you are unsure of the path to useOptional: Click &quot;Test credential&quot; and select a MID server and a target to test against to test everything is working ","version":"Next","tagName":"h3"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/openbao/docs/platform/servicenow/troubleshooting/","content":"","keywords":"","version":"Next"},{"title":"Check the logs​","type":1,"pageTitle":"Troubleshooting","url":"/openbao/docs/platform/servicenow/troubleshooting/#check-the-logs","content":" Check the log files inside logs/ in the agent installation folder for logs and errors. The resolver logs a line for each credential ID that it successfully queries, and also logs the fields that the credentials were extracted from.  If a particular credential ID is failing, search for that ID in the logs, and check that it is successfully queried and that the credentials were extracted from the fields you expected.  You will also find any exceptions that the resolver throws in the logs, including if it didn't find the minimum set of required fields as specified inconfiguration, or if it couldn't communicate with Vault.  ","version":"Next","tagName":"h2"},{"title":"Use the test credential feature​","type":1,"pageTitle":"Troubleshooting","url":"/openbao/docs/platform/servicenow/troubleshooting/#use-the-test-credential-feature","content":" When creating or configuring a credential in the ServiceNow UI, you should be able to click &quot;Test credential&quot; to perform a quick targeted test. Select the MID server that should query Vault, and select a target that the credential should work for to check that everything works as expected. If it doesn't, check the logs for errors and debug information as detailed above. ","version":"Next","tagName":"h2"},{"title":"Plugin system","type":0,"sectionRef":"#","url":"/openbao/docs/plugins/","content":"","keywords":"","version":"Next"},{"title":"Built-In plugins​","type":1,"pageTitle":"Plugin system","url":"/openbao/docs/plugins/#built-in-plugins","content":" Built-in plugins are shipped with OpenBao, often for commonly used integrations, and can be used without any prerequisite steps.  ","version":"Next","tagName":"h2"},{"title":"External plugins​","type":1,"pageTitle":"Plugin system","url":"/openbao/docs/plugins/#external-plugins","content":" External plugins are not shipped with OpenBao and require additional operator intervention to run.  To run an external plugin, a binary of the plugin is required. Plugin binaries can be obtained from releases.hashicorp.comor they can be built from source.  OpenBao's external plugins are completely separate, standalone applications that OpenBao executes and communicates with over RPC. Each time an OpenBao secret engine, auth method, or database plugin is mounted, a new process is spawned. However, plugins can be made to implement plugin multiplexingto improve performance. Plugin multiplexing allows plugin processes to be reused across all mounts of a given type.  info NOTE: See the OpenBao Integrations page to find a curated collection of official, partner, and community OpenBao plugins.  ","version":"Next","tagName":"h2"},{"title":"Plugin versioning​","type":1,"pageTitle":"Plugin system","url":"/openbao/docs/plugins/#plugin-versioning","content":" OpenBao supports managing, running and upgrading plugins using semantic version information.  The plugin catalog optionally supports specifying a semantic version when registering an external plugin. Multiple versions of a plugin can be registered in the catalog simultaneously, and a version can be selected when mounting a plugin or tuning an existing mount in-place.  If no version is specified when creating a new mount, the following precedence is used for any available plugins whose type and name match:  The plugin registered with no versionThe plugin with the most recent semantic version among any registered versionsThe plugin built into OpenBao  ","version":"Next","tagName":"h2"},{"title":"Built-In versions​","type":1,"pageTitle":"Plugin system","url":"/openbao/docs/plugins/#built-in-versions","content":" OpenBao will report a version for built-in plugins to indicate what version of the plugin code got built into OpenBao as a dependency. For example:  $ bao plugin list secret Name Version ---- ------- kubernetes v0.5.0+builtin kv v0.15.0+builtin ldap v1.14.8+builtin.openbao openldap v0.11.1+builtin pki v1.14.8+builtin.openbao rabbitmq v1.14.8+builtin.openbao ssh v1.14.8+builtin.openbao totp v1.14.8+builtin.openbao transit v1.14.8+builtin.openbao   Here, OpenBao has a dependency on v0.15.0 of the openbao-plugin-secrets-kvrepo, and the openbao metadata identifier for pki indicates that plugin's code was within the OpenBao repo. For plugins within the OpenBao repo, OpenBao's own major, minor, and patch versions are used to form the plugin version.  The builtin metadata identifier is reserved and cannot be used when registering external plugins. ","version":"Next","tagName":"h3"},{"title":"Vault Secrets Operator","type":0,"sectionRef":"#","url":"/openbao/docs/platform/k8s/vso/sources/vault/","content":"","keywords":"","version":"Next"},{"title":"Supported Vault platform and version​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#supported-vault-platform-and-version","content":" Platform\tVersionVault\t1.11+  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#features","content":" Vault Secrets Operator supports the following Vault features:  Sync from multiple instances of Vault.All Vault secret engines supported.TLS/mTLS communications with Vault.Support for all VSO features, including performing a rollout-restart upon secret rotation or during drift remediation.  ","version":"Next","tagName":"h2"},{"title":"Supported Vault authentication methods​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#supported-vault-authentication-methods","content":" Backend\tDescriptionKubernetes\tRelies on short-lived Kubernetes ServiceAccount tokens for Vault authentication JWT\tRelies on either static JWT tokens or short-lived Kubernetes ServiceAccount tokens for Vault authentication AppRole\tRelies on static AppRole credentials for Vault authentication AWS\tRelies on AWS credentials for Vault authentication  ","version":"Next","tagName":"h3"},{"title":"Vault access and custom resource definitions​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vault-access-and-custom-resource-definitions","content":" VaultConnection and VaultAuth CRDs provide Vault connection and authentication configuration information for the operator. Consider VaultConnection and VaultAuth as foundational resources used by all secret replication type resources.  ","version":"Next","tagName":"h2"},{"title":"VaultConnection custom resource​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vaultconnection-custom-resource","content":" Provides the required configuration details for connecting to a single Vault server instance.  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultConnection metadata: namespace: vso-example name: vault-connection spec: # required configuration # address to the Vault server. address: http://vault.vault.svc.cluster.local:8200 # optional configuration # HTTP headers to be included in all Vault requests. # headers: [] # TLS server name to use as the SNI host for TLS connections. # tlsServerName: &quot;&quot; # skip TLS verification for TLS connections to Vault. # skipTLSVerify: false # the trusted PEM encoded CA certificate chain stored in a Kubernetes Secret # caCertSecretRef: &quot;&quot;   ","version":"Next","tagName":"h3"},{"title":"VaultAuth custom resource​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vaultauth-custom-resource","content":" Provide the configuration necessary for the Operator to authenticate to a single Vault server instance as specified in a VaultConnection custom resource.  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultAuth metadata: namespace: vso-example name: vault-auth spec: # required configuration # VaultConnectionRef of the corresponding VaultConnection CustomResource. # If no value is specified the Operator will default to the `default` VaultConnection, # configured in its own Kubernetes namespace. vaultConnectionRef: vault-connection # Method to use when authenticating to Vault. method: kubernetes # Mount to use when authenticating to auth method. mount: kubernetes # Kubernetes specific auth configuration, requires that the Method be set to kubernetes. kubernetes: # role to use when authenticating to Vault role: example # ServiceAccount to use when authenticating to Vault # it is recommended to always provide a unique serviceAccount per Pod/application serviceAccount: default # optional configuration # Params to use when authenticating to Vault # params: [] # HTTP headers to be included in all Vault authentication requests. # headers: []   ","version":"Next","tagName":"h3"},{"title":"Vault secret custom resource definitions​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vault-secret-custom-resource-definitions","content":" Provide the configuration necessary for the Operator to replicate a single Vault Secret to a single Kubernetes Secret. Each supported CRD is specialized to a class of Vault secret, documented below.  ","version":"Next","tagName":"h2"},{"title":"VaultStaticSecret custom resource​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vaultstaticsecret-custom-resource","content":" Provides the configuration necessary for the Operator to synchronize a single Vault static Secret to a single Kubernetes Secret. Supported secrets engines: kv-v2, kv-v1  KV version 1 secret example​  The KV secrets engine's kvv1 mount path is specified under spec.mount of VaultStaticSecret custom resource. Please consult KV Secrets Engine - Version 1 - Setup for configuring KV secrets engine version 1. The following results in a request to http://127.0.0.1:8200/v1/kvv1/eng/apikey/google to retrieve the secret.  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultStaticSecret metadata: namespace: vso-example name: vault-static-secret-v1 spec: vaultAuthRef: vault-auth mount: kvv1 type: kv-v1 path: eng/apikey/google refreshAfter: 60s destination: create: true name: static-secret1   KV version 2 secret example​  Set the KV secrets engine (kvv2) mount path with the spec.mount parameter of your VaultStaticSecret custom resource. For more advanced KV secrets engine version 2 configuration options, consult theKV Secrets Engine - Version 2 - Setupguide.  For example, to send requests to http://127.0.0.1:8200/v1/kvv2/eng/apikey/googleto retrieve secrets:  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultStaticSecret metadata: namespace: vso-example name: vault-static-secret-v2 spec: vaultAuthRef: vault-auth mount: kvv2 type: kv-v2 path: eng/apikey/google version: 2 refreshAfter: 60s destination: create: true name: static-secret2   ","version":"Next","tagName":"h3"},{"title":"VaultPKISecret custom resource​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vaultpkisecret-custom-resource","content":" Provides the configuration necessary for the Operator to synchronize a single Vault PKI Secret to a single Kubernetes Secret. Supported secrets engines: pki  The PKI secrets engine's mount path is specified under spec.mount of VaultPKISecret custom resource. Please consult PKI Secrets Engine - Setup and Usage for configuring PKI secrets engine. The following results in a request to http://127.0.0.1:8200/v1/pki/issue/default to generate TLS certificates.  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultPKISecret metadata: namespace: vso-example name: vault-pki spec: vaultAuthRef: vault-auth mount: pki role: default commonName: example.com format: pem expiryOffset: 1s ttl: 60s namespace: tenant-1 destination: create: true name: pki1   ","version":"Next","tagName":"h3"},{"title":"VaultDynamicSecret custom resource​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#vaultdynamicsecret-custom-resource","content":" Provides the configuration necessary for the Operator to synchronize a single Vault dynamic Secret to a single Kubernetes Secret. Supported secrets engines non-exhaustive: databases, aws,azure, gcp, ...  Database secret example​  Set the database secret engine mount path (db) with the spec.mount of yourVaultDynamicSecret custom resource. For more advanced database secrets engine configuration options, consult theDatabase Secrets Engine - Setup guide.  For example, to send requests tohttp://127.0.0.1:8200/v1/db/creds/my-postgresql-role to generate a new credential:  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultDynamicSecret metadata: namespace: vso-example name: vault-dynamic-secret-db spec: vaultAuthRef: vault-auth mount: db path: creds/my-postgresql-role destination: create: true name: dynamic-db   AWS secret example​  Set the AWS secrets engine mount path (aws) with the spec.mount parameter of your VaultDynamicSecret custom resource. For more advanced AWS secrets engine configuration options, consult theAWS Secrets Engine - Setup guide.  For example, to send requests to http://127.0.0.1:8200/v1/aws/creds/my-iam-roleto generate a new IAM credential:  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultDynamicSecret metadata: namespace: vso-example name: vault-dynamic-secret-aws-iam spec: vaultAuthRef: vault-auth mount: aws path: creds/my-iam-role destination: create: true name: dynamic-aws-iam   To send requests to http://127.0.0.1:8200/v1/aws/sts/my-sts-role to generate a new STS credential:  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultDynamicSecret metadata: namespace: vso-example name: vault-dynamic-secret-aws-sts spec: vaultAuthRef: vault-auth mount: aws path: sts/my-sts-role destination: create: true name: dynamic-aws-sts   HCP Vault Secrets Example​  --- apiVersion: secrets.hashicorp.com/v1beta1 kind: VaultDynamicSecret metadata: namespace: vso-example name: vault-dynamic-secret-aws-iam-role spec: vaultAuthRef: vault-auth mount: aws path: creds/my-iam-role destination: create: true name: dynamic-aws-iam-role   For more details on any of the custom resources mentioned here, please see theapi-reference.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Vault Secrets Operator","url":"/openbao/docs/platform/k8s/vso/sources/vault/#tutorial","content":" Refer to the Vault Secrets Operator on Kubernetes tutorial to learn the end-to-end workflow using the Vault Secrets Operator. ","version":"Next","tagName":"h2"},{"title":"External plugin architecture","type":0,"sectionRef":"#","url":"/openbao/docs/plugins/plugin-architecture/","content":"","keywords":"","version":"Next"},{"title":"External plugin lifecycle​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#external-plugin-lifecycle","content":" OpenBao external plugins are long-running processes that remain running once they are spawned by OpenBao, the parent process. Plugin processes can be started by OpenBao's active node. Additionally, there are cases where plugin processes may be terminated by OpenBao. These cases include, but are not limited to:  OpenBao active node step-downOpenBao barrier sealOpenBao graceful shutdownDisabling a Secrets Engine or Auth method that uses external pluginsDatabase configured connection deletionDatabase configured connection updateDatabase configured connection reset requestDatabase root credentials rotationWAL Rollback from a previously failed root credentials rotation operation  The lifecycle of plugin processes are managed automatically by OpenBao. Termination of these processes are typical in certain scenarios, such as the ones listed above. OpenBao will start plugin processes when they are enabled. A plugin process may be started or terminated through other internal processes within OpenBao as well. Since OpenBao manages and tracks the lifecycle of its plugins, these processes should not be terminated by anything other than OpenBao. If a plugin process is shutdown out-of-band, the plugin process will be lazily loaded when a request that requires the plugin is received by OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Plugin communication​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-communication","content":" OpenBao communicates with external plugins over RPC. To secure this communication, OpenBao creates a mutually authenticated TLS connection with the plugin's RPC server. Plugins make use of the AutoMTLS feature ofgo-plugin which will automatically negotiate mutual TLS for transport authentication.  The api_addr must be set in order for the plugin process to establish communication with the OpenBao server during mount time. If the storage backend has HA enabled and supports automatic host address detection, OpenBao will automatically attempt to determine the api_addr as well.  ","version":"Next","tagName":"h2"},{"title":"Plugin registration​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-registration","content":" An important consideration of OpenBao's plugin system is to ensure the plugin invoked by OpenBao is authentic and maintains integrity. There are two components that an OpenBao operator needs to configure before external plugins can be run- the plugin directory and the plugin catalog entry.  ","version":"Next","tagName":"h2"},{"title":"Plugin directory​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-directory","content":" The plugin directory is a configuration option of OpenBao and can be specified in the configuration file. This setting specifies a directory in which all plugin binaries must live;this value cannot be a symbolic link. A plugin cannot be added to OpenBao unless it exists in the plugin directory. There is no default for this configuration option, and if it is not set, plugins cannot be added to OpenBao.  Enabling the file permissions check via the environment variable VAULT_ENABLE_FILE_PERMISSIONS_CHECKallows OpenBao to check if the config directory and files are owned by the user running OpenBao. It also checks if there are no write or execute permissions for group or others. OpenBao allows operators to specify the user and permissions of the plugin directory and binaries using parameters plugin_file_uid and plugin_file_permissions in config if an operator needs those to be different. This check is disabled by default.  ","version":"Next","tagName":"h3"},{"title":"Plugin catalog​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-catalog","content":" The plugin catalog is OpenBao's list of approved plugins. The catalog is stored in OpenBao's barrier and can only be updated by an OpenBao user with sudo permissions. Upon adding a new plugin, the plugin name, SHA256 sum of the executable, and the command that should be used to run the plugin must be provided. The catalog will ensure the executable referenced in the command exists in the plugin directory. When added to the catalog, the plugin is not automatically executed, but becomes visible to backends and can be executed by them. For more information on the plugin catalog please see the Plugin Catalog API docs.  An example of plugin registration in current versions of OpenBao:  $ bao plugin register -sha256=&lt;SHA256 Hex value of the plugin binary&gt; \\ secret \\ # type myplugin-database-plugin Success! Registered plugin: myplugin-database-plugin   ","version":"Next","tagName":"h3"},{"title":"Plugin execution​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-execution","content":" When a backend wants to run a plugin, it first looks up the plugin, by name, in the catalog. It then checks the executable's SHA256 sum against the one configured in the plugin catalog. Finally OpenBao runs the command configured in the catalog, sending along the JWT formatted response wrapping token and mlock settings. Like OpenBao, plugins support the use of mlock when available.  warning Note: If OpenBao is configured with mlock enabled, then the OpenBao executable and each plugin executable in your plugins directorymust be given the ability to use the mlock syscall.  ","version":"Next","tagName":"h3"},{"title":"Plugin upgrades​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-upgrades","content":" External plugins may be updated by registering and reloading them. More details on the upgrade procedure can be found inUpgrading OpenBao Plugins.  ","version":"Next","tagName":"h3"},{"title":"Plugin multiplexing​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#plugin-multiplexing","content":" To avoid spawning multiple plugin processes for mounts of the same type, plugins can implement plugin multiplexing. This allows a single plugin process to be used for multiple mounts of a given type. This single process will be multiplexed across all OpenBao namespaces for mounts of this type. Multiplexing a plugin does not affect the current behavior of existing plugins.  To enable multiplexing, the plugin must be compiled with the ServeMultiplexfunction call from OpenBao's respective plugin or dbplugin SDK packages. At this time, there is no opt-out capability for plugins that implement multiplexing. To use a non-multiplexed plugin, run an older version of the plugin, i.e., the plugin calls the Serve function.  More resources on implementing plugin multiplexing:  Database secrets enginesSecrets engines and auth methods  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#troubleshooting","content":" ","version":"Next","tagName":"h2"},{"title":"Unrecognized remote plugin message​","type":1,"pageTitle":"External plugin architecture","url":"/openbao/docs/plugins/plugin-architecture/#unrecognized-remote-plugin-message","content":" If the following error is encountered when enabling a plugin secret engine or auth method:  Unrecognized remote plugin message: This usually means that the plugin is either invalid or simply needs to be recompiled to support the latest protocol.   Verify whether the OpenBao process has mlock enabled, and if so, run the following command against the plugin binary:  $ sudo setcap cap_ipc_lock=+ep &lt;plugin-binary&gt;  ","version":"Next","tagName":"h3"},{"title":"Installing the Vault credential resolver","type":0,"sectionRef":"#","url":"/openbao/docs/platform/servicenow/installation/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing the Vault credential resolver","url":"/openbao/docs/platform/servicenow/installation/#prerequisites","content":" ServiceNow version Quebec+ (untested on previous versions)MID server version Quebec+ (untested on previous versions)Discovery and external credential plugins activated on ServiceNowWorking Vault deployment accessible from the MID server  ","version":"Next","tagName":"h2"},{"title":"Installing Vault agent​","type":1,"pageTitle":"Installing the Vault credential resolver","url":"/openbao/docs/platform/servicenow/installation/#installing-vault-agent","content":" Select your desired auth method from Agent's supported auth methodsand set it up in Vault For example, to set up AppRole auth and a role called role1 with the demo policy attached: vault auth enable approle vault write auth/approle/role/role1 bind_secret_id=true token_policies=demo To get the files required for the example Agent config below, you can then run: echo -n $(vault read -format json auth/approle/role/role1/role-id | jq -r '.data.role_id') &gt; /path/to/roleID echo -n $(vault write -format json -f auth/approle/role/role1/secret-id | jq -r '.data.secret_id') &gt; /path/to/secretID Create an agent.hcl config file. Your exact configuration may vary, but you must set cache.use_auto_auth_token = true, and the listener, vault andauto_auth blocks are also required to set up a working Agent, e.g.: listener &quot;tcp&quot; { address = &quot;127.0.0.1:8200&quot; tls_disable = false tls_cert_file = &quot;/path/to/cert.pem&quot; tls_key_file = &quot;/path/to/key.pem&quot; } cache { use_auto_auth_token = true } vault { address = &quot;http://vault.example.com:8200&quot; } auto_auth { method { type = &quot;approle&quot; config = { role_id_file_path = &quot;/path/to/roleID&quot; secret_id_file_path = &quot;/path/to/secretID&quot; remove_secret_id_file_after_reading = false } } } Install Vault Agent as a service running vault agent -config=/path/to/agent.hcl Documentation for Windows service installation here  ","version":"Next","tagName":"h2"},{"title":"Uploading JAR file to MID server​","type":1,"pageTitle":"Installing the Vault credential resolver","url":"/openbao/docs/platform/servicenow/installation/#uploading-jar-file-to-mid-server","content":" Use the ServiceNow app store to install Vault Credential Resolver The steps documented below are for pre ServiceNow UTAH versions. As of ServiceNow version UTAH, use the &quot;HashiCorp Vault Credential Resolver&quot; App from the ServiceNow App store to install the Vault Credential Resolver and verify the jar file installed is vault-servicenow-credential-resolver. If you wish to use a custom name, you must manually rename the deployed jar.  Download the latest version of the Vault Credential Resolver JAR file fromreleases.hashicorp.comIn ServiceNow, navigate to &quot;MID server - JAR files&quot; -&gt; New Manage Attachments -&gt; upload Vault Credential Resolver JARFill in name, version etc as desiredClick Submit Navigate to &quot;MID server - Properties&quot; -&gt; New Set Name: mid.external_credentials.vault.address, Value: Address of Vault Agent listener from previous step, e.g. http://127.0.0.1:8200Optional: Set the property mid.external_credentials.vault.ca to the trusted CA in PEM format if using TLS between the MID server and Vault Agent with a self-signed certificate.  ","version":"Next","tagName":"h2"},{"title":"Next steps​","type":1,"pageTitle":"Installing the Vault credential resolver","url":"/openbao/docs/platform/servicenow/installation/#next-steps","content":" See configuration for details on configuring the resolver and using credentials for discovery. ","version":"Next","tagName":"h2"},{"title":"Plugin development","type":0,"sectionRef":"#","url":"/openbao/docs/plugins/plugin-development/","content":"","keywords":"","version":"Next"},{"title":"Serving a plugin​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#serving-a-plugin","content":" ","version":"Next","tagName":"h2"},{"title":"Serving a plugin with multiplexing​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#serving-a-plugin-with-multiplexing","content":" warning Plugin multiplexing requires github.com/openbao/openbao/sdk v0.5.4 or above.  The following code exhibits an example main package for an OpenBao plugin using the OpenBao SDK for a secrets engine or auth method:  package main import ( &quot;os&quot; myPlugin &quot;your/plugin/import/path&quot; &quot;github.com/openbao/openbao/api&quot; &quot;github.com/openbao/openbao/sdk/plugin&quot; ) func main() { apiClientMeta := &amp;api.PluginAPIClientMeta{} flags := apiClientMeta.FlagSet() flags.Parse(os.Args[1:]) tlsConfig := apiClientMeta.GetTLSConfig() tlsProviderFunc := api.VaultPluginTLSProvider(tlsConfig) err := plugin.ServeMultiplex(&amp;plugin.ServeOpts{ BackendFactoryFunc: myPlugin.Factory, TLSProviderFunc: tlsProviderFunc, }) if err != nil { logger := hclog.New(&amp;hclog.LoggerOptions{}) logger.Error(&quot;plugin shutting down&quot;, &quot;error&quot;, err) os.Exit(1) } }   And that's basically it! You would just need to change myPlugin to your actual plugin.  ","version":"Next","tagName":"h3"},{"title":"Plugin backwards compatibility with OpenBao​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#plugin-backwards-compatibility-with-openbao","content":" Let's take a closer look at a snippet from the above main package.  \terr := plugin.ServeMultiplex(&amp;plugin.ServeOpts{ BackendFactoryFunc: myPlugin.Factory, TLSProviderFunc: tlsProviderFunc, })   The call to plugin.ServeMultiplex ensures that the plugin will use OpenBao's plugin multiplexing feature. However, this plugin will not be multiplexed if it is run by a version of OpenBao that does not support multiplexing. OpenBao will simply fall back to a plugin version that it can run. Additionally, we set the TLSProviderFunc to ensure that our plugin is backwards compatible with versions of OpenBao that do not support automatic mutual TLS for secure plugin communication. If you are certain your plugin does not need backwards compatibility, this field can be omitted.  ","version":"Next","tagName":"h2"},{"title":"Leveraging plugin versioning​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#leveraging-plugin-versioning","content":" Plugins can optionally self-report their own semantic version. For plugins that do so, OpenBao will automatically populate the plugin's version in the catalog without requiring the user to provide it. If users do provide a version during registration, OpenBao will error if the version provided does not match what the plugin reports. Plugins that report a non-empty version must report a validSemantic Version with a leading 'v' added or registration will fail, e.g. v1.0.0 or v2.3.2-beta.  Plugins that want to opt into this behavior can implement the version interface. However, it is not a prerequisite; users can still provide a version during registration if the plugin does not implement the version interface.  Auth and secrets plugins based on framework.Backend from the SDK should set theRunningVersionvariable, and the framework will implement the version interface.  Database plugins have a smaller API than framework.Backend exposes, and should instead implement thePluginVersionerinterface directly.  ","version":"Next","tagName":"h2"},{"title":"Building a plugin from source​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#building-a-plugin-from-source","content":" To build a plugin from source, first navigate to the location holding the desired plugin version. Next, run go build to obtain a new binary for the plugin. Finally,register the plugin and enable it.  ","version":"Next","tagName":"h2"},{"title":"Plugin development - resources​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#plugin-development---resources","content":" For more information on how to register and enable your plugin, refer to theBuilding Plugin Backendstutorial.  Other HashiCorp plugin development resources:  vault-auth-plugin-exampleCustom Secrets Engines  ","version":"Next","tagName":"h2"},{"title":"Plugin development - resources - community​","type":1,"pageTitle":"Plugin development","url":"/openbao/docs/plugins/plugin-development/#plugin-development---resources---community","content":" See the OpenBao Integrations page to find Community plugin examples/guides developed by community members. HashiCorp does not validate these for correctness. ","version":"Next","tagName":"h3"},{"title":"Plugin management","type":0,"sectionRef":"#","url":"/openbao/docs/plugins/plugin-management/","content":"","keywords":"","version":"Next"},{"title":"Registering external plugins​","type":1,"pageTitle":"Plugin management","url":"/openbao/docs/plugins/plugin-management/#registering-external-plugins","content":" Before an external plugin can be mounted, it needs to beregistered in the plugin catalog to ensure the plugin invoked by OpenBao is authentic and maintains integrity:  $ bao plugin register -sha256=&lt;SHA256 Hex value of the plugin binary&gt; \\ secret \\ # type passthrough-plugin Success! Registered plugin: passthrough-plugin   ","version":"Next","tagName":"h2"},{"title":"Enabling/Disabling external plugins​","type":1,"pageTitle":"Plugin management","url":"/openbao/docs/plugins/plugin-management/#enablingdisabling-external-plugins","content":" After the plugin is registered, it can be mounted by specifying the registered plugin name:  $ bao secrets enable -path=my-secrets passthrough-plugin Success! Enabled the passthrough-plugin secrets engine at: my-secrets/   Listing secrets engines will display secrets engines that are mounted as plugins:  $ bao secrets list Path Type Accessor Plugin Default TTL Max TTL Force No Cache Replication Behavior Description my-secrets/ plugin plugin_deb84140 passthrough-plugin system system false replicated   Disabling an external plugins is identical to disabling a built-in plugin:  $ bao secrets disable my-secrets   ","version":"Next","tagName":"h2"},{"title":"Upgrading plugins​","type":1,"pageTitle":"Plugin management","url":"/openbao/docs/plugins/plugin-management/#upgrading-plugins","content":" Upgrade instructions can be found in the Upgrading Plugins - Guidespage. ","version":"Next","tagName":"h2"},{"title":"Policies","type":0,"sectionRef":"#","url":"/openbao/docs/policies/","content":"","keywords":"","version":"Next"},{"title":"Community decisions​","type":1,"pageTitle":"Policies","url":"/openbao/docs/policies/#community-decisions","content":" Deprecation Policy, for executing the deprecation and removal of a feature from the code base.Plugin Support Policy, for deciding which plugins to keep within the OpenBao Core distribution and which to support as external plugins.Migration Path Policy, for compatibility guarantees between OpenBao and upstream. ","version":"Next","tagName":"h2"},{"title":"Deprecation policy","type":0,"sectionRef":"#","url":"/openbao/docs/policies/deprecation/","content":"","keywords":"","version":"Next"},{"title":"Prior to initial release​","type":1,"pageTitle":"Deprecation policy","url":"/openbao/docs/policies/deprecation/#prior-to-initial-release","content":" No policy prior to first release candidate; free to vote to remove plugins, features without following the deprecation policy. Any alpha, betas prior to release candidate would not need to follow the below process. A simple majority vote minus abstentions on a community call would be sufficient to enact deprecation and removal.Follow approach similar to upstream after first release candidate (described above). ","version":"Next","tagName":"h2"},{"title":"Release notes","type":0,"sectionRef":"#","url":"/openbao/docs/release-notes/","content":"Release notes Release notes describe major updates in new versions of OpenBao. Choose a version from the navigation sidebar to view the release notes for each of the major software packages in the OpenBao product line. Please refer to theChangelog for further information on product improvements, including a comprehensive list of bug fixes.","keywords":"","version":"Next"},{"title":"Migration policy","type":0,"sectionRef":"#","url":"/openbao/docs/policies/migration/","content":"","keywords":"","version":"Next"},{"title":"Definitions​","type":1,"pageTitle":"Migration policy","url":"/openbao/docs/policies/migration/#definitions","content":" From a consumption perspective, there are three personas we can define:  Bao Operators. These are the people tasked with deploying updates to the bao binary, handling outages, &amp;c. They might typically access /sys, setup new mounts, get high-privileged root tokens temporarily to setup additional clusters or change quotas, &amp;c, but aren't (for this discussion) direct consumers of many secrets methods. They likely also interface with OpenBao's configuration, logging, and auditing interfaces, and may interact briefly (during outages &amp;c) with storage directly. They'd be in charge of handling any migration which needs to occur during an upgrade or change event from upstream to OpenBao. While a breaking change, these are most likely to have a flexible enough deployment &amp; workflow to accept change. Connection Operators. These are individuals who deploy applications which talk to OpenBao. They might directly interact with bao's API namespace, to set up new accounts, services, potentially (if delegated by Bao operators) creating new secrets engines, and configuration any existing secrets engines in their purview. They may do this directly (via CLI or UI) or indirectly (via a centralized management service like OpenTofu). These types of users can accept a moderate amount of change, but changes to APIs (especially unexpectedly) can cause issues. Applications &amp; end-users. These are individuals (broadly speaking) which only interface with the API of authentication and secrets engines to get secrets (again, broadly speaking -- a PKI certificate is not a traditional secret nor does Transit expose a similar interface that grants leases). These typically have the least flexible workflow and are hesitant to change.  We can also talk about compatibility on several layers:  Seal compatibility. Is encrypted data drop-in compatible with upstream, for a given combination of (seal mechanism, storage provider, plugin). Can this storage layout be read (i.e., is the disk tree similar) by core and can the resulting plugin be loaded and function equivalently to API consumers? This implies no to minimal migration necessary. Storage compatibility. For unencrypted data (i.e., using an unencrypted backup/one-time migration bundle or using the unsupported-but-usefulsys/raw interface), can this be migrated from an upstream instance directly into downstream at an equivalent path without rewriting the data itself. This means all the rest of the core (minus the initial encryption layer and potentially meaning a different physical storage backend) are compatible with upstream. API compatibility. For consumers of upstream's secret's or auth plugin's API only, would they be able to point interchangeably at an upstream or OpenBao instance without caring about which, assuming suitable data &amp; plugins are available in both locations. This usage does not extend to non-plugin APIs (e.g., under /sys), but should include the GRPC external plugin communication mechanism.  (In this hierarchy it is implied that 1 implies 2 implies 3, i.e., a seal or storage compatible fork would imply API compatibility, and likewise seal compatibility implies storage compatibility).  ","version":"Next","tagName":"h2"},{"title":"Observations​","type":1,"pageTitle":"Migration policy","url":"/openbao/docs/policies/migration/#observations","content":" Notably, API compatibility is most aligned with the connection operators' and application &amp; end-users' goals: minimize API change. While seal and storage compatibility are cool from a Bao operator's perspective, breaking either (w.r.t. upstream -- likely ahead of initial GA) results in a one-time migration, but difficult from a Bao development community perspective. This type of compatibility helps cross-adoption but becomes hard to support, especially as several key portions are impossible to do without reverse engineering Vault Enterprise (e.g., auto-unseal, seal wrapping, replication, certain secret engine features, ...).  ","version":"Next","tagName":"h2"},{"title":"Proposal​","type":1,"pageTitle":"Migration policy","url":"/openbao/docs/policies/migration/#proposal","content":" Aim for API compatibility only, with limited seal compatibility when using remaining seal, storage, and plugins as discussed in that proposal.  This allows us to prune unnecessary features, create alternative, non-compatible implementations of various upstream, Enterprise features, and decreases maintenance burdens. This allows us to create a more healthy, separate but welcoming community from upstream.  It also recognizes that OpenBao (by discussing removing support for already deprecated changes or removing plugins that no maintainer has stepped up to support) will inevitably, intentionally or otherwise, deviate from upstream. It provides support commitment to portions of the organization most resistant to change, and allows Bao operators to decide whether or not to make the migration. It also recognizes that upstream may or may not make other decisions and potentially backwards-incompatible changes of their own, allowing us to take a different approach if necessary.  This still allows us to take advantage of the broader secrets &amp; auth engine ecosystem, as GRPC compatibility is still encouraged. And third-party client tooling should continue to function between the two, unless they were using unsupported, internal implementation details and crossing the API boundary.  However, it walks a fine line that, when a user's existing usage of upstream aligns with OpenBao's goals, the two should be drop-in compatible at the initial release. This then allows a smoother migration between the two projects.  ","version":"Next","tagName":"h2"},{"title":"Migration path​","type":1,"pageTitle":"Migration policy","url":"/openbao/docs/policies/migration/#migration-path","content":" This means that some operators will need to make a conscious, one-time migration from a compatible upstream version to an OpenBao version. This likely warrants the creation of documentation and tools to help aid this migration, on a per-plugin basis. It means that OpenBao's server will not be drop-in binary equivalent from upstream's, and that we should likely place some marker to detect and prevent incompatible, unsupported usage.  The remaining operators (who use a supported subset) will be able to drop-in replace like a regular upgrade. ","version":"Next","tagName":"h3"},{"title":"Plugin support policy","type":0,"sectionRef":"#","url":"/openbao/docs/policies/plugins/","content":"","keywords":"","version":"Next"},{"title":"Auth plugins​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#auth-plugins","content":" name\trepoapprole\tgithub.com/openbao/openbao/builtin/credential/approle cert\tgithub.com/openbao/openbao/builtin/credential/cert jwt\tgithub.com/hashicorp/vault-plugin-auth-jwt kerberos\tgithub.com/hashicorp/vault-plugin-auth-kerberos kubernetes\tgithub.com/hashicorp/vault-plugin-auth-kubernetes ldap\tgithub.com/openbao/openbao/builtin/credential/ldap radius\tgithub.com/openbao/openbao/builtin/credential/radius token\tgithub.com/openbao/openbao/builtin/credential/token userpass\tgithub.com/openbao/openbao/builtin/credential/userpass  ","version":"Next","tagName":"h2"},{"title":"Database plugins​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#database-plugins","content":" name\trepocassandra\tgithub.com/openbao/openbao/plugins/database/cassandra influxdb\tgithub.com/openbao/openbao/plugins/database/influxdb mysql\tgithub.com/openbao/openbao/plugins/database/mysql postgresql\tgithub.com/openbao/openbao/plugins/database/postgresql redis\tgithub.com/hashicorp/vault-plugin-database-redis  ","version":"Next","tagName":"h2"},{"title":"Secrets plugins​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#secrets-plugins","content":" name\trepodatabase\tgithub.com/openbao/openbao/builtin/logical/database kv\tgithub.com/hashicorp/vault-plugin-secrets-kv kubernetes\tgithub.com/hashicorp/vault-plugin-secrets-kubernetes openldap\tgithub.com/hashicorp/vault-plugin-secrets-openldap pki\tgithub.com/openbao/openbao/builtin/logical/pki rabbitmq\tgithub.com/openbao/openbao/builtin/logical/rabbitmq ssh\tgithub.com/openbao/openbao/builtin/logical/ssh totp\tgithub.com/openbao/openbao/builtin/logical/totp transit\tgithub.com/openbao/openbao/builtin/logical/transit  ","version":"Next","tagName":"h2"},{"title":"Storage backends​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#storage-backends","content":" name\treporaft\tgithub.com/openbao/openbao/physical/raft file\tgithub.com/openbao/openbao/sdk/physical/file inmem\tgithub.com/openbao/openbao/sdk/physical/inmem  ","version":"Next","tagName":"h2"},{"title":"go-kms-wrapping​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#go-kms-wrapping","content":" Initially no plugins will be removed from this, but the package will remain as a separate repository. However, if PKCS#11 bindings are contributed, this could warrant a migration from native seals to PKCS#11 libraries to reduce binary size and avoid the need to maintain each cloud provider's integration separately. This has the added benefit of easing cross-cloud migrations and being testable locally with SoftHSM.  Net additions and removals  ","version":"Next","tagName":"h2"},{"title":"Additions to main repo​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#additions-to-main-repo","content":" auth-jwtauth-kerberosauth-kubernetesdatabase-redissecrets-kvsecrets-kubernetessecrets-openldap  ","version":"Next","tagName":"h2"},{"title":"Removals of builtin plugins to external, community supported​","type":1,"pageTitle":"Plugin support policy","url":"/openbao/docs/policies/plugins/#removals-of-builtin-plugins-to-external-community-supported","content":" auth-alicloudauth-awsauth-azureauth-centiryauth-cfauth-gcpauth-githubauth-ociauth-oktadatabase-couchbasedatabase-elasticsearchdatabase-hanadatabase-mongodbdatabase-mongodbatlasdatabase-mssqldatabase-redis-elasticachedatabase-redshiftdatabase-snowflakesecrets-adsecrets-alicloudsecrets-awssecrets-azuresecrets-consulsecrets-gcpsecrets-gcpkmssecrets-monogodbatlassecrets-nomadsecrets-terraformstorage-aerospikestorage-alicloudossstorage-azurestorage-cassandrastorage-cockroachdbstorage-consulstorage-couchdbstorage-dynamodbstorage-etcdstorage-foundationdbstorage-gcsstorage-mantastorage-mssqlstorage-mysqlstorage-ocistorage-postgresqlstorage-s3sotrage-spannerstorage-switfstorage-zookeeper ","version":"Next","tagName":"h2"},{"title":"Cubbyhole secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/cubbyhole/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"Cubbyhole secrets engine","url":"/openbao/docs/secrets/cubbyhole/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  The cubbyhole secrets engine is enabled by default. It cannot be disabled, moved, or enabled multiple times.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Cubbyhole secrets engine","url":"/openbao/docs/secrets/cubbyhole/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials. The cubbyhole secrets engine allows for writing keys with arbitrary values.  Write arbitrary data: $ bao write cubbyhole/my-secret my-value=s3cr3t Success! Data written to: cubbyhole/my-secret Read arbitrary data: $ bao read cubbyhole/my-secret Key Value --- ----- my-value s3cr3t   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Cubbyhole secrets engine","url":"/openbao/docs/secrets/cubbyhole/#tutorial","content":" Refer to the Cubbyhole Response Wrappingtutorial to learn how to securely distribute the initial token to the trusted entity.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Cubbyhole secrets engine","url":"/openbao/docs/secrets/cubbyhole/#api","content":" The Cubbyhole secrets engine has a full HTTP API. Please see theCubbyhole secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"Secrets engines","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/","content":"","keywords":"","version":"Next"},{"title":"Secrets engines lifecycle​","type":1,"pageTitle":"Secrets engines","url":"/openbao/docs/secrets/#secrets-engines-lifecycle","content":" Most secrets engines can be enabled, disabled, tuned, and moved via the CLI or API.  Enable - This enables a secrets engine at a given path. With a few exceptions, secrets engines can be enabled at multiple paths. Each secrets engine is isolated to its path. By default, they are enabled at their &quot;type&quot; (e.g. &quot;kv&quot; enables at kv/).  danger Case-sensitive: The path where you enable secrets engines is case-sensitive. For example, the KV secrets engine enabled at kv/ and KV/ are treated as two distinct instances of KV secrets engine.  Disable - This disables an existing secrets engine. When a secrets engine is disabled, all of its secrets are revoked (if they support it), and all the data stored for that engine in the physical storage layer is deleted. Move - This moves the path for an existing secrets engine. This process revokes all secrets, since secret leases are tied to the path where they were created. The configuration data stored for the engine persists through the move. Tune - This tunes global configuration for the secrets engine such as the TTLs.  Once a secrets engine is enabled, you can interact with it directly at its path according to its own API. Use bao path-help to determine the paths it responds to.  Note that mount points cannot conflict with each other in OpenBao. There are two broad implications of this fact. The first is that you cannot have a mount which is prefixed with an existing mount. The second is that you cannot create a mount point that is named as a prefix of an existing mount. As an example, the mounts foo/bar and foo/baz can peacefully coexist with each other whereas foo and foo/baz cannot  ","version":"Next","tagName":"h2"},{"title":"Barrier view​","type":1,"pageTitle":"Secrets engines","url":"/openbao/docs/secrets/#barrier-view","content":" Secrets engines receive a barrier view to the configured OpenBao physical storage. This is a lot like a chroot.  When a secrets engine is enabled, a random UUID is generated. This becomes the data root for that engine. Whenever that engine writes to the physical storage layer, it is prefixed with that UUID folder. Since the OpenBao storage layer doesn't support relative access (such as ../), this makes it impossible for an enabled secrets engine to access other data.  This is an important security feature in OpenBao - even a malicious engine cannot access the data from any other engine. ","version":"Next","tagName":"h2"},{"title":"Databases","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/","content":"","keywords":"","version":"Next"},{"title":"Static roles​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#static-roles","content":" With dynamic secrets, OpenBao generates a unique username and password pair for each unique credential request. OpenBao also supports static roles for some database secrets engines. Static roles are a 1-to-1 mapping of OpenBao roles to usernames in a database. With static roles, OpenBao stores, and automatically rotates, passwords for the associated database user based on a configurable period of time.  When a client requests credentials for the static role, OpenBao returns the current password for whichever database user is mapped to the requested role. With static roles, anyone with the proper OpenBao policies can access the associated user account in the database.  Do not use static roles for root database credentials Do not manage the same root database credentials that you provide to OpenBao inconfig/ with static roles. OpenBao does not distinguish between standard credentials and root credentials when rotating passwords. If you assign your root credentials to a static role, any dynamic or static users managed by that database configuration will fail after rotation because the password for config/ is no longer valid. If you need to rotate root credentials, use theRotate root credentialsAPI endpoint.  Consult the database capabilities table to determine if your chosen database backend supports static roles.  ","version":"Next","tagName":"h3"},{"title":"Setup​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  Enable the database secrets engine: $ bao secrets enable database Success! Enabled the database secrets engine at: database/ By default, the secrets engine will enable at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure OpenBao with the proper plugin and connection information: $ bao write database/config/my-database \\ plugin_name=&quot;...&quot; \\ connection_url=&quot;...&quot; \\ allowed_roles=&quot;...&quot; \\ username=&quot;...&quot; \\ password=&quot;...&quot; \\   warning It is highly recommended a user within the database is created specifically for OpenBao to use. This user will be used to manipulate dynamic and static users within the database. This user is called the &quot;root&quot; user within the documentation.  OpenBao will use the user specified here to create/update/revoke database credentials. That user must have the appropriate permissions to perform actions upon other database users (create, update credentials, delete, etc.).  This secrets engine can configure multiple database connections. For details on the specific configuration options, please see the database-specific documentation.  After configuring the root user, it is highly recommended you rotate that user's password such that the openbao user is not accessible by any users other than OpenBao itself: $ bao write -force database/rotate-root/my-database   danger When this is done, the password for the user specified in the previous step is no longer accessible. Because of this, it is highly recommended that a user is created specifically for OpenBao to use to manage database users.  Configure a role that maps a name in OpenBao to a set of creation statements to create the database credential: $ bao write database/roles/my-role \\ db_name=my-database \\ creation_statements=&quot;...&quot; \\ default_ttl=&quot;1h&quot; \\ max_ttl=&quot;24h&quot; Success! Data written to: database/roles/my-role The {{username}} and {{password}} fields will be populated by the plugin with dynamically generated values. In some plugins the {{expiration}} field is also supported.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by reading from the /creds endpoint with the name of the role: $ bao read database/creds/my-role Key Value --- ----- lease_id database/creds/my-role/2f6a614c-4aa2-7b19-24b9-ad944a8d4de6 lease_duration 1h lease_renewable true password FSREZ1S0kFsZtLat-y94 username v-openbaouser-e2978cd0-ugp7iqI2hdlff5hfjylJ-1602537260   ","version":"Next","tagName":"h2"},{"title":"Database capabilities​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#database-capabilities","content":" All databases support dynamic roles and static roles. All plugins support rotating the root user's credentials.    Database\tRoot Credential Rotation\tDynamic Roles\tStatic Roles\tUsername Customization\tCredential TypesCassandra\tYes\tYes\tYes\tYes\tpassword InfluxDB\tYes\tYes\tYes\tYes\tpassword MySQL/MariaDB\tYes\tYes\tYes\tYes\tpassword PostgreSQL\tYes\tYes\tYes\tYes\tpassword Redis\tYes\tYes\tYes\tNo\tpassword  ","version":"Next","tagName":"h2"},{"title":"Custom plugins​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#custom-plugins","content":" This secrets engine allows custom database types to be run through the exposed plugin interface. Please see the custom database pluginfor more information.  ","version":"Next","tagName":"h2"},{"title":"Credential types​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#credential-types","content":" Database systems support a variety of authentication methods and credential types. The database secrets engine supports management of credentials alternative to usernames and passwords. The credential_typeand credential_config parameters of dynamic and static roles configure the credential that OpenBao will generate and make available to database plugins. See the documentation of individual database plugins for the credential types they support and usage examples.  ","version":"Next","tagName":"h2"},{"title":"Password generation​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#password-generation","content":" Passwords are generated via Password Policies. Databases can optionally set a password policy for use across all roles or at the individual role level for that database. For example, each time you callopenbao write database/config/my-database you can specify a password policy for all roles using my-database. Each database has a default password policy defined as: 20 characters with at least 1 uppercase character, at least 1 lowercase character, at least 1 number, and at least 1 dash character.  The default password generation can be represented as the following password policy:  length = 20 rule &quot;charset&quot; { charset = &quot;abcdefghijklmnopqrstuvwxyz&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;-&quot; min-chars = 1 }   ","version":"Next","tagName":"h2"},{"title":"Disable character escaping​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#disable-character-escaping","content":" You can specify the option disable_escaping with a value of true in some secrets engines to prevent OpenBao from escaping special characters in the username and password fields. This is necessary for some alternate connection string formats. See the databases secrets engine API docs and reference individual plugin documentation to determine support for this parameter.  For example, when the password contains URL-escaped characters like # or % they will remain as so instead of becoming %23 and %25 respectively.  $ bao write database/config/my-mysql-database \\ plugin_name=&quot;mysql-database-plugin&quot; \\ connection_url='server=localhost;port=3306;user id={{username}};password={{password}};database=mydb;' \\ username=&quot;root&quot; \\ password='your#StrongPassword%' \\ disable_escaping=&quot;true&quot;   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#tutorial","content":" Refer to the following step-by-step tutorials for more information:  Secrets as a Service: Dynamic SecretsDatabase Root Credential RotationDatabase Static Roles and Credential Rotation  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Databases","url":"/openbao/docs/secrets/databases/#api","content":" The database secrets engine has a full HTTP API. Please see the Database secret secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"Cassandra database secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/cassandra/","content":"","keywords":"","version":"Next"},{"title":"Capabilities​","type":1,"pageTitle":"Cassandra database secrets engine","url":"/openbao/docs/secrets/databases/cassandra/#capabilities","content":" Plugin Name\tRoot Credential Rotation\tDynamic Roles\tStatic Roles\tUsername Customizationcassandra-database-plugin\tYes\tYes\tYes (1.6+)\tYes (1.7+)  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Cassandra database secrets engine","url":"/openbao/docs/secrets/databases/cassandra/#setup","content":" OpenBao will need a Cassandra user with the following permissions: GRANT CREATE ON ALL ROLES to '&lt;YOUR USER&gt;'; GRANT ALTER ON ALL ROLES to '&lt;YOUR USER&gt;'; GRANT DROP ON ALL ROLES to '&lt;YOUR USER&gt;'; GRANT AUTHORIZE ON ALL ROLES to '&lt;YOUR USER&gt;'; Enable the database secrets engine if it is not already enabled: $ bao secrets enable database Success! Enabled the database secrets engine at: database/ By default, the secrets engine will enable at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure OpenBao with the proper plugin and connection information: $ bao write database/config/my-cassandra-database \\ plugin_name=&quot;cassandra-database-plugin&quot; \\ hosts=127.0.0.1 \\ protocol_version=4 \\ username=openbaouser \\ password=openbaopass \\ allowed_roles=my-role Configure a role that maps a name in OpenBao to an SQL statement to execute to create the database credential: $ bao write database/roles/my-role \\ db_name=my-cassandra-database \\ creation_statements=&quot;CREATE USER '{{username}}' WITH PASSWORD '{{password}}' NOSUPERUSER; \\ GRANT SELECT ON ALL KEYSPACES TO {{username}};&quot; \\ default_ttl=&quot;1h&quot; \\ max_ttl=&quot;24h&quot; Success! Data written to: database/roles/my-role   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Cassandra database secrets engine","url":"/openbao/docs/secrets/databases/cassandra/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by reading from the /creds endpoint with the name of the role: $ bao read database/creds/my-role Key Value --- ----- lease_id database/creds/my-role/2f6a614c-4aa2-7b19-24b9-ad944a8d4de6 lease_duration 1h lease_renewable true password 7iO-FxlVCdj8szsgGgsL username v_openbaouser_my_role_6zjahr4mjn5c9prgucy1_1602541475   ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Cassandra database secrets engine","url":"/openbao/docs/secrets/databases/cassandra/#api","content":" The full list of configurable options can be seen in the Cassandra database plugin API page.  For more information on the database secrets engine's HTTP API please see the Database secret secrets engine API page. ","version":"Next","tagName":"h2"},{"title":"InfluxDB database secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/influxdb/","content":"","keywords":"","version":"Next"},{"title":"Capabilities​","type":1,"pageTitle":"InfluxDB database secrets engine","url":"/openbao/docs/secrets/databases/influxdb/#capabilities","content":" Plugin Name\tRoot Credential Rotation\tDynamic Roles\tStatic Roles\tUsername Customizationinfluxdb-database-plugin\tYes\tYes\tYes (1.6+)\tYes (1.8+)  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"InfluxDB database secrets engine","url":"/openbao/docs/secrets/databases/influxdb/#setup","content":" Enable the database secrets engine if it is not already enabled: $ bao secrets enable database Success! Enabled the database secrets engine at: database/ By default, the secrets engine will enable at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure OpenBao with the proper plugin and connection information: $ bao write database/config/my-influxdb-database \\ plugin_name=&quot;influxdb-database-plugin&quot; \\ host=127.0.0.1 \\ username=openbaouser \\ password=openbaopass \\ allowed_roles=my-role Configure a role that maps a name in OpenBao to an SQL statement to execute to create the database credential: $ bao write database/roles/my-role \\ db_name=my-influxdb-database \\ creation_statements=&quot;CREATE USER \\&quot;{{username}}\\&quot; WITH PASSWORD '{{password}}'; \\ GRANT ALL ON \\&quot;openbao\\&quot; TO \\&quot;{{username}}\\&quot;;&quot; \\ default_ttl=&quot;1h&quot; \\ max_ttl=&quot;24h&quot; Success! Data written to: database/roles/my-role   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"InfluxDB database secrets engine","url":"/openbao/docs/secrets/databases/influxdb/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by reading from the /creds endpoint with the name of the role: $ bao read database/creds/my-role Key Value --- ----- lease_id database/creds/my-role/2f6a614c-4aa2-7b19-24b9-ad944a8d4de6 lease_duration 1h lease_renewable true password ux-TAAKTSZex6jgXhe67 username v_openbaouser_my_role_7XjvivMy80m7qQughmbk_1602541922   ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"InfluxDB database secrets engine","url":"/openbao/docs/secrets/databases/influxdb/#api","content":" The full list of configurable options can be seen in the InfluxDB database plugin API page.  For more information on the database secrets engine's HTTP API please see the Database secret secrets engine API page. ","version":"Next","tagName":"h2"},{"title":"PostgreSQL database secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/postgresql/","content":"","keywords":"","version":"Next"},{"title":"Capabilities​","type":1,"pageTitle":"PostgreSQL database secrets engine","url":"/openbao/docs/secrets/databases/postgresql/#capabilities","content":" Plugin Name\tRoot Credential Rotation\tDynamic Roles\tStatic Roles\tUsername Customizationpostgresql-database-plugin\tYes\tYes\tYes\tYes (1.7+)  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"PostgreSQL database secrets engine","url":"/openbao/docs/secrets/databases/postgresql/#setup","content":" Enable the database secrets engine if it is not already enabled: $ bao secrets enable database Success! Enabled the database secrets engine at: database/ By default, the secrets engine will enable at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure OpenBao with the proper plugin and connection information: $ bao write database/config/my-postgresql-database \\ plugin_name=&quot;postgresql-database-plugin&quot; \\ allowed_roles=&quot;my-role&quot; \\ connection_url=&quot;postgresql://{{username}}:{{password}}@localhost:5432/database-name&quot; \\ username=&quot;openbaouser&quot; \\ password=&quot;openbaopass&quot; \\ password_authentication=&quot;scram-sha-256&quot; Configure a role that maps a name in OpenBao to an SQL statement to execute to create the database credential: $ bao write database/roles/my-role \\ db_name=&quot;my-postgresql-database&quot; \\ creation_statements=&quot;CREATE ROLE \\&quot;{{name}}\\&quot; WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \\ GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\&quot;{{name}}\\&quot;;&quot; \\ default_ttl=&quot;1h&quot; \\ max_ttl=&quot;24h&quot; Success! Data written to: database/roles/my-role   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"PostgreSQL database secrets engine","url":"/openbao/docs/secrets/databases/postgresql/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by reading from the /creds endpoint with the name of the role: $ bao read database/creds/my-role Key Value --- ----- lease_id database/creds/my-role/2f6a614c-4aa2-7b19-24b9-ad944a8d4de6 lease_duration 1h lease_renewable true password SsnoaA-8Tv4t34f41baD username v-openbaouse-my-role-x   ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PostgreSQL database secrets engine","url":"/openbao/docs/secrets/databases/postgresql/#api","content":" The full list of configurable options can be seen in the PostgreSQL database plugin API page.  For more information on the database secrets engine's HTTP API please see theDatabase secrets engine API page. ","version":"Next","tagName":"h2"},{"title":"Custom database secrets engines","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/custom/","content":"","keywords":"","version":"Next"},{"title":"Plugin interface​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#plugin-interface","content":" All plugins for the database secrets engine must implement the same interface. This interface is found in sdk/database/dbplugin/v5/database.go  type Database interface { // Initialize the database plugin. This is the equivalent of a constructor for the // database object itself. Initialize(ctx context.Context, req InitializeRequest) (InitializeResponse, error) // NewUser creates a new user within the database. This user is temporary in that it // will exist until the TTL expires. NewUser(ctx context.Context, req NewUserRequest) (NewUserResponse, error) // UpdateUser updates an existing user within the database. UpdateUser(ctx context.Context, req UpdateUserRequest) (UpdateUserResponse, error) // DeleteUser from the database. This should not error if the user didn't // exist prior to this call. DeleteUser(ctx context.Context, req DeleteUserRequest) (DeleteUserResponse, error) // Type returns the Name for the particular database backend implementation. // This type name is usually set as a constant within the database backend // implementation, e.g. &quot;mysql&quot; for the MySQL database backend. This is used // for things like metrics and logging. No behavior is switched on this. Type() (string, error) // Close attempts to close the underlying database connection that was // established by the backend. Close() error }   Each of the request and response objects can also be found in sdk/database/dbplugin/v5/database.go.  In each of the requests, you will see at least 1 Statements object (in UpdateUserRequestthey are in sub-fields). This object represents the set of commands to run for that particular operation. For the NewUser function, this is a set of commands to create the user (and often set permissions for that user). These statements are from the following fields in the API:  API Argument\tRequest Objectcreation_statements\tNewUserRequest.Statements.Commands revocation_statements\tDeleteUserRequest.Statements.Commands rollback_statements\tNewUserRequest.RollbackStatements.Commands renew_statements\tUpdateUserRequest.Expiration.Statements.Commands rotation_statements\tUpdateUserRequest.Password.Statements.Commands root_rotation_statements\tUpdateUserRequest.Password.Statements.Commands  In many of the built-in plugins, they replace {{name}} (or {{username}}), {{password}}, and/or {{expiration}} with the associated values. It is up to your plugin to perform these string replacements. There is a helper function located in sdk/database/helper/dbutilcalled QueryHelper that assists in doing this string replacement. You are not required to use it, but it will make your plugin's behavior consistent with the built-in plugins.  The InitializeRequest object contains a map of keys to values. This data is what the user specified as the configuration for the plugin. Your plugin should use this data to make connections to the database. The response object contains a similar configuration map. The response object should contain the configuration map that should be saved within OpenBao. This allows the plugin to manipulate the configuration prior to saving it.  It is also passed a boolean value (InitializeRequest.VerifyConnection) indicating if your plugin should initialize a connection to the database during the Initialize call. This function is called when the configuration is written. This allows the user to know whether the configuration is valid and able to connect to the database in question. If this is set to false, no connection should be made during the Initialize call, but subsequent calls to the other functions will need to open a connection.  ","version":"Next","tagName":"h2"},{"title":"Serving a plugin​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#serving-a-plugin","content":" ","version":"Next","tagName":"h2"},{"title":"Serving a plugin with multiplexing​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#serving-a-plugin-with-multiplexing","content":" warning Plugin multiplexing requires github.com/openbao/openbao/sdk v0.4.0 or above.  The plugin runs as a separate binary outside of OpenBao, so the plugin itself will need a main function. Use the ServeMultiplex function withinsdk/database/dbplugin/v5 to serve your multiplexed plugin.  Below is an example setup:  package main import ( &quot;github.com/openbao/openbao/api&quot; dbplugin &quot;github.com/openbao/openbao/sdk/database/dbplugin/v5&quot; ) func main() { apiClientMeta := &amp;api.PluginAPIClientMeta{} flags := apiClientMeta.FlagSet() flags.Parse(os.Args[1:]) err := Run() if err != nil { log.Println(err) os.Exit(1) } } func Run() error { dbplugin.ServeMultiplex(dbType.(dbplugin.New)) return nil } func New() (interface{}, error) { db, err := newDatabase() if err != nil { return nil, err } // This middleware isn't strictly required, but highly recommended to prevent accidentally exposing // values such as passwords in error messages. An example of this is included below db = dbplugin.NewDatabaseErrorSanitizerMiddleware(db, db.secretValues) return db, nil } type MyDatabase struct { // Variables for the database password string } func newDatabase() (MyDatabase, error) { // ... db := &amp;MyDatabase{ // ... } return db, nil } func (db *MyDatabase) secretValues() map[string]string { return map[string]string{ db.password: &quot;[password]&quot;, } }   Replacing MyDatabase with the actual implementation of your database plugin.  ","version":"Next","tagName":"h3"},{"title":"Serving a plugin without multiplexing​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#serving-a-plugin-without-multiplexing","content":" Serving a plugin without multiplexing requires calling the Serve function from sdk/database/dbplugin/v5 to serve your plugin.  The setup is exactly the same as the multiplexed case above, except for theRun function:  func Run() error { dbType, err := New() if err != nil { return err } dbplugin.Serve(dbType.(dbplugin.Database)) return nil }   ","version":"Next","tagName":"h3"},{"title":"Running your plugin​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#running-your-plugin","content":" The above main package, once built, will supply you with a binary of your plugin. We also recommend if you are planning on distributing your plugin to build with gox for cross platform builds.  To use your plugin with the database secrets engine you need to place the binary in the plugin directory as specified in the plugin internals docs.  You should now be able to register your plugin into the OpenBao catalog. To do this your token will need sudo permissions.  $ bao write sys/plugins/catalog/database/mydatabase-database-plugin \\ sha256=&quot;...&quot; \\ command=&quot;mydatabase&quot; Success! Data written to: sys/plugins/catalog/database/mydatabase-database-plugin   Now you should be able to configure your plugin like any other:  $ bao write database/config/mydatabase \\ plugin_name=mydatabase-database-plugin \\ allowed_roles=&quot;readonly&quot; \\ myplugins_connection_details=&quot;...&quot;   ","version":"Next","tagName":"h2"},{"title":"Updating database plugins to leverage plugin versioning​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#updating-database-plugins-to-leverage-plugin-versioning","content":" Plugins can optionally self-report their own semantic version. For plugins that do so, OpenBao will automatically populate the plugin's version in the catalog without requiring the user to provide it. If users do provide a version during registration, OpenBao will error if the version provided does not match what the plugin reports. Plugins that report a non-empty version must report a validSemantic Version with a leading 'v' added or registration will fail, e.g. v1.0.0 or v2.3.2-beta.  Plugins that want to opt into this behavior can implement the version interface. However, it is not a prerequisite; users can still provide a version during registration if the plugin does not implement the version interface.  In addition to the Database interface above, database plugins can then also implement thePluginVersionerinterface:  // PluginVersioner is an optional interface to return version info. type PluginVersioner interface { // PluginVersion returns the version for the backend PluginVersion() PluginVersion } type PluginVersion struct { Version string }   ","version":"Next","tagName":"h2"},{"title":"Upgrading database plugins to leverage plugin multiplexing​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#upgrading-database-plugins-to-leverage-plugin-multiplexing","content":" ","version":"Next","tagName":"h2"},{"title":"Background​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#background","content":" Scaling many external plugins can become resource intensive. To address performance problems with scaling external plugins, database plugins can be made to implement plugin multiplexingwhich allows a single plugin process to be used for multiple database connections. To enable multiplexing, the plugin must be compiled with theServeMultiplex function call from OpenBao's dbplugin package.  ","version":"Next","tagName":"h3"},{"title":"Upgrading your database plugin to leverage plugin multiplexing​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#upgrading-your-database-plugin-to-leverage-plugin-multiplexing","content":" There is only one step required to upgrade from a non-multiplexed to a multiplexed database plugin: Change the Serve function call to ServeMultiplex.  This will run the RPC server for the plugin just as before. However, theServeMultiplex function takes the factory function directly as its argument. This factory function is a function that returns an object that implements thedbplugin.Database interface.  ","version":"Next","tagName":"h3"},{"title":"When should plugin multiplexing be avoided?​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#when-should-plugin-multiplexing-be-avoided","content":" Some use cases that should avoid plugin multiplexing might include:  Plugin process level separation is requiredAvoiding restart across all mounts/database connections for a plugin type on crashes or plugin reload calls  ","version":"Next","tagName":"h3"},{"title":"Upgrading database plugins to the v5 interface​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#upgrading-database-plugins-to-the-v5-interface","content":" ","version":"Next","tagName":"h2"},{"title":"Background​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#background-1","content":" The new interface was introduced for several reasons:  Password policies required that OpenBao be responsible for generating passwords. In the prior version, the database plugin was responsible for generating passwords. This prevented integration with password policies.Passwords needed to be generated by database plugins. This meant that plugin authors were responsible for generating secure passwords. This should be done with a helper function available within the OpenBao SDK, however there was nothing preventing an author from generating insecure passwords.There were a number of inconsistencies within the version 4 interface that made it confusing for authors. For instance: passwords were handled in 3 different ways.CreateUser generated a password and returned it, SetCredentials receives a password via a configuration struct and returns it, and RotateRootCredentials generated a password and was expected to return an updated copy of its entire configuration with the new password.The SetCredentials and RotateRootCredentials used for static credential rotation, and rotating the root user's credentials respectively were essentially the same operation: change a user's password. The only practical difference was which user it was referring to. This was especially evident when SetCredentials was used when rotating root credentials (unless static credential rotation wasn't supported by the plugin in question).The old interface included both Init and Initialize adding to the confusion.  The new interface is roughly modeled after a gRPC interface. It has improved future compatibility by not requiring changes to the interface definition to add additional data in the requests or responses. It also simplifies the interface by merging several into a single function call.  ","version":"Next","tagName":"h3"},{"title":"Upgrading your custom database​","type":1,"pageTitle":"Custom database secrets engines","url":"/openbao/docs/secrets/databases/custom/#upgrading-your-custom-database","content":" OpenBao supports both version 4 and version 5 database plugins. The support for version 4 plugins will be removed in a future release. To determine if a plugin is using version 4 or version 5, the following is a list of changes in no particular order that you can check against your plugin to determine the version:  The import path for version 4 is github.com/openbao/openbao/sdk/database/dbpluginwhereas the import path for version 5 is github.com/openbao/openbao/sdk/database/dbplugin/v5Version 4 has the following functions: Initialize, Init, CreateUser, RenewUser,RevokeUser, SetCredentials, RotateRootCredentials, Type, and Close. You can see the full function signatures in sdk/database/dbplugin/plugin.go.Version 5 has the following functions: Initialize, NewUser, UpdateUser, DeleteUser,Type, and Close. You can see the full function signatures insdk/database/dbplugin/v5/database.go.  If you are using a version 4 custom database plugin, the following are basic instructions for upgrading to version 5.  info In version 4, password generation was the responsibility of the plugin. This is no longer the case with version 5. OpenBao is responsible for generating passwords and passing them to the plugin via NewUserRequest.Password and UpdateUserRequest.Password.NewPassword.  Change the import path from github.com/openbao/openbao/sdk/database/dbplugin togithub.com/openbao/openbao/sdk/database/dbplugin/v5. The package name is the same, so any references to dbplugin can remain as long as those symbols exist within the new package (such as the Serve function).An easy way to see what functions need to be implemented is to put the following as a global variable within your package: var _ dbplugin.Database = (*MyDatabase)(nil). This will fail to compile if the MyDatabase type does not adhere to the dbplugin.Database interface.Replace Init and Initialize with the new Initialize function definition. The fields thatInit was taking (config and verifyConnection) are now wrapped into InitializeRequest. The returned map[string]interface{} object is now wrapped into InitializeResponse. Only Initialize is needed to adhere to the Database interface.Update CreateUser to NewUser. The NewUserRequest object contains the username and password of the user to be created. It also includes a list of statements for creating the user as well as several other fields that may or may not be applicable. Your custom plugin should use the password provided in the request, not generate one. If you generate a password instead, OpenBao will not know about it and will give the caller the wrong password.SetCredentials, RotateRootCredentials, and RenewUser are combined into UpdateUser. The request object, UpdateUserRequest contains three parts: the username to change, aChangePassword and a ChangeExpiration object. When one of the objects is not nil, this indicates that particular field (password or expiration) needs to change. For instance, if the ChangePassword field is not-nil, the user's password should be changed. This is equivalent to calling SetCredentials. If the ChangeExpiration field is not-nil, the user's expiration date should be changed. This is equivalent to calling RenewUser. Many databases don't need to do anything with the updated expiration.Update RevokeUser to DeleteUser. This is the simplest change. The username to be deleted is enclosed in the DeleteUserRequest object. ","version":"Next","tagName":"h3"},{"title":"Redis database secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/redis/","content":"","keywords":"","version":"Next"},{"title":"Capabilities​","type":1,"pageTitle":"Redis database secrets engine","url":"/openbao/docs/secrets/databases/redis/#capabilities","content":" Plugin Name\tRoot Credential Rotation\tDynamic Roles\tStatic Roles\tUsername Customizationredis-database-plugin\tYes\tYes\tYes\tNo  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Redis database secrets engine","url":"/openbao/docs/secrets/databases/redis/#setup","content":" Enable the database secrets engine if it is not already enabled: $ bao secrets enable database Success! Enabled the database secrets engine at: database/ By default, the secrets engine will enable at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure OpenBao with the proper plugin and connection configuration: $ bao write database/config/my-redis-database \\ plugin_name=&quot;redis-database-plugin&quot; \\ host=&quot;localhost&quot; \\ port=6379 \\ tls=true \\ ca_cert=&quot;$CACERT&quot; \\ username=&quot;user&quot; \\ password=&quot;pass&quot; \\ allowed_roles=&quot;my-*-role&quot; You should consider rotating the admin password. Note that if you do, the new password will never be made available through OpenBao, so you should create an OpenBao-specific database admin user for this. $ bao write -force database/rotate-root/my-redis-database   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Redis database secrets engine","url":"/openbao/docs/secrets/databases/redis/#usage","content":" After the secrets engine is configured, write dynamic and static roles to OpenBao to enable generating credentials.  ","version":"Next","tagName":"h2"},{"title":"Dynamic roles​","type":1,"pageTitle":"Redis database secrets engine","url":"/openbao/docs/secrets/databases/redis/#dynamic-roles","content":" Configure a dynamic role that maps a name in OpenBao to a JSON string containing the Redis ACL rules, which are either documented here or in the output of the ACL CAT Redis command. $ bao write database/roles/my-dynamic-role \\ db_name=&quot;my-redis-database&quot; \\ creation_statements='[&quot;+@admin&quot;]' \\ default_ttl=&quot;5m&quot; \\ max_ttl=&quot;1h&quot; Success! Data written to: database/roles/my-dynamic-role Note that if a creation_statement is not provided the user account will default to a read only user, '[&quot;~*&quot;, &quot;+@read&quot;]' that can read any key. Generate a new set of credentials by reading from the /creds endpoint with the name of the role: $ bao read database/creds/my-dynamic-role Key Value --- ----- lease_id database/creds/my-dynamic-role/OxCTXJcxQ2F4lReWPjbezSnA lease_duration 5m lease_renewable true password dACqHsav6-attdv1glGZ username V_TOKEN_MY-DYNAMIC-ROLE_YASUQUF3GVVD0ZWTEMK4_1608481717   ","version":"Next","tagName":"h3"},{"title":"Static roles​","type":1,"pageTitle":"Redis database secrets engine","url":"/openbao/docs/secrets/databases/redis/#static-roles","content":" Configure a static role that maps a name in OpenBao to an existing Redis user. $ bao write database/static-roles/my-static-role \\ db_name=&quot;my-redis-database&quot; \\ username=&quot;my-existing-redis-user&quot; \\ rotation_period=5m Success! Data written to: database/static-roles/my-static-role Retrieve the credentials from the /static-creds endpoint: $ bao read database/static-creds/my-static-role Key Value --- ----- last_vault_rotation 2020-12-20T10:39:49.647822-06:00 password ylKNgqa3NPVAioBf-0S5 rotation_period 5m ttl 4m39s username my-existing-redis-user   ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"Redis database secrets engine","url":"/openbao/docs/secrets/databases/redis/#api","content":" The full list of configurable options can be seen in the Redis Database Plugin API page.  For more information on the database secrets engine's HTTP API please see the Database Secrets Engine API page. ","version":"Next","tagName":"h2"},{"title":"MySQL/MariaDB database secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/databases/mysql-maria/","content":"","keywords":"","version":"Next"},{"title":"Capabilities​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#capabilities","content":" Plugin Name\tRoot Credential Rotation\tDynamic Roles\tStatic Roles\tUsername CustomizationDepends (see: above)\tYes\tYes\tYes\tYes (1.7+)  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#setup","content":" Enable the database secrets engine if it is not already enabled: $ bao secrets enable database Success! Enabled the database secrets engine at: database/ By default, the secrets engine will enable at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure OpenBao with the proper plugin and connection information: $ bao write database/config/my-mysql-database \\ plugin_name=mysql-database-plugin \\ connection_url=&quot;{{username}}:{{password}}@tcp(127.0.0.1:3306)/&quot; \\ allowed_roles=&quot;my-role&quot; \\ username=&quot;openbaouser&quot; \\ password=&quot;openbaopass&quot; Configure a role that maps a name in OpenBao to an SQL statement to execute to create the database credential: $ bao write database/roles/my-role \\ db_name=my-mysql-database \\ creation_statements=&quot;CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT ON *.* TO '{{name}}'@'%';&quot; \\ default_ttl=&quot;1h&quot; \\ max_ttl=&quot;24h&quot; Success! Data written to: database/roles/my-role   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by reading from the /creds endpoint with the name of the role: $ bao read database/creds/my-role Key Value --- ----- lease_id database/creds/my-role/2f6a614c-4aa2-7b19-24b9-ad944a8d4de6 lease_duration 1h lease_renewable true password yY-57n3X5UQhxnmFRP3f username v_openbaouser_my-role_crBWVqVh2Hc1   ","version":"Next","tagName":"h2"},{"title":"Client x509 certificate authentication​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#client-x509-certificate-authentication","content":" This plugin supports using MySQL's x509 Client-side Certificate Authentication  To use this authentication mechanism, configure the plugin:  $ bao write database/config/my-mysql-database \\ plugin_name=mysql-database-plugin \\ allowed_roles=&quot;my-role&quot; \\ connection_url=&quot;user:password@tcp(localhost:3306)/test&quot; \\ tls_certificate_key=@/path/to/client.pem \\ tls_ca=@/path/to/client.ca   Note: tls_certificate_key and tls_ca map to ssl-cert (combined with ssl-key)and ssl-ca configuration options from MySQL with the exception that the OpenBao parameters are the contents of those files, not filenames. As such, the two options are independent of each other. See the MySQL Connection Optionsfor more information.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#examples","content":" ","version":"Next","tagName":"h2"},{"title":"Using wildcards in grant statements​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#using-wildcards-in-grant-statements","content":" MySQL supports using wildcards in grant statements. These are sometimes needed by applications which expect access to a large number of databases inside MySQL. This can be realized by using a wildcard in the grant statement. For example if you want the user created by OpenBao to have access to all databases starting withfooapp_ you could use the following creation statement:  CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}'; GRANT SELECT ON `fooapp\\_%`.* TO '{{name}}'@'%';   MySQL expects the part in which the wildcards are to be placed inside backticks. If you want to add this creation statement to OpenBao via the OpenBao CLI you cannot simply paste the above statement on the CLI because the shell will interpret the text between the backticks as something that must be executed. The easiest way to get around this is to encode the creation statement as Base64 and feed this to OpenBao. For example:  $ bao write database/roles/my-role \\ db_name=mysql \\ creation_statements=&quot;Q1JFQVRFIFVTRVIgJ3t7bmFtZX19J0AnJScgSURFTlRJRklFRCBCWSAne3twYXNzd29yZH19JzsgR1JBTlQgU0VMRUNUIE9OIGBmb29hcHBcXyVgLiogVE8gJ3t7bmFtZX19J0AnJSc7&quot; \\ default_ttl=&quot;1h&quot; \\ max_ttl=&quot;24h&quot;   ","version":"Next","tagName":"h3"},{"title":"Rotating root credentials in MySQL 5.6​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#rotating-root-credentials-in-mysql-56","content":" The default root rotation setup for MySQL uses the ALTER USER syntax present in MySQL 5.7 and up. For MySQL 5.6, the root rotation statementsmust be configured to use the old SET PASSWORD syntax. For example:  $ bao write database/config/my-mysql-database \\ plugin_name=mysql-database-plugin \\ connection_url=&quot;{{username}}:{{password}}@tcp(127.0.0.1:3306)/&quot; \\ root_rotation_statements=&quot;SET PASSWORD = PASSWORD('{{password}}')&quot; \\ allowed_roles=&quot;my-role&quot; \\ username=&quot;root&quot; \\ password=&quot;mysql&quot;   For a guide in root credential rotation, see Database Root Credential Rotation.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"MySQL/MariaDB database secrets engine","url":"/openbao/docs/secrets/databases/mysql-maria/#api","content":" The full list of configurable options can be seen in the MySQL database plugin API page.  For more information on the database secrets engine's HTTP API please see theDatabase secrets engine API page. ","version":"Next","tagName":"h2"},{"title":"Identity secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/identity/","content":"","keywords":"","version":"Next"},{"title":"API​","type":1,"pageTitle":"Identity secrets engine","url":"/openbao/docs/secrets/identity/#api","content":" The Identity secrets engine has a full HTTP API. Please see theIdentity secrets engine API for more details.  Additionally, OpenBao can be configured as an OIDC identity provider. Please see the OIDC identity provider API for more details. ","version":"Next","tagName":"h2"},{"title":"Identity tokens","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/identity/identity-token/","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#introduction","content":" Identity information is used throughout OpenBao, but it can also be exported for use by other applications. An authorized user/application can request a token that encapsulates identity information for their associated entity. These tokens are signed JWTs following the OIDC ID token structure. The public keys used to authenticate the tokens are published by OpenBao on an unauthenticated endpoint following OIDC discovery and JWKS conventions, which should be directly usable by JWT/OIDC libraries. An introspection endpoint is also provided by OpenBao for token verification.  ","version":"Next","tagName":"h2"},{"title":"Roles and keys​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#roles-and-keys","content":" OIDC-compliant ID tokens are generated against a role which allows configuration of token claims via a templating system, token ttl, and a way to specify which &quot;key&quot; will be used to sign the token. The role template is an optional parameter to customize the token contents and is described in the next section. Token TTL controls the expiration time of the token, after which verification libraries will consider the token invalid. All roles have an associated client_id that will be added to the token's aud parameter. JWT/OIDC libraries will usually require this value. The parameter may be set by the operator to a chosen value, or a OpenBao-generated value will be used if left unconfigured.  A role's key parameter links a role to an existing named key (multiple roles may refer to the same key). It is not possible to generate an unsigned ID token.  A named key is a public/private key pair generated by OpenBao. The private key is used to sign the identity tokens, and the public key is used by clients to verify the signature. Keys are regularly rotated, whereby a new key pair is generated and the previous public key is retained for a limited time for verification purposes.  A named key's configuration specifies a rotation period, a verification ttl, signing algorithm and allowed client IDs. Rotation period specifies the frequency at which a new signing key is generated and the private portion of the previous signing key is deleted. Verification ttl is the time a public key is retained for verification after being rotated. By default, keys are rotated every 24 hours, and continue to be available for verification for 24 hours after their rotation.  A key's list of allowed client IDs limits which roles may reference the key. The parameter may be set to * to allow all roles. The validity evaluation is made when a token is requested, not during configuration.  ","version":"Next","tagName":"h3"},{"title":"Token contents and templates​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#token-contents-and-templates","content":" Identity tokens will always contain, at a minimum, the claims required by OIDC:  iss - Issuer URLsub - Requester's entity IDaud - client_id for the roleiat - Time of issueexp - Expiration time for the token  In addition, the operator may configure per-role templates that allow a variety of other entity information to be added to the token. The templates are structured as JSON with replaceable parameters. The parameter syntax is the same as that used for ACL Path Templating.  For example:  { &quot;color&quot;: {{identity.entity.metadata.color}}, &quot;userinfo&quot;: { &quot;username&quot;: {{identity.entity.aliases.usermap_123.metadata.username}}, &quot;groups&quot;: {{identity.entity.groups.names}} }, &quot;nbf&quot;: {{time.now}} }   When a token is requested, the resulting template might be populated as:  { &quot;color&quot;: &quot;green&quot;, &quot;userinfo&quot;: { &quot;username&quot;: &quot;bob&quot;, &quot;groups&quot;: [&quot;web&quot;, &quot;engr&quot;, &quot;default&quot;] }, &quot;nbf&quot;: 1561411915 }   which would be merged with the base OIDC claims into the final token:  { &quot;iss&quot;: &quot;https://10.1.1.45:8200/v1/identity/oidc&quot;, &quot;sub&quot;: &quot;a2cd63d3-5364-406f-980e-8d71bb0692f5&quot;, &quot;aud&quot;: &quot;SxSouteCYPBoaTFy94hFghmekos&quot;, &quot;iat&quot;: 1561411915, &quot;exp&quot;: 1561412215, &quot;color&quot;: &quot;green&quot;, &quot;userinfo&quot;: { &quot;username&quot;: &quot;bob&quot;, &quot;groups&quot;: [&quot;web&quot;, &quot;engr&quot;, &quot;default&quot;] }, &quot;nbf&quot;: 1561411915 }   Note how the template is merged, with top level template keys becoming top level token keys. For this reason, templates may not contain top level keys that overwrite the standard OIDC claims.  Template parameters that are not present for an entity, such as a metadata that isn't present, or an alias accessor which doesn't exist, are simply empty strings or objects, depending on the data type.  Templates are configured on the role and may be optionally encoded as base64.  The full list of template parameters is shown below:  Name\tDescriptionidentity.entity.id\tThe entity's ID identity.entity.name\tThe entity's name identity.entity.groups.ids\tThe IDs of the groups the entity is a member of identity.entity.groups.names\tThe names of the groups the entity is a member of identity.entity.metadata\tMetadata associated with the entity identity.entity.metadata.&lt;metadata key&gt;\tMetadata associated with the entity for the given key identity.entity.aliases.&lt;mount accessor&gt;.id\tEntity alias ID for the given mount identity.entity.aliases.&lt;mount accessor&gt;.name\tEntity alias name for the given mount identity.entity.aliases.&lt;mount accessor&gt;.metadata\tMetadata associated with the alias for the given mount identity.entity.aliases.&lt;mount accessor&gt;.metadata.&lt;metadata key&gt;\tMetadata associated with the alias for the given mount and metadata key identity.entity.aliases.&lt;mount accessor&gt;.custom_metadata\tCustom metadata associated with the alias for the given mount identity.entity.aliases.&lt;mount accessor&gt;.custom_metadata.&lt;custom_metadata key&gt;\tCustom metadata associated with the alias for the given mount and custom metadata key time.now\tCurrent time as integral seconds since the Epoch time.now.plus.&lt;duration&gt;\tCurrent time plus a duration format string time.now.minus.&lt;duration&gt;\tCurrent time minus a duration format string  ","version":"Next","tagName":"h3"},{"title":"Token generation​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#token-generation","content":" An authenticated client may request a token using the token generation endpoint. The token will be generated per the requested role's specifications, for the requester's entity. It is not possible to generate tokens for an arbitrary entity.  ","version":"Next","tagName":"h3"},{"title":"Verifying authenticity of ID tokens generated by OpenBao​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#verifying-authenticity-of-id-tokens-generated-by-openbao","content":" An identity token may be verified by the client party using the public keys published by OpenBao, or via an OpenBao-provided introspection endpoint.  OpenBao will serve standard &quot;.well-known&quot; endpoints that allow easy integration with OIDC verification libraries. Configuring the libraries will typically involve providing an issuer URL and client ID. The library will then handle key requests and can validate the signature and claims requirements on tokens. This approach has the advantage of only requiring access to OpenBao, not authorization, as the .well-known endpoints are unauthenticated.  Alternatively, the token may be sent to OpenBao for verification via anintrospection endpoint. The response will indicate whether the token is &quot;active&quot; or not, as well as any errors that occurred during validation. Beyond simply allowing the client to delegate verification to OpenBao, using this endpoint incorporates the additional check of whether the entity is still active or not, which is something that cannot be determined from the token alone. Unlike the .well-known endpoint, accessing the introspection endpoint does require a valid OpenBao token and sufficient authorization.  ","version":"Next","tagName":"h3"},{"title":"Issuer considerations​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#issuer-considerations","content":" The identity token system has one configurable parameter: issuer. The issueriss claim is particularly important for proper validation of the token by clients. Consumers of the token will request public keys from OpenBao using the issuer URL, so it must be network reachable. Furthermore, the returned set of keys will include an issuer that must match the request.  By default OpenBao will set the issuer to the OpenBao instance'sapi_addr. This means that tokens issued in a given cluster should be validated within that same cluster. Alternatively, the issuer parameter may be configured explicitly. This address must point to the identity/oidc path for the OpenBao instance (e.g.https://openbao-1.example.com:8200/v1/identity/oidc) and should be reachable by any client trying to validate identity tokens.  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"Identity tokens","url":"/openbao/docs/secrets/identity/identity-token/#api","content":" The Identity secrets engine has a full HTTP API. Please see theIdentity secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"OIDC identity provider","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/identity/oidc-provider/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"OIDC identity provider","url":"/openbao/docs/secrets/identity/oidc-provider/#setup","content":" The OpenBao OIDC provider system is built on top of the identity secrets engine. This secrets engine is mounted by default and cannot be disabled or moved.  Each OpenBao namespace has a default OIDC providerand key. This built-in configuration enables client applications to begin using OpenBao as a source of identity with minimal configuration. For details on the built-in configuration and advanced options, see the OIDC providerconcepts page.  The following steps show a minimal configuration that allows a client application to use OpenBao as an OIDC provider.  Enable an OpenBao auth method: $ bao auth enable userpass Success! Enabled userpass auth method at: userpass/   Any OpenBao auth method may be used within the OIDC flow. For simplicity, enable theuserpass auth method.  Create a user: $ bao write auth/userpass/users/end-user password=&quot;securepassword&quot; Success! Data written to: auth/userpass/users/end-user This user will authenticate to OpenBao through a client application, otherwise known as an OIDC relying party. Create a client application: $ bao write identity/oidc/client/my-webapp \\ redirect_uris=&quot;https://localhost:9702/auth/oidc-callback&quot; \\ assignments=&quot;allow_all&quot; Success! Data written to: identity/oidc/client/my-webapp This operation creates a client application which can be used to configure an OIDC relying party. See the client applicationssection for details on different client types, including confidential and public clients. The assignments parameter limits the OpenBao entities and groups that are allowed to authenticate through the client application. By default, no OpenBao entities are allowed. To allow all OpenBao entities to authenticate, the built-in allow_allassignment is provided. Read client credentials: $ bao read identity/oidc/client/my-webapp Key Value --- ----- access_token_ttl 24h assignments [allow_all] client_id GSDTnn3KaOrLpNlVGlYLS9TVsZgOTweO client_secret hvo_secret_gBKHcTP58C4aq7FqPWsuqKgpiiegd7ahpifGae9WGkHRCwFEJTZA9KGdNVpzE0r8 client_type confidential id_token_ttl 24h key default redirect_uris [https://localhost:9702/auth/oidc-callback] The client_id and client_secret are the client application's credentials. These values are typically required when configuring an OIDC relying party. Read OIDC discovery configuration: $ curl -s http://127.0.0.1:8200/v1/identity/oidc/provider/default/.well-known/openid-configuration { &quot;issuer&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/default&quot;, &quot;jwks_uri&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/default/.well-known/keys&quot;, &quot;authorization_endpoint&quot;: &quot;http://127.0.0.1:8200/ui/vault/identity/oidc/provider/default/authorize&quot;, &quot;token_endpoint&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/default/token&quot;, &quot;userinfo_endpoint&quot;: &quot;http://127.0.0.1:8200/v1/identity/oidc/provider/default/userinfo&quot;, &quot;request_parameter_supported&quot;: false, &quot;request_uri_parameter_supported&quot;: false, &quot;id_token_signing_alg_values_supported&quot;: [ &quot;RS256&quot;, &quot;RS384&quot;, &quot;RS512&quot;, &quot;ES256&quot;, &quot;ES384&quot;, &quot;ES512&quot;, &quot;EdDSA&quot; ], &quot;response_types_supported&quot;: [ &quot;code&quot; ], &quot;scopes_supported&quot;: [ &quot;openid&quot; ], &quot;subject_types_supported&quot;: [ &quot;public&quot; ], &quot;grant_types_supported&quot;: [ &quot;authorization_code&quot; ], &quot;token_endpoint_auth_methods_supported&quot;: [ &quot;none&quot;, &quot;client_secret_basic&quot;, &quot;client_secret_post&quot; ] } Each OpenBao OIDC provider publishes discovery metadata. The issuer value is typically required when configuring an OIDC relying party.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"OIDC identity provider","url":"/openbao/docs/secrets/identity/oidc-provider/#usage","content":" After configuring an OpenBao auth method and client application, the following details can be used to configure an OIDC relying party to delegate end-user authentication to OpenBao.  client_id - The ID of the client applicationclient_secret - The secret of the client applicationissuer - The issuer of the OpenBao OIDC provider  A number of HashiCorp products provide OIDC authentication methods. This means that they can leverage OpenBao as a source of identity using the OIDC protocol. See the following links for details on configuring OIDC authentication for other HashiCorp products:  BoundaryConsulWaypointNomad  Otherwise, refer to the documentation of the specific OIDC relying party for usage details.  ","version":"Next","tagName":"h2"},{"title":"Supported flows​","type":1,"pageTitle":"OIDC identity provider","url":"/openbao/docs/secrets/identity/oidc-provider/#supported-flows","content":" The OpenBao OIDC provider feature currently supports the following authentication flow:  Authorization Code Flow.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"OIDC identity provider","url":"/openbao/docs/secrets/identity/oidc-provider/#tutorial","content":" Refer to the OpenBao as an OIDC Identity Providertutorial to learn how to configure a HashiCorp Boundaryto leverage OpenBao as a source of identity using the OIDC protocol.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"OIDC identity provider","url":"/openbao/docs/secrets/identity/oidc-provider/#api","content":" The OpenBao OIDC provider feature has a full HTTP API. Please see theOIDC identity provider API for more details. ","version":"Next","tagName":"h2"},{"title":"KV secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/kv/","content":"","keywords":"","version":"Next"},{"title":"KV version 1​","type":1,"pageTitle":"KV secrets engine","url":"/openbao/docs/secrets/kv/#kv-version-1","content":" When running the kv secrets backend non-versioned, only the most recently written value for a key will be preserved. The benefits of non-versioned kvis a reduced storage size for each key since no additional metadata or history is stored. Additionally, requests going to a backend configured this way will be more performant because for any given request there will be fewer storage calls and no locking.  More information about running in this mode can be found in the K/V Version 1 Docs  ","version":"Next","tagName":"h2"},{"title":"KV version 2​","type":1,"pageTitle":"KV secrets engine","url":"/openbao/docs/secrets/kv/#kv-version-2","content":" When running v2 of the kv backend a key can retain a configurable number of versions. This defaults to 10 versions. The older versions' metadata and data can be retrieved. Additionally, Check-and-Set operations can be used to avoid overwriting data unintentionally.  When a version is deleted the underlying data is not removed, rather it is marked as deleted. Deleted versions can be undeleted. To permanently remove a version's data the destroy command or API endpoint can be used. Additionally all versions and metadata for a key can be deleted by deleting on the metadata command or API endpoint. Each of these operations can be ACL'ed differently, restricting who has permissions to soft delete, undelete, or fully remove data.  More information about running in this mode can be found in the K/V Version 2 Docs ","version":"Next","tagName":"h2"},{"title":"KV secrets engine - version 1","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/kv/kv-v1/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"KV secrets engine - version 1","url":"/openbao/docs/secrets/kv/kv-v1/#setup","content":" To enable a version 1 kv store:  $ bao secrets enable -version=1 kv   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"KV secrets engine - version 1","url":"/openbao/docs/secrets/kv/kv-v1/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials. The kv secrets engine allows for writing keys with arbitrary values.  Write arbitrary data: $ bao kv put kv/my-secret my-value=s3cr3t Success! Data written to: kv/my-secret Read arbitrary data: $ bao kv get kv/my-secret Key Value --- ----- my-value s3cr3t List the keys: $ bao kv list kv/ Keys ---- my-secret Delete a key: $ bao kv delete kv/my-secret Success! Data deleted (if it existed) at: kv/my-secret   You can also use OpenBao's password policy feature to generate arbitrary values.  Write a password policy: $ bao write sys/policies/password/example policy=-&lt;&lt;EOF length=20 rule &quot;charset&quot; { charset = &quot;abcdefghij0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;!@#$%^&amp;*STUVWXYZ&quot; min-chars = 1 } EOF Write data using the example policy: $ bao kv put kv/my-generated-secret \\ password=$(bao read -field password sys/policies/password/example/generate) Read the generated data: $ bao kv get kv/my-generated-secret ====== Data ====== Key Value --- ----- password ^dajd609Xf8Zhac$dW24   ","version":"Next","tagName":"h2"},{"title":"TTLs​","type":1,"pageTitle":"KV secrets engine - version 1","url":"/openbao/docs/secrets/kv/kv-v1/#ttls","content":" Unlike other secrets engines, the KV secrets engine does not enforce TTLs for expiration. Instead, the lease_duration is a hint for how often consumers should check back for a new value.  If provided a key of ttl, the KV secrets engine will utilize this value as the lease duration:  $ bao kv put kv/my-secret ttl=30m my-value=s3cr3t Success! Data written to: kv/my-secret   Even with a ttl set, the secrets engine never removes data on its own. Thettl key is merely advisory.  When reading a value with a ttl, both the ttl key and the refresh interval will reflect the value:  $ bao kv get kv/my-secret Key Value --- ----- my-value s3cr3t ttl 30m   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"KV secrets engine - version 1","url":"/openbao/docs/secrets/kv/kv-v1/#tutorial","content":" Refer to the Static Secrets: Key/Value Secrets Enginetutorial to learn how to set up a uniform workflow to securely store sensitive information.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"KV secrets engine - version 1","url":"/openbao/docs/secrets/kv/kv-v1/#api","content":" The KV secrets engine has a full HTTP API. Please see theKV secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"PKI secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/","content":"","keywords":"","version":"Next"},{"title":"Table of contents​","type":1,"pageTitle":"PKI secrets engine","url":"/openbao/docs/secrets/pki/#table-of-contents","content":" The PKI Secrets Engine documentation is split into the following pieces:  Overview - this document.Setup and Usage - a brief description of setting up and using the PKI Secrets Engine to issue certificates.Quick Start - Root CA Setup - A quick start guide for setting up a root CA.Quick Start - Intermediate CA Setup - A quick start guide for setting up an intermediate CA.Considerations - A list of helpful considerations to keep in mind when using and operating the PKI Secrets Engine.Troubleshooting ACME - A list of advice for troubleshooting failures with ACME issuance and OpenBao PKI.Rotation Primitives - A document which explains different types of certificates used to achieve rotation.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"PKI secrets engine","url":"/openbao/docs/secrets/pki/#tutorial","content":" Refer to the following tutorials for PKI secrets engine usage examples:  Build Your Own Certificate Authority (CA)Build Certificate Authority (CA) in Vault with an offline RootEnable ACME with PKI secrets enginePKI Unified CRL and OCSP With Cross Cluster RevocationConfigure OpenBao as a Certificate Manager in Kubernetes with HelmGenerate mTLS Certificates for Nomad using OpenBao  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PKI secrets engine","url":"/openbao/docs/secrets/pki/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"LDAP secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/ldap/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#setup","content":" Enable the LDAP secret engine: $ bao secrets enable ldap By default, the secrets engine will mount at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure the credentials that OpenBao uses to communicate with LDAP to generate passwords: $ bao write ldap/config \\ binddn=$USERNAME \\ bindpass=$PASSWORD \\ url=ldaps://138.91.247.105 Note: it's recommended a dedicated entry management account be created specifically for OpenBao. Rotate the root password so only OpenBao knows the credentials: $ bao write -f ldap/rotate-root Note: it's not possible to retrieve the generated password once rotated by OpenBao. It's recommended a dedicated entry management account be created specifically for OpenBao.  ","version":"Next","tagName":"h2"},{"title":"Schemas​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#schemas","content":" The LDAP Secret Engine supports three different schemas:  openldap (default)racfad  OpenLDAP​  By default, the LDAP Secret Engine assumes the entry password is stored in userPassword. There are many object classes that provide userPassword including for example:  organizationorganizationalUnitorganizationalRoleinetOrgPersonpersonposixAccount  Resource access control facility (RACF)​  For managing IBM's Resource Access Control Facility (RACF) security system, the secret engine must be configured to use the schema racf.  Generated passwords must be 8 characters or less to support RACF. The length of the password can be configured using a password policy:  $ bao write ldap/config \\ binddn=$USERNAME \\ bindpass=$PASSWORD \\ url=ldaps://138.91.247.105 \\ schema=racf \\ password_policy=racf_password_policy   Active directory (AD)​  For managing Active Directory instances, the secret engine must be configured to use the schema ad.  $ bao write ldap/config \\ binddn=$USERNAME \\ bindpass=$PASSWORD \\ url=ldaps://138.91.247.105 \\ schema=ad   ","version":"Next","tagName":"h3"},{"title":"Static credentials​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#static-credentials","content":" ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#setup-1","content":" Configure a static role that maps a name in OpenBao to an entry in LDAP. Password rotation settings will be managed by this role. $ bao write ldap/static-role/lf-edge\\ dn='uid=lf-edge,ou=users,dc=lf-edge,dc=com' \\ username='openbao'\\ rotation_period=&quot;24h&quot; Request credentials for the &quot;openbao&quot; role: $ bao read ldap/static-cred/lf-edge   ","version":"Next","tagName":"h3"},{"title":"Password rotation​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#password-rotation","content":" Passwords can be managed in two ways:  automatic time based rotationmanual rotation  ","version":"Next","tagName":"h3"},{"title":"Auto password rotation​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#auto-password-rotation","content":" Passwords will automatically be rotated based on the rotation_period configured in the static role (minimum of 5 seconds). When requesting credentials for a static role, the response will include the time before the next rotation (ttl).  Auto-rotation is currently only supported for static roles. The binddn account used by OpenBao should be rotated using the rotate-root endpoint to generate a password only OpenBao will know.  ","version":"Next","tagName":"h3"},{"title":"Manual rotation​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#manual-rotation","content":" Static roles can be manually rotated using the rotate-role endpoint. When manually rotated the rotation period will start over.  ","version":"Next","tagName":"h3"},{"title":"Deleting static roles​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#deleting-static-roles","content":" Passwords are not rotated upon deletion of a static role. The password should be manually rotated prior to deleting the role or revoking access to the static role.  ","version":"Next","tagName":"h3"},{"title":"Dynamic credentials​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#dynamic-credentials","content":" ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#setup-2","content":" Dynamic credentials can be configured by calling the /role/:role_name endpoint:  $ bao write ldap/role/dynamic-role \\ creation_ldif=@/path/to/creation.ldif \\ deletion_ldif=@/path/to/deletion.ldif \\ rollback_ldif=@/path/to/rollback.ldif \\ default_ttl=1h \\ max_ttl=24h   info Note: The rollback_ldif argument is optional, but recommended. The statements within rollback_ldif will be executed if the creation fails for any reason. This ensures any entities are removed in the event of a failure.  To generate credentials:  $ bao read ldap/creds/dynamic-role Key Value --- ----- lease_id ldap/creds/dynamic-role/HFgd6uKaDomVMvJpYbn9q4q5 lease_duration 1h lease_renewable true distinguished_names [cn=v_token_dynamic-role_FfH2i1c4dO_1611952635,ou=users,dc=learn,dc=example] password xWMjkIFMerYttEbzfnBVZvhRQGmhpAA0yeTya8fdmDB3LXDzGrjNEPV2bCPE9CW6 username v_token_testrole_FfH2i1c4dO_1611952635   The distinguished_names field is an array of DNs that are created from the creation_ldif statements. If more than one LDIF entry is included, the DN from each statement will be included in this field. Each entry in this field corresponds to a single LDIF statement. No de-duplication occurs and order is maintained.  ","version":"Next","tagName":"h3"},{"title":"LDIF entries​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#ldif-entries","content":" User account management is provided through LDIF entries. The LDIF entries may be a base64-encoded version of the LDIF string. The string will be parsed and validated to ensure that it adheres to LDIF syntax. A good reference for proper LDIF syntax can be found here.  Some important things to remember when crafting your LDIF entries:  There should not be any trailing spaces on any line, including empty linesEach modify block needs to be preceded with an empty lineMultiple modifications for a dn can be defined in a single modify block. Each modification needs to close with a single dash (-)  ","version":"Next","tagName":"h3"},{"title":"Active directory (AD)​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#active-directory-ad-1","content":" For Active Directory, there are a few additional details that are important to remember:  To create a user programmatically in AD, you first add a user object and then modify that user to provide a password and enable the account.  Passwords in AD are set using the unicodePwd field. This must be proceeded by two (2) colons (::). When setting a password programmatically in AD, the following criteria must be met: The password must be enclosed in double quotes (&quot; &quot;)The password must be in UTF16LE formatThe password must be base64-encodedAdditional details can be found here Once a user's password has been set, it can be enabled. AD uses the userAccountControl field for this purpose: To enable the account, set userAccountControl to 512You will likely also want to disable AD's password expiration for this dynamic user account. TheuserAccountControl value for this is: 65536userAccountControl flags are cumulative, so to set both of the above two flags, add up the two values (512 + 65536 = 66048): set userAccountControl to 66048See herefor details on userAccountControl flags  sAMAccountName is a common field when working with AD users. It is used to provide compatibility with legacy Windows NT systems and has a limit of 20 characters. Keep this in mind when defining your username_template. See here for additional details.  Since the default username_template is longer than 20 characters which follows the template of v_{{.DisplayName}}_{{.RoleName}}_{{random 10}}_{{unix_time}}, we recommend customising the username_template on the role configuration to generate accounts with names less than 20 characters. Please refer to the username templating document for more information.  With regard to adding dynamic users to groups, AD doesn't let you directly modify a user's memberOf attribute. The member attribute of a group and memberOf attribute of a user arelinked attributes. Linked attributes are forward link/back link pairs, with the forward link able to be modified. In the case of AD group membership, the group's member attribute is the forward link. In order to add a newly-created dynamic user to a group, we also need to issue a modify request to the desired group and update the group membership with the new user.  Active directory LDIF example​  The various *_ldif parameters are templates that use the go templatelanguage. A complete LDIF example for creating an Active Directory user account is provided here for reference:  dn: CN={{.Username}},OU=OpenBao,DC=adtesting,DC=lab changetype: add objectClass: top objectClass: person objectClass: organizationalPerson objectClass: user userPrincipalName: {{.Username}}@adtesting.lab sAMAccountName: {{.Username}} dn: CN={{.Username}},OU=OpenBao,DC=adtesting,DC=lab changetype: modify replace: unicodePwd unicodePwd::{{ printf &quot;%q&quot; .Password | utf16le | base64 }} - replace: userAccountControl userAccountControl: 66048 - dn: CN=test-group,OU=OpenBao,DC=adtesting,DC=lab changetype: modify add: member member: CN={{.Username}},OU=OpenBao,DC=adtesting,DC=lab -   ","version":"Next","tagName":"h3"},{"title":"Service account Check-Out​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#service-account-check-out","content":" Service account check-out provides a library of service accounts that can be checked out by a person or by machines. OpenBao will automatically rotate the password each time a service account is checked in. Service accounts can be voluntarily checked in, or OpenBao will check them in when their lending period (or, &quot;ttl&quot;, in OpenBao's language) ends.  The service account check-out functionality works with various schemas, including OpenLDAP, Active Directory, and RACF. In the following usage example, the secrets engine is configured to manage a library of service accounts in an Active Directory instance.  First we'll need to enable the LDAP secrets engine and tell it how to securely connect to an AD server.  $ bao secrets enable ldap Success! Enabled the ad secrets engine at: ldap/ $ bao write ldap/config \\ binddn=$USERNAME \\ bindpass=$PASSWORD \\ url=ldaps://138.91.247.105 \\ userdn='dc=example,dc=com'   Our next step is to designate a set of service accounts for check-out.  $ bao write ldap/library/accounting-team \\ service_account_names=fizz@example.com,buzz@example.com \\ ttl=10h \\ max_ttl=20h \\ disable_check_in_enforcement=false   In this example, the service account names of fizz@example.com and buzz@example.com have already been created on the remote AD server. They've been set aside solely for OpenBao to handle. The ttl is how long each check-out will last before OpenBao checks in a service account, rotating its password during check-in. The max_ttl is the maximum amount of time it can live if it's renewed. These default to 24h, and both use duration format strings. Also by default, a service account must be checked in by the same OpenBao entity or client token that checked it out. However, if this behavior causes problems, set disable_check_in_enforcement=true.  When a library of service accounts has been created, view their status at any time to see if they're available or checked out.  $ bao read ldap/library/accounting-team/status Key Value --- ----- buzz@example.com map[available:true] fizz@example.com map[available:true]   To check out any service account that's available, simply execute:  $ bao write -f ldap/library/accounting-team/check-out Key Value --- ----- lease_id ldap/library/accounting-team/check-out/EpuS8cX7uEsDzOwW9kkKOyGW lease_duration 10h lease_renewable true password ?@09AZKh03hBORZPJcTDgLfntlHqxLy29tcQjPVThzuwWAx/Twx4a2ZcRQRqrZ1w service_account_name fizz@example.com   If the default ttl for the check-out is higher than needed, set the check-out to last for a shorter time by using:  $ bao write ldap/library/accounting-team/check-out ttl=30m Key Value --- ----- lease_id ldap/library/accounting-team/check-out/gMonJ2jB6kYs6d3Vw37WFDCY lease_duration 30m lease_renewable true password ?@09AZerLLuJfEMbRqP+3yfQYDSq6laP48TCJRBJaJu/kDKLsq9WxL9szVAvL/E1 service_account_name buzz@example.com   This can be a nice way to say, &quot;Although I can have a check-out for 24 hours, if I haven't checked it in after 30 minutes, I forgot or I'm a dead instance, so you can just check it back in.&quot;  If no service accounts are available for check-out, OpenBao will return a 400 Bad Request.  $ bao write -f ldap/library/accounting-team/check-out Error writing data to ldap/library/accounting-team/check-out: Error making API request. URL: POST http://localhost:8200/v1/ldap/library/accounting-team/check-out Code: 400. Errors: * No service accounts available for check-out.   To extend a check-out, renew its lease.  $ bao lease renew ldap/library/accounting-team/check-out/0C2wmeaDmsToVFc0zDiX9cMq Key Value --- ----- lease_id ldap/library/accounting-team/check-out/0C2wmeaDmsToVFc0zDiX9cMq lease_duration 10h lease_renewable true   Renewing a check-out means its current password will live longer, since passwords are rotated anytime a password is checked in either by a caller, or by OpenBao because the check-out ttlends.  To check a service account back in for others to use, call:  $ bao write -f ldap/library/accounting-team/check-in Key Value --- ----- check_ins [fizz@example.com]   Most of the time this will just work, but if multiple service accounts are checked out by the same caller, OpenBao will need to know which one(s) to check in.  $ bao write ldap/library/accounting-team/check-in service_account_names=fizz@example.com Key Value --- ----- check_ins [fizz@example.com]   To perform a check-in, OpenBao verifies that the caller should be able to check in a given service account. To do this, OpenBao looks for either the same entity IDused to check out the service account, or the same client token.  If a caller is unable to check in a service account, or simply doesn't try, OpenBao will check it back in automatically when the ttl expires. However, if that is too long, service accounts can be forcibly checked in by a highly privileged user through:  $ bao write -f ldap/library/manage/accounting-team/check-in Key Value --- ----- check_ins [fizz@example.com]   Or, alternatively, revoking the secret's lease has the same effect.  $ bao lease revoke ldap/library/accounting-team/check-out/PvBVG0m7pEg2940Cb3Jw3KpJ All revocation operations queued successfully!   ","version":"Next","tagName":"h2"},{"title":"LDAP password policy​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#ldap-password-policy","content":" The LDAP secret engine does not hash or encrypt passwords prior to modifying values in LDAP. This behavior can cause plaintext passwords to be stored in LDAP.  To avoid having plaintext passwords stored, the LDAP server should be configured with an LDAP password policy (ppolicy, not to be confused with an OpenBao password policy). A ppolicy can enforce rules such as hashing plaintext passwords by default.  The following is an example of an LDAP password policy to enforce hashing on the data information tree (DIT) dc=openbao,dc=com:  dn: cn=module{0},cn=config changetype: modify add: olcModuleLoad olcModuleLoad: ppolicy dn: olcOverlay={2}ppolicy,olcDatabase={1}mdb,cn=config changetype: add objectClass: olcPPolicyConfig objectClass: olcOverlayConfig olcOverlay: {2}ppolicy olcPPolicyDefault: cn=default,ou=pwpolicies,dc=openbao,dc=com olcPPolicyForwardUpdates: FALSE olcPPolicyHashCleartext: TRUE olcPPolicyUseLockout: TRUE   ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#tutorial","content":" Refer to the LDAP Secrets Enginetutorial to learn how to configure and use the LDAP secrets engine.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"LDAP secrets engine","url":"/openbao/docs/secrets/ldap/#api","content":" The LDAP secrets engine has a full HTTP API. Please see the LDAP secrets engine API docsfor more details. ","version":"Next","tagName":"h2"},{"title":"Kubernetes secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/kubernetes/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"Kubernetes secrets engine","url":"/openbao/docs/secrets/kubernetes/#setup","content":" The Kubernetes Secrets Engine must be configured in advance before it can perform its functions. These steps are usually completed by an operator or configuration management tool.  By default, OpenBao will connect to Kubernetes using its own service account. If using the standard Helm chart, this service account is created automatically by default and named after the Helm release (often openbao, but this can be configured via the Helm value server.serviceAccount.name). It's necessary to ensure that the service account OpenBao uses will have permissions to manage service account tokens, and optionally manage service accounts, roles, and role bindings. These permissions can be managed using a Kubernetes role or cluster role. The role is attached to the OpenBao service account with a role binding or cluster role binding. For example, a minimal cluster role to create service account tokens is: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: k8s-minimal-secrets-abilities rules: - apiGroups: [&quot;&quot;] resources: [&quot;serviceaccounts/token&quot;] verbs: [&quot;create&quot;] Similarly, you can create a more permissive cluster role with full permissions to manage tokens, service accounts, bindings, and roles. apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: k8s-full-secrets-abilities rules: - apiGroups: [&quot;&quot;] resources: [&quot;serviceaccounts&quot;, &quot;serviceaccounts/token&quot;] verbs: [&quot;create&quot;, &quot;update&quot;, &quot;delete&quot;] - apiGroups: [&quot;rbac.authorization.k8s.io&quot;] resources: [&quot;rolebindings&quot;, &quot;clusterrolebindings&quot;] verbs: [&quot;create&quot;, &quot;update&quot;, &quot;delete&quot;] - apiGroups: [&quot;rbac.authorization.k8s.io&quot;] resources: [&quot;roles&quot;, &quot;clusterroles&quot;] verbs: [&quot;bind&quot;, &quot;escalate&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;] Create this role in Kubernetes (e.g., with kubectl apply -f). Moreover, if you want to use label selection to configure the namespaces on which a role can act, you will need to grant OpenBao permissions to read namespaces. apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: k8s-full-secrets-abilities-with-labels rules: - apiGroups: [&quot;&quot;] resources: [&quot;namespaces&quot;] verbs: [&quot;get&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;serviceaccounts&quot;, &quot;serviceaccounts/token&quot;] verbs: [&quot;create&quot;, &quot;update&quot;, &quot;delete&quot;] - apiGroups: [&quot;rbac.authorization.k8s.io&quot;] resources: [&quot;rolebindings&quot;, &quot;clusterrolebindings&quot;] verbs: [&quot;create&quot;, &quot;update&quot;, &quot;delete&quot;] - apiGroups: [&quot;rbac.authorization.k8s.io&quot;] resources: [&quot;roles&quot;, &quot;clusterroles&quot;] verbs: [&quot;bind&quot;, &quot;escalate&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;]   warning Note: Getting the right permissions for OpenBao will require some trial and error most likely since Kubernetes has strict protections against privilege escalation. You can read more in theKubernetes RBAC documentation.  warning Note: Protect the OpenBao service account, especially if you use broader permissions for it, as it is essentially a cluster administrator account.  Create a role binding to bind the role to OpenBao's service account and grant OpenBao permission to manage tokens. apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: openbao-token-creator-binding roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: k8s-minimal-secrets-abilities subjects: - kind: ServiceAccount name: openbao namespace: openbao For more information on Kubernetes roles, service accounts, bindings, and tokens, visit theKubernetes RBAC documentation. If OpenBao will not be automatically managing roles or service accounts (seeAutomatically Managing Roles and Service Accounts), then you will need to set up a service account that OpenBao will issue tokens for.  warning Note: It is highly recommended that the service account that OpenBao issues tokens for is NOT the same service account that OpenBao itself uses.  The examples we will use will under the namespace test, which you can create if it does not already exist.  $ kubectl create namespace test namespace/test created   Here is a simple set up of a service account, role, and role binding in the Kubernetes testnamespace with basic permissions we will use for this document:  apiVersion: v1 kind: ServiceAccount metadata: name: test-service-account-with-generated-token namespace: test --- apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: test-role-list-pods namespace: test rules: - apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;] verbs: [&quot;list&quot;] --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: test-role-abilities namespace: test roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: test-role-list-pods subjects: - kind: ServiceAccount name: test-service-account-with-generated-token namespace: test   You can create these objects with kubectl apply -f.  Enable the Kubernetes Secrets Engine: $ bao secrets enable kubernetes Success! Enabled the kubernetes Secrets Engine at: kubernetes/ By default, the secrets engine will mount at the same name as the engine, i.e.,kubernetes/ here. This can be changed by passing the -path argument when enabling. Configure the mount point. An empty config is allowed. $ bao write -f kubernetes/config Configuration options are available as specified in theAPI docs. You can now configure Kubernetes Secrets Engine to create an OpenBao role (not the same as a Kubernetes role) that can generate service account tokens for the given service account: $ bao write kubernetes/roles/my-role \\ allowed_kubernetes_namespaces=&quot;*&quot; \\ service_account_name=&quot;test-service-account-with-generated-token&quot; \\ token_default_ttl=&quot;10m&quot;   ","version":"Next","tagName":"h2"},{"title":"Generating credentials​","type":1,"pageTitle":"Kubernetes secrets engine","url":"/openbao/docs/secrets/kubernetes/#generating-credentials","content":" After a user has authenticated to OpenBao and has sufficient permissions, a write to thecreds endpoint for the OpenBao role will generate and return a new service account token.  $ bao write kubernetes/creds/my-role \\ kubernetes_namespace=test Key Value –-- ----- lease_id kubernetes/creds/my-role/31d771a6-... lease_duration 10m0s lease_renwable false service_account_name test-service-account-with-generated-token service_account_namespace test service_account_token eyJHbGci0iJSUzI1NiIsImtpZCI6ImlrUEE...   You can use the service account token above (eyJHbG...) with any Kubernetes API request that its service account is authorized for (through role bindings).  $ curl -sk $(kubectl config view --minify -o 'jsonpath={.clusters[].cluster.server}')/api/v1/namespaces/test/pods \\ --header &quot;Authorization: Bearer eyJHbGci0iJSUzI1Ni...&quot; { &quot;kind&quot;: &quot;PodList&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: { &quot;resourceVersion&quot;: &quot;1624&quot; }, &quot;items&quot;: [] }   When the lease expires, you can verify that the token has been revoked.  $ curl -sk $(kubectl config view --minify -o 'jsonpath={.clusters[].cluster.server}')/api/v1/namespaces/test/pods \\ --header &quot;Authorization: Bearer eyJHbGci0iJSUzI1Ni...&quot; { &quot;kind&quot;: &quot;Status&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {}, &quot;status&quot;: &quot;Failure&quot;, &quot;message&quot;: &quot;Unauthorized&quot;, &quot;reason&quot;: &quot;Unauthorized&quot;, &quot;code&quot;: 401 }   ","version":"Next","tagName":"h2"},{"title":"TTL​","type":1,"pageTitle":"Kubernetes secrets engine","url":"/openbao/docs/secrets/kubernetes/#ttl","content":" Kubernetes service account tokens have a time-to-live (TTL). When a token expires it is automatically revoked.  You can set a default (token_default_ttl) and a maximum TTL (token_max_ttl) when creating or tuning the OpenBao role.  $ bao write kubernetes/roles/my-role \\ allowed_kubernetes_namespaces=&quot;*&quot; \\ service_account_name=&quot;new-service-account-with-generated-token&quot; \\ token_default_ttl=&quot;10m&quot; \\ token_max_ttl=&quot;2h&quot;   You can also set a TTL (ttl) when you generate the token from the credentials endpoint. The TTL of the token will be given the default if not specified (and cannot exceed the maximum TTL of the role, if present).  $ bao write kubernetes/creds/my-role \\ kubernetes_namespace=test \\ ttl=20m Key Value –-- ----- lease_id kubernetes/creds/my-role/31d771a6-... lease_duration 20m0s lease_renwable false service_account_name new-service-account-with-generated-token service_account_namespace test service_account_token eyJHbGci0iJSUzI1NiIsImtpZCI6ImlrUEE...   You can verify the token's TTL by decoding the JWT token and extracting the iat(issued at) and exp (expiration time) claims.  $ echo 'eyJhbGc...' | cut -d'.' -f2 | base64 -d | jq -r '.iat,.exp|todate' 2022-05-20T17:14:50Z 2022-05-20T17:34:50Z   ","version":"Next","tagName":"h2"},{"title":"Audiences​","type":1,"pageTitle":"Kubernetes secrets engine","url":"/openbao/docs/secrets/kubernetes/#audiences","content":" Kubernetes service account tokens have audiences.  You can set default audiences (token_default_audiences) when creating or tuning the OpenBao role. The Kubernetes cluster default audiences for service account tokens will be used if not specified.  $ bao write kubernetes/roles/my-role \\ allowed_kubernetes_namespaces=&quot;*&quot; \\ service_account_name=&quot;new-service-account-with-generated-token&quot; \\ token_default_audiences=&quot;custom-audience&quot;   You can also set audiences (audiences) when you generate the token from the credentials endpoint. The audiences of the token will be given the default audiences if not specified.  $ bao write kubernetes/creds/my-role \\ kubernetes_namespace=test \\ audiences=&quot;another-custom-audience&quot; Key Value –-- ----- lease_id kubernetes/creds/my-role/SriWQf0bPZ... lease_duration 768h lease_renwable false service_account_name new-service-account-with-generated-token service_account_namespace test service_account_token eyJHbGci0iJSUzI1NiIsImtpZCI6ImlrUEE...   You can verify the token's audiences by decoding the JWT.  $ echo 'eyJhbGc...' | cut -d'.' -f2 | base64 -d {&quot;aud&quot;:[&quot;another-custom-audience&quot;]...   ","version":"Next","tagName":"h2"},{"title":"Automatically managing roles and service accounts​","type":1,"pageTitle":"Kubernetes secrets engine","url":"/openbao/docs/secrets/kubernetes/#automatically-managing-roles-and-service-accounts","content":" When configuring the OpenBao role, you can pass in parameters to specify that you want to automatically generate the Kubernetes service account and role binding, and optionally generate the Kubernetes role itself.  If you want to configure the OpenBao role to use a pre-existing Kubernetes role, but generate the service account and role binding automatically, you can set the kubernetes_role_nameparameter.  $ bao write kubernetes/roles/auto-managed-sa-role \\ allowed_kubernetes_namespaces=&quot;test&quot; \\ kubernetes_role_name=&quot;test-role-list-pods&quot;   warning Note: OpenBao's service account will also need access to the resources it is granting access to. This can be done for the examples above with kubectl -n test create rolebinding --role test-role-list-pods --serviceaccount=openbao:openbao openbao-test-role-abilities. This is how Kubernetes prevents privilege escalation. You can read more in theKubernetes RBAC documentation.  You can then get credentials with the automatically generated service account.  $ bao write kubernetes/creds/auto-managed-sa-role \\ kubernetes_namespace=test Key Value --- ----- lease_id kubernetes/creds/auto-managed-sa-role/cujRLYjKZUMQk6dkHBGGWm67 lease_duration 768h lease_renewable false service_account_name v-token-auto-man-1653001548-5z6hrgsxnmzncxejztml4arz service_account_namespace test service_account_token eyJHbGci0iJSUzI1Ni...   Furthermore, OpenBao can also automatically create the role in addition to the service account and role binding by specifying the generated_role_rules parameter, which accepts a set of JSON or YAML rules for the generated role.  $ bao write kubernetes/roles/auto-managed-sa-and-role \\ allowed_kubernetes_namespaces=&quot;test&quot; \\ generated_role_rules='{&quot;rules&quot;:[{&quot;apiGroups&quot;:[&quot;&quot;],&quot;resources&quot;:[&quot;pods&quot;],&quot;verbs&quot;:[&quot;list&quot;]}]}'   You can then get credentials in the same way as before.  $ bao write kubernetes/creds/auto-managed-sa-and-role \\ kubernetes_namespace=test Key Value --- ----- lease_id kubernetes/creds/auto-managed-sa-and-role/pehLtegoTP8vCkcaQozUqOHf lease_duration 768h lease_renewable false service_account_name v-token-auto-man-1653002096-4imxf3ytjh5hbyro9s1oqdo3 service_account_namespace test service_account_token eyJHbGci0iJSUzI1Ni...   ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Kubernetes secrets engine","url":"/openbao/docs/secrets/kubernetes/#api","content":" The Kubernetes Secrets Engine has a full HTTP API. Please see theKubernetes Secrets Engine API docs for more details. ","version":"Next","tagName":"h2"},{"title":"KV secrets engine - version 2","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/kv/kv-v2/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  A v2 kv secrets engine can be enabled by:  $ bao secrets enable -version=2 kv   Or, you can pass kv-v2 as the secrets engine type:  $ bao secrets enable kv-v2   Additionally, when running a dev-mode server, the v2 kv secrets engine is enabled by default at the path secret/ (for non-dev servers, it is currently v1). It can be disabled, moved, or enabled multiple times at different paths. Each instance of the KV secrets engine is isolated and unique.  ","version":"Next","tagName":"h2"},{"title":"Upgrading from version 1​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#upgrading-from-version-1","content":" An existing version 1 kv store can be upgraded to a version 2 kv store via the CLI or API, as shown below. This will start an upgrade process to upgrade the existing key/value data to a versioned format. The mount will be inaccessible during this process. This process could take a long time, so plan accordingly.  Once upgraded to version 2, the former paths at which the data was accessible will no longer suffice. You will need to adjust user policies to add access to the version 2 paths as detailed in the ACL Rules section below. Similarly, users/applications will need to update the paths at which they interact with the kv data once it has been upgraded to version 2.  An existing version 1 kv can be upgraded to a version 2 KV store with the CLI command:  $ bao kv enable-versioning secret/ Success! Tuned the secrets engine at: secret/   or via the API:  $ cat payload.json { &quot;options&quot;: { &quot;version&quot;: &quot;2&quot; } }   $ curl \\ --header &quot;X-Vault-Token: ...&quot; \\ --request POST \\ --data @payload.json \\ http://127.0.0.1:8200/v1/sys/mounts/secret/tune   ","version":"Next","tagName":"h2"},{"title":"ACL rules​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#acl-rules","content":" The version 2 kv store uses a prefixed API, which is different from the version 1 API. Before upgrading from a version 1 kv the ACL rules should be changed. Also different paths in the version 2 API can be ACL'ed differently.  Writing and reading versions are prefixed with the data/ path. This policy that worked for the version 1 kv:  path &quot;secret/dev/team-1/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;, &quot;read&quot;] }   Should be changed to:  path &quot;secret/data/dev/team-1/*&quot; { capabilities = [&quot;create&quot;, &quot;update&quot;, &quot;read&quot;] }   There are different levels of data deletion for this backend. To grant a policy the permissions to delete the latest version of a key:  path &quot;secret/data/dev/team-1/*&quot; { capabilities = [&quot;delete&quot;] }   To allow the policy to delete any version of a key:  path &quot;secret/delete/dev/team-1/*&quot; { capabilities = [&quot;update&quot;] }   To allow a policy to undelete data:  path &quot;secret/undelete/dev/team-1/*&quot; { capabilities = [&quot;update&quot;] }   To allow a policy to destroy versions:  path &quot;secret/destroy/dev/team-1/*&quot; { capabilities = [&quot;update&quot;] }   To allow a policy to list keys:  path &quot;secret/metadata/dev/team-1/*&quot; { capabilities = [&quot;list&quot;] }   To allow a policy to view metadata for each version:  path &quot;secret/metadata/dev/team-1/*&quot; { capabilities = [&quot;read&quot;] }   To allow a policy to permanently remove all versions and metadata for a key:  path &quot;secret/metadata/dev/team-1/*&quot; { capabilities = [&quot;delete&quot;] }   The allowed_parameters, denied_parameters, and required_parameters fields are not supported for policies used with the version 2 kv store. See the Policies Conceptsfor a description of these parameters.  See the API Specification for more information.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials. The kv secrets engine allows for writing keys with arbitrary values.  The path-like KV-v1 syntax for referencing a secret (secret/foo) can still be used in KV-v2, but we recommend using the -mount=secret flag syntax to avoid mistaking it for the actual path to the secret (secret/data/foo is the real path).  ","version":"Next","tagName":"h2"},{"title":"Writing/Reading arbitrary data​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#writingreading-arbitrary-data","content":" Write arbitrary data: $ bao kv put -mount=secret my-secret foo=a bar=b Key Value --- ----- created_time 2019-06-19T17:20:22.985303Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 Read arbitrary data: $ bao kv get -mount=secret my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:20:22.985303Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 ====== Data ====== Key Value --- ----- foo a bar b Write another version, the previous version will still be accessible. The-cas flag can optionally be passed to perform a check-and-set operation. If not set the write will be allowed. In order for a write to be successful, cas must be set to the current version of the secret. If set to 0 a write will only be allowed if the key doesn’t exist as unset keys do not have any version information. Also remember that soft deletes do not remove any underlying version data from storage. In order to write to a soft deleted key, the cas parameter must match the key's current version. $ bao kv put -mount=secret -cas=1 my-secret foo=aa bar=bb Key Value --- ----- created_time 2019-06-19T17:22:23.369372Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 2 Reading now will return the newest version of the data: $ bao kv get -mount=secret my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:22:23.369372Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 2 ====== Data ====== Key Value --- ----- foo aa bar bb Partial updates can be accomplished using the bao kv patch command. A command will initially attempt an HTTP PATCH request which requires thepatch ACL capability. The PATCH request will fail if the token used is associated with a policy that does not contain the patch capability. In this case the command will perform a read, local update, and subsequent write which require both the read and update ACL capabilities. The -cas flag can optionally be passed to perform a check-and-set operation. It will only be used in the case of the initial PATCH request. The read-then-write flow will use the version value from the secret returned by the read to perform a check-and-set operation in the subsequent write. $ bao kv patch -mount=secret -cas=2 my-secret bar=bbb Key Value --- ----- created_time 2019-06-19T17:23:49.199802Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 3 The bao kv patch command also supports a -method flag which can be used to specify HTTP PATCH or read-then-write. The supported values arepatch and rw for HTTP PATCH and read-then-write, respectively. Perform a patch using the patch method: $ bao kv patch -mount=secret -method=patch -cas=2 my-secret bar=bbb Key Value --- ----- created_time 2019-06-19T17:23:49.199802Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 3 Perform a patch using the read-then-write method: $ bao kv patch -mount=secret -method=rw my-secret bar=bbb Key Value --- ----- created_time 2019-06-19T17:23:49.199802Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 3 Reading after a patch will return the newest version of the data in which only the specified fields were updated: $ bao kv get -mount=secret my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:23:49.199802Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 3 ====== Data ====== Key Value --- ----- foo aa bar bbb Previous versions can be accessed with the -version flag: $ bao kv get -mount=secret -version=1 my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:20:22.985303Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 ====== Data ====== Key Value --- ----- foo a bar b   You can also use OpenBao's password policy feature to generate arbitrary values.  Write a password policy: $ bao write sys/policies/password/example policy=-&lt;&lt;EOF length=20 rule &quot;charset&quot; { charset = &quot;abcdefghij0123456789&quot; min-chars = 1 } rule &quot;charset&quot; { charset = &quot;!@#$%^&amp;*STUVWXYZ&quot; min-chars = 1 } EOF Write data using the example policy: $ bao kv put -mount=secret my-generated-secret \\ password=$(bao read -field password sys/policies/password/example/generate) Example output: ========= Secret Path ========= secret/data/my-generated-secret ======= Metadata ======= Key Value --- ----- created_time 2023-05-10T14:32:32.37354939Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 Read the generated data: $ bao kv get -mount=secret my-generated-secret ========= Secret Path ========= secret/data/my-generated-secret ======= Metadata ======= Key Value --- ----- created_time 2023-05-10T14:32:32.37354939Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 1 ====== Data ====== Key Value --- ----- password !hh&amp;be1e4j16dVc0ggae   ","version":"Next","tagName":"h3"},{"title":"Deleting and destroying data​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#deleting-and-destroying-data","content":" When deleting data the standard bao kv delete command will perform a soft delete. It will mark the version as deleted and populate a deletion_timetimestamp. Soft deletes do not remove the underlying version data from storage, which allows the version to be undeleted. The bao kv undelete command handles undeleting versions.  A version's data is permanently deleted only when the key has more versions than are allowed by the max-versions setting, or when using bao kv destroy. When the destroy command is used the underlying version data will be removed and the key metadata will be marked as destroyed. If a version is cleaned up by going over max-versions the version metadata will also be removed from the key.  See the commands below for more information:  The latest version of a key can be deleted with the delete command, this also takes a -versions flag to delete prior versions: $ bao kv delete -mount=secret my-secret Success! Data deleted (if it existed) at: secret/data/my-secret Versions can be undeleted: $ bao kv undelete -mount=secret -versions=2 my-secret Success! Data written to: secret/undelete/my-secret $ bao kv get -mount=secret my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:23:21.834403Z custom_metadata &lt;nil&gt; deletion_time n/a destroyed false version 2 ====== Data ====== Key Value --- ----- my-value short-lived-s3cr3t Destroying a version permanently deletes the underlying data: $ bao kv destroy -mount=secret -versions=2 my-secret Success! Data written to: secret/destroy/my-secret   ","version":"Next","tagName":"h3"},{"title":"Key metadata​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#key-metadata","content":" All versions and key metadata can be tracked with the metadata command &amp; API. Deleting the metadata key will cause all metadata and versions for that key to be permanently removed.  See the commands below for more information:  All metadata and versions for a key can be viewed: $ bao kv metadata get -mount=secret my-secret ========== Metadata ========== Key Value --- ----- cas_required false created_time 2019-06-19T17:20:22.985303Z current_version 2 custom_metadata &lt;nil&gt; delete_version_after 0s max_versions 0 oldest_version 0 updated_time 2019-06-19T17:22:23.369372Z ====== Version 1 ====== Key Value --- ----- created_time 2019-06-19T17:20:22.985303Z deletion_time n/a destroyed false ====== Version 2 ====== Key Value --- ----- created_time 2019-06-19T17:22:23.369372Z deletion_time n/a destroyed true The metadata settings for a key can be configured: $ bao kv metadata put -mount=secret -max-versions 2 -delete-version-after=&quot;3h25m19s&quot; my-secret Success! Data written to: secret/metadata/my-secret Delete-version-after settings will apply only to new versions. Max versions changes will be applied on next write: $ bao kv put -mount=secret my-secret my-value=newer-s3cr3t Key Value --- ----- created_time 2019-06-19T17:31:16.662563Z custom_metadata &lt;nil&gt; deletion_time 2019-06-19T20:56:35.662563Z destroyed false version 4 Once a key has more versions than max versions the oldest versions are cleaned up: $ bao kv metadata get -mount=secret my-secret ========== Metadata ========== Key Value --- ----- cas_required false created_time 2019-06-19T17:20:22.985303Z current_version 4 custom_metadata &lt;nil&gt; delete_version_after 3h25m19s max_versions 2 oldest_version 3 updated_time 2019-06-19T17:31:16.662563Z ====== Version 3 ====== Key Value --- ----- created_time 2019-06-19T17:23:21.834403Z deletion_time n/a destroyed true ====== Version 4 ====== Key Value --- ----- created_time 2019-06-19T17:31:16.662563Z deletion_time 2019-06-19T20:56:35.662563Z destroyed false A secret's key metadata can contain custom metadata used to describe the secret. The data will be stored as string-to-string key-value pairs. The -custom-metadata flag can be repeated to add multiple key-value pairs. The bao kv metadata put command can be used to fully overwrite the value of custom_metadata: $ bao kv metadata put -mount=secret -custom-metadata=foo=abc -custom-metadata=bar=123 my-secret Success! Data written to: secret/metadata/my-secret $ bao kv get -mount=secret my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:22:23.369372Z custom_metadata map[bar:123 foo:abc] deletion_time n/a destroyed false version 2 ====== Data ====== Key Value --- ----- foo aa bar bb The bao kv metadata patch command can be used to partially overwrite the value of custom_metadata. The following invocation will update custom_metadata sub-field foo but leave bar untouched: $ bao kv metadata patch -mount=secret -custom-metadata=foo=def my-secret Success! Data written to: secret/metadata/my-secret $ bao kv get -mount=secret my-secret ====== Metadata ====== Key Value --- ----- created_time 2019-06-19T17:22:23.369372Z custom_metadata map[bar:123 foo:def] deletion_time n/a destroyed false version 2 ====== Data ====== Key Value --- ----- foo aa bar bb Permanently delete all metadata and versions for a key: $ bao kv metadata delete -mount=secret my-secret Success! Data deleted (if it existed) at: secret/metadata/my-secret   ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#tutorial","content":" Refer to the Versioned Key/Value Secrets Enginetutorial to learn how to use KV secrets engine v2 to version or roll back secrets.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"KV secrets engine - version 2","url":"/openbao/docs/secrets/kv/kv-v2/#api","content":" The KV secrets engine has a full HTTP API. Please see theKV secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"PKI secrets engine - quick start - root CA setup","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/quick-start-root-ca/","content":"","keywords":"","version":"Next"},{"title":"Tutorial​","type":1,"pageTitle":"PKI secrets engine - quick start - root CA setup","url":"/openbao/docs/secrets/pki/quick-start-root-ca/#tutorial","content":" Refer to the Build Your Own Certificate Authority (CA)guide for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PKI secrets engine - quick start - root CA setup","url":"/openbao/docs/secrets/pki/quick-start-root-ca/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"PKI secrets engine - quick start - intermediate CA setup","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/quick-start-intermediate-ca/","content":"","keywords":"","version":"Next"},{"title":"Tutorial​","type":1,"pageTitle":"PKI secrets engine - quick start - intermediate CA setup","url":"/openbao/docs/secrets/pki/quick-start-intermediate-ca/#tutorial","content":" Refer to the Build Your Own Certificate Authority (CA)guide for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PKI secrets engine - quick start - intermediate CA setup","url":"/openbao/docs/secrets/pki/quick-start-intermediate-ca/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"PKI secrets engine - considerations","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/considerations/","content":"","keywords":"","version":"Next"},{"title":"Table of contents​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#table-of-contents","content":" Be Careful with Root CAsOne CA Certificate, One Secrets Engine Always Configure a Default Issuer Key Types Matter Cluster Performance and Key Types Use a CA Hierarchy Cross-Signed Intermediates Cluster URLs are ImportantAutomate Rotation with ACME ACME Stores CertificatesACME Role Restrictions Require EABACME and the Public InternetACME Errors are in Server LogsACME Security ConsiderationsACME and Client Counting Keep Certificate Lifetimes Short, For CRL's Sake NotAfter Behavior on Leaf CertificatesCluster Performance and Quantity of Leaf Certificates You must configure issuing/CRL/OCSP information in advanceDistribution of CRLs and OCSPAutomate CRL Building and TidyingSpectrum of Revocation Support What Are Cross-Cluster CRLs? Issuer Subjects and CRLsAutomate Leaf Certificate RenewalSafe MinimumsToken Lifetimes and RevocationSafe Usage of RolesTelemetryAuditingRole-Based AccessReplicated DataSetsCluster ScalabilityPSS SupportIssuer Storage Migration Issues  ","version":"Next","tagName":"h2"},{"title":"Be careful with root CAs​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#be-careful-with-root-cas","content":" OpenBao storage is secure, but not as secure as a piece of paper in a bank vault. It is, after all, networked software. If your root CA is hosted outside of OpenBao, don't put it in OpenBao as well; instead, issue a shorter-lived intermediate CA certificate and put this into OpenBao. This aligns with industry best practices.  Since 0.4, the secrets engine supports generating self-signed root CAs and creating and signing CSRs for intermediate CAs. In each instance, for security reasons, the private key can only be exported at generation time, and the ability to do so is part of the command path (so it can be put into ACL policies).  If you plan on using intermediate CAs with OpenBao, it is suggested that you let OpenBao create CSRs and do not export the private key, then sign those with your root CA (which may be a second mount of the pki secrets engine).  ","version":"Next","tagName":"h2"},{"title":"One CA certificate, one secrets engine​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#one-ca-certificate-one-secrets-engine","content":" The PKI Secrets Engine supports multiple issuers in a single mount. However, in order to simplify the configuration, it is strongly recommended that operators limit a mount to a single issuer. If you want to issue certificates from multiple disparate CAs, mount the PKI secrets engine at multiple mount points with separate CA certificates in each.  The rationale for separating mounts is to simplify permissions management: very few individuals need access to perform operations with the root, but many need access to create leaves. The operations on a root should generally be limited to issuing and revoking intermediate CAs, which is a highly privileged operation; it becomes much easier to audit these operations when they're in a separate mount than if they're mixed in with day-to-day leaf issuance.  A common pattern is to have one mount act as your root CA and to use this CA only to sign intermediate CA CSRs from other PKI secrets engines.  To keep old CAs active, there's two approaches to achieving rotation:  Use multiple secrets engines. This allows a fresh start, preserving the old issuer and CRL. OpenBao ACL policy can be updated to deny new issuance under the old mount point and roles can be re-evaluated before being imported into the new mount point.Use multiple issuers in the same mount point. The usage of the old issuer can be restricted to CRL signing, and existing roles and ACL policy can be kept as-is. This allows cross-signing within the same mount, and consumers of the mount won't have to update their configuration. Once the transitional period for this rotation has completed and all past issued certificate have expired, it is encouraged to fully remove the old issuer and any unnecessary cross-signed issuers from the mount point.  Another suggested use case for multiple issuers in the same mount is splitting issuance by TTL lifetime. For short-lived certificates, an intermediate stored in OpenBao will often out-perform a HSM-backed intermediate. For longer-lived certificates, however, it is often important to have the intermediate key material secured throughout the lifetime of the end-entity certificate. This means that two intermediates in the same mount -- one backed by the HSM and one backed by OpenBao -- can satisfy both use cases. Operators can make roles setting maximum TTLs for each issuer and consumers of the mount can decide which to use.  ","version":"Next","tagName":"h2"},{"title":"Always configure a default issuer​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#always-configure-a-default-issuer","content":" For backwards compatibility, the default issueris used to service PKI endpoints without an explicit issuer (either via path selection or role-based selection). When certificates are revoked and their issuer is no longer part of this PKI mount, OpenBao places them on the default issuer's CRL. This means maintaining a default issuer is important for both backwards compatibility for issuing certificates and for ensuring revoked certificates land on a CRL.  ","version":"Next","tagName":"h3"},{"title":"Key types matter​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#key-types-matter","content":" Certain key types have impacts on performance. Signing certificates from a RSA key will be slower than issuing from an ECDSA or Ed25519 key. Key generation (using /issue/:role endpoints) using RSA keys will also be slow: RSA key generation involves finding suitable random primes, whereas Ed25519 keys can be random data. As the number of bits goes up (RSA 2048 -&gt; 4096 or ECDSA P-256 -&gt; P-521), signature times also increases.  This matters in both directions: not only is issuance more expensive, but validation of the corresponding signature (in say, TLS handshakes) will also be more expensive. Careful consideration of both issuer and issued key types can have meaningful impacts on performance of not only OpenBao, but systems using these certificates.  ","version":"Next","tagName":"h2"},{"title":"Cluster performance and key type​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#cluster-performance-and-key-type","content":" The benchmark-vault project can be used to measure the performance of an OpenBao PKI instance. In general, some considerations to be aware of:  RSA key generation is much slower and highly variable than EC key generation. If performance and throughput are a necessity, consider using EC keys (including NIST P-curves and Ed25519) instead of RSA. Key signing requests (via /pki/sign) will be faster than (/pki/issue), especially for RSA keys: this removes the necessity for OpenBao to generate key material and can sign the key material provided by the client. This signing step is common between both endpoints, so key generation is pure overhead if the client has a sufficiently secure source of entropy. The CA's key type matters as well: using a RSA CA will result in a RSA signature and takes longer than a ECDSA or Ed25519 CA. Storage is an important factor: with BYOC Revocation, using no_store=true still gives you the ability to revoke certificates and audit logs can be used to track issuance. Clusters using a remote storage over a slow network and using no_store=false will result in additional latency on issuance. Adding leases for every issued certificate compounds the problem. Storing too many certificates results in longer LIST /pki/certs time, including the time to tidy the instance. As such, for large scale deployments (&gt;= 250k active certificates) it is recommended to use audit logs to track certificates outside of OpenBao.  As a general comparison on unspecified hardware, using benchmark-vault for30s on a local, single node, raft-backed OpenBao instance:  OpenBao can issue 300k certificates using EC P-256 for CA &amp; leaf keys and without storage. But switching to storing these leaves drops that number to 65k, and only 20k with leases. Using large, expensive RSA-4096 bit keys, OpenBao can only issue 160 leaves, regardless of whether or not storage or leases were used. The 95% key generation time is above 10s. In comparison, using P-521 keys, OpenBao can issue closer to 30k leaves without leases and 18k with leases.  These numbers are for example only, to represent the impact different key types can have on PKI cluster performance.  The use of ACME adds additional latency into these numbers, both because certificates need to be stored and because challenge validation needs to be performed.  ","version":"Next","tagName":"h3"},{"title":"Use a CA hierarchy​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#use-a-ca-hierarchy","content":" It is generally recommended to use a hierarchical CA setup, with a root certificate which issues one or more intermediates (based on usage), which in turn issue the leaf certificates.  This allows stronger storage or policy guarantees around protection of the root CA, while letting OpenBao manage the intermediate CAs and issuance of leaves. Different intermediates might be issued for different usage, such as VPN signing, Email signing, or testing versus production TLS services. This helps to keep CRLs limited to specific purposes: for example, VPN services don't care about the revoked set of email signing certificates if they're using separate certificates and different intermediates, and thus don't need both CRL contents. Additionally, this allows higher risk intermediates (such as those issuing longer-lived email signing certificates) to have HSM-backing without impacting the performance of easier-to-rotate intermediates and certificates (such as TLS intermediates).  OpenBao supports the use of both the allowed_domains parameter on Roles and the permitted_dns_domainsparameter to set the Name Constraints extensionon root and intermediate generation. This allows for several layers of separation of concerns between TLS-based services.  ","version":"Next","tagName":"h2"},{"title":"Cross-Signed intermediates​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#cross-signed-intermediates","content":" When cross-signing intermediates from two separate roots, two separate intermediate issuers will exist within the OpenBao PKI mount. In order to correctly serve the cross-signed chain on issuance requests, themanual_chain override is required on either or both intermediates. This can be constructed in the following order:  this issuer (self)this rootthe other copy of this intermediatethe other root  All requests to this issuer for signing will now present the full cross-signed chain.  ","version":"Next","tagName":"h3"},{"title":"Cluster URLs are important​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#cluster-urls-are-important","content":" ACME support uses the same configuration as templated AIA URLsto allow ACME clients to discover the URL of this cluster.  warning Warning: It is important to ensure that this configuration is up to date and maintained correctly, always pointing to the node's cluster address (which may be a Load Balanced or a DNS Round-Robbin address). If this configuration is not set on every node, certificate issuance (via REST and/or via ACME) will fail.  ","version":"Next","tagName":"h2"},{"title":"Automate rotation with ACME​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#automate-rotation-with-acme","content":" The PKI Engine supports the Automatic Certificate Management Environment (ACME) protocol. This is a standardized way to handle validation, issuance, rotation, and revocation of server certificates.  Many ecosystems, from web servers like Caddy, Nginx, and Apache, to orchestration environments like Kubernetes (via cert-manager) natively support issuance via the ACME protocol. For deployments without native support, stand-alone tools like certbot support fetching and renewing certificates on behalf of consumers. OpenBao's PKI Engine only includes server support for ACME; no client functionality has been included.  warning Note: OpenBao's PKI ACME server caps the certificate's validity at 90 days maximum, regardless of role and/or global limits. Shorter validity durations can be set via limiting the role's TTL to be under 90 days. Aligning with Let's Encrypt, we do not support the optional NotBeforeand NotAfter order request parameters.  ","version":"Next","tagName":"h2"},{"title":"ACME stores certificates​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#acme-stores-certificates","content":" Because ACME requires stored certificates in order to function, the notesbelow about automating tidy are especially important for the long-term health of the PKI cluster. ACME also introduces additional resource types (accounts, orders, authorizations, and challenges) that must be tidied via the tidy_acme=trueoption. Orders, authorizations, and challenges are cleaned up based on thesafety_bufferparameter, but accounts can live longer past their last issued certificate by controlling the acme_account_safety_bufferparameter.  As a consequence of the above, and like the discussions in the Cluster Scalability section, because these roles haveno_store=false set, ACME can only issue certificates on the active nodes of PR clusters; standby nodes, if contacted, will transparently forward all requests to the active node.  ","version":"Next","tagName":"h3"},{"title":"ACME role restrictions require EAB​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#acme-role-restrictions-require-eab","content":" Because ACME by default has no external authorization engine and is unauthenticated from an OpenBao perspective, the use of roles with ACME in the default configuration are of limited value as any ACME client can request certificates under any role by proving possession of the requested certificate identifiers.  To solve this issue, there are two possible approaches:  Use a restrictive allowed_roles, allowed_issuers, anddefault_directory_policy ACME configurationto let only a single role and issuer be used. This prevents user choice, allowing some global restrictions to be placed on issuance and avoids requiring ACME clients to have (at initial setup) access to an OpenBao token other mechanism for acquiring an OpenBao EAB ACME token.Use a more permissive configuration witheab_policy=always-requiredto allow more roles and users to select the roles, but bind ACME clients to an OpenBao token which can be suitably ACL'd to particular sets of approved ACME directories.  The choice of approach depends on the policies of the organization wishing to use ACME.  Another consequence of the OpenBao unauthenticated nature of ACME requests are that role templating, based on entity information, cannot be used as there is no token and thus no entity associated with the request, even when EAB binding is used.  ","version":"Next","tagName":"h3"},{"title":"ACME and the public internet​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#acme-and-the-public-internet","content":" Using ACME is possible over the public internet; public CAs like Let's Encrypt offer this as a service. Similarly, organizations running internal PKI infrastructure might wish to issue server certificates to pieces of infrastructure outside of their internal network boundaries, from a publicly accessible OpenBao instance. By default, without enforcing a restrictiveeab_policy, this results in a complicated threat model: any external client which can prove possession of a domain can issue a certificate under this CA, which might be considered more trusted by this organization.  As such, we strongly recommend publicly facing OpenBao instances enforce that PKI mount operators have required a restrictive eab_policy=always-requiredconfiguration. System administrators of OpenBao instances can enforce this by setting theVAULT_DISABLE_PUBLIC_ACME=true environment variable.  ","version":"Next","tagName":"h3"},{"title":"ACME errors are in server logs​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#acme-errors-are-in-server-logs","content":" Because the ACME client is not necessarily trusted (as account registration may not be tied to a valid OpenBao token when EAB is not used), many error messages end up in the OpenBao server logs out of security necessity. When troubleshooting issues with clients requesting certificates, first check the client's logs, if any, (e.g., certbot will state the log location on errors), and then correlate with OpenBao server logs to identify the failure reason.  ","version":"Next","tagName":"h3"},{"title":"ACME security considerations​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#acme-security-considerations","content":" ACME allows any client to use OpenBao to make some sort of external call; while the design of ACME attempts to minimize this scope and will prohibit issuance if incorrect servers are contacted, it cannot account for all possible remote server implementations. OpenBao's ACME server makes three types of requests:  DNS requests for _acme-challenge.&lt;domain&gt;, which should be least invasive and most safe.TLS ALPN requests for the acme-tls/1 protocol, which should be safely handled by the TLS before any application code is invoked.HTTP requests to http://&lt;domain&gt;/.well-known/acme-challenge/&lt;token&gt;, which could be problematic based on server design; if all requests, regardless of path, are treated the same and assumed to be trusted, this could result in OpenBao being used to make (invalid) requests. Ideally, any such server implementations should be updated to ignore such ACME validation requests or to block access originating from OpenBao to this service.  In all cases, no information about the response presented by the remote server is returned to the ACME client.  When running OpenBao on multiple networks, note that OpenBao's ACME server places no restrictions on requesting client/destination identifier validations paths; a client could use a HTTP challenge to force OpenBao to reach out to a server on a network it could otherwise not access.  ","version":"Next","tagName":"h3"},{"title":"ACME and client counting​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#acme-and-client-counting","content":" ACME contributes differently to usage metrics than other interactions with the PKI Secrets Engine. Due to its use of unauthenticated requests (which do not generate OpenBao tokens), it would not be counted in the traditional activity log APIs. Instead, certificates issued via ACME will be counted via their unique certificate identifiers (the combination of CN, DNS SANs, and IP SANs). These will create a stable identifier that will be consistent across renewals, other ACME clients, mounts, and namespaces, contributing to the activity log presently as a non-entity token attributed to the first mount which created that request.  ","version":"Next","tagName":"h3"},{"title":"Keep certificate lifetimes short, for CRL's sake​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#keep-certificate-lifetimes-short-for-crls-sake","content":" This secrets engine aligns with OpenBao's philosophy of short-lived secrets. As such it is not expected that CRLs will grow large; the only place a private key is ever returned is to the requesting client (this secrets engine does notstore generated private keys, except for CA certificates). In most cases, if the key is lost, the certificate can simply be ignored, as it will expire shortly.  If a certificate must truly be revoked, the normal OpenBao revocation function can be used, and any revocation action will cause the CRL to be regenerated. When the CRL is regenerated, any expired certificates are removed from the CRL (and any revoked, expired certificate are removed from secrets engine storage). This is an expensive operation! Due to the structure of the CRL standard, OpenBao must read all revoked certificates into memory in order to rebuild the CRL and clients must fetch the regenerated CRL.  This secrets engine does not support multiple CRL endpoints with sliding date windows; often such mechanisms will have the transition point a few days apart, but this gets into the expected realm of the actual certificate validity periods issued from this secrets engine. A good rule of thumb for this secrets engine would be to simply not issue certificates with a validity period greater than your maximum comfortable CRL lifetime. Alternately, you can control CRL caching behavior on the client to ensure that checks happen more often.  Often multiple endpoints are used in case a single CRL endpoint is down so that clients don't have to figure out what to do with a lack of response. Run OpenBao in HA mode, and the CRL endpoint should be available even if a particular node is down.  warning Note: When using multiple issuers in the same mount point, different issuers may have different CRLs (depending on subject and key material). This means that OpenBao may need to regenerate multiple CRLs. This is again a rationale for keeping TTLs short and avoiding revocation if possible.  warning Note: OpenBao supports two complementary revocation mechanisms: Delta CRLs, which allow for rebuilds of smaller, incremental additions to the last complete CRL, and OCSP, which allows responding to revocation status requests for individual certificates. When coupled with the new CRL auto-rebuild functionality, this means that the revoking step isn't as costly (as the CRL isn't always rebuilt on each revocation), outside of storage considerations. However, while the rebuild operation still can be expensive with lots of certificates, it will be done on a schedule rather than on demand.  ","version":"Next","tagName":"h2"},{"title":"NotAfter behavior on leaf certificates​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#notafter-behavior-on-leaf-certificates","content":" The PKI Secrets Engine supports a leaf_not_after_behavior parameter on issuers. This allows modification of the issuance behavior: should OpenBao err, preventing issuance of a longer-lived leaf cert than issuer, silently truncate to that of the issuer's NotAfter value, or permit longer expirations.  It is strongly suggested to use err or truncate for intermediates;permit is only useful for root certificates, as intermediate's NotAfter expiration are checked when validating presented chains.  In combination with a cascading expiration with longer lived roots (perhaps on the range of 2-10 years), shorter lived intermediates (perhaps on the range of 6 months to 2 years), and short-lived leaf certificates (on the range of 30 to 90 days), and the rotation strategies discussed in other sections, this should keep the CRLs adequately small.  ","version":"Next","tagName":"h3"},{"title":"Cluster performance and quantity of leaf certificates​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#cluster-performance-and-quantity-of-leaf-certificates","content":" As mentioned above, keeping TTLs short (or using no_store=true) and avoiding leases is important for a healthy cluster. However it is important to note this is a scale problem: 10-1000 long-lived, stored certificates are probably fine, but 50k-100k become a problem and 500k+ stored, unexpired certificates can negatively impact even large OpenBao clusters--even with short TTLs!  However, once these certificates are expired, a tidy operationwill clean up CRLs and OpenBao cluster storage.  Note that organizational risk assessments for certificate compromise might mean certain certificate types should always be issued with no_store=false; even short-lived broad wildcard certificates (say, *.example.com) might be important enough to have precise control over revocation. However, an internal service with a well-scoped certificate (say, service.example.com) might be of low enough risk to issue a 90-day TTL with no_store=true, preventing the need for revocation in the unlikely case of compromise.  Having a shorter TTL decreases the likelihood of needing to revoke a cert (but cannot prevent it entirely) and decrease the impact of any such compromise.  warning Note: The PKI Secret Engine's Bring-Your-Own-Cert (BYOC) functionality allows revocation of certificates not previously stored (e.g., issued via a role with no_store=true). This means that setting no_store=true is safe to be used globally, regardless of importance of issued certificates (and their likelihood for revocation).  ","version":"Next","tagName":"h3"},{"title":"You must configure issuing/CRL/OCSP information in advance​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#you-must-configure-issuingcrlocsp-information-in-advance","content":" This secrets engine serves CRLs from a predictable location, but it is not possible for the secrets engine to know where it is running. Therefore, you must configure desired URLs for the issuing certificate, CRL distribution points, and OCSP servers manually using the config/urls endpoint. It is supported to have more than one of each of these by passing in the multiple URLs as a comma-separated string parameter.  warning Note: When using multiple issuers in the same mount, it is suggested to use the per-issuer AIA fields rather than the global (/config/urls) variant. This is for correctness: these fields are used for chain building and automatic CRL detection in certain applications. If they point to the wrong issuer's information, these applications may break.  ","version":"Next","tagName":"h2"},{"title":"Distribution of CRLs and OCSP​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#distribution-of-crls-and-ocsp","content":" Both CRLs and OCSP allow interrogating revocation status of certificates. Both of these methods include internal security and authenticity (both CRLs and OCSP responses are signed by the issuing CA within OpenBao). This means both are fine to distribute over non-secure and non-authenticated channels, such as HTTP.  ","version":"Next","tagName":"h2"},{"title":"Automate CRL building and tidying​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#automate-crl-building-and-tidying","content":" The PKI Secrets Engine supports automated CRL rebuilding (including optional Delta CRLs which can be built more frequently than complete CRLs) via the/config/crl endpoint. Additionally, tidying of revoked and expired certificates can be configured automatically via the /config/auto-tidyendpoint. Both of these should be enabled to ensure compatibility with the wider PKIX ecosystem and performance of the cluster.  ","version":"Next","tagName":"h2"},{"title":"Spectrum of revocation support​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#spectrum-of-revocation-support","content":" The PKI secrets engine has the ability to support a spectrum of cluster sizes and certificate revocation quantities.  For users with few revocations or who want a unified view and have the inter-cluster bandwidth to support it, we recommend turning on auto rebuilding of CRLs, cross-cluster revocation queues, and cross-cluster CRLs. This allows all consumers of the CRLs to have the most accurate picture of revocations, regardless of which cluster they talk to.  If the unified CRL becomes too big for the underlying storage mechanism or for a single host to build, we recommend relying on OCSP instead of CRLs. These have much smaller storage entries, and the CRL disabled flag is independent of unified_crls, allowing unified OCSP to remain.  However, when cross-cluster traffic becomes too high (or if CRLs are still necessary in addition to OCSP), we recommend sharding the CRL between different clusters. This has been the default behavior of OpenBao, but with the introduction of per-cluster, templated AIA information, the leaf certificate's Authority Information Access (AIA) info will point directly to the cluster which issued it, allowing the correct CRL for this cert to be identified by the application. This more correctly mimics the behavior of Let's Encrypt's CRL sharding.  This sharding behavior can also be used for OCSP, if the cross-cluster traffic for revocation entries becomes too high.  For users who wish to manage revocation manually, using the audit logs to track certificate issuance would allow an external system to identify which certificates were issued. These can be manually tracked for revocation, and a custom CRL can be builtusing externally tracked revocations. This would allow usage of roles set tono_store=true, so OpenBao is strictly used as an issuing authority and isn't storing any certificates, issued or revoked. For the highest of revocation volumes, this could be the best option.  Notably, this last approach can either be used for the creation of externally stored unified or sharded CRLs. If a single external unified CRL becomes unreasonably large, each cluster's certificates could have AIA info point to an externally stored and maintained, sharded CRL. However, OpenBao has no mechanism to sign OCSP requests at this time.  ","version":"Next","tagName":"h2"},{"title":"Automate leaf certificate renewal​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#automate-leaf-certificate-renewal","content":" To manage certificates for services at scale, it is best to automate the certificate renewal as much as possible. OpenBao Agent has support for automatically renewing requested certificatesbased on the validTo field. Other solutions might involve usingcert-manager in Kubernetes or OpenShift, backed by the OpenBao CA.  ","version":"Next","tagName":"h2"},{"title":"Safe minimums​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#safe-minimums","content":" Since its inception, this secrets engine has enforced SHA256 for signature hashes rather than SHA1. A minimum of 2048 bits for RSA keys is also enforced. Software that can handle SHA256 signatures should also be able to handle 2048-bit keys, and 1024-bit keys are considered unsafe and are disallowed in the Internet PKI.  ","version":"Next","tagName":"h2"},{"title":"Token lifetimes and revocation​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#token-lifetimes-and-revocation","content":" When a token expires, it revokes all leases associated with it. This means that long-lived CA certs need correspondingly long-lived tokens, something that is easy to forget. Root and intermediate CA certs don't have associated leases, to prevent unintended revocation when not using a token with a long enough lifetime. To revoke these certificates, use the pki/revoke endpoint.  ","version":"Next","tagName":"h2"},{"title":"Safe usage of roles​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#safe-usage-of-roles","content":" The OpenBao PKI Secrets Engine supports many options to limit issuance viaRoles. Careful consideration of construction is necessary to ensure that more permissions are not given than necessary. Additionally, roles should generally do one thing; multiple roles should be preferable over having too permissive roles that allow arbitrary issuance (e.g., allow_any_name should generally be used sparingly, if at all).  allow_any_name should generally be set to false; this is the default.allow_localhost should generally be set to false for production services, unless listening on localhost is expected.Unless necessary, allow_wildcard_certificates should generally be set tofalse. This is not the default due to backwards compatibility concerns. This is especially necessary when allow_subdomains or allow_glob_domainsare enabled. enforce_hostnames should generally be enabled for TLS services; this is the default.allow_ip_sans should generally be set to false (but defaults to true), unless IP address certificates are explicitly required.When using short TTLs (&lt; 30 days) or with high issuance volume, it is generally recommend to set no_store to true (defaults to false). This prevents revocation but allows higher throughput as OpenBao no longer needs to store every issued certificate. This is discussed more in theReplicated Datasets section below.Do not use roles with root certificates (issuer_ref). Root certificates should generally only issue intermediates (see the section on CA hierarchy above), which doesn't rely on roles.Limit key_usage and ext_key_usage; don't attempt to allow all usages for all purposes. Generally the default values are useful for client and server TLS authentication.  ","version":"Next","tagName":"h2"},{"title":"Telemetry​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#telemetry","content":" Beyond OpenBao's default telemetry around request processing, PKI exposes count and duration metrics for the issue, sign, sign-verbatim, and revoke calls. The metrics keys take the form mount-path,operation,[failure] with labels for namespace and role name.  Note that these metrics are per-node and thus would need to be aggregated across nodes and clusters.  ","version":"Next","tagName":"h2"},{"title":"Auditing​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#auditing","content":" Because OpenBao HMACs audit string keys by default, it is necessary to tune PKI secrets mounts to get an accurate view of issuance that is occurring under this mount.  warning Note: Depending on usage of OpenBao, CRLs (and rarely, CA chains) can grow to be rather large. We don't recommend un-HMACing the crl field for this reason, but note that the recommendations below suggest to un-HMAC thecertificate response parameter, which the CRL can be served in via the /pki/cert/crl API endpoint. Additionally, the http_raw_body can be used to return CRL both in PEM and raw binary DER form, so it is suggested not to un-HMAC that field to not corrupt the log format. If this is done with only a syslog audit device, OpenBao can deny requests (with an opaque 500 Internal Error message) after the action has been performed on the server, because it was unable to log the message. The suggested workaround is to either leave the certificate and crlresponse fields HMACed and/or to also enable the fileaudit log type.  Some suggested keys to un-HMAC for requests are as follows:  csr - the requested CSR to sign,certificate - the requested self-signed certificate to re-sign or when importing issuers,Various issuance-related overriding parameters, such as: issuer_ref - the issuer requested to sign this certificate,common_name - the requested common name,alt_names - alternative requested DNS-type SANs for this certificate,other_sans - other (non-DNS, non-Email, non-IP, non-URI) requested SANs for this certificate,ip_sans - requested IP-type SANs for this certificate,uri_sans - requested URI-type SANs for this certificate,ttl - requested expiration date of this certificate,not_after - requested expiration date of this certificate,serial_number - the subject's requested serial number,key_type - the requested key type,private_key_format - the requested key format which is also used for the public certificate format as well, Various role- or issuer-related generation parameters, such as: ou - the subject's organizational unit,organization - the subject's organization,country - the subject's country code,locality - the subject's locality,province - the subject's province,street_address - the subject's street address,postal_code - the subject's postal code,permitted_dns_domains - permitted DNS domains,policy_identifiers - the requested policy identifiers when creating a role, andext_key_usage_oids - the extended key usage OIDs for the requested certificate.  Some suggested keys to un-HMAC for responses are as follows:  certificate - the certificate that was issued,issuing_ca - the certificate of the CA which issued the requested certificate,serial_number - the serial number of the certificate that was issued,error - to show errors associated with the request, andca_chain - optional due to noise; the full CA chain of the issuer of the requested certificate.  warning Note: These list of parameters to un-HMAC are provided as a suggestion and may not be exhaustive.  The following keys are suggested NOT to un-HMAC, due to their sensitive nature:  private_key - this response parameter contains the private keys generated by OpenBao during issuance, andpem_bundle this request parameter is only used on the issuer-import paths and may contain sensitive private key material.  ","version":"Next","tagName":"h2"},{"title":"Role-Based access​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#role-based-access","content":" OpenBao supports path-based ACL Policiesfor limiting access to various paths within OpenBao.  The following is a condensed example reference of ACLing the PKI Secrets Engine. These are just a suggestion; other personas and policy approaches may also be valid.  We suggest the following personas:  Operator; a privileged user who manages the health of the PKI subsystem; manages issuers and key material.Agent; a semi-privileged user that manages roles and handles revocation on behalf of an operator; may also handle delegated issuance. This may also be called an administrator or role manager.Advanced; potentially a power-user or service that has access to additional issuance APIs.Requester; a low-level user or service that simply requests certificates.Unauthed; any arbitrary user or service that lacks an OpenBao token.  For these personas, we suggest the following ACLs, in condensed, tabular form:  Path\tOperations\tOperator\tAgent\tAdvanced\tRequester\tUnauthed/ca(/pem)?\tRead\tYes\tYes\tYes\tYes\tYes /ca_chain\tRead\tYes\tYes\tYes\tYes\tYes /crl(/pem)?\tRead\tYes\tYes\tYes\tYes\tYes /crl/delta(/pem)?\tRead\tYes\tYes\tYes\tYes\tYes /cert/:serial(/raw(/pem)?)?\tRead\tYes\tYes\tYes\tYes\tYes /issuers\tList\tYes\tYes\tYes\tYes\tYes /issuer/:issuer_ref/(json¦der¦pem)\tRead\tYes\tYes\tYes\tYes\tYes /issuer/:issuer_ref/crl(/der¦/pem)?\tRead\tYes\tYes\tYes\tYes\tYes /issuer/:issuer_ref/crl/delta(/der¦/pem)?\tRead\tYes\tYes\tYes\tYes\tYes /ocsp/&lt;request&gt;\tRead\tYes\tYes\tYes\tYes\tYes /ocsp\tWrite\tYes\tYes\tYes\tYes\tYes /certs\tList\tYes\tYes\tYes\tYes /revoke-with-key\tWrite\tYes\tYes\tYes\tYes /roles\tList\tYes\tYes\tYes\tYes /roles/:role\tRead\tYes\tYes\tYes\tYes /(issue¦sign)/:role\tWrite\tYes\tYes\tYes\tYes /issuer/:issuer_ref/(issue¦sign)/:role\tWrite\tYes\tYes\tYes /config/auto-tidy\tRead\tYes\tYes /config/ca\tRead\tYes\tYes /config/crl\tRead\tYes\tYes /config/issuers\tRead\tYes\tYes /crl/rotate\tRead\tYes\tYes /crl/rotate-delta\tRead\tYes\tYes /roles/:role\tWrite\tYes\tYes /issuer/:issuer_ref\tRead\tYes\tYes /sign-verbatim(/:role)?\tWrite\tYes\tYes /issuer/:issuer_ref/sign-verbatim(/:role)?\tWrite\tYes\tYes /revoke\tWrite\tYes\tYes /tidy\tWrite\tYes\tYes /tidy-cancel\tWrite\tYes\tYes /tidy-status\tRead\tYes\tYes /config/auto-tidy\tWrite\tYes /config/ca\tWrite\tYes /config/crl\tWrite\tYes /config/issuers\tWrite\tYes /config/keys\tRead, Write\tYes /config/urls\tRead, Write\tYes /issuer/:issuer_ref\tWrite\tYes /issuer/:issuer_ref/revoke\tWrite\tYes /issuer/:issuer_ref/sign-intermediate\tWrite\tYes /issuer/issuer_ref/sign-self-issued\tWrite\tYes /issuers/generate/+/+\tWrite\tYes /issuers/import/+\tWrite\tYes /intermediate/generate/+\tWrite\tYes /intermediate/cross-sign\tWrite\tYes /intermediate/set-signed\tWrite\tYes /keys\tList\tYes /key/:key_ref\tRead, Write\tYes /keys/generate/+\tWrite\tYes /keys/import\tWrite\tYes /root/generate/+\tWrite\tYes /root/sign-intermediate\tWrite\tYes /root/sign-self-issued\tWrite\tYes /root/rotate/+\tWrite\tYes /root/replace\tWrite\tYes   ","version":"Next","tagName":"h2"},{"title":"Cluster scalability​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#cluster-scalability","content":" Most non-introspection operations in the PKI secrets engine require a write to storage, and so are forwarded to the cluster's active node for execution. This table outlines which operations can be executed on performance standby nodes and thus scale horizontally across all nodes within a cluster.  Path\tOperationsca[/pem]\tRead cert/serial-number\tRead cert/ca_chain\tRead config/crl\tRead certs\tList ca_chain\tRead crl[/pem]\tRead issue\tUpdate * revoke/serial-number\tRead sign\tUpdate * sign-verbatim\tUpdate *  * Only if the corresponding role has no_store set to true and generate_leaseset to false. If generate_lease is true the lease creation will be forwarded to the active node; if no_store is false the entire request will be forwarded to the active node.  ","version":"Next","tagName":"h2"},{"title":"PSS support​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#pss-support","content":" Go lacks support for PSS certificates, keys, and CSRs using the rsaPSS OID (1.2.840.113549.1.1.10). It requires all RSA certificates, keys, and CSRs to use the alternative rsaEncryption OID (1.2.840.113549.1.1.1).  When using OpenSSL to generate CAs or CSRs from PKCS8-encoded PSS keys, the resulting CAs and CSRs will have the rsaPSS OID. Go and OpenBao will reject them. Instead, use OpenSSL to generate or convert to a PKCS#1v1.5 private key file and use this to generate the CSR. OpenBao will, depending on the role and the signing mechanism, still use a PSS signature despite thersaEncryption OID on the request as the SubjectPublicKeyInfo and SignatureAlgorithm fields are orthogonal. When creating an external CA and importing it into OpenBao, ensure that the rsaEncryption OID is present on the SubjectPublicKeyInfo field even if the SignatureAlgorithm is PSS-based.  These certificates generated by Go (with rsaEncryption OID but PSS-based signatures) are otherwise compatible with the fully PSS-based certificates. OpenSSL and NSS support parsing and verifying chains using this type of certificate. Note that some TLS implementations may not support these types of certificates if they do not support rsa_pss_rsae_* signature schemes. Additionally, some implementations allow rsaPSS OID certificates to contain restrictions on signature parameters allowed by this certificate, but Go and OpenBao do not support adding such restrictions.  Go additionally lacks support for creating OCSP responses with the PSS signature algorithm. OpenBao will automatically downgrade issuers with PSS-based revocation signature algorithms to PKCS#1v1.5, but note that certain KMS devices (like HSMs and GCP) may not support this with the same key. As a result, the OCSP responder may fail to sign responses, returning an internal error.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#tutorial","content":" Refer to the Build Your Own Certificate Authority (CA)guide for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PKI secrets engine - considerations","url":"/openbao/docs/secrets/pki/considerations/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"PKI secrets engine - rotation primitives","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/rotation-primitives/","content":"","keywords":"","version":"Next"},{"title":"X.509 certificate fields​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#x509-certificate-fields","content":" X.509 is a complex specification; modern implementations tend to refer toRFC 5280 for specific details. For validation of certificates, both RFC 5280 and the TLS validation RFC 6125 are important for understanding how to achieve rotation.  The following is a simplification of these standards for the purpose of this document.  Every X.509 certificate begins with an asymmetric key pair, using an algorithm like RSA or ECDSA. This key pair is used to create a Certificate Signing Request (CSR), which contains a set of fields the requester would like in the final certificate (but, it is up to the Certificate Authority (CA) to decide what fields to take from the CSR and which to override). The CSR also contains the public key of the pair, which is signed by the private key of the key pair to prove possession. Usually, the requester would ask for attributes in the Subject field of the CSR or in the Subject Alternative Name extension CSR to be respected in the final certificate. It is up to the CA if these values are trusted or not. When approved by the issuing authority (which may be backed by this asymmetric key itself in the case of a root self-signed certificate), the authority attaches the Subject of its certificate to the issued certificate in the Issuer field, assigns a unique serial number to the issued certificate, and signs the set of fields with its private key, thus creating the certificate.  There are some important restrictions here:  One certificate can only have one Issuer, but this issuer is identified by the Subject on the issuing certificate and its public key.One key pair can be used for multiple certificates, but one certificate can only have one backing key material.  The following fields on the final certificate are relevant to rotation:  The backing publicand private key material (Subject Public Key Info). Note that the private key is not included in the certificate but is uniquely determined by the public key material. The Subject of the certificate. This identifies the entity to which the certificate was issued. While the SAN values (in the Subject Alternative Nameextension) is useful when validating TLS Server certificates against the negotiated hostname and URI, it isn't generally relevant for the purposes of validating intermediate certificate chains or in rotation. The Validityperiod of this certificate. Notably, RFC 5280 does not place any requirements around the issued certificate's validity period relative to the validity period of the issuing certificate. However, it does statethat certificates ought to be revoked if their status cannot be maintained up to their notAfter date. This is why OpenBao's /pki/issuer/:issuer_refconfiguration endpoint maintains the leaf_not_after_behavior per-issuer rather than per-role.Additionally, some browsers will place ultimate trust in the certificates in their trust stores, even when these certificates are expired. Note that this only applies to certificates in the trust store; validity periods will still be enforced for certificates not in the store (such as intermediates). The Issuer andsignatureValueof this certificate. In the issued certificate's Issuer field, the issuing certificate places its own Subject value. This allows the issuer to be identified later (without having to try signature validation against every known local certificate), when validating the presented certificate and chain.The signature over the entire certificate (by the issuer's private key) is then placed in the signatureValue field. The optional Authority Key Identifierfield. This field can contain either (or both) of two values: The hash of the issuer's public key. This extension is set and this value is filled in by OpenBao.The Issuer's Subject and Serial Number. This value is not set by OpenBao. The latter is a dangerous restriction for the purposes of rotation: it prevents cross-signing and reissuance as the new issuing certificates (while having the same backing key material) will have different serial numbers. See the Limitations of Primitivessection below for more information on this restriction. The Serial Numberof this certificate. This field is unique to a specific issuer; when a certificate is reissued by its parent authority, it will always have a different serial number field. The CRL distributionpoint field. This is a field detailing where a CRL is expected to exist for this certificate and under which CRL issuers (defaulting to the issuing certificate itself) the CRL is expected to be signed by. This is mostly informational and for server software like nginx, OpenBao's Cert Auth method, and Apache, CRLs are provided to the server, rather than having the server fetch CRLs for certificates automatically.Note that root certificates (in browsers trust stores) are generally not considered revocable. However, if an intermediate is revoked by serial, it will appear on its parent's CRL, and may prevent rotation from happening.  ","version":"Next","tagName":"h2"},{"title":"X.509 rotation primitives​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#x509-rotation-primitives","content":" Rotation (from an organizational standpoint) can only safely happen with certain intermediate X.509 certificates being issued. To distinguish the two types of certificates used to achieve rotation, this document notates them as primitives.  Rotation of an end-entity certificate is trivial from an X.509 trust chain perspective; this process happens every day and should only depend on what is in the trust store and not the end-entity certificate itself. In OpenBao, the requester would hit the various issuance endpoints (/pki/issue/:name or/pki/sign/:name -- or use the unsafe /pki/sign-verbatim) and swap out the old certificate with the new certificate and reload the configuration or restart the service. Other parts of the organizations might useACME for certificate issuance and rotation, especially if the service is public-facing (and thus needs to be issued by a Public CA). Given it was signed by a trusted root, any devices connecting to the service would not know the difference.  Rotation of intermediate certificates is almost as easy. Assuming a decent operational setup (wherein during end-entity issuance, the full certificate chain is updated in the service's configuration), this should be as easy as creating a new intermediate CA, signing it against the root CA, and then beginning issuance against the new intermediate certificate. In OpenBao, if the intermediate is generated in an existing mount path (or is moved into such), the requesting entity shouldn't care much. Under ACME, Let's Encrypt has successfully rotated intermediates to present a cross-signed chain (for older Android devices). Assuming the old intermediate's parent(s) are still valid and trusted, certificates issued under old intermediates should continue to validate.  The hard part of rotation--calling for the use of these primitives--is rotating root certificates. These live in every device's trust store and are hard to update from an organization-wide operational perspective. Unless the organization can swap out roots almost instantaneously and simultaneously (e.g., via an agent) with no missed devices, this process will likely span months.  To make this process lower risk, there are various primitive certificate types that use the above certificate fields. Key to their success is the following note:  warning Note: While certificates are added to the trust store, it is ultimately the associated key material that determines trust: two issuer certificates with the same subject but different public keys cannot validate the same leaf certificate; only if the keys are the same can this occur.  ","version":"Next","tagName":"h2"},{"title":"Cross-Signed primitive​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#cross-signed-primitive","content":" This is the most common type of rotation primitive. A common CSR is signed by two CAs, resulting in two certificates. These certificates must have the same Subject (but may have different Issuers and will have different Serial Numbers) and the same backing key material, to allow certificates they sign to be trusted by either variant.  Note that, due to restrictions in how end-entity certificates are used and validated (services and validation libraries expect only one), cross-signing most typically only applies to intermediate.  A note on Cross-Signed roots​  Technically, cross-signing can occur between two roots, allowing trust bundles with either root to validate certs issued through the other. However, this process creates a certificate that is effectively an intermediate (as it is no longer self-signed) and usually must be served alongside the trust chain. Given this restriction, it's preferable to instead cross-sign the top-level intermediates under the root unless strictly necessary when the old root certificate has been used to directly issue leaf certificates.  So, the rest of this process flow assumes an intermediate is being cross-signed as this is more common.  Process flow​   ------------------- | generate key pair | -------------&gt; ... ------------------- ... | | ... -------------- -------------- ... | generate CSR | | generate CSR | ... -------------- -------------- ... | | ... ----------- ----------- ... | signed by | | signed by | ... | root A | | root B | ... ----------- ----------- ...   Here, a key pair was generated at some point in time. Two CSRs are created and sent to two different root authorities (Root A and Root B). These result in two separate certificates (potentially with different validity periods) with the same Subject and same backing key material.  Note that this cross-signing need not happen simultaneously; there could be a gap of several years between the first and second certificate. Additionally, there's no limit on the number of cross-signed &quot;duplicate&quot; (used loosely--with the same subject and key material) certificates: this could be cross-signed by many different root certificates if necessary and desired.  Certificate hierarchy​   -------- -------- | root A | | root B | -------- -------- | | ---------------- ---------------- | intermediate C | &lt;- same key material -&gt; | intermediate D | ---------------- | ---------------- | ------------------- | leaf certificates | -------------------   The above process results in two trust paths: either of root A or root B (or both) could exist in the client's trust stores and the leaf certificate would validate correctly. Because the same key material is used for both intermediate certificates (C and D), the issued leaf certificate's signature field would be the same regardless of which intermediate was contacted.  Cross-signing is thus a unifying primitive; two separate trust paths now join into a single one, by having leaf certificate's issuer field to point to two separate paths (via duplication of the certificate in the chain) and would be conditionally validated based on which root is present in the trust store.  This construct is documented and used in several places:  https://letsencrypt.org/certificates/https://scotthelme.co.uk/cross-signing-alternate-trust-paths-how-they-work/https://security.stackexchange.com/questions/14043/what-is-the-use-of-cross-signing-certificates-in-x-509  Execution in OpenBao​  To create a cross-signed certificate in OpenBao, use the /intermediate/cross-signendpoint. Here, when creating a cross-signature to all cert B to be validated by cert A, provide the values (key_ref, all Subject parts, &amp;c) for cert B during intermediate generation. Then sign this CSR (using the /issuer/:issuer_ref/sign-intermediateendpoint) with cert A's reference and provide necessary values from cert B (e.g., Subject parts). cert A may live outside OpenBao. Finally, import the cross-signed certificate into OpenBaousing the /issuers/import/cert endpoint.  If this process succeeded, and both cert A and cert B and their key material lives in OpenBao, the newly imported cross-signed certificate will have a ca_chain response field during readcontaining cert A, and cert B's ca_chain will contain the cross-signed cert and its ca_chain value.  warning Note: Regardless of issuer type, is important to provide all relevant parameters as they were originally; OpenBao does not infer e.g., the Subject name parameters from the existing issuer; it merely reuses the same key material.  Notes on manual_chain​  If an intermediate is cross-signed and imported into the same mount as its pair, OpenBao will not detect the cross-signed pairs during automatic chain building. As a result, leaf issuance will have a chain that only includes one of these pairs of chains. This is because the leaf issuance's ca_chainparameter copies the value from signing issuer directly, rather than computing its own copy of the chain.  To fix this, update the manual_chain field on the issuersto include the chains of both pairs. For instance, given intA signed byrootA and intB signed by rootB as its cross-signed version, one could do the following:  $ bao patch pki/issuer/intA manual_chain=self,rootA,intB,rootB $ bao patch pki/issuer/intB manual_chain=self,rootB,intA,rootA   This will ensure that issuance with either copy of the intermediate reports the full cross-signed chain when signing leaf certs.  ","version":"Next","tagName":"h3"},{"title":"Reissuance primitive​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#reissuance-primitive","content":" The second most common type of rotation primitive. In this scheme, the existing key material is used to generate a new certificate, usually at a much later point in time from the existing issuance.  While similar to the cross-signed primitive, this one differs in that usually the reissuance happens after the original certificate expires or is close to expiration and is reissued by the original root CA. In the event of a self-signed certificate (e.g., a root certificate), this parent certificate would be itself. In both cases, this changes the contents of the certificate (due to the new serial number) but allows all existing leaf signatures to still validate.  Unlike the cross-signed primitive, this primitive type can be used on all types of certificates (including leaves, intermediates, and roots).  Process flow​   ------------------- | generate key pair | ---------------&gt; ... ------------------- ... | | ... -------------- -------------- ... | generate CSR | &lt;-&gt; | generate CSR | ... -------------- -------------- ... | | ... ------------------ ------------------ ... | signed by issuer | -&gt; | signed by issuer | -&gt; ... ------------------ ------------------ ...   In this process flow, a single key pair is generated at some point in time and stored. The CSR (with same requested fields) is generated from this common key material and signed by the same issuer at multiple points in time, preserving all critical fields (Subject, Issuer, &amp;c). While there is strictly no limit on the number of times a key can be reissued, at some point safety would dictate the key material should be rotated instead of being continually reissued.  Certificate hierarchy​   ------ -----------| root |------------- / ------ \\ | | --------------- --------------- | original cert | &lt;- same key material -&gt; | reissued cert | --------------- | --------------- | ------------------- | leaf certificates | -------------------   Note that while this again results in two trust paths, depending on which intermediate certificate is presented and is still valid, only a root need be trusted. When a reissued certificate is a root certificate, the issuance link is simply self-loop. But, in this case, note that both certificates are (technically) valid issuers of each other. This means it should be possible to provide a reissued root certificate in the TLS certificate chain and have it chain back to an existing root certificate in a trust store.  This primitive type is thus an incrementing primitive; the life cycle of an existing key is extended into the future by issuing a new certificate with the same key material from the existing authority.  Execution in OpenBao​  To create a reissued root certificate in OpenBao, use /issuers/generate/root/existingendpoint. This allows the generation of a new root certificate with the existing key material (via the key_ref request parameter). If this process succeeded, when reading the issuer(via GET /issuer/:issuer_ref), both issuers (old and reissued) will appear in each others' ca_chain response field (unless prevented so by a manual_chainvalue).  To create a reissued intermediate certificate in OpenBao, this is a three step process:  Use the /issuers/generate/intermediate/existingendpointto generate a new CSR with the existing key material with the key_refrequest parameter.Sign this CSR via the same signing process under the same issuer. This step is specific to the parent CA, which may or may not be OpenBao.Finally, use the /intermediate/set-signed endpointto import the signed certificate from step 2.  If the process to reissue an intermediate certificate succeeded, whenreading the issuer (viaGET /issuer/:issuer_ref), both issuers (old and reissued) will have the same ca_chain response field, except for the first entry (unless prevented so by a manual_chain value).  warning Note: Regardless of issuer type, is important to provide all relevant parameters as they were originally; OpenBao does not infer e.g., the Subject name parameters from the existing issuer; it merely reuses the same key material.  ","version":"Next","tagName":"h3"},{"title":"Temporal primitives​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#temporal-primitives","content":" We can use the above primitive types to rotate roots and intermediates to new keys and extend their lifetimes. This time-based rotation is what ultimately allows us to rotate root certificates.  There's two main variants of this: a forward primitive, wherein an old certificate is used to bless new key material, and a backwards primitive, wherein a new certificate is used to bless old key material. Both of these primitives are independently used by Let's Encrypt in the aforementioned chain of trust document:  The link from DST Root CA X3 to ISRG Root X1 is an example of a forward primitive.The link from ISRG Root X1 to R3 (which was originally signed by DST Root CA X3) is an example of a backwards primitive.  For most organizations with a hierarchical structured CA setup, cross-signing all intermediates with both the new and old root CAs is sufficient for root rotation.  However, for organizations which have directly issued leaf certificates from a root, the old root will need to be reissued under the new root (with shorter duration) to allow these certificates to continue to validate. This combines both of the above primitives (cross-signing and reissuance) into a single backwards primitive step. In the future, these organizations should probably move to a more standard, hierarchical setup.  ","version":"Next","tagName":"h3"},{"title":"Limitations of primitives​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#limitations-of-primitives","content":" The certificate's Authority Key Identifierextension field may contain either or both of the issuer's keyIdentifier (a hash of the public key) or both the issuer's Subject and Serial Number fields. Generating certificates with the latter enabled (luckily not possible in OpenBao, especially so since OpenBao uses strictly random serial numbers) prevents building a proper cross-signed chain without re-issuing the same serial number, which will not work with most browsers' trust stores and validation engines, due to caching of certificatesused in successful validations. In the strictest sense, when using a cross-signing primitive (from a different CA), the intermediate could be reissued with the same serial number, assuming no previous certificate was issued by that CA with that serial. This does not work when using a reissuance primitive as these are technically the same authority and thus this authority must issue certificates with unique serial numbers.  ","version":"Next","tagName":"h3"},{"title":"Suggested root rotation procedure​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#suggested-root-rotation-procedure","content":" The following is a suggested process for achieving root rotation easily and without (outage) impact to the broader organization, assuming best practices are being followed. Some adaption will be necessary.  Note that this process takes time. How much time is dependent on the automation level and operational awareness of the organization.  Generate the new root certificate. For clarity, it is suggested to use a new common name to distinguish it from the old root certificate. Key material need not be the same. Cross-sign all existing intermediates. It is important to update the manual chain on the issuers as discussed in that section, as we assume servers are configured to combine thecertificate field with the ca_chain field on renewal and issuance, thus getting the cross-signed intermediates. Encourage rotation to pickup the new cross-signed intermediates. With short-lived certificates, this should happen automatically. However, for some long-lived certs, it is suggested to rotate them manually and proactively. This step takes time, and depends on the types of certificates issued (e.g., server certs, code signing, or client auth). Once all chains have been updated, new systems can be brought online with only the new root certificate, and connect to all existing systems. Existing systems can now be migrated with a one-shot root switch: the new root can be added and the old root can be removed at the same time. Assuming the above step 3 can be achieved in a reasonable amount of time, this decreases the time it takes to move the majority of systems over to fully using the new root and no longer trusting the old root. This step also takes time, depending on how quickly the organization can migrate roots and ensure all such systems are migrated. If some systems are offline and only infrequently online (or, if they have hard-coded certificate stores and need to reach obsolescence first), the organization might not be ready to move on to future steps. At this point, since all systems now use the new root, it is safe to remove or archive the old root and intermediates, updating the manual chain to point strictly to the new intermediate+root.  At this point, rotation is fully completed.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#tutorial","content":" Refer to the Build Your Own Certificate Authority (CA)guide for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PKI secrets engine - rotation primitives","url":"/openbao/docs/secrets/pki/rotation-primitives/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"PKI secrets engine - setup and usage","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/setup/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"PKI secrets engine - setup and usage","url":"/openbao/docs/secrets/pki/setup/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  Enable the PKI secrets engine: $ bao secrets enable pki Success! Enabled the pki secrets engine at: pki/ By default, the secrets engine will mount at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Increase the TTL by tuning the secrets engine. The default value of 30 days may be too short, so increase it to 1 year: $ bao secrets tune -max-lease-ttl=8760h pki Success! Tuned the secrets engine at: pki/ Note that individual roles can restrict this value to be shorter on a per-certificate basis. This just configures the global maximum for this secrets engine. Configure a CA certificate and private key. OpenBao can accept an existing key pair, or it can generate its own self-signed root. In general, we recommend maintaining your root CA outside of OpenBao and providing OpenBao a signed intermediate CA. $ bao write pki/root/generate/internal \\ common_name=my-website.com \\ ttl=8760h Key Value --- ----- certificate -----BEGIN CERTIFICATE-----... expiration 1536807433 issuing_ca -----BEGIN CERTIFICATE-----... serial_number 7c:f1:fb:2c:6e:4d:99:0e:82:1b:08:0a:81:ed:61:3e:1d:fa:f5:29 The returned certificate is purely informative. The private key is safely stored internally in OpenBao. Update the CRL location and issuing certificates. These values can be updated in the future. $ bao write pki/config/urls \\ issuing_certificates=&quot;http://127.0.0.1:8200/v1/pki/ca&quot; \\ crl_distribution_points=&quot;http://127.0.0.1:8200/v1/pki/crl&quot; Success! Data written to: pki/config/urls Configure a role that maps a name in OpenBao to a procedure for generating a certificate. When users or machines generate credentials, they are generated against this role: $ bao write pki/roles/example-dot-com \\ allowed_domains=my-website.com \\ allow_subdomains=true \\ max_ttl=72h Success! Data written to: pki/roles/example-dot-com   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"PKI secrets engine - setup and usage","url":"/openbao/docs/secrets/pki/setup/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by writing to the /issue endpoint with the name of the role: $ bao write pki/issue/example-dot-com \\ common_name=www.my-website.com Key Value --- ----- certificate -----BEGIN CERTIFICATE-----... issuing_ca -----BEGIN CERTIFICATE-----... private_key -----BEGIN RSA PRIVATE KEY-----... private_key_type rsa serial_number 1d:2e:c6:06:45:18:60:0e:23:d6:c5:17:43:c0:fe:46:ed:d1:50:be The output will include a dynamically generated private key and certificate which corresponds to the given role and expires in 72h (as dictated by our role definition). The issuing CA and trust chain is also returned for automation simplicity.  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"PKI secrets engine - setup and usage","url":"/openbao/docs/secrets/pki/setup/#tutorial","content":" Refer to the Build Your Own Certificate Authority (CA)guide for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"PKI secrets engine - setup and usage","url":"/openbao/docs/secrets/pki/setup/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"Troubleshoot PKI Secrets Engine and ACME","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/pki/troubleshooting-acme/","content":"","keywords":"","version":"Next"},{"title":"Error: Unable to register an account with the ACME server​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#error-unable-to-register-an-account-with-the-acme-server","content":" ","version":"Next","tagName":"h2"},{"title":"Symptoms​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#symptoms","content":" When registering a new account without an External Account Binding (EAB), the OpenBao Server rejects the request with a response like:  Unable to register an account with ACME server  with further information provided in the debug logs (in the case ofcertbot):  Server requires external account binding.  or, if the client incorrectly contacted the server, an error like:  The request must include a value for the 'externalAccountBinding' field  In either case, a new account needs to be created with an EAB token created by OpenBao.  ","version":"Next","tagName":"h3"},{"title":"Cause​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#cause","content":" If a server has been updated to require eab_policy=always-required in theACME configuration, new account registration (and reuse of existing accounts will fail).  ","version":"Next","tagName":"h3"},{"title":"Resolution​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#resolution","content":" Using an OpenBao token, fetch a new external account binding for the desired directory:  $ bao write -f pki/roles/my-role-name/acme/new-eab ... directory roles/my-role-name/acme/directory id bc8088d9-3816-5177-ae8e-d8393265f7dd key MHcCAQE... additional data elided ... ...   Then pass this new EAB token into the ACME client. For example, withcertbot:  $ certbot [... additional parameters ...] \\ --server https://cluster-b.openbao.example.com/v1/pki/roles/my-role-name/acme/directory \\ --eab-kid bc8088d9-3816-5177-ae8e-d8393265f7dd \\ --eab-hmac-key MHcCAQE... additional data elided ...   Ensure that the ACME directory passed to the ACME client matches that fetched from the OpenBao.  ","version":"Next","tagName":"h3"},{"title":"Error: Failed to verify eab​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#error-failed-to-verify-eab","content":" ","version":"Next","tagName":"h2"},{"title":"Symptoms​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#symptoms-1","content":" When initializing a new account against this OpenBao server, the ACME client might error with a message like:  The client lacks sufficient authorization :: failed to verify eab  This is caused by requesting an EAB from a directory not matching the one the client used.  ","version":"Next","tagName":"h3"},{"title":"Cause​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#cause-1","content":" If an EAB account token is incorrectly used with the wrong directory, the ACME server will reject the request with an error about insufficient permissions.  ","version":"Next","tagName":"h3"},{"title":"Resolution​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#resolution-1","content":" Ensure the requested EAB token matches the directory. For a given directory at /some/path/acme/directory, fetch EAB tokens from/some/path/amce/new-eab. The remaining resolution steps are the same as for debugging account registration failures.  ","version":"Next","tagName":"h3"},{"title":"Error: ACME validation failed for {challenge_id}​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#error-acme-validation-failed-for-challenge_id","content":" ","version":"Next","tagName":"h2"},{"title":"Symptoms​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#symptoms-2","content":" When viewing the OpenBao server logs or attempting to fetch a certificate via an ACME client, an error like:  ACME validation failed for a465a798-4400-6c17-6735-e1b38c23de38-tls-alpn-01: ...  indicates that the server was unable to validate this challenge accepted by the client.  ","version":"Next","tagName":"h3"},{"title":"Cause​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#cause-2","content":" OpenBao can not verify the server's identity through the client's requestedchallenge type (dns-01,http-01, or tls-alpn-01). OpenBao will not issue the certificate requested by the client.  ","version":"Next","tagName":"h3"},{"title":"Resolution​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#resolution-2","content":" Ensure that DNS is configured correctly from the OpenBao server's perspective, including setting any custom DNS resolver.  Ensure that any firewalls are set up to allow OpenBao to talk to the relevant systems (the DNS server in the case of dns-01, port 80 on the target machine for http-01, or port 443 on the target machine for tls-alpn-01challenges).  ","version":"Next","tagName":"h3"},{"title":"Error: The client lacks sufficient authorization: account in status: revoked​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#error-the-client-lacks-sufficient-authorization-account-in-status-revoked","content":" ","version":"Next","tagName":"h2"},{"title":"Symptoms​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#symptoms-3","content":" When attempting to renew a certificate, the ACME client reports an error:  The client lacks sufficient authorization: account in status: revoked  ","version":"Next","tagName":"h3"},{"title":"Cause​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#cause-3","content":" If you run a manual tidy or haveauto-tidy enabled with `tidy_acme=true, OpenBao will periodically remove stale ACME accounts.  Connections from clients using removed accounts will be rejected.  ","version":"Next","tagName":"h3"},{"title":"Resolution​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#resolution-3","content":" Refer to the ACME client's documentation for removing cached local configuration and setup a new account, specifying any EABs as required.  ","version":"Next","tagName":"h3"},{"title":"Get help​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#get-help","content":" Please provide the following information when contacting Hashicorp Support or filing a GitHub issue to help with our investigation and reproducibility:  ACME client name and versionACME client logs and/or outputOpenBao server DEBUG level logs  ","version":"Next","tagName":"h2"},{"title":"Tutorial​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#tutorial","content":" Refer to the Build Your Own Certificate Authority (CA)guide for a step-by-step tutorial.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Troubleshoot PKI Secrets Engine and ACME","url":"/openbao/docs/secrets/pki/troubleshooting-acme/#api","content":" The PKI secrets engine has a full HTTP API. Please see thePKI secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"RabbitMQ secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/rabbitmq/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"RabbitMQ secrets engine","url":"/openbao/docs/secrets/rabbitmq/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  Enable the RabbitMQ secrets engine: $ bao secrets enable rabbitmq Success! Enabled the rabbitmq secrets engine at: rabbitmq/ By default, the secrets engine will mount at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure the credentials that OpenBao uses to communicate with RabbitMQ to generate credentials: $ bao write rabbitmq/config/connection \\ connection_uri=&quot;http://localhost:15672&quot; \\ username=&quot;admin&quot; \\ password=&quot;password&quot; Success! Data written to: rabbitmq/config/connection It is important that the OpenBao user have the administrator privilege to manager users. Configure a role that maps a name in OpenBao to virtual host permissions: $ bao write rabbitmq/roles/my-role \\ vhosts='{&quot;/&quot;:{&quot;write&quot;: &quot;.*&quot;, &quot;read&quot;: &quot;.*&quot;}}' Success! Data written to: rabbitmq/roles/my-role By writing to the roles/my-role path we are defining the my-role role. This role will be created by evaluating the given vhosts, vhost_topicsand tags statements. By default, no tags, no virtual hosts or topic permissions are assigned to a role. If no topic permissions are defined and the default authorisation backend is used, publishing to a topic exchange or consuming from a topic is always authorised. You can read more about RabbitMQ management tagsand RabbitMQ topic authorization.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"RabbitMQ secrets engine","url":"/openbao/docs/secrets/rabbitmq/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new credential by reading from the /creds endpoint with the name of the role: $ bao read rabbitmq/creds/my-role Key Value --- ----- lease_id rabbitmq/creds/my-role/I39Hu8XXOombof4wiK5bKMn9 lease_duration 768h lease_renewable true password 3yNDBikgQvrkx2VA2zhq5IdSM7IWk1RyMYJr username root-39669250-3894-8032-c420-3d58483ebfc4 Using ACLs, it is possible to restrict using the rabbitmq secrets engine such that trusted operators can manage the role definitions, and both users and applications are restricted in the credentials they are allowed to read.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"RabbitMQ secrets engine","url":"/openbao/docs/secrets/rabbitmq/#api","content":" The RabbitMQ secrets engine has a full HTTP API. Please see theRabbitMQ secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"SSH secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/ssh/","content":"","keywords":"","version":"Next"},{"title":"API​","type":1,"pageTitle":"SSH secrets engine","url":"/openbao/docs/secrets/ssh/#api","content":" The SSH secrets engine has a full HTTP API. Please see theSSH secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"One-Time SSH passwords","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/","content":"","keywords":"","version":"Next"},{"title":"Drawbacks​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#drawbacks","content":" The main concern with the OTP secrets engine type is the remote host's connection to OpenBao; if compromised, an attacker could spoof the OpenBao server returning a successful request. This risk can be mitigated by using TLS for the connection to OpenBao and checking certificate validity; future enhancements to this secrets engine may allow for extra security on top of what TLS provides.  ","version":"Next","tagName":"h3"},{"title":"Mount the secrets engine​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#mount-the-secrets-engine","content":" $ bao secrets enable ssh Successfully mounted 'ssh' at 'ssh'!   ","version":"Next","tagName":"h3"},{"title":"Create a role​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#create-a-role","content":" Create a role with the key_type parameter set to otp. All of the machines represented by the role's CIDR list should have helper properly installed and configured.  $ bao write ssh/roles/otp_key_role \\ key_type=otp \\ default_user=username \\ cidr_list=x.x.x.x/y,m.m.m.m/n Success! Data written to: ssh/roles/otp_key_role   ","version":"Next","tagName":"h3"},{"title":"Create a credential​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#create-a-credential","content":" Create an OTP credential for an IP of the remote host that belongs tootp_key_role.  $ bao write ssh/creds/otp_key_role ip=x.x.x.x Key Value lease_id ssh/creds/otp_key_role/73bbf513-9606-4bec-816c-5a2f009765a5 lease_duration 600 lease_renewable\tfalse port 22 username username ip x.x.x.x key 2f7e25a2-24c9-4b7b-0d35-27d5e5203a5c key_type otp   ","version":"Next","tagName":"h3"},{"title":"Establish an SSH session​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#establish-an-ssh-session","content":" $ ssh username@x.x.x.x Password: &lt;Enter OTP&gt; username@x.x.x.x:~$   ","version":"Next","tagName":"h3"},{"title":"Automate it!​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#automate-it","content":" A single CLI command can be used to create a new OTP and invoke SSH with the correct parameters to connect to the host.  $ bao ssh -role otp_key_role -mode otp username@x.x.x.x OTP for the session is `b4d47e1b-4879-5f4e-ce5c-7988d7986f37` [Note: Install `sshpass` to automate typing in OTP] Password: &lt;Enter OTP&gt;   The OTP will be entered automatically using sshpass if it is installed.  $ bao ssh -role otp_key_role -mode otp -strict-host-key-checking=no username@x.x.x.x username@&lt;IP of remote host&gt;:~$   Note: sshpass cannot handle host key checking. Host key checking can be disabled by setting -strict-host-key-checking=no.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#tutorial","content":" Refer to the SSH Secrets Engine: One-Time SSH Password tutorial to learn how to use the OpenBao SSH secrets engine to secure authentication and authorization for access to machines.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"One-Time SSH passwords","url":"/openbao/docs/secrets/ssh/one-time-ssh-passwords/#api","content":" The SSH secrets engine has a full HTTP API. Please see theSSH secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"TOTP secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/totp/","content":"","keywords":"","version":"Next"},{"title":"As a generator​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#as-a-generator","content":" The TOTP secrets engine can act as a TOTP code generator. In this mode, it can replace traditional TOTP generators like Google Authenticator. It provides an added layer of security since the ability to generate codes is guarded by policies and the entire process is audited.  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  Enable the TOTP secrets engine: $ bao secrets enable totp Success! Enabled the totp secrets engine at: totp/ By default, the secrets engine will mount at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Configure a named key. The name of this key will be a human identifier as to its purpose. $ bao write totp/keys/my-key \\ url=&quot;otpauth://totp/OpenBao:test@test.com?secret=Y64VEVMBTSXCYIWRSHRNDZW62MPGVU2G&amp;issuer=OpenBao&quot; Success! Data written to: totp/keys/my-key The url corresponds to the secret key or value from the barcode provided by the third-party service.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can generate credentials.  Generate a new time-based OTP by reading from the /code endpoint with the name of the key: $ bao read totp/code/my-key Key Value --- ----- code 260610 Using ACLs, it is possible to restrict using the TOTP secrets engine such that trusted operators can manage the key definitions, and both users and applications are restricted in the credentials they are allowed to read.  ","version":"Next","tagName":"h3"},{"title":"As a provider​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#as-a-provider","content":" The TOTP secrets engine can also act as a TOTP provider. In this mode, it can be used to generate new keys and validate passwords generated using those keys.  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#setup-1","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  Enable the TOTP secrets engine: $ bao secrets enable totp Success! Enabled the totp secrets engine at: totp/ By default, the secrets engine will mount at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Create a named key, using the generate option. This tells OpenBao to be the provider: $ bao write totp/keys/my-user \\ generate=true \\ issuer=OpenBao \\ account_name=user@test.com Key Value --- ----- barcode iVBORw0KGgoAAAANSUhEUgAAAMgAAADIEAAAAADYoy0BA... url otpauth://totp/OpenBao:user@test.com?algorithm=SHA1&amp;digits=6&amp;issuer=OpenBao&amp;period=30&amp;secret=V7MBSK324I7KF6KVW34NDFH2GYHIF6JY The response includes a base64-encoded barcode and OTP url. Both are equivalent. Give these to the user who is authenticating with TOTP.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#usage-1","content":" As a user, validate a TOTP code generated by a third-party app: $ bao write totp/code/my-user code=886531 Key Value --- ----- valid true   ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"TOTP secrets engine","url":"/openbao/docs/secrets/totp/#api","content":" The TOTP secrets engine has a full HTTP API. Please see theTOTP secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"Key wrapping for transit key import","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/transit/key-wrapping-guide/","content":"","keywords":"","version":"Next"},{"title":"Mount the secrets engine​","type":1,"pageTitle":"Key wrapping for transit key import","url":"/openbao/docs/secrets/transit/key-wrapping-guide/#mount-the-secrets-engine","content":" $ bao secrets enable transit Success! Enabled the transit secrets engine at: transit/   ","version":"Next","tagName":"h3"},{"title":"Retrieve the transit wrapping key​","type":1,"pageTitle":"Key wrapping for transit key import","url":"/openbao/docs/secrets/transit/key-wrapping-guide/#retrieve-the-transit-wrapping-key","content":" $ bao read transit/wrapping_key   This returns a 4096-bit RSA key.  The steps after this depend on whether the key is stored using a software solution or in an HSM.  ","version":"Next","tagName":"h3"},{"title":"Software example (Go)​","type":1,"pageTitle":"Key wrapping for transit key import","url":"/openbao/docs/secrets/transit/key-wrapping-guide/#software-example-go","content":" This example assumes that the key is stored in software using the variable name key. It demonstrates how to wrap the target key using Golang crypto libraries.  Once you have the wrapping key, you can parse it using the encoding/pemand crypto/x509 libraries (the example code below assumes that the wrapping key has been written to a variable called wrappingKeyString):  keyBlock, _ := pem.Decode([]byte(wrappingKeyString)) parsedKey, err := x509.ParsePKIXPublicKey(keyBlock.Bytes) if err != nil { return err }   Then generate an ephemeral AES key for wrapping the target key. This example uses Golang's crypto/rand library for generating the key:  ephemeralAESKey := make([]byte, 32) _, err := rand.Read(ephemeralAESKey) if err != nil { return err }   warning NOTE: Be sure to securely delete the ephemeral AES key once it has been used!  Google's tink libraryprovides a function for performing the key wrap operation:  wrapKWP, err := subtle.NewKWP(aesKey) if err != nil { return err } wrappedTargetKey, err := wrapKWP.Wrap(key) if err != nil { return err }   Then encrypt the ephemeral AES key using the transit wrapping key:  wrappedAESKey, err := rsa.EncryptOAEP( sha256.New(), rand.Reader, wrappingKey, ephemeralAESKey, []byte{}, ) if err != nil { return err }   Note that though this example uses SHA256, OpenBao also supports the use of SHA1, SHA384, or SHA512. The hash function that was used at this step will need to be provided as a parameter when importing the key.  Finally, concatenate the wrapped keys into a single byte string. The leftmost 4096 bits of the string should be the wrapped AES key, and the remaining bits should be the wrapped target key. Then the resulting bytes should be base64-encoded.  combinedCiphertext := append(wrappedAESKey, wrappedTargetKey...) base64Ciphertext := base64.StdEncoding.EncodeToString(combinedCiphertext)   This is the ciphertext that should be provided to OpenBao when importing a key into the transit secrets engine.  $ bao write transit/keys/test-key/import ciphertext=$CIPHERTEXT hash_function=SHA256 type=$KEY_TYPE   ","version":"Next","tagName":"h3"},{"title":"AWS CloudHSM example​","type":1,"pageTitle":"Key wrapping for transit key import","url":"/openbao/docs/secrets/transit/key-wrapping-guide/#aws-cloudhsm-example","content":" This example demonstrates how to import a key into the transit secrets engine from an AWS CloudHSM cluster. The process and mechanisms used will apply to importing a key from an HSM in general, but the details will differ between HSMs.  For information on creating and communicating with an AWS CloudHSM cluster, see the Getting Started guide in the AWS CloudHSM documentation.  Communication with the HSM uses AWS's key_mgmt_util tool. For help setting that up, see the Getting Started page for key_mgmt_util.  The first step is writing the transit wrapping key to the HSM. This involves creating a new RSA public key object with the key returned by transit'swrapping_key endpoint.  $ importPubKey -f wrapping_key.pem -l &quot;openbao-transit-wrapping-key&quot;   This will create the public key in the HSM with all of the necessary permissions. If you're using a different tool, make sure that the usage for the wrapping key includes the attribute CKA_WRAP.  The next step is wrapping the target key using the wrapping key. If the ID of the target key is 1 and the wrapping key is 2, the command looks like this:  $ wrapKey -noheader -k 1 -w 2 -t 3 -m 7 -out ciphertext.key   The -m 7 flag specifies the mechanism to use for the key wrapping. For AWS CloudHSM, 7 corresponds to the PKCS11 mechanism CKM_AES_RSA_KEY_WRAP (see the AWS documentation for details). The -t 3 flag specifies SHA256 as the hash function. The result is written to a file called ciphertext.key. The noheader flag ensures that the ciphertext does not include an AWS-specific header.  The output from this is a binary file, which needs to be base64-encoded when it is provided to OpenBao.  $ export CIPHERTEXT=$(base64 ciphertext.key) $ bao write transit/keys/test-key/import ciphertext=$CIPHERTEXT hash_function=SHA256 type=$KEY_TYPE   Once the key has been imported, it can be used like any other transit key. ","version":"Next","tagName":"h3"},{"title":"Signed SSH certificates","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/","content":"","keywords":"","version":"Next"},{"title":"Client key signing​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#client-key-signing","content":" Before a client can request their SSH key be signed, the OpenBao SSH secrets engine must be configured. Usually an OpenBao administrator or security team performs these steps. It is also possible to automate these actions using a configuration management tool like Chef, Puppet, Ansible, or Salt.  ","version":"Next","tagName":"h2"},{"title":"Signing key & role configuration​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#signing-key--role-configuration","content":" The following steps are performed in advance by an OpenBao administrator, security team, or configuration management tooling.  Mount the secrets engine. Like all secrets engines in OpenBao, the SSH secrets engine must be mounted before use. $ bao secrets enable -path=ssh-client-signer ssh Successfully mounted 'ssh' at 'ssh-client-signer'! This enables the SSH secrets engine at the path &quot;ssh-client-signer&quot;. It is possible to mount the same secrets engine multiple times using different-path arguments. The name &quot;ssh-client-signer&quot; is not special - it can be any name, but this documentation will assume &quot;ssh-client-signer&quot;. Configure OpenBao with a CA for signing client keys using the /config/caendpoint. If you do not have an internal CA, OpenBao can generate a keypair for you. $ bao write ssh-client-signer/config/ca generate_signing_key=true Key Value --- ----- public_key ssh-rsa AAAAB3NzaC1yc2EA... If you already have a keypair, specify the public and private key parts as part of the payload: $ bao write ssh-client-signer/config/ca \\ private_key=&quot;...&quot; \\ public_key=&quot;...&quot; Regardless of whether it is generated or uploaded, the client signer public key is accessible via the API at the /public_key endpoint or the CLI (see next step). Add the public key to all target host's SSH configuration. This process can be manual or automated using a configuration management tool. The public key is accessible via the API and does not require authentication. $ curl -o /etc/ssh/trusted-user-ca-keys.pem http://127.0.0.1:8200/v1/ssh-client-signer/public_key $ bao read -field=public_key ssh-client-signer/config/ca &gt; /etc/ssh/trusted-user-ca-keys.pem Add the path where the public key contents are stored to the SSH configuration file as the TrustedUserCAKeys option. # /etc/ssh/sshd_config # ... TrustedUserCAKeys /etc/ssh/trusted-user-ca-keys.pem Restart the SSH service to pick up the changes. Create a named OpenBao role for signing client keys. Because of the way some SSH certificate features are implemented, options are passed as a map. The following example adds the permit-pty extension to the certificate, and allows the user to specify their own values for permit-pty and permit-port-forwardingwhen requesting the certificate. $ bao write ssh-client-signer/roles/my-role -&lt;&lt;&quot;EOH&quot; { &quot;algorithm_signer&quot;: &quot;rsa-sha2-256&quot;, &quot;allow_user_certificates&quot;: true, &quot;allowed_users&quot;: &quot;*&quot;, &quot;allowed_extensions&quot;: &quot;permit-pty,permit-port-forwarding&quot;, &quot;default_extensions&quot;: { &quot;permit-pty&quot;: &quot;&quot; }, &quot;key_type&quot;: &quot;ca&quot;, &quot;default_user&quot;: &quot;ubuntu&quot;, &quot;ttl&quot;: &quot;30m0s&quot; } EOH   ","version":"Next","tagName":"h3"},{"title":"Client SSH authentication​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#client-ssh-authentication","content":" The following steps are performed by the client (user) that wants to authenticate to machines managed by OpenBao. These commands are usually run from the client's local workstation.  Locate or generate the SSH public key. Usually this is ~/.ssh/id_rsa.pub. If you do not have an SSH keypair, generate one: $ ssh-keygen -t rsa -C &quot;user@example.com&quot; Ask OpenBao to sign your public key. This file usually ends in .pub and the contents begin with ssh-rsa .... $ bao write ssh-client-signer/sign/my-role \\ public_key=@$HOME/.ssh/id_rsa.pub Key Value --- ----- serial_number c73f26d2340276aa signed_key ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1... The result will include the serial and the signed key. This signed key is another public key. To customize the signing options, use a JSON payload: $ bao write ssh-client-signer/sign/my-role -&lt;&lt;&quot;EOH&quot; { &quot;public_key&quot;: &quot;ssh-rsa AAA...&quot;, &quot;valid_principals&quot;: &quot;my-user&quot;, &quot;key_id&quot;: &quot;custom-prefix&quot;, &quot;extensions&quot;: { &quot;permit-pty&quot;: &quot;&quot;, &quot;permit-port-forwarding&quot;: &quot;&quot; } } EOH Save the resulting signed, public key to disk. Limit permissions as needed. $ bao write -field=signed_key ssh-client-signer/sign/my-role \\ public_key=@$HOME/.ssh/id_rsa.pub &gt; signed-cert.pub If you are saving the certificate directly beside your SSH keypair, suffix the name with -cert.pub (~/.ssh/id_rsa-cert.pub). With this naming scheme, OpenSSH will automatically use it during authentication. (Optional) View enabled extensions, principals, and metadata of the signed key. $ ssh-keygen -Lf ~/.ssh/signed-cert.pub SSH into the host machine using the signed key. You must supply both the signed public key from OpenBao and the corresponding private key as authentication to the SSH call. $ ssh -i signed-cert.pub -i ~/.ssh/id_rsa username@10.0.23.5   ","version":"Next","tagName":"h3"},{"title":"Host key signing​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#host-key-signing","content":" For an added layer of security, we recommend enabling host key signing. This is used in conjunction with client key signing to provide an additional integrity layer. When enabled, the SSH agent will verify the target host is valid and trusted before attempting to SSH. This will reduce the probability of a user accidentally SSHing into an unmanaged or malicious machine.  ","version":"Next","tagName":"h2"},{"title":"Signing key configuration​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#signing-key-configuration","content":" Mount the secrets engine. For the most security, mount at a different path from the client signer. $ bao secrets enable -path=ssh-host-signer ssh Successfully mounted 'ssh' at 'ssh-host-signer'! Configure OpenBao with a CA for signing host keys using the /config/caendpoint. If you do not have an internal CA, OpenBao can generate a keypair for you. $ bao write ssh-host-signer/config/ca generate_signing_key=true Key Value --- ----- public_key ssh-rsa AAAAB3NzaC1yc2EA... If you already have a keypair, specify the public and private key parts as part of the payload: $ bao write ssh-host-signer/config/ca \\ private_key=&quot;...&quot; \\ public_key=&quot;...&quot; Regardless of whether it is generated or uploaded, the host signer public key is accessible via the API at the /public_key endpoint. Extend host key certificate TTLs. $ bao secrets tune -max-lease-ttl=87600h ssh-host-signer Create a role for signing host keys. Be sure to fill in the list of allowed domains, set allow_bare_domains, or both. $ bao write ssh-host-signer/roles/hostrole \\ key_type=ca \\ algorithm_signer=rsa-sha2-256 \\ ttl=87600h \\ allow_host_certificates=true \\ allowed_domains=&quot;localdomain,example.com&quot; \\ allow_subdomains=true Sign the host's SSH public key. $ bao write ssh-host-signer/sign/hostrole \\ cert_type=host \\ public_key=@/etc/ssh/ssh_host_rsa_key.pub Key Value --- ----- serial_number 3746eb17371540d9 signed_key ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1y... Set the resulting signed certificate as HostCertificate in the SSH configuration on the host machine. $ bao write -field=signed_key ssh-host-signer/sign/hostrole \\ cert_type=host \\ public_key=@/etc/ssh/ssh_host_rsa_key.pub &gt; /etc/ssh/ssh_host_rsa_key-cert.pub Set permissions on the certificate to be 0640: $ chmod 0640 /etc/ssh/ssh_host_rsa_key-cert.pub Add host key and host certificate to the SSH configuration file. # /etc/ssh/sshd_config # ... # For client keys TrustedUserCAKeys /etc/ssh/trusted-user-ca-keys.pem # For host keys HostKey /etc/ssh/ssh_host_rsa_key HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub Restart the SSH service to pick up the changes.  ","version":"Next","tagName":"h3"},{"title":"Client-Side host verification​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#client-side-host-verification","content":" Retrieve the host signing CA public key to validate the host signature of target machines. $ curl http://127.0.0.1:8200/v1/ssh-host-signer/public_key $ bao read -field=public_key ssh-host-signer/config/ca Add the resulting public key to the known_hosts file with authority. # ~/.ssh/known_hosts @cert-authority *.example.com ssh-rsa AAAAB3NzaC1yc2EAAA... SSH into target machines as usual.  ","version":"Next","tagName":"h3"},{"title":"Troubleshooting​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#troubleshooting","content":" When initially configuring this type of key signing, enable VERBOSE SSH logging to help annotate any errors in the log.  # /etc/ssh/sshd_config # ... LogLevel VERBOSE   Restart SSH after making these changes.  By default, SSH logs to /var/log/auth.log, but so do many other things. To extract just the SSH logs, use the following:  $ tail -f /var/log/auth.log | grep --line-buffered &quot;sshd&quot;   If you are unable to make a connection to the host, the SSH server logs may provide guidance and insights.  ","version":"Next","tagName":"h2"},{"title":"Name is not a listed principal​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#name-is-not-a-listed-principal","content":" If the auth.log displays the following messages:  # /var/log/auth.log key_cert_check_authority: invalid certificate Certificate invalid: name is not a listed principal   The certificate does not permit the username as a listed principal for authenticating to the system. This is most likely due to an OpenSSH bug (seeknown issues for more information). This bug does not respect the allowed_users option value of &quot;*&quot;. Here are ways to work around this issue:  Set default_user in the role. If you are always authenticating as the same user, set the default_user in the role to the username you are SSHing into the target machine: $ bao write ssh/roles/my-role -&lt;&lt;&quot;EOH&quot; { &quot;default_user&quot;: &quot;YOUR_USER&quot;, // ... } EOH Set valid_principals during signing. In situations where multiple users may be authenticating to SSH vian OpenBao, set the list of valid principles during key signing to include the current username: $ bao write ssh-client-signer/sign/my-role -&lt;&lt;&quot;EOH&quot; { &quot;valid_principals&quot;: &quot;my-user&quot; // ... } EOH   ","version":"Next","tagName":"h3"},{"title":"No prompt after login​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#no-prompt-after-login","content":" If you do not see a prompt after authenticating to the host machine, the signed certificate may not have the permit-pty extension. There are two ways to add this extension to the signed certificate.  As part of the role creation $ bao write ssh-client-signer/roles/my-role -&lt;&lt;&quot;EOH&quot; { &quot;default_extensions&quot;: { &quot;permit-pty&quot;: &quot;&quot; } // ... } EOH As part of the signing operation itself: $ bao write ssh-client-signer/sign/my-role -&lt;&lt;&quot;EOH&quot; { &quot;extensions&quot;: { &quot;permit-pty&quot;: &quot;&quot; } // ... } EOH   ","version":"Next","tagName":"h3"},{"title":"No port forwarding​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#no-port-forwarding","content":" If port forwarding from the guest to the host is not working, the signed certificate may not have the permit-port-forwarding extension. Add the extension as part of the role creation or signing process to enable port forwarding. See no prompt after login for examples.  { &quot;default_extensions&quot;: { &quot;permit-port-forwarding&quot;: &quot;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"No x11 forwarding​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#no-x11-forwarding","content":" If X11 forwarding from the guest to the host is not working, the signed certificate may not have the permit-X11-forwarding extension. Add the extension as part of the role creation or signing process to enable X11 forwarding. See no prompt after login for examples.  { &quot;default_extensions&quot;: { &quot;permit-X11-forwarding&quot;: &quot;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"No agent forwarding​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#no-agent-forwarding","content":" If agent forwarding from the guest to the host is not working, the signed certificate may not have the permit-agent-forwarding extension. Add the extension as part of the role creation or signing process to enable agent forwarding. See no prompt after login for examples.  { &quot;default_extensions&quot;: { &quot;permit-agent-forwarding&quot;: &quot;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Key comments​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#key-comments","content":" There are additional steps needed to preserve comment attributesin keys which ought to be considered if they are required. Private and public key may have comments applied to them and for example where ssh-keygen is used with its -C parameter - similar to:  ssh-keygen -C &quot;...Comments&quot; -N &quot;&quot; -t rsa -b 4096 -f host-ca   Adapted key values containing comments must be provided with the key related parameters as per the OpenBao CLI and API steps demonstrated below.  # Using CLI: bao secrets enable -path=hosts-ca ssh KEY_PRI=$(cat ~/.ssh/id_rsa | sed -z 's/\\n/\\\\n/g') KEY_PUB=$(cat ~/.ssh/id_rsa.pub | sed -z 's/\\n/\\\\n/g') # Create / update keypair in OpenBao bao write ssh-client-signer/config/ca \\ generate_signing_key=false \\ private_key=&quot;${KEY_PRI}&quot; \\ public_key=&quot;${KEY_PUB}&quot;   # Using API: curl -X POST -H &quot;X-Vault-Token: ...&quot; -d '{&quot;type&quot;:&quot;ssh&quot;}' http://127.0.0.1:8200/v1/sys/mounts/hosts-ca KEY_PRI=$(cat ~/.ssh/id_rsa | sed -z 's/\\n/\\\\n/g') KEY_PUB=$(cat ~/.ssh/id_rsa.pub | sed -z 's/\\n/\\\\n/g') tee payload.json &lt;&lt;EOF { &quot;generate_signing_key&quot; : false, &quot;private_key&quot; : &quot;${KEY_PRI}&quot;, &quot;public_key&quot; : &quot;${KEY_PUB}&quot; } EOF # Create / update keypair in OpenBao curl -X POST -H &quot;X-Vault-Token: ...&quot; -d @payload.json http://127.0.0.1:8200/v1/hosts-ca/config/ca   warning IMPORTANT: Do NOT add a private key password since OpenBao can't decrypt it. Destroy the keypair and payload.json from your hosts immediately after they have been confirmed as successfully uploaded.  ","version":"Next","tagName":"h3"},{"title":"Known issues​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#known-issues","content":" On SELinux-enforcing systems, you may need to adjust related types so that the SSH daemon is able to read it. For example, adjust the signed host certificate to be an sshd_key_t type. On some versions of SSH, you may get the following error: no separate private key for certificate This is a bug introduced in OpenSSH version 7.2 and fixed in 7.5. SeeOpenSSH bug 2617 for details. On some versions of SSH, you may get the following error on target host: userauth_pubkey: certificate signature algorithm ssh-rsa: signature algorithm not supported [preauth] Fix is to add below line to /etc/ssh/sshd_config CASignatureAlgorithms ^ssh-rsa The ssh-rsa algorithm is no longer supported in OpenSSH 8.2  ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"Signed SSH certificates","url":"/openbao/docs/secrets/ssh/signed-ssh-certificates/#api","content":" The SSH secrets engine has a full HTTP API. Please see theSSH secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"Upgrading OpenBao","type":0,"sectionRef":"#","url":"/openbao/docs/upgrading/","content":"","keywords":"","version":"Next"},{"title":"Agent​","type":1,"pageTitle":"Upgrading OpenBao","url":"/openbao/docs/upgrading/#agent","content":" The OpenBao Agent is an API client of the OpenBao Server. OpenBao APIs are almost always backwards compatible. When they are not, this is called out in the upgrade guide for the new OpenBao version, and there is a lengthy deprecation period. The OpenBao Agent version can lag behind the OpenBao Server version, though we recommend keeping all OpenBao instances up to date with the most recent minor OpenBao version to the extent possible.  ","version":"Next","tagName":"h2"},{"title":"Testing the upgrade​","type":1,"pageTitle":"Upgrading OpenBao","url":"/openbao/docs/upgrading/#testing-the-upgrade","content":" It's always a good idea to try to ensure that the upgrade will be successful in your environment. The ideal way to do this is to take a snapshot of your data and load it into a test cluster. However, if you are issuing secrets to third party resources (cloud credentials, database credentials, etc.) ensure that you do not allow external network connectivity during testing, in case credentials expire. This prevents the test cluster from trying to revoke these resources along with the non-test cluster.  ","version":"Next","tagName":"h2"},{"title":"Non-HA installations​","type":1,"pageTitle":"Upgrading OpenBao","url":"/openbao/docs/upgrading/#non-ha-installations","content":" Upgrading non-HA installations of OpenBao is as simple as replacing the OpenBao binary with the new version and restarting OpenBao. Any upgrade tasks that can be performed for you will be taken care of when OpenBao is unsealed.  Always use SIGINT or SIGTERM to properly shut down OpenBao.  Be sure to also read and follow any instructions in the version-specific upgrade notes.  ","version":"Next","tagName":"h2"},{"title":"HA installations​","type":1,"pageTitle":"Upgrading OpenBao","url":"/openbao/docs/upgrading/#ha-installations","content":" Please refer to our OpenBao HA upgrades documentation for more details. ","version":"Next","tagName":"h2"},{"title":"Transit secrets engine","type":0,"sectionRef":"#","url":"/openbao/docs/secrets/transit/","content":"","keywords":"","version":"Next"},{"title":"Working set management​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#working-set-management","content":" The Transit engine supports versioning of keys. Key versions that are earlier than a key's specified min_decryption_version gets archived, and the rest of the key versions belong to the working set. This is a performance consideration to keep key loading fast, as well as a security consideration: by disallowing decryption of old versions of keys, found ciphertext corresponding to obsolete (but sensitive) data can not be decrypted by most users, but in an emergency the min_decryption_version can be moved back to allow for legitimate decryption.  Currently this archive is stored in a single storage entry. With some storage backends, notably those using Raft or Paxos for HA capabilities, frequent rotation may lead to a storage entry size for the archive that is larger than the storage backend can handle. For frequent rotation needs, using named keys that correspond to time bounds (e.g. five-minute periods floored to the closest multiple of five) may provide a good alternative, allowing for several keys to be live at once and a deterministic way to decide which key to use at any given time.  ","version":"Next","tagName":"h2"},{"title":"NIST rotation guidance​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#nist-rotation-guidance","content":" Periodic rotation of the encryption keys is recommended, even in the absence of compromise. For AES-GCM keys, rotation should occur before approximately 232encryptions have been performed by a key version, following the guidelines of NIST publication 800-38D. It is recommended that operators estimate the encryption rate of a key and use that to determine a frequency of rotation that prevents the guidance limits from being reached. For example, if one determines that the estimated rate is 40 million operations per day, then rotating a key every three months is sufficient.  ","version":"Next","tagName":"h2"},{"title":"Key types​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#key-types","content":" As of now, the transit secrets engine supports the following key types (all key types also generate separate HMAC keys):  aes128-gcm96: AES-GCM with a 128-bit AES key and a 96-bit nonce; supports encryption, decryption, key derivation, and convergent encryptionaes256-gcm96: AES-GCM with a 256-bit AES key and a 96-bit nonce; supports encryption, decryption, key derivation, and convergent encryption (default)chacha20-poly1305: ChaCha20-Poly1305 with a 256-bit key; supports encryption, decryption, key derivation, and convergent encryptioned25519: Ed25519; supports signing, signature verification, and key derivationecdsa-p256: ECDSA using curve P-256; supports signing and signature verificationecdsa-p384: ECDSA using curve P-384; supports signing and signature verificationecdsa-p521: ECDSA using curve P-521; supports signing and signature verificationrsa-2048: 2048-bit RSA key; supports encryption, decryption, signing, and signature verificationrsa-3072: 3072-bit RSA key; supports encryption, decryption, signing, and signature verificationrsa-4096: 4096-bit RSA key; supports encryption, decryption, signing, and signature verificationhmac: HMAC; supporting HMAC generation and verification.  warning Note: All key types support HMAC operations through the use of a second randomly generated key created key creation time or rotation. The HMAC key type only supports HMAC, and behaves identically to other algorithms with respect to the HMAC operations but supports key import. By default, the HMAC key type uses a 256-bit key.  RSA operations use one of the following methods:  OAEP (encrypt, decrypt), with SHA-256 hash function and MGF,PSS (sign, verify), with configurable hash function also used for MGF, andPKCS#1v1.5: (sign, verify), with configurable hash function.  ","version":"Next","tagName":"h2"},{"title":"Convergent encryption​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#convergent-encryption","content":" Convergent encryption is a mode where the same set of plaintext+context always result in the same ciphertext. It does this by deriving a key using a key derivation function but also by deterministically deriving a nonce. Because these properties differ for any combination of plaintext and ciphertext over a keyspace the size of 2^256, the risk of nonce reuse is near zero.  This has many practical uses. One common usage mode is to allow values to be stored encrypted in a database, but with limited lookup/query support, so that rows with the same value for a specific field can be returned from a query.  To accommodate for any needed upgrades to the algorithm, different versions of convergent encryption have historically been supported:  Version 1 required the client to provide their own nonce, which is highly flexible but if done incorrectly can be dangerous. Keys using this version cannot be upgraded.Version 2 used an algorithmic approach to deriving the parameters. However, the algorithm used was susceptible to offline plaintext-confirmation attacks, which could allow attackers to brute force decryption if the plaintext size was small. Keys using version 2 can be upgraded by simply performing a rotate operation to a new key version; existing values can then be rewrapped against the new key version and will use the version 3 algorithm.Version 3 uses a different algorithm designed to be resistant to offline plaintext-confirmation attacks. It is similar to AES-SIV in that it uses a PRF to generate the nonce from the plaintext.  ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#setup","content":" Most secrets engines must be configured in advance before they can perform their functions. These steps are usually completed by an operator or configuration management tool.  Enable the Transit secrets engine: $ bao secrets enable transit Success! Enabled the transit secrets engine at: transit/ By default, the secrets engine will mount at the name of the engine. To enable the secrets engine at a different path, use the -path argument. Create a named encryption key: $ bao write -f transit/keys/my-key Success! Data written to: transit/keys/my-key Usually each application has its own encryption key.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#usage","content":" After the secrets engine is configured and a user/machine has an OpenBao token with the proper permission, it can use this secrets engine.  Encrypt some plaintext data using the /encrypt endpoint with a named key: NOTE: All plaintext data must be base64-encoded. The reason for this requirement is that OpenBao does not require that the plaintext is &quot;text&quot;. It could be a binary file such as a PDF or image. The easiest safe transport mechanism for this data as part of a JSON payload is to base64-encode it. $ bao write transit/encrypt/my-key plaintext=$(echo &quot;my secret data&quot; | base64) Key Value --- ----- ciphertext vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w== The returned ciphertext starts with vault:v1:. The first prefix (vault) identifies that it has been wrapped by OpenBao. The v1 indicates the key version 1 was used to encrypt the plaintext; therefore, when you rotate keys, OpenBao knows which version to use for decryption. The rest is a base64 concatenation of the initialization vector (IV) and ciphertext. Note that OpenBao does not store any of this data. The caller is responsible for storing the encrypted ciphertext. When the caller wants the plaintext, it must provide the ciphertext back to OpenBao to decrypt the value.  danger OpenBao HTTP API imposes a maximum request size of 32MB to prevent a denial of service attack. This can be tuned per listenerblock in the OpenBao server configuration.  Decrypt a piece of data using the /decrypt endpoint with a named key: $ bao write transit/decrypt/my-key ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w== Key Value --- ----- plaintext bXkgc2VjcmV0IGRhdGEK The resulting data is base64-encoded (see the note above for details on why). Decode it to get the raw plaintext: $ base64 --decode &lt;&lt;&lt; &quot;bXkgc2VjcmV0IGRhdGEK&quot; my secret data It is also possible to script this decryption using some clever shell scripting in one command: $ bao write -field=plaintext transit/decrypt/my-key ciphertext=... | base64 --decode my secret data Using ACLs, it is possible to restrict using the transit secrets engine such that trusted operators can manage the named keys, and applications can only encrypt or decrypt using the named keys they need access to. Rotate the underlying encryption key. This will generate a new encryption key and add it to the keyring for the named key: $ bao write -f transit/keys/my-key/rotate Success! Data written to: transit/keys/my-key/rotate Future encryptions will use this new key. Old data can still be decrypted due to the use of a key ring. Upgrade already-encrypted data to a new key. OpenBao will decrypt the value using the appropriate key in the keyring and then encrypted the resulting plaintext with the newest key in the keyring. $ bao write transit/rewrap/my-key ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w== Key Value --- ----- ciphertext vault:v2:0VHTTBb2EyyNYHsa3XiXsvXOQSLKulH+NqS4eRZdtc2TwQCxqJ7PUipvqQ== This process does not reveal the plaintext data. As such, an OpenBao policy could grant almost an untrusted process the ability to &quot;rewrap&quot; encrypted data, since the process would not be able to get access to the plaintext data.  ","version":"Next","tagName":"h2"},{"title":"Bring your own key (BYOK)​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#bring-your-own-key-byok","content":" warning Note: Key import functionality supports cases in which there is a need to bring in an existing key from an HSM or other outside system. It is more secure to have Transit generate and manage a key within OpenBao.  First, the wrapping key needs to be read from transit:  $ bao read transit/wrapping_key   The wrapping key will be a 4096-bit RSA public key.  Then the wrapping key is used to create the ciphertext input for the import endpoint, as described below. In the below, the target key refers to the key being imported.  ","version":"Next","tagName":"h2"},{"title":"HSM​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#hsm","content":" If the key is being imported from an HSM that supports PKCS#11, there are two possible scenarios:  If the HSM supports the CKM_RSA_AES_KEY_WRAP mechanism, that can be used to wrap the target key using the wrapping key. Otherwise, two mechanisms can be combined to wrap the target key. First, a 256-bit AES key should be generated and then used to wrap the target key using the CKM_AES_KEY_WRAP_KWP mechanism. Then the AES key should be wrapped under the wrapping key using the CKM_RSA_PKCS_OAEP mechanism using MGF1 and either SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512.  The ciphertext is constructed by appending the wrapped target key to the wrapped AES key.  The ciphertext bytes should be base64-encoded.  ","version":"Next","tagName":"h3"},{"title":"Manual process​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#manual-process","content":" If the target key is not stored in an HSM or KMS, the following steps can be used to construct the ciphertext for the input of the import endpoint:  Generate an ephemeral 256-bit AES key. Wrap the target key using the ephemeral AES key with AES-KWP.  warning Note: When wrapping a symmetric key (such as an AES or ChaCha20 key), wrap the raw bytes of the key. For instance, with an AES 128-bit key, this'll be a byte array 16 characters in length that will directly be wrapped without base64 or other encodings. When wrapping an asymmetric key (such as a RSA or ECDSA key), wrap the PKCS8 encoded format of this key, in raw DER/binary form. Do not apply PEM encoding to this blob prior to encryption and do not base64 encode it.  Wrap the AES key under the OpenBao wrapping key using RSAES-OAEP with MGF1 and either SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512. Delete the ephemeral AES key. Append the wrapped target key to the wrapped AES key. Base64 encode the result.  For more details about wrapping the key for import into transit, see thekey wrapping guide.  ","version":"Next","tagName":"h3"},{"title":"Tutorial​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#tutorial","content":" Refer to the Encryption as a Service: Transit Secrets Enginetutorial to learn how to use the transit secrets engine to handle cryptographic functions on data in-transit.  ","version":"Next","tagName":"h2"},{"title":"API​","type":1,"pageTitle":"Transit secrets engine","url":"/openbao/docs/secrets/transit/#api","content":" The Transit secrets engine has a full HTTP API. Please see theTransit secrets engine API for more details. ","version":"Next","tagName":"h2"},{"title":"Upgrading OpenBao plugins","type":0,"sectionRef":"#","url":"/openbao/docs/upgrading/plugins/","content":"","keywords":"","version":"Next"},{"title":"Plugin upgrade procedure​","type":1,"pageTitle":"Upgrading OpenBao plugins","url":"/openbao/docs/upgrading/plugins/#plugin-upgrade-procedure","content":" The following procedures detail steps for upgrading a plugin that has been mounted at a path on a running server. The steps are the same whether the plugin being upgraded is built-in or external.  ","version":"Next","tagName":"h2"},{"title":"Upgrading auth and secrets plugins​","type":1,"pageTitle":"Upgrading OpenBao plugins","url":"/openbao/docs/upgrading/plugins/#upgrading-auth-and-secrets-plugins","content":" The process is nearly identical for auth and secret plugins. If you are upgrading an auth plugin, just replace all usages of secrets or secret with auth.  Register the first version of your plugin to the catalog. Skip this step if your initial plugin is built-in or already registered. $ bao plugin register \\ -sha256=&lt;SHA256 Hex value of the plugin binary&gt; \\ secret \\ my-secret-plugin Mount the plugin. Skip this step if your initial plugin is already mounted. $ bao secrets enable my-secret-plugin Register a second version of your plugin. You must use the same plugin type and name (the last two arguments) as the plugin being upgraded. This is true regardless of whether the plugin being upgraded is built-in or external. $ bao plugin register \\ -sha256=&lt;SHA256 Hex value of the plugin binary&gt; \\ -command=my-secret-plugin-1.0.1 \\ -version=v1.0.1 \\ secret \\ my-secret-plugin Tune the existing mount to configure it to use the newly registered version. $ bao secrets tune -plugin-version=v1.0.1 my-secret-plugin If you wish, you can check the updated configuration. Notice the &quot;Version&quot; is now different from the &quot;Running Version&quot;. $ bao secrets list -detailed Finally, trigger a plugin reload to reload all mounted backends using that plugin or a subset of the mounts using that plugin with either the plugin or mounts flag respectively. $ bao plugin reload -plugin my-secret-plugin   Until the last step, the mount will still run the first version of my-secret-plugin. When the reload is triggered, OpenBao will kill my-secret-plugin’s process and start the new plugin process for my-secret-plugin version 1.0.1. The &quot;Running Version&quot; should also now match the &quot;Version&quot; when you run bao secrets list -detailed.  info Important: Plugin reload of a new plugin binary must be performed on each OpenBao instance. Performing a plugin upgrade on a single instance or through a load balancer can result in mismatched plugin binaries within a cluster. On a replicated cluster this may be accomplished by setting the 'scope' parameter of the reload to 'global'.  ","version":"Next","tagName":"h3"},{"title":"Upgrading database plugins​","type":1,"pageTitle":"Upgrading OpenBao plugins","url":"/openbao/docs/upgrading/plugins/#upgrading-database-plugins","content":" Register the first version of your plugin to the catalog. Skip this step if your initial plugin is built-in or already registered. $ bao plugin register -sha256=&lt;SHA256 Hex value of the plugin binary&gt; \\ database \\ my-db-plugin Mount the plugin. Skip this step if your initial plugin is already mounted. $ bao secrets enable database $ bao write database/config/my-db \\ plugin_name=my-db-plugin \\ # ... Register a second version of your plugin. You must use the same plugin type and name (the last two arguments) as the plugin being upgraded. This is true regardless of whether the plugin being upgraded is built-in or external. $ bao plugin register \\ -sha256=&lt;SHA256 Hex value of the plugin binary&gt; \\ -command=my-db-plugin-1.0.1 \\ -version=v1.0.1 \\ database \\ my-db-plugin Update the database config with the new version. The database secrets engine will immediately reload the plugin, using the new version. Any omitted config parameters will not be updated. $ bao write database/config/my-db \\ plugin_version=v1.0.1   Until the last step, the mount will still run the first version of my-db-plugin. When the reload is triggered, OpenBao will kill my-db-plugin’s process and start the new plugin process for my-db-plugin version 1.0.1.  ","version":"Next","tagName":"h3"},{"title":"Downgrading plugins​","type":1,"pageTitle":"Upgrading OpenBao plugins","url":"/openbao/docs/upgrading/plugins/#downgrading-plugins","content":" Plugin downgrades follow the same procedure as upgrades. You can use the OpenBao plugin list command to check what plugin versions are available to downgrade to:  $ bao plugin list secret Name Version ---- ------- cassandra v1.12.0+builtin.bao kv v0.13.3+builtin ldap v1.12.0+builtin.bao mysql v1.12.0+builtin.bao openldap v0.9.0+builtin pki v1.12.0+builtin.bao postgresql v1.12.0+builtin.bao rabbitmq v1.12.0+builtin.bao ssh v1.12.0+builtin.bao totp v1.12.0+builtin.bao transit v1.12.0+builtin.bao   ","version":"Next","tagName":"h3"},{"title":"Additional upgrade notes​","type":1,"pageTitle":"Upgrading OpenBao plugins","url":"/openbao/docs/upgrading/plugins/#additional-upgrade-notes","content":" As mentioned earlier, disabling existing mounts will wipe the existing data.Overwriting an existing version in the catalog will affect all uses of that plugin version. So if you have 5 different Secrets mounts using the same plugin, they'll all start using the new binary if you overwrite it. We recommend treating plugin versions in the catalog as immutable, much like version control tags.Each plugin has its own data within OpenBao storage. While it is rare for OpenBao maintained plugins to update their storage schema, it is up to plugin authors to manage schema upgrades and downgrades. Check the plugin release notes for any unsupported upgrade or downgrade transitions, especially before moving to a new major version or downgrading.Existing OpenBao leases and tokensare generally unaffected by plugin upgrades and reloads. This is because the lifecycle of leases and tokens is handled by core systems within OpenBao. The plugin itself only handles renewal and revocation of them when it’s requested by those core systems. ","version":"Next","tagName":"h3"},{"title":"OpenBao HA upgrades","type":0,"sectionRef":"#","url":"/openbao/docs/upgrading/vault-ha-upgrade/","content":"","keywords":"","version":"Next"},{"title":"HA installations​","type":1,"pageTitle":"OpenBao HA upgrades","url":"/openbao/docs/upgrading/vault-ha-upgrade/#ha-installations","content":" Regardless of the method you use, do not fail over from a newer version of OpenBao to an older version. Our suggested procedure is designed to prevent this.  Please note that OpenBao does not support true zero-downtime upgrades, but with proper upgrade procedure the downtime should be very short (a few hundred milliseconds to a second depending on how the speed of access to the storage backend).  Perform these steps on each standby:  Properly shut down OpenBao on the standby node via SIGINT or SIGTERMReplace the OpenBao binary with the new version; ensure that mlock()capability is added to the new binary withsetcapStart the standby nodeUnseal the standby nodeVerify bao status shows correct Version and HA Mode is standbyReview the node's logs to ensure successful startup and unseal  At this point all standby nodes are upgraded and ready to take over. The upgrade will not complete until one of the upgraded standby nodes takes over active duty.  To complete the cluster upgrade:  Properly shut down the remaining (active) node  note It is important that you shut the node down properly. This will perform a step-down and release the HA lock, allowing a standby node to take over with a very short delay. If you kill OpenBao without letting it release the lock, a standby node will not be able to take over until the lock's timeout period has expired. This is backend-specific but could be ten seconds or more.  Replace the OpenBao binary with the new version; ensure that mlock()capability is added to the new binary withsetcapStart the nodeUnseal the nodeVerify bao status shows correct Version and HA Mode is standbyReview the node's logs to ensure successful startup and unseal  Internal upgrade tasks will happen after one of the upgraded standby nodes takes over active duty.  Be sure to also read and follow any instructions in the version-specific upgrade notes. ","version":"Next","tagName":"h2"},{"title":"Use cases","type":0,"sectionRef":"#","url":"/openbao/docs/use-cases/","content":"","keywords":"","version":"Next"},{"title":"General secret storage​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#general-secret-storage","content":" As workloads become more and more ephemeral and short-lived, having long-lived static credentials pose a big security threat vector. What if credentials are accidentally leaked, or an employee leaves with their post it notes that contain the AWS access key, or someone checks their S3 access token to a public GH repo? With OpenBao, you can generate short-lived, just-in-time credentials that are automatically revoked when their time expires. This means users and security teams do not have to worry about manually revoking or changing these credentials.  ","version":"Next","tagName":"h2"},{"title":"Static secrets​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#static-secrets","content":" Credentials can be long-lived and static, where they don't change or are changed infrequently. OpenBao can store these secrets bedhind its cryptographic barrier, and clients can request them to use in their applications.  Refer to the Versioned Key/Value Secrets Engine tutorial and learn how a versioned key-value secrets engine protects your static secrets.  ","version":"Next","tagName":"h3"},{"title":"Dynamic secrets​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#dynamic-secrets","content":" The key value with secrets storage is the ability to dynamically generate credentials. These credentials are created when clients need them. OpenBao can also manage the lifecycle of these credentials, including but not limited to, deleting them after a defined period of time.  Refer to the Dynamic Secrets: Database Secrets Engine tutorial and learn how OpenBao can dynamically manage your database credentials.  In addition to database credential management, OpenBao can manage your Active Directory accounts, SSH keys, PKI certificates and more. Visit the Secrets Management tutorial series to learn more about secrets management using OpenBao.  ","version":"Next","tagName":"h3"},{"title":"Data encryption​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#data-encryption","content":" Many organizations seek solutions to encrypt/decrypt application data within a cloud or multi-datacenter environment; deploying cryptography and maintaining a complex key management infrastructure can be expensive and challenging to develop. OpenBao provides encryption as a service with centralized key management to simplify encrypting data in transit and stored across clouds and datacenters. OpenBao can encrypt/decrypt data stored elsewhere, essentially allowing applications to encrypt their data while storing it in the primary data store. OpenBao's security team manages and maintains the responsibility of the data encryption within the OpenBao environment, allowing developers to focus solely on encrypting/decrypting data as needed.  ","version":"Next","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#resources","content":" Try our Encryption as a Service: Transit Secrets Engine to learn the essential workings of the Transit secrets engine handles cryptographic functions on data in-transit. For more advanced data protection, refer to the Advanced Data Protection tutorial series. OpenBao's Transform secrets engine handles secure data transformation and tokenization against provided input value.  ","version":"Next","tagName":"h3"},{"title":"Identity-Based access​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#identity-based-access","content":" Organizations need a way to manage identity sprawl with the proliferation of different clouds, services, and systems- all with their identity providers. The risk of compromising an organization's security infrastructure increases as organizations are forced to manage multiple identity management systems as they try to implement solutions to unify a single logical identity across numerous cloud platforms. Different platforms support different methods and constructs for identity, making it difficult to recognize a user or identity across multiple forms of credentials. OpenBao solves this challenge by using a unified ACL system to broker access to systems and secrets and merges identities across providers. With identity-based access, organizations can leverage any trusted resource identity to regulate and manage system and application access, and authentication across various clouds, systems, and endpoints.  ","version":"Next","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Use cases","url":"/openbao/docs/use-cases/#resources-1","content":" Try our Identity: Entities and Groups tutorial to learn how OpenBao's unified identity system works. Follow the Policies tutorial series to learn how OpenBao enforces role-based access control (RBAC) across multiple cloud environments. ","version":"Next","tagName":"h3"},{"title":"What is OpenBao?","type":0,"sectionRef":"#","url":"/openbao/docs/what-is-openbao/","content":"","keywords":"","version":"Next"},{"title":"How does OpenBao work?​","type":1,"pageTitle":"What is OpenBao?","url":"/openbao/docs/what-is-openbao/#how-does-openbao-work","content":" OpenBao works primarily with tokens and a token is associated to the client's policy. Each policy is path-based and policy rules constrains the actions and accessibility to the paths for each client. With OpenBao, you can create tokens manually and assign them to your clients, or the clients can log in and obtain a token. The illustration below displays OpenBao's core workflow.    The core OpenBao workflow consists of four stages:  Authenticate: Authentication in OpenBao is the process by which a client supplies information that OpenBao uses to determine if they are who they say they are. Once the client is authenticated against an auth method, a token is generated and associated to a policy.Validation: OpenBao validates the client against third-party trusted sources, such as Github, LDAP, AppRole, and more.Authorize: A client is matched against the OpenBao security policy. This policy is a set of rules defining which API endpoints a client has access to with its OpenBao token. Policies provide a declarative way to grant or forbid access to certain paths and operations in OpenBao.Access: OpenBao grants access to secrets, keys, and encryption capabilities by issuing a token based on policies associated with the client’s identity. The client can then use their OpenBao token for future operations.  ","version":"Next","tagName":"h3"},{"title":"Why OpenBao?​","type":1,"pageTitle":"What is OpenBao?","url":"/openbao/docs/what-is-openbao/#why-openbao","content":" Most enterprises today have credentials sprawled across their organizations. Passwords, API keys, and credentials are stored in plain text, app source code, config files, and other locations. Because these credentials live everywhere, the sprawl can make it difficult and daunting to really know who has access and authorization to what. Having credentials in plain text also increases the potential for malicious attacks, both by internal and external attackers.  OpenBao was designed with these challenges in mind. OpenBao takes all of these credentials and centralizes them so that they are defined in one location, which reduces unwanted exposure to credentials. But OpenBao takes it a few steps further by making sure users, apps, and systems are authenticated and explicitly authorized to access resources, while also providing an audit trail that captures and preserves a history of clients' actions.  The key features of OpenBao are:  Secure Secret Storage: Arbitrary key/value secrets can be stored in OpenBao. OpenBao encrypts these secrets prior to writing them to persistent storage, so gaining access to the raw storage isn't enough to access your secrets. Dynamic Secrets: OpenBao can generate secrets on-demand for some systems, such as Kubernetes or SQL databases. For example, when an application needs to access a Kubernetes cluster, it asks OpenBao for credentials, and OpenBao will generate an Kubernetes service account token with valid permissions on demand. After creating these dynamic secrets, OpenBao will also automatically revoke them after the lease is up. Data Encryption: OpenBao can encrypt and decrypt data without storing it. This allows security teams to define encryption parameters and developers to store encrypted data in a location such as a SQL database without having to design their own encryption methods. Leasing and Renewal: All secrets in OpenBao have a lease associated with them. At the end of the lease, OpenBao will automatically revoke that secret. Clients are able to renew leases via built-in renew APIs. Revocation: OpenBao has built-in support for secret revocation. OpenBao can revoke not only single secrets, but a tree of secrets, for example all secrets read by a specific user, or all secrets of a particular type. Revocation assists in key rolling as well as locking down systems in the case of an intrusion.  info Tip: Learn more about OpenBao use cases.  ","version":"Next","tagName":"h3"},{"title":"Community​","type":1,"pageTitle":"What is OpenBao?","url":"/openbao/docs/what-is-openbao/#community","content":" We welcome questions, suggestions, and contributions from the community.  Ask questions in GitHub Discussions.Read our contributing guide.Submit an issue for bugs and feature requests. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}